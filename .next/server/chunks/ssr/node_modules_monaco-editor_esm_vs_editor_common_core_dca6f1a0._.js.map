{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/position.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/position.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/position.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A position in the editor. This interface is suitable for serialization.\n */\nexport interface IPosition {\n\t/**\n\t * line number (starts at 1)\n\t */\n\treadonly lineNumber: number;\n\t/**\n\t * column (the first character in a line is between column 1 and column 2)\n\t */\n\treadonly column: number;\n}\n\n/**\n * A position in the editor.\n */\nexport class Position {\n\t/**\n\t * line number (starts at 1)\n\t */\n\tpublic readonly lineNumber: number;\n\t/**\n\t * column (the first character in a line is between column 1 and column 2)\n\t */\n\tpublic readonly column: number;\n\n\tconstructor(lineNumber: number, column: number) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.column = column;\n\t}\n\n\t/**\n\t * Create a new position from this position.\n\t *\n\t * @param newLineNumber new line number\n\t * @param newColumn new column\n\t */\n\twith(newLineNumber: number = this.lineNumber, newColumn: number = this.column): Position {\n\t\tif (newLineNumber === this.lineNumber && newColumn === this.column) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new Position(newLineNumber, newColumn);\n\t\t}\n\t}\n\n\t/**\n\t * Derive a new position from this position.\n\t *\n\t * @param deltaLineNumber line number delta\n\t * @param deltaColumn column delta\n\t */\n\tdelta(deltaLineNumber: number = 0, deltaColumn: number = 0): Position {\n\t\treturn this.with(Math.max(1, this.lineNumber + deltaLineNumber), Math.max(1, this.column + deltaColumn));\n\t}\n\n\t/**\n\t * Test if this position equals other position\n\t */\n\tpublic equals(other: IPosition): boolean {\n\t\treturn Position.equals(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` equals position `b`\n\t */\n\tpublic static equals(a: IPosition | null, b: IPosition | null): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.lineNumber === b.lineNumber &&\n\t\t\ta.column === b.column\n\t\t);\n\t}\n\n\t/**\n\t * Test if this position is before other position.\n\t * If the two positions are equal, the result will be false.\n\t */\n\tpublic isBefore(other: IPosition): boolean {\n\t\treturn Position.isBefore(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` is before position `b`.\n\t * If the two positions are equal, the result will be false.\n\t */\n\tpublic static isBefore(a: IPosition, b: IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column < b.column;\n\t}\n\n\t/**\n\t * Test if this position is before other position.\n\t * If the two positions are equal, the result will be true.\n\t */\n\tpublic isBeforeOrEqual(other: IPosition): boolean {\n\t\treturn Position.isBeforeOrEqual(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` is before position `b`.\n\t * If the two positions are equal, the result will be true.\n\t */\n\tpublic static isBeforeOrEqual(a: IPosition, b: IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column <= b.column;\n\t}\n\n\t/**\n\t * A function that compares positions, useful for sorting\n\t */\n\tpublic static compare(a: IPosition, b: IPosition): number {\n\t\tconst aLineNumber = a.lineNumber | 0;\n\t\tconst bLineNumber = b.lineNumber | 0;\n\n\t\tif (aLineNumber === bLineNumber) {\n\t\t\tconst aColumn = a.column | 0;\n\t\t\tconst bColumn = b.column | 0;\n\t\t\treturn aColumn - bColumn;\n\t\t}\n\n\t\treturn aLineNumber - bLineNumber;\n\t}\n\n\t/**\n\t * Clone this position.\n\t */\n\tpublic clone(): Position {\n\t\treturn new Position(this.lineNumber, this.column);\n\t}\n\n\t/**\n\t * Convert to a human-readable representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '(' + this.lineNumber + ',' + this.column + ')';\n\t}\n\n\t// ---\n\n\t/**\n\t * Create a `Position` from an `IPosition`.\n\t */\n\tpublic static lift(pos: IPosition): Position {\n\t\treturn new Position(pos.lineNumber, pos.column);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IPosition`.\n\t */\n\tpublic static isIPosition(obj: any): obj is IPosition {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.lineNumber === 'number')\n\t\t\t&& (typeof obj.column === 'number')\n\t\t);\n\t}\n\n\tpublic toJSON(): IPosition {\n\t\treturn {\n\t\t\tlineNumber: this.lineNumber,\n\t\t\tcolumn: this.column\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A position in the editor. This interface is suitable for serialization.\n */\nexport interface IPosition {\n\t/**\n\t * line number (starts at 1)\n\t */\n\treadonly lineNumber: number;\n\t/**\n\t * column (the first character in a line is between column 1 and column 2)\n\t */\n\treadonly column: number;\n}\n\n/**\n * A position in the editor.\n */\nexport class Position {\n\t/**\n\t * line number (starts at 1)\n\t */\n\tpublic readonly lineNumber: number;\n\t/**\n\t * column (the first character in a line is between column 1 and column 2)\n\t */\n\tpublic readonly column: number;\n\n\tconstructor(lineNumber: number, column: number) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.column = column;\n\t}\n\n\t/**\n\t * Create a new position from this position.\n\t *\n\t * @param newLineNumber new line number\n\t * @param newColumn new column\n\t */\n\twith(newLineNumber: number = this.lineNumber, newColumn: number = this.column): Position {\n\t\tif (newLineNumber === this.lineNumber && newColumn === this.column) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn new Position(newLineNumber, newColumn);\n\t\t}\n\t}\n\n\t/**\n\t * Derive a new position from this position.\n\t *\n\t * @param deltaLineNumber line number delta\n\t * @param deltaColumn column delta\n\t */\n\tdelta(deltaLineNumber: number = 0, deltaColumn: number = 0): Position {\n\t\treturn this.with(Math.max(1, this.lineNumber + deltaLineNumber), Math.max(1, this.column + deltaColumn));\n\t}\n\n\t/**\n\t * Test if this position equals other position\n\t */\n\tpublic equals(other: IPosition): boolean {\n\t\treturn Position.equals(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` equals position `b`\n\t */\n\tpublic static equals(a: IPosition | null, b: IPosition | null): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.lineNumber === b.lineNumber &&\n\t\t\ta.column === b.column\n\t\t);\n\t}\n\n\t/**\n\t * Test if this position is before other position.\n\t * If the two positions are equal, the result will be false.\n\t */\n\tpublic isBefore(other: IPosition): boolean {\n\t\treturn Position.isBefore(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` is before position `b`.\n\t * If the two positions are equal, the result will be false.\n\t */\n\tpublic static isBefore(a: IPosition, b: IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column < b.column;\n\t}\n\n\t/**\n\t * Test if this position is before other position.\n\t * If the two positions are equal, the result will be true.\n\t */\n\tpublic isBeforeOrEqual(other: IPosition): boolean {\n\t\treturn Position.isBeforeOrEqual(this, other);\n\t}\n\n\t/**\n\t * Test if position `a` is before position `b`.\n\t * If the two positions are equal, the result will be true.\n\t */\n\tpublic static isBeforeOrEqual(a: IPosition, b: IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column <= b.column;\n\t}\n\n\t/**\n\t * A function that compares positions, useful for sorting\n\t */\n\tpublic static compare(a: IPosition, b: IPosition): number {\n\t\tconst aLineNumber = a.lineNumber | 0;\n\t\tconst bLineNumber = b.lineNumber | 0;\n\n\t\tif (aLineNumber === bLineNumber) {\n\t\t\tconst aColumn = a.column | 0;\n\t\t\tconst bColumn = b.column | 0;\n\t\t\treturn aColumn - bColumn;\n\t\t}\n\n\t\treturn aLineNumber - bLineNumber;\n\t}\n\n\t/**\n\t * Clone this position.\n\t */\n\tpublic clone(): Position {\n\t\treturn new Position(this.lineNumber, this.column);\n\t}\n\n\t/**\n\t * Convert to a human-readable representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '(' + this.lineNumber + ',' + this.column + ')';\n\t}\n\n\t// ---\n\n\t/**\n\t * Create a `Position` from an `IPosition`.\n\t */\n\tpublic static lift(pos: IPosition): Position {\n\t\treturn new Position(pos.lineNumber, pos.column);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IPosition`.\n\t */\n\tpublic static isIPosition(obj: any): obj is IPosition {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.lineNumber === 'number')\n\t\t\t&& (typeof obj.column === 'number')\n\t\t);\n\t}\n\n\tpublic toJSON(): IPosition {\n\t\treturn {\n\t\t\tlineNumber: this.lineNumber,\n\t\t\tcolumn: this.column\n\t\t};\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/range.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/range.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/range.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\n\n/**\n * A range in the editor. This interface is suitable for serialization.\n */\nexport interface IRange {\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\treadonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\treadonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\tpublic readonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\tpublic readonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\tpublic readonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\tpublic readonly endColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tif ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n\t\t\tthis.startLineNumber = endLineNumber;\n\t\t\tthis.startColumn = endColumn;\n\t\t\tthis.endLineNumber = startLineNumber;\n\t\t\tthis.endColumn = startColumn;\n\t\t} else {\n\t\t\tthis.startLineNumber = startLineNumber;\n\t\t\tthis.startColumn = startColumn;\n\t\t\tthis.endLineNumber = endLineNumber;\n\t\t\tthis.endColumn = endColumn;\n\t\t}\n\t}\n\n\t/**\n\t * Test if this range is empty.\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn Range.isEmpty(this);\n\t}\n\n\t/**\n\t * Test if `range` is empty.\n\t */\n\tpublic static isEmpty(range: IRange): boolean {\n\t\treturn (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n\t}\n\n\t/**\n\t * Test if position is in this range. If the position is at the edges, will return true.\n\t */\n\tpublic containsPosition(position: IPosition): boolean {\n\t\treturn Range.containsPosition(this, position);\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return true.\n\t */\n\tpublic static containsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return false.\n\t * @internal\n\t */\n\tpublic static strictContainsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if range is in this range. If the range is equal to this range, will return true.\n\t */\n\tpublic containsRange(range: IRange): boolean {\n\t\treturn Range.containsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n\t */\n\tpublic static containsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n\t */\n\tpublic strictContainsRange(range: IRange): boolean {\n\t\treturn Range.strictContainsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n\t */\n\tpublic static strictContainsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic plusRange(range: IRange): Range {\n\t\treturn Range.plusRange(this, range);\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic static plusRange(a: IRange, b: IRange): Range {\n\t\tlet startLineNumber: number;\n\t\tlet startColumn: number;\n\t\tlet endLineNumber: number;\n\t\tlet endColumn: number;\n\n\t\tif (b.startLineNumber < a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = b.startColumn;\n\t\t} else if (b.startLineNumber === a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = Math.min(b.startColumn, a.startColumn);\n\t\t} else {\n\t\t\tstartLineNumber = a.startLineNumber;\n\t\t\tstartColumn = a.startColumn;\n\t\t}\n\n\t\tif (b.endLineNumber > a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = b.endColumn;\n\t\t} else if (b.endLineNumber === a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = Math.max(b.endColumn, a.endColumn);\n\t\t} else {\n\t\t\tendLineNumber = a.endLineNumber;\n\t\t\tendColumn = a.endColumn;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic intersectRanges(range: IRange): Range | null {\n\t\treturn Range.intersectRanges(this, range);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic static intersectRanges(a: IRange, b: IRange): Range | null {\n\t\tlet resultStartLineNumber = a.startLineNumber;\n\t\tlet resultStartColumn = a.startColumn;\n\t\tlet resultEndLineNumber = a.endLineNumber;\n\t\tlet resultEndColumn = a.endColumn;\n\t\tconst otherStartLineNumber = b.startLineNumber;\n\t\tconst otherStartColumn = b.startColumn;\n\t\tconst otherEndLineNumber = b.endLineNumber;\n\t\tconst otherEndColumn = b.endColumn;\n\n\t\tif (resultStartLineNumber < otherStartLineNumber) {\n\t\t\tresultStartLineNumber = otherStartLineNumber;\n\t\t\tresultStartColumn = otherStartColumn;\n\t\t} else if (resultStartLineNumber === otherStartLineNumber) {\n\t\t\tresultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n\t\t}\n\n\t\tif (resultEndLineNumber > otherEndLineNumber) {\n\t\t\tresultEndLineNumber = otherEndLineNumber;\n\t\t\tresultEndColumn = otherEndColumn;\n\t\t} else if (resultEndLineNumber === otherEndLineNumber) {\n\t\t\tresultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n\t\t}\n\n\t\t// Check if selection is now empty\n\t\tif (resultStartLineNumber > resultEndLineNumber) {\n\t\t\treturn null;\n\t\t}\n\t\tif (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n\t}\n\n\t/**\n\t * Test if this range equals other.\n\t */\n\tpublic equalsRange(other: IRange | null | undefined): boolean {\n\t\treturn Range.equalsRange(this, other);\n\t}\n\n\t/**\n\t * Test if range `a` equals `b`.\n\t */\n\tpublic static equalsRange(a: IRange | null | undefined, b: IRange | null | undefined): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.startLineNumber === b.startLineNumber &&\n\t\t\ta.startColumn === b.startColumn &&\n\t\t\ta.endLineNumber === b.endLineNumber &&\n\t\t\ta.endColumn === b.endColumn\n\t\t);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic getEndPosition(): Position {\n\t\treturn Range.getEndPosition(this);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic static getEndPosition(range: IRange): Position {\n\t\treturn new Position(range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic getStartPosition(): Position {\n\t\treturn Range.getStartPosition(this);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic static getStartPosition(range: IRange): Position {\n\t\treturn new Position(range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Transform to a user presentable string representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n\t}\n\n\t/**\n\t * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n\t */\n\tpublic setEndPosition(endLineNumber: number, endColumn: number): Range {\n\t\treturn new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n\t */\n\tpublic setStartPosition(startLineNumber: number, startColumn: number): Range {\n\t\treturn new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic collapseToStart(): Range {\n\t\treturn Range.collapseToStart(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic static collapseToStart(range: IRange): Range {\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic collapseToEnd(): Range {\n\t\treturn Range.collapseToEnd(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic static collapseToEnd(range: IRange): Range {\n\t\treturn new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Moves the range by the given amount of lines.\n\t */\n\tpublic delta(lineCount: number): Range {\n\t\treturn new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n\t}\n\n\tpublic isSingleLine(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumber;\n\t}\n\n\t// ---\n\n\tpublic static fromPositions(start: IPosition, end: IPosition = start): Range {\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Create a `Range` from an `IRange`.\n\t */\n\tpublic static lift(range: undefined | null): null;\n\tpublic static lift(range: IRange): Range;\n\tpublic static lift(range: IRange | undefined | null): Range | null;\n\tpublic static lift(range: IRange | undefined | null): Range | null {\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IRange`.\n\t */\n\tpublic static isIRange(obj: any): obj is IRange {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.startLineNumber === 'number')\n\t\t\t&& (typeof obj.startColumn === 'number')\n\t\t\t&& (typeof obj.endLineNumber === 'number')\n\t\t\t&& (typeof obj.endColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two ranges are touching in any way.\n\t */\n\tpublic static areIntersectingOrTouching(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n\t */\n\tpublic static areIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting, but not touching at all.\n\t */\n\tpublic static areOnlyIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < (b.startLineNumber - 1) || (a.endLineNumber === b.startLineNumber && a.endColumn < (b.startColumn - 1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < (a.startLineNumber - 1) || (b.endLineNumber === a.startLineNumber && b.endColumn < (a.startColumn - 1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the startPosition and then on the endPosition\n\t */\n\tpublic static compareRangesUsingStarts(a: IRange | null | undefined, b: IRange | null | undefined): number {\n\t\tif (a && b) {\n\t\t\tconst aStartLineNumber = a.startLineNumber | 0;\n\t\t\tconst bStartLineNumber = b.startLineNumber | 0;\n\n\t\t\tif (aStartLineNumber === bStartLineNumber) {\n\t\t\t\tconst aStartColumn = a.startColumn | 0;\n\t\t\t\tconst bStartColumn = b.startColumn | 0;\n\n\t\t\t\tif (aStartColumn === bStartColumn) {\n\t\t\t\t\tconst aEndLineNumber = a.endLineNumber | 0;\n\t\t\t\t\tconst bEndLineNumber = b.endLineNumber | 0;\n\n\t\t\t\t\tif (aEndLineNumber === bEndLineNumber) {\n\t\t\t\t\t\tconst aEndColumn = a.endColumn | 0;\n\t\t\t\t\t\tconst bEndColumn = b.endColumn | 0;\n\t\t\t\t\t\treturn aEndColumn - bEndColumn;\n\t\t\t\t\t}\n\t\t\t\t\treturn aEndLineNumber - bEndLineNumber;\n\t\t\t\t}\n\t\t\t\treturn aStartColumn - bStartColumn;\n\t\t\t}\n\t\t\treturn aStartLineNumber - bStartLineNumber;\n\t\t}\n\t\tconst aExists = (a ? 1 : 0);\n\t\tconst bExists = (b ? 1 : 0);\n\t\treturn aExists - bExists;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the endPosition and then on the startPosition\n\t */\n\tpublic static compareRangesUsingEnds(a: IRange, b: IRange): number {\n\t\tif (a.endLineNumber === b.endLineNumber) {\n\t\t\tif (a.endColumn === b.endColumn) {\n\t\t\t\tif (a.startLineNumber === b.startLineNumber) {\n\t\t\t\t\treturn a.startColumn - b.startColumn;\n\t\t\t\t}\n\t\t\t\treturn a.startLineNumber - b.startLineNumber;\n\t\t\t}\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\t\treturn a.endLineNumber - b.endLineNumber;\n\t}\n\n\t/**\n\t * Test if the range spans multiple lines.\n\t */\n\tpublic static spansMultipleLines(range: IRange): boolean {\n\t\treturn range.endLineNumber > range.startLineNumber;\n\t}\n\n\tpublic toJSON(): IRange {\n\t\treturn this;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\n\n/**\n * A range in the editor. This interface is suitable for serialization.\n */\nexport interface IRange {\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\treadonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\treadonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\tpublic readonly startLineNumber: number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\tpublic readonly startColumn: number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\tpublic readonly endLineNumber: number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\tpublic readonly endColumn: number;\n\n\tconstructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number) {\n\t\tif ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n\t\t\tthis.startLineNumber = endLineNumber;\n\t\t\tthis.startColumn = endColumn;\n\t\t\tthis.endLineNumber = startLineNumber;\n\t\t\tthis.endColumn = startColumn;\n\t\t} else {\n\t\t\tthis.startLineNumber = startLineNumber;\n\t\t\tthis.startColumn = startColumn;\n\t\t\tthis.endLineNumber = endLineNumber;\n\t\t\tthis.endColumn = endColumn;\n\t\t}\n\t}\n\n\t/**\n\t * Test if this range is empty.\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn Range.isEmpty(this);\n\t}\n\n\t/**\n\t * Test if `range` is empty.\n\t */\n\tpublic static isEmpty(range: IRange): boolean {\n\t\treturn (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n\t}\n\n\t/**\n\t * Test if position is in this range. If the position is at the edges, will return true.\n\t */\n\tpublic containsPosition(position: IPosition): boolean {\n\t\treturn Range.containsPosition(this, position);\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return true.\n\t */\n\tpublic static containsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `position` is in `range`. If the position is at the edges, will return false.\n\t * @internal\n\t */\n\tpublic static strictContainsPosition(range: IRange, position: IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if range is in this range. If the range is equal to this range, will return true.\n\t */\n\tpublic containsRange(range: IRange): boolean {\n\t\treturn Range.containsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n\t */\n\tpublic static containsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n\t */\n\tpublic strictContainsRange(range: IRange): boolean {\n\t\treturn Range.strictContainsRange(this, range);\n\t}\n\n\t/**\n\t * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n\t */\n\tpublic static strictContainsRange(range: IRange, otherRange: IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic plusRange(range: IRange): Range {\n\t\treturn Range.plusRange(this, range);\n\t}\n\n\t/**\n\t * A reunion of the two ranges.\n\t * The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic static plusRange(a: IRange, b: IRange): Range {\n\t\tlet startLineNumber: number;\n\t\tlet startColumn: number;\n\t\tlet endLineNumber: number;\n\t\tlet endColumn: number;\n\n\t\tif (b.startLineNumber < a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = b.startColumn;\n\t\t} else if (b.startLineNumber === a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = Math.min(b.startColumn, a.startColumn);\n\t\t} else {\n\t\t\tstartLineNumber = a.startLineNumber;\n\t\t\tstartColumn = a.startColumn;\n\t\t}\n\n\t\tif (b.endLineNumber > a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = b.endColumn;\n\t\t} else if (b.endLineNumber === a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = Math.max(b.endColumn, a.endColumn);\n\t\t} else {\n\t\t\tendLineNumber = a.endLineNumber;\n\t\t\tendColumn = a.endColumn;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic intersectRanges(range: IRange): Range | null {\n\t\treturn Range.intersectRanges(this, range);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic static intersectRanges(a: IRange, b: IRange): Range | null {\n\t\tlet resultStartLineNumber = a.startLineNumber;\n\t\tlet resultStartColumn = a.startColumn;\n\t\tlet resultEndLineNumber = a.endLineNumber;\n\t\tlet resultEndColumn = a.endColumn;\n\t\tconst otherStartLineNumber = b.startLineNumber;\n\t\tconst otherStartColumn = b.startColumn;\n\t\tconst otherEndLineNumber = b.endLineNumber;\n\t\tconst otherEndColumn = b.endColumn;\n\n\t\tif (resultStartLineNumber < otherStartLineNumber) {\n\t\t\tresultStartLineNumber = otherStartLineNumber;\n\t\t\tresultStartColumn = otherStartColumn;\n\t\t} else if (resultStartLineNumber === otherStartLineNumber) {\n\t\t\tresultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n\t\t}\n\n\t\tif (resultEndLineNumber > otherEndLineNumber) {\n\t\t\tresultEndLineNumber = otherEndLineNumber;\n\t\t\tresultEndColumn = otherEndColumn;\n\t\t} else if (resultEndLineNumber === otherEndLineNumber) {\n\t\t\tresultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n\t\t}\n\n\t\t// Check if selection is now empty\n\t\tif (resultStartLineNumber > resultEndLineNumber) {\n\t\t\treturn null;\n\t\t}\n\t\tif (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n\t}\n\n\t/**\n\t * Test if this range equals other.\n\t */\n\tpublic equalsRange(other: IRange | null | undefined): boolean {\n\t\treturn Range.equalsRange(this, other);\n\t}\n\n\t/**\n\t * Test if range `a` equals `b`.\n\t */\n\tpublic static equalsRange(a: IRange | null | undefined, b: IRange | null | undefined): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.startLineNumber === b.startLineNumber &&\n\t\t\ta.startColumn === b.startColumn &&\n\t\t\ta.endLineNumber === b.endLineNumber &&\n\t\t\ta.endColumn === b.endColumn\n\t\t);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic getEndPosition(): Position {\n\t\treturn Range.getEndPosition(this);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic static getEndPosition(range: IRange): Position {\n\t\treturn new Position(range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic getStartPosition(): Position {\n\t\treturn Range.getStartPosition(this);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic static getStartPosition(range: IRange): Position {\n\t\treturn new Position(range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Transform to a user presentable string representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n\t}\n\n\t/**\n\t * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n\t */\n\tpublic setEndPosition(endLineNumber: number, endColumn: number): Range {\n\t\treturn new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n\t */\n\tpublic setStartPosition(startLineNumber: number, startColumn: number): Range {\n\t\treturn new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic collapseToStart(): Range {\n\t\treturn Range.collapseToStart(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's start position.\n\t */\n\tpublic static collapseToStart(range: IRange): Range {\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic collapseToEnd(): Range {\n\t\treturn Range.collapseToEnd(this);\n\t}\n\n\t/**\n\t * Create a new empty range using this range's end position.\n\t */\n\tpublic static collapseToEnd(range: IRange): Range {\n\t\treturn new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Moves the range by the given amount of lines.\n\t */\n\tpublic delta(lineCount: number): Range {\n\t\treturn new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n\t}\n\n\tpublic isSingleLine(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumber;\n\t}\n\n\t// ---\n\n\tpublic static fromPositions(start: IPosition, end: IPosition = start): Range {\n\t\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Create a `Range` from an `IRange`.\n\t */\n\tpublic static lift(range: undefined | null): null;\n\tpublic static lift(range: IRange): Range;\n\tpublic static lift(range: IRange | undefined | null): Range | null;\n\tpublic static lift(range: IRange | undefined | null): Range | null {\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\t/**\n\t * Test if `obj` is an `IRange`.\n\t */\n\tpublic static isIRange(obj: any): obj is IRange {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.startLineNumber === 'number')\n\t\t\t&& (typeof obj.startColumn === 'number')\n\t\t\t&& (typeof obj.endLineNumber === 'number')\n\t\t\t&& (typeof obj.endColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two ranges are touching in any way.\n\t */\n\tpublic static areIntersectingOrTouching(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n\t */\n\tpublic static areIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if the two ranges are intersecting, but not touching at all.\n\t */\n\tpublic static areOnlyIntersecting(a: IRange, b: IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < (b.startLineNumber - 1) || (a.endLineNumber === b.startLineNumber && a.endColumn < (b.startColumn - 1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < (a.startLineNumber - 1) || (b.endLineNumber === a.startLineNumber && b.endColumn < (a.startColumn - 1))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the startPosition and then on the endPosition\n\t */\n\tpublic static compareRangesUsingStarts(a: IRange | null | undefined, b: IRange | null | undefined): number {\n\t\tif (a && b) {\n\t\t\tconst aStartLineNumber = a.startLineNumber | 0;\n\t\t\tconst bStartLineNumber = b.startLineNumber | 0;\n\n\t\t\tif (aStartLineNumber === bStartLineNumber) {\n\t\t\t\tconst aStartColumn = a.startColumn | 0;\n\t\t\t\tconst bStartColumn = b.startColumn | 0;\n\n\t\t\t\tif (aStartColumn === bStartColumn) {\n\t\t\t\t\tconst aEndLineNumber = a.endLineNumber | 0;\n\t\t\t\t\tconst bEndLineNumber = b.endLineNumber | 0;\n\n\t\t\t\t\tif (aEndLineNumber === bEndLineNumber) {\n\t\t\t\t\t\tconst aEndColumn = a.endColumn | 0;\n\t\t\t\t\t\tconst bEndColumn = b.endColumn | 0;\n\t\t\t\t\t\treturn aEndColumn - bEndColumn;\n\t\t\t\t\t}\n\t\t\t\t\treturn aEndLineNumber - bEndLineNumber;\n\t\t\t\t}\n\t\t\t\treturn aStartColumn - bStartColumn;\n\t\t\t}\n\t\t\treturn aStartLineNumber - bStartLineNumber;\n\t\t}\n\t\tconst aExists = (a ? 1 : 0);\n\t\tconst bExists = (b ? 1 : 0);\n\t\treturn aExists - bExists;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the endPosition and then on the startPosition\n\t */\n\tpublic static compareRangesUsingEnds(a: IRange, b: IRange): number {\n\t\tif (a.endLineNumber === b.endLineNumber) {\n\t\t\tif (a.endColumn === b.endColumn) {\n\t\t\t\tif (a.startLineNumber === b.startLineNumber) {\n\t\t\t\t\treturn a.startColumn - b.startColumn;\n\t\t\t\t}\n\t\t\t\treturn a.startLineNumber - b.startLineNumber;\n\t\t\t}\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\t\treturn a.endLineNumber - b.endLineNumber;\n\t}\n\n\t/**\n\t * Test if the range spans multiple lines.\n\t */\n\tpublic static spansMultipleLines(range: IRange): boolean {\n\t\treturn range.endLineNumber > range.startLineNumber;\n\t}\n\n\tpublic toJSON(): IRange {\n\t\treturn this;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 504, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/selection.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/selection.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\nimport { Range } from './range.js';\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport interface ISelection {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\treadonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\treadonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\treadonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\treadonly positionColumn: number;\n}\n\n/**\n * The direction of a selection.\n */\nexport const enum SelectionDirection {\n\t/**\n\t * The selection starts above where it ends.\n\t */\n\tLTR,\n\t/**\n\t * The selection starts below where it ends.\n\t */\n\tRTL\n}\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\tpublic readonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\tpublic readonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\tpublic readonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\tpublic readonly positionColumn: number;\n\n\tconstructor(selectionStartLineNumber: number, selectionStartColumn: number, positionLineNumber: number, positionColumn: number) {\n\t\tsuper(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n\t\tthis.selectionStartLineNumber = selectionStartLineNumber;\n\t\tthis.selectionStartColumn = selectionStartColumn;\n\t\tthis.positionLineNumber = positionLineNumber;\n\t\tthis.positionColumn = positionColumn;\n\t}\n\n\t/**\n\t * Transform to a human-readable representation.\n\t */\n\tpublic override toString(): string {\n\t\treturn '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n\t}\n\n\t/**\n\t * Test if equals other selection.\n\t */\n\tpublic equalsSelection(other: ISelection): boolean {\n\t\treturn (\n\t\t\tSelection.selectionsEqual(this, other)\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two selections are equal.\n\t */\n\tpublic static selectionsEqual(a: ISelection, b: ISelection): boolean {\n\t\treturn (\n\t\t\ta.selectionStartLineNumber === b.selectionStartLineNumber &&\n\t\t\ta.selectionStartColumn === b.selectionStartColumn &&\n\t\t\ta.positionLineNumber === b.positionLineNumber &&\n\t\t\ta.positionColumn === b.positionColumn\n\t\t);\n\t}\n\n\t/**\n\t * Get directions (LTR or RTL).\n\t */\n\tpublic getDirection(): SelectionDirection {\n\t\tif (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n\t\t\treturn SelectionDirection.LTR;\n\t\t}\n\t\treturn SelectionDirection.RTL;\n\t}\n\n\t/**\n\t * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic override setEndPosition(endLineNumber: number, endColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t\t}\n\t\treturn new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n\t}\n\n\t/**\n\t * Get the position at `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic getPosition(): Position {\n\t\treturn new Position(this.positionLineNumber, this.positionColumn);\n\t}\n\n\t/**\n\t * Get the position at the start of the selection.\n\t*/\n\tpublic getSelectionStart(): Position {\n\t\treturn new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n\t}\n\n\t/**\n\t * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n\t */\n\tpublic override setStartPosition(startLineNumber: number, startColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t\t}\n\t\treturn new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n\t}\n\n\t// ----\n\n\t/**\n\t * Create a `Selection` from one or two positions\n\t */\n\tpublic static override fromPositions(start: IPosition, end: IPosition = start): Selection {\n\t\treturn new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Creates a `Selection` from a range, given a direction.\n\t */\n\tpublic static fromRange(range: Range, direction: SelectionDirection): Selection {\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\t} else {\n\t\t\treturn new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n\t\t}\n\t}\n\n\t/**\n\t * Create a `Selection` from an `ISelection`.\n\t */\n\tpublic static liftSelection(sel: ISelection): Selection {\n\t\treturn new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n\t}\n\n\t/**\n\t * `a` equals `b`.\n\t */\n\tpublic static selectionsArrEqual(a: ISelection[], b: ISelection[]): boolean {\n\t\tif (a && !b || !a && b) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = a.length; i < len; i++) {\n\t\t\tif (!this.selectionsEqual(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `obj` is an `ISelection`.\n\t */\n\tpublic static isISelection(obj: any): obj is ISelection {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.selectionStartLineNumber === 'number')\n\t\t\t&& (typeof obj.selectionStartColumn === 'number')\n\t\t\t&& (typeof obj.positionLineNumber === 'number')\n\t\t\t&& (typeof obj.positionColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Create with a direction.\n\t */\n\tpublic static createWithDirection(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, direction: SelectionDirection): Selection {\n\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t}\n\n\t\treturn new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IPosition, Position } from './position.js';\nimport { Range } from './range.js';\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport interface ISelection {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\treadonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\treadonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\treadonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\treadonly positionColumn: number;\n}\n\n/**\n * The direction of a selection.\n */\nexport const enum SelectionDirection {\n\t/**\n\t * The selection starts above where it ends.\n\t */\n\tLTR,\n\t/**\n\t * The selection starts below where it ends.\n\t */\n\tRTL\n}\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\tpublic readonly selectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\tpublic readonly selectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\tpublic readonly positionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\tpublic readonly positionColumn: number;\n\n\tconstructor(selectionStartLineNumber: number, selectionStartColumn: number, positionLineNumber: number, positionColumn: number) {\n\t\tsuper(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n\t\tthis.selectionStartLineNumber = selectionStartLineNumber;\n\t\tthis.selectionStartColumn = selectionStartColumn;\n\t\tthis.positionLineNumber = positionLineNumber;\n\t\tthis.positionColumn = positionColumn;\n\t}\n\n\t/**\n\t * Transform to a human-readable representation.\n\t */\n\tpublic override toString(): string {\n\t\treturn '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n\t}\n\n\t/**\n\t * Test if equals other selection.\n\t */\n\tpublic equalsSelection(other: ISelection): boolean {\n\t\treturn (\n\t\t\tSelection.selectionsEqual(this, other)\n\t\t);\n\t}\n\n\t/**\n\t * Test if the two selections are equal.\n\t */\n\tpublic static selectionsEqual(a: ISelection, b: ISelection): boolean {\n\t\treturn (\n\t\t\ta.selectionStartLineNumber === b.selectionStartLineNumber &&\n\t\t\ta.selectionStartColumn === b.selectionStartColumn &&\n\t\t\ta.positionLineNumber === b.positionLineNumber &&\n\t\t\ta.positionColumn === b.positionColumn\n\t\t);\n\t}\n\n\t/**\n\t * Get directions (LTR or RTL).\n\t */\n\tpublic getDirection(): SelectionDirection {\n\t\tif (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n\t\t\treturn SelectionDirection.LTR;\n\t\t}\n\t\treturn SelectionDirection.RTL;\n\t}\n\n\t/**\n\t * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic override setEndPosition(endLineNumber: number, endColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t\t}\n\t\treturn new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n\t}\n\n\t/**\n\t * Get the position at `positionLineNumber` and `positionColumn`.\n\t */\n\tpublic getPosition(): Position {\n\t\treturn new Position(this.positionLineNumber, this.positionColumn);\n\t}\n\n\t/**\n\t * Get the position at the start of the selection.\n\t*/\n\tpublic getSelectionStart(): Position {\n\t\treturn new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n\t}\n\n\t/**\n\t * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n\t */\n\tpublic override setStartPosition(startLineNumber: number, startColumn: number): Selection {\n\t\tif (this.getDirection() === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t\t}\n\t\treturn new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n\t}\n\n\t// ----\n\n\t/**\n\t * Create a `Selection` from one or two positions\n\t */\n\tpublic static override fromPositions(start: IPosition, end: IPosition = start): Selection {\n\t\treturn new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n\t}\n\n\t/**\n\t * Creates a `Selection` from a range, given a direction.\n\t */\n\tpublic static fromRange(range: Range, direction: SelectionDirection): Selection {\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\t} else {\n\t\t\treturn new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n\t\t}\n\t}\n\n\t/**\n\t * Create a `Selection` from an `ISelection`.\n\t */\n\tpublic static liftSelection(sel: ISelection): Selection {\n\t\treturn new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n\t}\n\n\t/**\n\t * `a` equals `b`.\n\t */\n\tpublic static selectionsArrEqual(a: ISelection[], b: ISelection[]): boolean {\n\t\tif (a && !b || !a && b) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = a.length; i < len; i++) {\n\t\t\tif (!this.selectionsEqual(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Test if `obj` is an `ISelection`.\n\t */\n\tpublic static isISelection(obj: any): obj is ISelection {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.selectionStartLineNumber === 'number')\n\t\t\t&& (typeof obj.selectionStartColumn === 'number')\n\t\t\t&& (typeof obj.positionLineNumber === 'number')\n\t\t\t&& (typeof obj.positionColumn === 'number')\n\t\t);\n\t}\n\n\t/**\n\t * Create with a direction.\n\t */\n\tpublic static createWithDirection(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, direction: SelectionDirection): Selection {\n\n\t\tif (direction === SelectionDirection.LTR) {\n\t\t\treturn new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t}\n\n\t\treturn new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 629, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/cursorColumns.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/cursorColumns.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\n\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n\n\tprivate static _nextVisibleColumn(codePoint: number, visibleColumn: number, tabSize: number): number {\n\t\tif (codePoint === CharCode.Tab) {\n\t\t\treturn CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n\t\t}\n\t\tif (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n\t\t\treturn visibleColumn + 2;\n\t\t}\n\t\treturn visibleColumn + 1;\n\t}\n\n\t/**\n\t * Returns a visible column from a column.\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static visibleColumnFromColumn(lineContent: string, column: number, tabSize: number): number {\n\t\tconst textLen = Math.min(column - 1, lineContent.length);\n\t\tconst text = lineContent.substring(0, textLen);\n\t\tconst iterator = new strings.GraphemeIterator(text);\n\n\t\tlet result = 0;\n\t\twhile (!iterator.eol()) {\n\t\t\tconst codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n\t\t\titerator.nextGraphemeLength();\n\n\t\t\tresult = this._nextVisibleColumn(codePoint, result, tabSize);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a column from a visible column.\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static columnFromVisibleColumn(lineContent: string, visibleColumn: number, tabSize: number): number {\n\t\tif (visibleColumn <= 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst lineContentLength = lineContent.length;\n\t\tconst iterator = new strings.GraphemeIterator(lineContent);\n\n\t\tlet beforeVisibleColumn = 0;\n\t\tlet beforeColumn = 1;\n\t\twhile (!iterator.eol()) {\n\t\t\tconst codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n\t\t\titerator.nextGraphemeLength();\n\n\t\t\tconst afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n\t\t\tconst afterColumn = iterator.offset + 1;\n\n\t\t\tif (afterVisibleColumn >= visibleColumn) {\n\t\t\t\tconst beforeDelta = visibleColumn - beforeVisibleColumn;\n\t\t\t\tconst afterDelta = afterVisibleColumn - visibleColumn;\n\t\t\t\tif (afterDelta < beforeDelta) {\n\t\t\t\t\treturn afterColumn;\n\t\t\t\t} else {\n\t\t\t\t\treturn beforeColumn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbeforeVisibleColumn = afterVisibleColumn;\n\t\t\tbeforeColumn = afterColumn;\n\t\t}\n\n\t\t// walked the entire string\n\t\treturn lineContentLength + 1;\n\t}\n\n\t/**\n\t * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static nextRenderTabStop(visibleColumn: number, tabSize: number): number {\n\t\treturn visibleColumn + tabSize - visibleColumn % tabSize;\n\t}\n\n\t/**\n\t * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static nextIndentTabStop(visibleColumn: number, indentSize: number): number {\n\t\treturn CursorColumns.nextRenderTabStop(visibleColumn, indentSize);\n\t}\n\n\t/**\n\t * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static prevRenderTabStop(column: number, tabSize: number): number {\n\t\treturn Math.max(0, column - 1 - (column - 1) % tabSize);\n\t}\n\n\t/**\n\t * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static prevIndentTabStop(column: number, indentSize: number): number {\n\t\treturn CursorColumns.prevRenderTabStop(column, indentSize);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\n\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n\n\tprivate static _nextVisibleColumn(codePoint: number, visibleColumn: number, tabSize: number): number {\n\t\tif (codePoint === CharCode.Tab) {\n\t\t\treturn CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n\t\t}\n\t\tif (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n\t\t\treturn visibleColumn + 2;\n\t\t}\n\t\treturn visibleColumn + 1;\n\t}\n\n\t/**\n\t * Returns a visible column from a column.\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static visibleColumnFromColumn(lineContent: string, column: number, tabSize: number): number {\n\t\tconst textLen = Math.min(column - 1, lineContent.length);\n\t\tconst text = lineContent.substring(0, textLen);\n\t\tconst iterator = new strings.GraphemeIterator(text);\n\n\t\tlet result = 0;\n\t\twhile (!iterator.eol()) {\n\t\t\tconst codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n\t\t\titerator.nextGraphemeLength();\n\n\t\t\tresult = this._nextVisibleColumn(codePoint, result, tabSize);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a column from a visible column.\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static columnFromVisibleColumn(lineContent: string, visibleColumn: number, tabSize: number): number {\n\t\tif (visibleColumn <= 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst lineContentLength = lineContent.length;\n\t\tconst iterator = new strings.GraphemeIterator(lineContent);\n\n\t\tlet beforeVisibleColumn = 0;\n\t\tlet beforeColumn = 1;\n\t\twhile (!iterator.eol()) {\n\t\t\tconst codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n\t\t\titerator.nextGraphemeLength();\n\n\t\t\tconst afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n\t\t\tconst afterColumn = iterator.offset + 1;\n\n\t\t\tif (afterVisibleColumn >= visibleColumn) {\n\t\t\t\tconst beforeDelta = visibleColumn - beforeVisibleColumn;\n\t\t\t\tconst afterDelta = afterVisibleColumn - visibleColumn;\n\t\t\t\tif (afterDelta < beforeDelta) {\n\t\t\t\t\treturn afterColumn;\n\t\t\t\t} else {\n\t\t\t\t\treturn beforeColumn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbeforeVisibleColumn = afterVisibleColumn;\n\t\t\tbeforeColumn = afterColumn;\n\t\t}\n\n\t\t// walked the entire string\n\t\treturn lineContentLength + 1;\n\t}\n\n\t/**\n\t * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static nextRenderTabStop(visibleColumn: number, tabSize: number): number {\n\t\treturn visibleColumn + tabSize - visibleColumn % tabSize;\n\t}\n\n\t/**\n\t * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static nextIndentTabStop(visibleColumn: number, indentSize: number): number {\n\t\treturn CursorColumns.nextRenderTabStop(visibleColumn, indentSize);\n\t}\n\n\t/**\n\t * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static prevRenderTabStop(column: number, tabSize: number): number {\n\t\treturn Math.max(0, column - 1 - (column - 1) % tabSize);\n\t}\n\n\t/**\n\t * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n\t * @see {@link CursorColumns}\n\t */\n\tpublic static prevIndentTabStop(column: number, indentSize: number): number {\n\t\treturn CursorColumns.prevRenderTabStop(column, indentSize);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/misc/indentation.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/misc/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/misc/indentation.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/misc/vs/editor/common/core/misc/indentation.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport { CursorColumns } from '../cursorColumns.js';\n\nfunction _normalizeIndentationFromWhitespace(str: string, indentSize: number, insertSpaces: boolean): string {\n\tlet spacesCnt = 0;\n\tfor (let i = 0; i < str.length; i++) {\n\t\tif (str.charAt(i) === '\\t') {\n\t\t\tspacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n\t\t} else {\n\t\t\tspacesCnt++;\n\t\t}\n\t}\n\n\tlet result = '';\n\tif (!insertSpaces) {\n\t\tconst tabsCnt = Math.floor(spacesCnt / indentSize);\n\t\tspacesCnt = spacesCnt % indentSize;\n\t\tfor (let i = 0; i < tabsCnt; i++) {\n\t\t\tresult += '\\t';\n\t\t}\n\t}\n\n\tfor (let i = 0; i < spacesCnt; i++) {\n\t\tresult += ' ';\n\t}\n\n\treturn result;\n}\n\nexport function normalizeIndentation(str: string, indentSize: number, insertSpaces: boolean): string {\n\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n\tif (firstNonWhitespaceIndex === -1) {\n\t\tfirstNonWhitespaceIndex = str.length;\n\t}\n\treturn _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../../base/common/strings.js';\nimport { CursorColumns } from '../cursorColumns.js';\n\nfunction _normalizeIndentationFromWhitespace(str: string, indentSize: number, insertSpaces: boolean): string {\n\tlet spacesCnt = 0;\n\tfor (let i = 0; i < str.length; i++) {\n\t\tif (str.charAt(i) === '\\t') {\n\t\t\tspacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n\t\t} else {\n\t\t\tspacesCnt++;\n\t\t}\n\t}\n\n\tlet result = '';\n\tif (!insertSpaces) {\n\t\tconst tabsCnt = Math.floor(spacesCnt / indentSize);\n\t\tspacesCnt = spacesCnt % indentSize;\n\t\tfor (let i = 0; i < tabsCnt; i++) {\n\t\t\tresult += '\\t';\n\t\t}\n\t}\n\n\tfor (let i = 0; i < spacesCnt; i++) {\n\t\tresult += ' ';\n\t}\n\n\treturn result;\n}\n\nexport function normalizeIndentation(str: string, indentSize: number, insertSpaces: boolean): string {\n\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n\tif (firstNonWhitespaceIndex === -1) {\n\t\tfirstNonWhitespaceIndex = str.length;\n\t}\n\treturn _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,KAAK,OAAO,MAAM,oCAAoC,CAAC;AAC9D,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;;;AAEpD,SAAS,mCAAmC,CAAC,GAAW,EAAE,UAAkB,EAAE,YAAqB;IAClG,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;QACrC,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;YAC5B,SAAS,GAAG,2MAAa,CAAC,iBAAiB,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;QACpE,CAAC,MAAM,CAAC;YACP,SAAS,EAAE,CAAC;QACb,CAAC;IACF,CAAC;IAED,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,IAAI,CAAC,YAAY,EAAE,CAAC;QACnB,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,UAAU,CAAC,CAAC;QACnD,SAAS,GAAG,SAAS,GAAG,UAAU,CAAC;QACnC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,EAAE,CAAE,CAAC;YAClC,MAAM,IAAI,IAAI,CAAC;QAChB,CAAC;IACF,CAAC;IAED,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,CAAE,CAAC;QACpC,MAAM,IAAI,GAAG,CAAC;IACf,CAAC;IAED,OAAO,MAAM,CAAC;AACf,CAAC;AAEK,SAAU,oBAAoB,CAAC,GAAW,EAAE,UAAkB,EAAE,YAAqB;IAC1F,IAAI,uBAAuB,GAAG,OAAO,CAAC,6LAAuB,CAAC,GAAG,CAAC,CAAC;IACnE,IAAI,uBAAuB,KAAK,CAAC,CAAC,EAAE,CAAC;QACpC,uBAAuB,GAAG,GAAG,CAAC,MAAM,CAAC;IACtC,CAAC;IACD,OAAO,mCAAmC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,EAAE,uBAAuB,CAAC,EAAE,UAAU,EAAE,YAAY,CAAC,GAAG,GAAG,CAAC,SAAS,CAAC,uBAAuB,CAAC,CAAC;AAC1J,CAAC","debugId":null}},
    {"offset": {"line": 767, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/characterClassifier.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/characterClassifier.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { toUint8 } from '../../../base/common/uint.js';\n\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier<T extends number> {\n\t/**\n\t * Maintain a compact (fully initialized ASCII map for quickly classifying ASCII characters - used more often in code).\n\t */\n\tprotected readonly _asciiMap: Uint8Array;\n\n\t/**\n\t * The entire map (sparse array).\n\t */\n\tprotected readonly _map: Map<number, number>;\n\n\tprotected readonly _defaultValue: number;\n\n\tconstructor(_defaultValue: T) {\n\t\tconst defaultValue = toUint8(_defaultValue);\n\n\t\tthis._defaultValue = defaultValue;\n\t\tthis._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n\t\tthis._map = new Map<number, number>();\n\t}\n\n\tprivate static _createAsciiMap(defaultValue: number): Uint8Array {\n\t\tconst asciiMap = new Uint8Array(256);\n\t\tasciiMap.fill(defaultValue);\n\t\treturn asciiMap;\n\t}\n\n\tpublic set(charCode: number, _value: T): void {\n\t\tconst value = toUint8(_value);\n\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\tthis._asciiMap[charCode] = value;\n\t\t} else {\n\t\t\tthis._map.set(charCode, value);\n\t\t}\n\t}\n\n\tpublic get(charCode: number): T {\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\treturn <T>this._asciiMap[charCode];\n\t\t} else {\n\t\t\treturn <T>(this._map.get(charCode) || this._defaultValue);\n\t\t}\n\t}\n\n\tpublic clear() {\n\t\tthis._asciiMap.fill(this._defaultValue);\n\t\tthis._map.clear();\n\t}\n}\n\nconst enum Boolean {\n\tFalse = 0,\n\tTrue = 1\n}\n\nexport class CharacterSet {\n\n\tprivate readonly _actual: CharacterClassifier<Boolean>;\n\n\tconstructor() {\n\t\tthis._actual = new CharacterClassifier<Boolean>(Boolean.False);\n\t}\n\n\tpublic add(charCode: number): void {\n\t\tthis._actual.set(charCode, Boolean.True);\n\t}\n\n\tpublic has(charCode: number): boolean {\n\t\treturn (this._actual.get(charCode) === Boolean.True);\n\t}\n\n\tpublic clear(): void {\n\t\treturn this._actual.clear();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { toUint8 } from '../../../base/common/uint.js';\n\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier<T extends number> {\n\t/**\n\t * Maintain a compact (fully initialized ASCII map for quickly classifying ASCII characters - used more often in code).\n\t */\n\tprotected readonly _asciiMap: Uint8Array;\n\n\t/**\n\t * The entire map (sparse array).\n\t */\n\tprotected readonly _map: Map<number, number>;\n\n\tprotected readonly _defaultValue: number;\n\n\tconstructor(_defaultValue: T) {\n\t\tconst defaultValue = toUint8(_defaultValue);\n\n\t\tthis._defaultValue = defaultValue;\n\t\tthis._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n\t\tthis._map = new Map<number, number>();\n\t}\n\n\tprivate static _createAsciiMap(defaultValue: number): Uint8Array {\n\t\tconst asciiMap = new Uint8Array(256);\n\t\tasciiMap.fill(defaultValue);\n\t\treturn asciiMap;\n\t}\n\n\tpublic set(charCode: number, _value: T): void {\n\t\tconst value = toUint8(_value);\n\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\tthis._asciiMap[charCode] = value;\n\t\t} else {\n\t\t\tthis._map.set(charCode, value);\n\t\t}\n\t}\n\n\tpublic get(charCode: number): T {\n\t\tif (charCode >= 0 && charCode < 256) {\n\t\t\treturn <T>this._asciiMap[charCode];\n\t\t} else {\n\t\t\treturn <T>(this._map.get(charCode) || this._defaultValue);\n\t\t}\n\t}\n\n\tpublic clear() {\n\t\tthis._asciiMap.fill(this._defaultValue);\n\t\tthis._map.clear();\n\t}\n}\n\nconst enum Boolean {\n\tFalse = 0,\n\tTrue = 1\n}\n\nexport class CharacterSet {\n\n\tprivate readonly _actual: CharacterClassifier<Boolean>;\n\n\tconstructor() {\n\t\tthis._actual = new CharacterClassifier<Boolean>(Boolean.False);\n\t}\n\n\tpublic add(charCode: number): void {\n\t\tthis._actual.set(charCode, Boolean.True);\n\t}\n\n\tpublic has(charCode: number): boolean {\n\t\treturn (this._actual.get(charCode) === Boolean.True);\n\t}\n\n\tpublic clear(): void {\n\t\treturn this._actual.clear();\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;AAEhG,OAAO,EAAE,OAAO,EAAE,MAAM,8BAA8B,CAAC;;AAKjD,MAAO,mBAAmB;IAa/B,YAAY,aAAgB,CAAA;QAC3B,MAAM,YAAY,OAAG,kLAAO,EAAC,aAAa,CAAC,CAAC;QAE5C,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;QAClC,IAAI,CAAC,SAAS,GAAG,mBAAmB,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC;QACnE,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG,EAAkB,CAAC;IACvC,CAAC;IAEO,MAAM,CAAC,eAAe,CAAC,YAAoB,EAAA;QAClD,MAAM,QAAQ,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;QACrC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC5B,OAAO,QAAQ,CAAC;IACjB,CAAC;IAEM,GAAG,CAAC,QAAgB,EAAE,MAAS,EAAA;QACrC,MAAM,KAAK,OAAG,kLAAO,EAAC,MAAM,CAAC,CAAC;QAE9B,IAAI,QAAQ,IAAI,CAAC,IAAI,QAAQ,GAAG,GAAG,EAAE,CAAC;YACrC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;QAClC,CAAC,MAAM,CAAC;YACP,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QAChC,CAAC;IACF,CAAC;IAEM,GAAG,CAAC,QAAgB,EAAA;QAC1B,IAAI,QAAQ,IAAI,CAAC,IAAI,QAAQ,GAAG,GAAG,EAAE,CAAC;YACrC,OAAU,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;QACpC,CAAC,MAAM,CAAC;YACP,OAAU,AAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,CAAC;QAC3D,CAAC;IACF,CAAC;IAEM,KAAK,GAAA;QACX,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACxC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;IACnB,CAAC;CACD;AAOK,MAAO,YAAY;IAIxB,aAAA;QACC,IAAI,CAAC,OAAO,GAAG,IAAI,mBAAmB,CAAA,EAAA,iBAAA,GAAwB,CAAC;IAChE,CAAC;IAEM,GAAG,CAAC,QAAgB,EAAA;QAC1B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAA,EAAA,gBAAA,GAAe,CAAC;IAC1C,CAAC;IAEM,GAAG,CAAC,QAAgB,EAAA;QAC1B,OAAO,AAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAA,EAAA,gBAAA,EAAiB,CAAC,CAAC;IACtD,CAAC;IAEM,KAAK,GAAA;QACX,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;IAC7B,CAAC;CACD","debugId":null}},
    {"offset": {"line": 828, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/wordCharacterClassifier.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/wordCharacterClassifier.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { safeIntl } from '../../../base/common/date.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\n\nexport const enum WordCharacterClass {\n\tRegular = 0,\n\tWhitespace = 1,\n\tWordSeparator = 2\n}\n\nexport class WordCharacterClassifier extends CharacterClassifier<WordCharacterClass> {\n\n\tpublic readonly intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[];\n\tprivate readonly _segmenter: Lazy<Intl.Segmenter> | null = null;\n\tprivate _cachedLine: string | null = null;\n\tprivate _cachedSegments: IntlWordSegmentData[] = [];\n\n\tconstructor(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]) {\n\t\tsuper(WordCharacterClass.Regular);\n\t\tthis.intlSegmenterLocales = intlSegmenterLocales;\n\t\tif (this.intlSegmenterLocales.length > 0) {\n\t\t\tthis._segmenter = safeIntl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n\t\t} else {\n\t\t\tthis._segmenter = null;\n\t\t}\n\n\t\tfor (let i = 0, len = wordSeparators.length; i < len; i++) {\n\t\t\tthis.set(wordSeparators.charCodeAt(i), WordCharacterClass.WordSeparator);\n\t\t}\n\n\t\tthis.set(CharCode.Space, WordCharacterClass.Whitespace);\n\t\tthis.set(CharCode.Tab, WordCharacterClass.Whitespace);\n\t}\n\n\tpublic findPrevIntlWordBeforeOrAtOffset(line: string, offset: number): IntlWordSegmentData | null {\n\t\tlet candidate: IntlWordSegmentData | null = null;\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n\t\t\tif (segment.index > offset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcandidate = segment;\n\t\t}\n\t\treturn candidate;\n\t}\n\n\tpublic findNextIntlWordAtOrAfterOffset(lineContent: string, offset: number): IntlWordSegmentData | null {\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n\t\t\tif (segment.index < offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn segment;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate _getIntlSegmenterWordsOnLine(line: string): IntlWordSegmentData[] {\n\t\tif (!this._segmenter) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Check if the line has changed from the previous call\n\t\tif (this._cachedLine === line) {\n\t\t\treturn this._cachedSegments;\n\t\t}\n\n\t\t// Update the cache with the new line\n\t\tthis._cachedLine = line;\n\t\tthis._cachedSegments = this._filterWordSegments(this._segmenter.value.segment(line));\n\n\t\treturn this._cachedSegments;\n\t}\n\n\tprivate _filterWordSegments(segments: Intl.Segments): IntlWordSegmentData[] {\n\t\tconst result: IntlWordSegmentData[] = [];\n\t\tfor (const segment of segments) {\n\t\t\tif (this._isWordLike(segment)) {\n\t\t\t\tresult.push(segment);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _isWordLike(segment: Intl.SegmentData): segment is IntlWordSegmentData {\n\t\tif (segment.isWordLike) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport interface IntlWordSegmentData extends Intl.SegmentData {\n\tisWordLike: true;\n}\n\nconst wordClassifierCache = new LRUCache<string, WordCharacterClassifier>(10);\n\nexport function getMapForWordSeparators(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]): WordCharacterClassifier {\n\tconst key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n\tlet result = wordClassifierCache.get(key)!;\n\tif (!result) {\n\t\tresult = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n\t\twordClassifierCache.set(key, result);\n\t}\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { safeIntl } from '../../../base/common/date.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { CharacterClassifier } from './characterClassifier.js';\n\nexport const enum WordCharacterClass {\n\tRegular = 0,\n\tWhitespace = 1,\n\tWordSeparator = 2\n}\n\nexport class WordCharacterClassifier extends CharacterClassifier<WordCharacterClass> {\n\n\tpublic readonly intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[];\n\tprivate readonly _segmenter: Lazy<Intl.Segmenter> | null = null;\n\tprivate _cachedLine: string | null = null;\n\tprivate _cachedSegments: IntlWordSegmentData[] = [];\n\n\tconstructor(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]) {\n\t\tsuper(WordCharacterClass.Regular);\n\t\tthis.intlSegmenterLocales = intlSegmenterLocales;\n\t\tif (this.intlSegmenterLocales.length > 0) {\n\t\t\tthis._segmenter = safeIntl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n\t\t} else {\n\t\t\tthis._segmenter = null;\n\t\t}\n\n\t\tfor (let i = 0, len = wordSeparators.length; i < len; i++) {\n\t\t\tthis.set(wordSeparators.charCodeAt(i), WordCharacterClass.WordSeparator);\n\t\t}\n\n\t\tthis.set(CharCode.Space, WordCharacterClass.Whitespace);\n\t\tthis.set(CharCode.Tab, WordCharacterClass.Whitespace);\n\t}\n\n\tpublic findPrevIntlWordBeforeOrAtOffset(line: string, offset: number): IntlWordSegmentData | null {\n\t\tlet candidate: IntlWordSegmentData | null = null;\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n\t\t\tif (segment.index > offset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcandidate = segment;\n\t\t}\n\t\treturn candidate;\n\t}\n\n\tpublic findNextIntlWordAtOrAfterOffset(lineContent: string, offset: number): IntlWordSegmentData | null {\n\t\tfor (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n\t\t\tif (segment.index < offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn segment;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate _getIntlSegmenterWordsOnLine(line: string): IntlWordSegmentData[] {\n\t\tif (!this._segmenter) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Check if the line has changed from the previous call\n\t\tif (this._cachedLine === line) {\n\t\t\treturn this._cachedSegments;\n\t\t}\n\n\t\t// Update the cache with the new line\n\t\tthis._cachedLine = line;\n\t\tthis._cachedSegments = this._filterWordSegments(this._segmenter.value.segment(line));\n\n\t\treturn this._cachedSegments;\n\t}\n\n\tprivate _filterWordSegments(segments: Intl.Segments): IntlWordSegmentData[] {\n\t\tconst result: IntlWordSegmentData[] = [];\n\t\tfor (const segment of segments) {\n\t\t\tif (this._isWordLike(segment)) {\n\t\t\t\tresult.push(segment);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _isWordLike(segment: Intl.SegmentData): segment is IntlWordSegmentData {\n\t\tif (segment.isWordLike) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport interface IntlWordSegmentData extends Intl.SegmentData {\n\tisWordLike: true;\n}\n\nconst wordClassifierCache = new LRUCache<string, WordCharacterClassifier>(10);\n\nexport function getMapForWordSeparators(wordSeparators: string, intlSegmenterLocales: Intl.UnicodeBCP47LocaleIdentifier[]): WordCharacterClassifier {\n\tconst key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n\tlet result = wordClassifierCache.get(key)!;\n\tif (!result) {\n\t\tresult = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n\t\twordClassifierCache.set(key, result);\n\t}\n\treturn result;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/wordHelper.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/wordHelper.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n\n/**\n * Word inside a model.\n */\nexport interface IWordAtPosition {\n\t/**\n\t * The word.\n\t */\n\treadonly word: string;\n\t/**\n\t * The column where the word starts.\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * The column where the word ends.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords: string = ''): RegExp {\n\tlet source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\tfor (const sep of USUAL_WORD_SEPARATORS) {\n\t\tif (allowInWords.indexOf(sep) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tsource += '\\\\' + sep;\n\t}\n\tsource += '\\\\s]+)';\n\treturn new RegExp(source, 'g');\n}\n\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\n\nexport function ensureValidWordDefinition(wordDefinition?: RegExp | null): RegExp {\n\tlet result: RegExp = DEFAULT_WORD_REGEXP;\n\n\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\tif (!wordDefinition.global) {\n\t\t\tlet flags = 'g';\n\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\tflags += 'i';\n\t\t\t}\n\t\t\tif (wordDefinition.multiline) {\n\t\t\t\tflags += 'm';\n\t\t\t}\n\t\t\tif (wordDefinition.unicode) {\n\t\t\t\tflags += 'u';\n\t\t\t}\n\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t} else {\n\t\t\tresult = wordDefinition;\n\t\t}\n\t}\n\n\tresult.lastIndex = 0;\n\n\treturn result;\n}\n\n\nexport interface IGetWordAtTextConfig {\n\tmaxLen: number;\n\twindowSize: number;\n\ttimeBudget: number;\n}\n\n\nconst _defaultConfig = new LinkedList<IGetWordAtTextConfig>();\n_defaultConfig.unshift({\n\tmaxLen: 1000,\n\twindowSize: 15,\n\ttimeBudget: 150\n});\n\nexport function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number, config?: IGetWordAtTextConfig): IWordAtPosition | null {\n\t// Ensure the regex has the 'g' flag, otherwise this will loop forever\n\twordDefinition = ensureValidWordDefinition(wordDefinition);\n\n\tif (!config) {\n\t\tconfig = Iterable.first(_defaultConfig)!;\n\t}\n\n\tif (text.length > config.maxLen) {\n\t\t// don't throw strings that long at the regexp\n\t\t// but use a sub-string in which a word must occur\n\t\tlet start = column - config.maxLen / 2;\n\t\tif (start < 0) {\n\t\t\tstart = 0;\n\t\t} else {\n\t\t\ttextOffset += start;\n\t\t}\n\t\ttext = text.substring(start, column + config.maxLen / 2);\n\t\treturn getWordAtText(column, wordDefinition, text, textOffset, config);\n\t}\n\n\tconst t1 = Date.now();\n\tconst pos = column - 1 - textOffset;\n\n\tlet prevRegexIndex = -1;\n\tlet match: RegExpExecArray | null = null;\n\n\tfor (let i = 1; ; i++) {\n\t\t// check time budget\n\t\tif (Date.now() - t1 >= config.timeBudget) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// reset the index at which the regexp should start matching, also know where it\n\t\t// should stop so that subsequent search don't repeat previous searches\n\t\tconst regexIndex = pos - config.windowSize * i;\n\t\twordDefinition.lastIndex = Math.max(0, regexIndex);\n\t\tconst thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n\n\t\tif (!thisMatch && match) {\n\t\t\t// stop: we have something\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch = thisMatch;\n\n\t\t// stop: searched at start\n\t\tif (regexIndex <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tprevRegexIndex = regexIndex;\n\t}\n\n\tif (match) {\n\t\tconst result = {\n\t\t\tword: match[0],\n\t\t\tstartColumn: textOffset + 1 + match.index,\n\t\t\tendColumn: textOffset + 1 + match.index + match[0].length\n\t\t};\n\t\twordDefinition.lastIndex = 0;\n\t\treturn result;\n\t}\n\n\treturn null;\n}\n\nfunction _findRegexMatchEnclosingPosition(wordDefinition: RegExp, text: string, pos: number, stopPos: number): RegExpExecArray | null {\n\tlet match: RegExpExecArray | null;\n\twhile (match = wordDefinition.exec(text)) {\n\t\tconst matchIndex = match.index || 0;\n\t\tif (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n\t\t\treturn match;\n\t\t} else if (stopPos > 0 && matchIndex > stopPos) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n\n/**\n * Word inside a model.\n */\nexport interface IWordAtPosition {\n\t/**\n\t * The word.\n\t */\n\treadonly word: string;\n\t/**\n\t * The column where the word starts.\n\t */\n\treadonly startColumn: number;\n\t/**\n\t * The column where the word ends.\n\t */\n\treadonly endColumn: number;\n}\n\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords: string = ''): RegExp {\n\tlet source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\tfor (const sep of USUAL_WORD_SEPARATORS) {\n\t\tif (allowInWords.indexOf(sep) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tsource += '\\\\' + sep;\n\t}\n\tsource += '\\\\s]+)';\n\treturn new RegExp(source, 'g');\n}\n\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\n\nexport function ensureValidWordDefinition(wordDefinition?: RegExp | null): RegExp {\n\tlet result: RegExp = DEFAULT_WORD_REGEXP;\n\n\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\tif (!wordDefinition.global) {\n\t\t\tlet flags = 'g';\n\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\tflags += 'i';\n\t\t\t}\n\t\t\tif (wordDefinition.multiline) {\n\t\t\t\tflags += 'm';\n\t\t\t}\n\t\t\tif (wordDefinition.unicode) {\n\t\t\t\tflags += 'u';\n\t\t\t}\n\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t} else {\n\t\t\tresult = wordDefinition;\n\t\t}\n\t}\n\n\tresult.lastIndex = 0;\n\n\treturn result;\n}\n\n\nexport interface IGetWordAtTextConfig {\n\tmaxLen: number;\n\twindowSize: number;\n\ttimeBudget: number;\n}\n\n\nconst _defaultConfig = new LinkedList<IGetWordAtTextConfig>();\n_defaultConfig.unshift({\n\tmaxLen: 1000,\n\twindowSize: 15,\n\ttimeBudget: 150\n});\n\nexport function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number, config?: IGetWordAtTextConfig): IWordAtPosition | null {\n\t// Ensure the regex has the 'g' flag, otherwise this will loop forever\n\twordDefinition = ensureValidWordDefinition(wordDefinition);\n\n\tif (!config) {\n\t\tconfig = Iterable.first(_defaultConfig)!;\n\t}\n\n\tif (text.length > config.maxLen) {\n\t\t// don't throw strings that long at the regexp\n\t\t// but use a sub-string in which a word must occur\n\t\tlet start = column - config.maxLen / 2;\n\t\tif (start < 0) {\n\t\t\tstart = 0;\n\t\t} else {\n\t\t\ttextOffset += start;\n\t\t}\n\t\ttext = text.substring(start, column + config.maxLen / 2);\n\t\treturn getWordAtText(column, wordDefinition, text, textOffset, config);\n\t}\n\n\tconst t1 = Date.now();\n\tconst pos = column - 1 - textOffset;\n\n\tlet prevRegexIndex = -1;\n\tlet match: RegExpExecArray | null = null;\n\n\tfor (let i = 1; ; i++) {\n\t\t// check time budget\n\t\tif (Date.now() - t1 >= config.timeBudget) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// reset the index at which the regexp should start matching, also know where it\n\t\t// should stop so that subsequent search don't repeat previous searches\n\t\tconst regexIndex = pos - config.windowSize * i;\n\t\twordDefinition.lastIndex = Math.max(0, regexIndex);\n\t\tconst thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n\n\t\tif (!thisMatch && match) {\n\t\t\t// stop: we have something\n\t\t\tbreak;\n\t\t}\n\n\t\tmatch = thisMatch;\n\n\t\t// stop: searched at start\n\t\tif (regexIndex <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tprevRegexIndex = regexIndex;\n\t}\n\n\tif (match) {\n\t\tconst result = {\n\t\t\tword: match[0],\n\t\t\tstartColumn: textOffset + 1 + match.index,\n\t\t\tendColumn: textOffset + 1 + match.index + match[0].length\n\t\t};\n\t\twordDefinition.lastIndex = 0;\n\t\treturn result;\n\t}\n\n\treturn null;\n}\n\nfunction _findRegexMatchEnclosingPosition(wordDefinition: RegExp, text: string, pos: number, stopPos: number): RegExpExecArray | null {\n\tlet match: RegExpExecArray | null;\n\twhile (match = wordDefinition.exec(text)) {\n\t\tconst matchIndex = match.index || 0;\n\t\tif (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n\t\t\treturn match;\n\t\t} else if (stopPos > 0 && matchIndex > stopPos) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn null;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1058, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/stringBuilder.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/stringBuilder.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\n\nlet _utf16LE_TextDecoder: TextDecoder | null;\nfunction getUTF16LE_TextDecoder(): TextDecoder {\n\tif (!_utf16LE_TextDecoder) {\n\t\t_utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n\t}\n\treturn _utf16LE_TextDecoder;\n}\n\nlet _utf16BE_TextDecoder: TextDecoder | null;\nfunction getUTF16BE_TextDecoder(): TextDecoder {\n\tif (!_utf16BE_TextDecoder) {\n\t\t_utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n\t}\n\treturn _utf16BE_TextDecoder;\n}\n\nlet _platformTextDecoder: TextDecoder | null;\nexport function getPlatformTextDecoder(): TextDecoder {\n\tif (!_platformTextDecoder) {\n\t\t_platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n\t}\n\treturn _platformTextDecoder;\n}\n\nexport function decodeUTF16LE(source: Uint8Array, offset: number, len: number): string {\n\tconst view = new Uint16Array(source.buffer, offset, len);\n\tif (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n\t\t// UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n\t\t// It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n\t\t// We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n\t\t// So we use the manual decoder\n\t\treturn compatDecodeUTF16LE(source, offset, len);\n\t}\n\treturn getUTF16LE_TextDecoder().decode(view);\n}\n\nfunction compatDecodeUTF16LE(source: Uint8Array, offset: number, len: number): string {\n\tconst result: string[] = [];\n\tlet resultLen = 0;\n\tfor (let i = 0; i < len; i++) {\n\t\tconst charCode = buffer.readUInt16LE(source, offset); offset += 2;\n\t\tresult[resultLen++] = String.fromCharCode(charCode);\n\t}\n\treturn result.join('');\n}\n\nexport class StringBuilder {\n\n\tprivate readonly _capacity: number;\n\tprivate readonly _buffer: Uint16Array;\n\n\tprivate _completedStrings: string[] | null;\n\tprivate _bufferLength: number;\n\n\tconstructor(capacity: number) {\n\t\tthis._capacity = capacity | 0;\n\t\tthis._buffer = new Uint16Array(this._capacity);\n\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic reset(): void {\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic build(): string {\n\t\tif (this._completedStrings !== null) {\n\t\t\tthis._flushBuffer();\n\t\t\treturn this._completedStrings.join('');\n\t\t}\n\t\treturn this._buildBuffer();\n\t}\n\n\tprivate _buildBuffer(): string {\n\t\tif (this._bufferLength === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n\t\treturn getPlatformTextDecoder().decode(view);\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tconst bufferString = this._buildBuffer();\n\t\tthis._bufferLength = 0;\n\n\t\tif (this._completedStrings === null) {\n\t\t\tthis._completedStrings = [bufferString];\n\t\t} else {\n\t\t\tthis._completedStrings[this._completedStrings.length] = bufferString;\n\t\t}\n\t}\n\n\t/**\n\t * Append a char code (<2^16)\n\t */\n\tpublic appendCharCode(charCode: number): void {\n\t\tconst remainingSpace = this._capacity - this._bufferLength;\n\n\t\tif (remainingSpace <= 1) {\n\t\t\tif (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n\t\t\t\tthis._flushBuffer();\n\t\t\t}\n\t\t}\n\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\t/**\n\t * Append an ASCII char code (<2^8)\n\t */\n\tpublic appendASCIICharCode(charCode: number): void {\n\t\tif (this._bufferLength === this._capacity) {\n\t\t\t// buffer is full\n\t\t\tthis._flushBuffer();\n\t\t}\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\tpublic appendString(str: string): void {\n\t\tconst strLen = str.length;\n\n\t\tif (this._bufferLength + strLen >= this._capacity) {\n\t\t\t// This string does not fit in the remaining buffer space\n\n\t\t\tthis._flushBuffer();\n\t\t\tthis._completedStrings![this._completedStrings!.length] = str;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < strLen; i++) {\n\t\t\tthis._buffer[this._bufferLength++] = str.charCodeAt(i);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\n\nlet _utf16LE_TextDecoder: TextDecoder | null;\nfunction getUTF16LE_TextDecoder(): TextDecoder {\n\tif (!_utf16LE_TextDecoder) {\n\t\t_utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n\t}\n\treturn _utf16LE_TextDecoder;\n}\n\nlet _utf16BE_TextDecoder: TextDecoder | null;\nfunction getUTF16BE_TextDecoder(): TextDecoder {\n\tif (!_utf16BE_TextDecoder) {\n\t\t_utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n\t}\n\treturn _utf16BE_TextDecoder;\n}\n\nlet _platformTextDecoder: TextDecoder | null;\nexport function getPlatformTextDecoder(): TextDecoder {\n\tif (!_platformTextDecoder) {\n\t\t_platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n\t}\n\treturn _platformTextDecoder;\n}\n\nexport function decodeUTF16LE(source: Uint8Array, offset: number, len: number): string {\n\tconst view = new Uint16Array(source.buffer, offset, len);\n\tif (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n\t\t// UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n\t\t// It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n\t\t// We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n\t\t// So we use the manual decoder\n\t\treturn compatDecodeUTF16LE(source, offset, len);\n\t}\n\treturn getUTF16LE_TextDecoder().decode(view);\n}\n\nfunction compatDecodeUTF16LE(source: Uint8Array, offset: number, len: number): string {\n\tconst result: string[] = [];\n\tlet resultLen = 0;\n\tfor (let i = 0; i < len; i++) {\n\t\tconst charCode = buffer.readUInt16LE(source, offset); offset += 2;\n\t\tresult[resultLen++] = String.fromCharCode(charCode);\n\t}\n\treturn result.join('');\n}\n\nexport class StringBuilder {\n\n\tprivate readonly _capacity: number;\n\tprivate readonly _buffer: Uint16Array;\n\n\tprivate _completedStrings: string[] | null;\n\tprivate _bufferLength: number;\n\n\tconstructor(capacity: number) {\n\t\tthis._capacity = capacity | 0;\n\t\tthis._buffer = new Uint16Array(this._capacity);\n\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic reset(): void {\n\t\tthis._completedStrings = null;\n\t\tthis._bufferLength = 0;\n\t}\n\n\tpublic build(): string {\n\t\tif (this._completedStrings !== null) {\n\t\t\tthis._flushBuffer();\n\t\t\treturn this._completedStrings.join('');\n\t\t}\n\t\treturn this._buildBuffer();\n\t}\n\n\tprivate _buildBuffer(): string {\n\t\tif (this._bufferLength === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n\t\treturn getPlatformTextDecoder().decode(view);\n\t}\n\n\tprivate _flushBuffer(): void {\n\t\tconst bufferString = this._buildBuffer();\n\t\tthis._bufferLength = 0;\n\n\t\tif (this._completedStrings === null) {\n\t\t\tthis._completedStrings = [bufferString];\n\t\t} else {\n\t\t\tthis._completedStrings[this._completedStrings.length] = bufferString;\n\t\t}\n\t}\n\n\t/**\n\t * Append a char code (<2^16)\n\t */\n\tpublic appendCharCode(charCode: number): void {\n\t\tconst remainingSpace = this._capacity - this._bufferLength;\n\n\t\tif (remainingSpace <= 1) {\n\t\t\tif (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n\t\t\t\tthis._flushBuffer();\n\t\t\t}\n\t\t}\n\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\t/**\n\t * Append an ASCII char code (<2^8)\n\t */\n\tpublic appendASCIICharCode(charCode: number): void {\n\t\tif (this._bufferLength === this._capacity) {\n\t\t\t// buffer is full\n\t\t\tthis._flushBuffer();\n\t\t}\n\t\tthis._buffer[this._bufferLength++] = charCode;\n\t}\n\n\tpublic appendString(str: string): void {\n\t\tconst strLen = str.length;\n\n\t\tif (this._bufferLength + strLen >= this._capacity) {\n\t\t\t// This string does not fit in the remaining buffer space\n\n\t\t\tthis._flushBuffer();\n\t\t\tthis._completedStrings![this._completedStrings!.length] = str;\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < strLen; i++) {\n\t\t\tthis._buffer[this._bufferLength++] = str.charCodeAt(i);\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1190, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/offsetRange.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/ranges/offsetRange.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/vs/editor/common/core/ranges/offsetRange.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\n\nexport interface IOffsetRange {\n\treadonly start: number;\n\treadonly endExclusive: number;\n}\n\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange implements IOffsetRange {\n\tpublic static fromTo(start: number, endExclusive: number): OffsetRange {\n\t\treturn new OffsetRange(start, endExclusive);\n\t}\n\n\tpublic static addRange(range: OffsetRange, sortedRanges: OffsetRange[]): void {\n\t\tlet i = 0;\n\t\twhile (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n\t\t\ti++;\n\t\t}\n\t\tlet j = i;\n\t\twhile (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n\t\t\tj++;\n\t\t}\n\t\tif (i === j) {\n\t\t\tsortedRanges.splice(i, 0, range);\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, sortedRanges[i].start);\n\t\t\tconst end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n\t\t\tsortedRanges.splice(i, j - i, new OffsetRange(start, end));\n\t\t}\n\t}\n\n\tpublic static tryCreate(start: number, endExclusive: number): OffsetRange | undefined {\n\t\tif (start > endExclusive) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new OffsetRange(start, endExclusive);\n\t}\n\n\tpublic static ofLength(length: number): OffsetRange {\n\t\treturn new OffsetRange(0, length);\n\t}\n\n\tpublic static ofStartAndLength(start: number, length: number): OffsetRange {\n\t\treturn new OffsetRange(start, start + length);\n\t}\n\n\tpublic static emptyAt(offset: number): OffsetRange {\n\t\treturn new OffsetRange(offset, offset);\n\t}\n\n\tconstructor(public readonly start: number, public readonly endExclusive: number) {\n\t\tif (start > endExclusive) {\n\t\t\tthrow new BugIndicatingError(`Invalid range: ${this.toString()}`);\n\t\t}\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.start === this.endExclusive;\n\t}\n\n\tpublic delta(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start + offset, this.endExclusive + offset);\n\t}\n\n\tpublic deltaStart(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start + offset, this.endExclusive);\n\t}\n\n\tpublic deltaEnd(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start, this.endExclusive + offset);\n\t}\n\n\tpublic get length(): number {\n\t\treturn this.endExclusive - this.start;\n\t}\n\n\tpublic toString() {\n\t\treturn `[${this.start}, ${this.endExclusive})`;\n\t}\n\n\tpublic equals(other: OffsetRange): boolean {\n\t\treturn this.start === other.start && this.endExclusive === other.endExclusive;\n\t}\n\n\tpublic contains(offset: number): boolean {\n\t\treturn this.start <= offset && offset < this.endExclusive;\n\t}\n\n\t/**\n\t * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n\t * The joined range is the smallest range that contains both ranges.\n\t */\n\tpublic join(other: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n\t}\n\n\t/**\n\t * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n\t *\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: OffsetRange): OffsetRange | undefined {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\tif (start <= end) {\n\t\t\treturn new OffsetRange(start, end);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectionLength(range: OffsetRange): number {\n\t\tconst start = Math.max(this.start, range.start);\n\t\tconst end = Math.min(this.endExclusive, range.endExclusive);\n\t\treturn Math.max(0, end - start);\n\t}\n\n\tpublic intersects(other: OffsetRange): boolean {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\treturn start < end;\n\t}\n\n\tpublic intersectsOrTouches(other: OffsetRange): boolean {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\treturn start <= end;\n\t}\n\n\tpublic isBefore(other: OffsetRange): boolean {\n\t\treturn this.endExclusive <= other.start;\n\t}\n\n\tpublic isAfter(other: OffsetRange): boolean {\n\t\treturn this.start >= other.endExclusive;\n\t}\n\n\tpublic slice<T>(arr: readonly T[]): T[] {\n\t\treturn arr.slice(this.start, this.endExclusive);\n\t}\n\n\tpublic substring(str: string): string {\n\t\treturn str.substring(this.start, this.endExclusive);\n\t}\n\n\t/**\n\t * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n\t * The range must not be empty.\n\t */\n\tpublic clip(value: number): number {\n\t\tif (this.isEmpty) {\n\t\t\tthrow new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n\t\t}\n\t\treturn Math.max(this.start, Math.min(this.endExclusive - 1, value));\n\t}\n\n\t/**\n\t * Returns `r := value + k * length` such that `r` is contained in this range.\n\t * The range must not be empty.\n\t *\n\t * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n\t */\n\tpublic clipCyclic(value: number): number {\n\t\tif (this.isEmpty) {\n\t\t\tthrow new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n\t\t}\n\t\tif (value < this.start) {\n\t\t\treturn this.endExclusive - ((this.start - value) % this.length);\n\t\t}\n\t\tif (value >= this.endExclusive) {\n\t\t\treturn this.start + ((value - this.start) % this.length);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic forEach(f: (offset: number) => void): void {\n\t\tfor (let i = this.start; i < this.endExclusive; i++) {\n\t\t\tf(i);\n\t\t}\n\t}\n\n\t/**\n\t * this: [ 5, 10), range: [10, 15) => [5, 15)]\n\t * Throws if the ranges are not touching.\n\t*/\n\tpublic joinRightTouching(range: OffsetRange): OffsetRange {\n\t\tif (this.endExclusive !== range.start) {\n\t\t\tthrow new BugIndicatingError(`Invalid join: ${this.toString()} and ${range.toString()}`);\n\t\t}\n\t\treturn new OffsetRange(this.start, range.endExclusive);\n\t}\n}\n\nexport class OffsetRangeSet {\n\tprivate readonly _sortedRanges: OffsetRange[] = [];\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tlet i = 0;\n\t\twhile (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n\t\t\ti++;\n\t\t}\n\t\tlet j = i;\n\t\twhile (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n\t\t\tj++;\n\t\t}\n\t\tif (i === j) {\n\t\t\tthis._sortedRanges.splice(i, 0, range);\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._sortedRanges[i].start);\n\t\t\tconst end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n\t\t\tthis._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn this._sortedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\t/**\n\t * Returns of there is a value that is contained in this instance and the given range.\n\t */\n\tpublic intersectsStrict(other: OffsetRange): boolean {\n\t\t// TODO use binary search\n\t\tlet i = 0;\n\t\twhile (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n\t\t\ti++;\n\t\t}\n\t\treturn i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n\t}\n\n\tpublic intersectWithRange(other: OffsetRange): OffsetRangeSet {\n\t\t// TODO use binary search + slice\n\t\tconst result = new OffsetRangeSet();\n\t\tfor (const range of this._sortedRanges) {\n\t\t\tconst intersection = range.intersect(other);\n\t\t\tif (intersection) {\n\t\t\t\tresult.addRange(intersection);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic intersectWithRangeLength(other: OffsetRange): number {\n\t\treturn this.intersectWithRange(other).length;\n\t}\n\n\tpublic get length(): number {\n\t\treturn this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\n\nexport interface IOffsetRange {\n\treadonly start: number;\n\treadonly endExclusive: number;\n}\n\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange implements IOffsetRange {\n\tpublic static fromTo(start: number, endExclusive: number): OffsetRange {\n\t\treturn new OffsetRange(start, endExclusive);\n\t}\n\n\tpublic static addRange(range: OffsetRange, sortedRanges: OffsetRange[]): void {\n\t\tlet i = 0;\n\t\twhile (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n\t\t\ti++;\n\t\t}\n\t\tlet j = i;\n\t\twhile (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n\t\t\tj++;\n\t\t}\n\t\tif (i === j) {\n\t\t\tsortedRanges.splice(i, 0, range);\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, sortedRanges[i].start);\n\t\t\tconst end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n\t\t\tsortedRanges.splice(i, j - i, new OffsetRange(start, end));\n\t\t}\n\t}\n\n\tpublic static tryCreate(start: number, endExclusive: number): OffsetRange | undefined {\n\t\tif (start > endExclusive) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new OffsetRange(start, endExclusive);\n\t}\n\n\tpublic static ofLength(length: number): OffsetRange {\n\t\treturn new OffsetRange(0, length);\n\t}\n\n\tpublic static ofStartAndLength(start: number, length: number): OffsetRange {\n\t\treturn new OffsetRange(start, start + length);\n\t}\n\n\tpublic static emptyAt(offset: number): OffsetRange {\n\t\treturn new OffsetRange(offset, offset);\n\t}\n\n\tconstructor(public readonly start: number, public readonly endExclusive: number) {\n\t\tif (start > endExclusive) {\n\t\t\tthrow new BugIndicatingError(`Invalid range: ${this.toString()}`);\n\t\t}\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.start === this.endExclusive;\n\t}\n\n\tpublic delta(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start + offset, this.endExclusive + offset);\n\t}\n\n\tpublic deltaStart(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start + offset, this.endExclusive);\n\t}\n\n\tpublic deltaEnd(offset: number): OffsetRange {\n\t\treturn new OffsetRange(this.start, this.endExclusive + offset);\n\t}\n\n\tpublic get length(): number {\n\t\treturn this.endExclusive - this.start;\n\t}\n\n\tpublic toString() {\n\t\treturn `[${this.start}, ${this.endExclusive})`;\n\t}\n\n\tpublic equals(other: OffsetRange): boolean {\n\t\treturn this.start === other.start && this.endExclusive === other.endExclusive;\n\t}\n\n\tpublic contains(offset: number): boolean {\n\t\treturn this.start <= offset && offset < this.endExclusive;\n\t}\n\n\t/**\n\t * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n\t * The joined range is the smallest range that contains both ranges.\n\t */\n\tpublic join(other: OffsetRange): OffsetRange {\n\t\treturn new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n\t}\n\n\t/**\n\t * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n\t *\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: OffsetRange): OffsetRange | undefined {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\tif (start <= end) {\n\t\t\treturn new OffsetRange(start, end);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectionLength(range: OffsetRange): number {\n\t\tconst start = Math.max(this.start, range.start);\n\t\tconst end = Math.min(this.endExclusive, range.endExclusive);\n\t\treturn Math.max(0, end - start);\n\t}\n\n\tpublic intersects(other: OffsetRange): boolean {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\treturn start < end;\n\t}\n\n\tpublic intersectsOrTouches(other: OffsetRange): boolean {\n\t\tconst start = Math.max(this.start, other.start);\n\t\tconst end = Math.min(this.endExclusive, other.endExclusive);\n\t\treturn start <= end;\n\t}\n\n\tpublic isBefore(other: OffsetRange): boolean {\n\t\treturn this.endExclusive <= other.start;\n\t}\n\n\tpublic isAfter(other: OffsetRange): boolean {\n\t\treturn this.start >= other.endExclusive;\n\t}\n\n\tpublic slice<T>(arr: readonly T[]): T[] {\n\t\treturn arr.slice(this.start, this.endExclusive);\n\t}\n\n\tpublic substring(str: string): string {\n\t\treturn str.substring(this.start, this.endExclusive);\n\t}\n\n\t/**\n\t * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n\t * The range must not be empty.\n\t */\n\tpublic clip(value: number): number {\n\t\tif (this.isEmpty) {\n\t\t\tthrow new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n\t\t}\n\t\treturn Math.max(this.start, Math.min(this.endExclusive - 1, value));\n\t}\n\n\t/**\n\t * Returns `r := value + k * length` such that `r` is contained in this range.\n\t * The range must not be empty.\n\t *\n\t * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n\t */\n\tpublic clipCyclic(value: number): number {\n\t\tif (this.isEmpty) {\n\t\t\tthrow new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n\t\t}\n\t\tif (value < this.start) {\n\t\t\treturn this.endExclusive - ((this.start - value) % this.length);\n\t\t}\n\t\tif (value >= this.endExclusive) {\n\t\t\treturn this.start + ((value - this.start) % this.length);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic forEach(f: (offset: number) => void): void {\n\t\tfor (let i = this.start; i < this.endExclusive; i++) {\n\t\t\tf(i);\n\t\t}\n\t}\n\n\t/**\n\t * this: [ 5, 10), range: [10, 15) => [5, 15)]\n\t * Throws if the ranges are not touching.\n\t*/\n\tpublic joinRightTouching(range: OffsetRange): OffsetRange {\n\t\tif (this.endExclusive !== range.start) {\n\t\t\tthrow new BugIndicatingError(`Invalid join: ${this.toString()} and ${range.toString()}`);\n\t\t}\n\t\treturn new OffsetRange(this.start, range.endExclusive);\n\t}\n}\n\nexport class OffsetRangeSet {\n\tprivate readonly _sortedRanges: OffsetRange[] = [];\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tlet i = 0;\n\t\twhile (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n\t\t\ti++;\n\t\t}\n\t\tlet j = i;\n\t\twhile (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n\t\t\tj++;\n\t\t}\n\t\tif (i === j) {\n\t\t\tthis._sortedRanges.splice(i, 0, range);\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._sortedRanges[i].start);\n\t\t\tconst end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n\t\t\tthis._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn this._sortedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\t/**\n\t * Returns of there is a value that is contained in this instance and the given range.\n\t */\n\tpublic intersectsStrict(other: OffsetRange): boolean {\n\t\t// TODO use binary search\n\t\tlet i = 0;\n\t\twhile (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n\t\t\ti++;\n\t\t}\n\t\treturn i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n\t}\n\n\tpublic intersectWithRange(other: OffsetRange): OffsetRangeSet {\n\t\t// TODO use binary search + slice\n\t\tconst result = new OffsetRangeSet();\n\t\tfor (const range of this._sortedRanges) {\n\t\t\tconst intersection = range.intersect(other);\n\t\t\tif (intersection) {\n\t\t\t\tresult.addRange(intersection);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic intersectWithRangeLength(other: OffsetRange): number {\n\t\treturn this.intersectWithRange(other).length;\n\t}\n\n\tpublic get length(): number {\n\t\treturn this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1411, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/misc/textModelDefaults.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/misc/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/misc/textModelDefaults.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/misc/vs/editor/common/core/misc/textModelDefaults.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const EDITOR_MODEL_DEFAULTS = {\n\ttabSize: 4,\n\tindentSize: 4,\n\tinsertSpaces: true,\n\tdetectIndentation: true,\n\ttrimAutoWhitespace: true,\n\tlargeFileOptimizations: true,\n\tbracketPairColorizationOptions: {\n\t\tenabled: true,\n\t\tindependentColorPoolPerBracketType: false,\n\t},\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const EDITOR_MODEL_DEFAULTS = {\n\ttabSize: 4,\n\tindentSize: 4,\n\tinsertSpaces: true,\n\tdetectIndentation: true,\n\ttrimAutoWhitespace: true,\n\tlargeFileOptimizations: true,\n\tbracketPairColorizationOptions: {\n\t\tenabled: true,\n\t\tindependentColorPoolPerBracketType: false,\n\t},\n};\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEzF,MAAM,qBAAqB,GAAG;IACpC,OAAO,EAAE,CAAC;IACV,UAAU,EAAE,CAAC;IACb,YAAY,EAAE,IAAI;IAClB,iBAAiB,EAAE,IAAI;IACvB,kBAAkB,EAAE,IAAI;IACxB,sBAAsB,EAAE,IAAI;IAC5B,8BAA8B,EAAE;QAC/B,OAAO,EAAE,IAAI;QACb,kCAAkC,EAAE,KAAK;KACzC;CACD,CAAC","debugId":null}},
    {"offset": {"line": 1434, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/editorColorRegistry.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight, editorWarningBackground } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', null, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'));\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'));\n\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorPrimaryForeground = registerColor('editorMultiCursor.primary.foreground', editorCursorForeground, nls.localize('editorMultiCursorPrimaryForeground', 'Color of the primary editor cursor when multiple cursors are present.'));\nexport const editorMultiCursorPrimaryBackground = registerColor('editorMultiCursor.primary.background', editorCursorBackground, nls.localize('editorMultiCursorPrimaryBackground', 'The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorMultiCursorSecondaryForeground = registerColor('editorMultiCursor.secondary.foreground', editorCursorForeground, nls.localize('editorMultiCursorSecondaryForeground', 'Color of secondary editor cursors when multiple cursors are present.'));\nexport const editorMultiCursorSecondaryBackground = registerColor('editorMultiCursor.secondary.background', editorCursorBackground, nls.localize('editorMultiCursorSecondaryBackground', 'The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\n\nexport const deprecatedEditorIndentGuides = registerColor('editorIndentGuide.background', editorWhitespaces, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'), false, nls.localize('deprecatedEditorIndentGuides', '\\'editorIndentGuide.background\\' is deprecated. Use \\'editorIndentGuide.background1\\' instead.'));\nexport const deprecatedEditorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', editorWhitespaces, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'), false, nls.localize('deprecatedEditorActiveIndentGuide', '\\'editorIndentGuide.activeBackground\\' is deprecated. Use \\'editorIndentGuide.activeBackground1\\' instead.'));\n\nexport const editorIndentGuide1 = registerColor('editorIndentGuide.background1', deprecatedEditorIndentGuides, nls.localize('editorIndentGuides1', 'Color of the editor indentation guides (1).'));\nexport const editorIndentGuide2 = registerColor('editorIndentGuide.background2', '#00000000', nls.localize('editorIndentGuides2', 'Color of the editor indentation guides (2).'));\nexport const editorIndentGuide3 = registerColor('editorIndentGuide.background3', '#00000000', nls.localize('editorIndentGuides3', 'Color of the editor indentation guides (3).'));\nexport const editorIndentGuide4 = registerColor('editorIndentGuide.background4', '#00000000', nls.localize('editorIndentGuides4', 'Color of the editor indentation guides (4).'));\nexport const editorIndentGuide5 = registerColor('editorIndentGuide.background5', '#00000000', nls.localize('editorIndentGuides5', 'Color of the editor indentation guides (5).'));\nexport const editorIndentGuide6 = registerColor('editorIndentGuide.background6', '#00000000', nls.localize('editorIndentGuides6', 'Color of the editor indentation guides (6).'));\n\nexport const editorActiveIndentGuide1 = registerColor('editorIndentGuide.activeBackground1', deprecatedEditorActiveIndentGuides, nls.localize('editorActiveIndentGuide1', 'Color of the active editor indentation guides (1).'));\nexport const editorActiveIndentGuide2 = registerColor('editorIndentGuide.activeBackground2', '#00000000', nls.localize('editorActiveIndentGuide2', 'Color of the active editor indentation guides (2).'));\nexport const editorActiveIndentGuide3 = registerColor('editorIndentGuide.activeBackground3', '#00000000', nls.localize('editorActiveIndentGuide3', 'Color of the active editor indentation guides (3).'));\nexport const editorActiveIndentGuide4 = registerColor('editorIndentGuide.activeBackground4', '#00000000', nls.localize('editorActiveIndentGuide4', 'Color of the active editor indentation guides (4).'));\nexport const editorActiveIndentGuide5 = registerColor('editorIndentGuide.activeBackground5', '#00000000', nls.localize('editorActiveIndentGuide5', 'Color of the active editor indentation guides (5).'));\nexport const editorActiveIndentGuide6 = registerColor('editorIndentGuide.activeBackground6', '#00000000', nls.localize('editorActiveIndentGuide6', 'Color of the active editor indentation guides (6).'));\n\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', deprecatedEditorActiveLineNumber, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', null, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\n\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\n\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\n\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\n\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\n\nexport const editorGutter = registerColor('editorGutter.background', editorBackground, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\n\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\n\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', null, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\n\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', rulerRangeDefault, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\n\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', '#00000000', nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', '#00000000', nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', '#00000000', nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\n\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\n\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', '#00000000', nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', '#00000000', nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', '#00000000', nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', '#00000000', nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', '#00000000', nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', '#00000000', nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\n\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', '#00000000', nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', '#00000000', nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', '#00000000', nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', '#00000000', nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', '#00000000', nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', '#00000000', nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\n\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', editorWarningForeground, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', editorWarningBackground, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n\n\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n\tconst background = theme.getColor(editorBackground);\n\tconst lineHighlight = theme.getColor(editorLineHighlight);\n\tconst imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n\tif (imeBackground) {\n\t\tcollector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n\t}\n});\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1791, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/misc/rgba.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/misc/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/misc/rgba.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/misc/vs/editor/common/core/misc/rgba.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n\t_rgba8Brand: void = undefined;\n\n\tstatic readonly Empty = new RGBA8(0, 0, 0, 0);\n\n\t/**\n\t * Red: integer in [0-255]\n\t */\n\tpublic readonly r: number;\n\t/**\n\t * Green: integer in [0-255]\n\t */\n\tpublic readonly g: number;\n\t/**\n\t * Blue: integer in [0-255]\n\t */\n\tpublic readonly b: number;\n\t/**\n\t * Alpha: integer in [0-255]\n\t */\n\tpublic readonly a: number;\n\n\tconstructor(r: number, g: number, b: number, a: number) {\n\t\tthis.r = RGBA8._clamp(r);\n\t\tthis.g = RGBA8._clamp(g);\n\t\tthis.b = RGBA8._clamp(b);\n\t\tthis.a = RGBA8._clamp(a);\n\t}\n\n\tpublic equals(other: RGBA8): boolean {\n\t\treturn (\n\t\t\tthis.r === other.r\n\t\t\t&& this.g === other.g\n\t\t\t&& this.b === other.b\n\t\t\t&& this.a === other.a\n\t\t);\n\t}\n\n\tpublic static _clamp(c: number): number {\n\t\tif (c < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (c > 255) {\n\t\t\treturn 255;\n\t\t}\n\t\treturn c | 0;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n\t_rgba8Brand: void = undefined;\n\n\tstatic readonly Empty = new RGBA8(0, 0, 0, 0);\n\n\t/**\n\t * Red: integer in [0-255]\n\t */\n\tpublic readonly r: number;\n\t/**\n\t * Green: integer in [0-255]\n\t */\n\tpublic readonly g: number;\n\t/**\n\t * Blue: integer in [0-255]\n\t */\n\tpublic readonly b: number;\n\t/**\n\t * Alpha: integer in [0-255]\n\t */\n\tpublic readonly a: number;\n\n\tconstructor(r: number, g: number, b: number, a: number) {\n\t\tthis.r = RGBA8._clamp(r);\n\t\tthis.g = RGBA8._clamp(g);\n\t\tthis.b = RGBA8._clamp(b);\n\t\tthis.a = RGBA8._clamp(a);\n\t}\n\n\tpublic equals(other: RGBA8): boolean {\n\t\treturn (\n\t\t\tthis.r === other.r\n\t\t\t&& this.g === other.g\n\t\t\t&& this.b === other.b\n\t\t\t&& this.a === other.a\n\t\t);\n\t}\n\n\tpublic static _clamp(c: number): number {\n\t\tif (c < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (c > 255) {\n\t\t\treturn 255;\n\t\t}\n\t\treturn c | 0;\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG,CAEhG;;;GAGG;;;;AACG,MAAO,KAAK;;QAGD,IAAA,CAAA,KAAK,GAAG,IAAI,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAvB,AAAwB,CAAC;IAAA,CAAA;IAmB9C,YAAY,CAAS,EAAE,CAAS,EAAE,CAAS,EAAE,CAAS,CAAA;QArBtD,IAAA,CAAA,WAAW,GAAS,SAAS,CAAC;QAsB7B,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC1B,CAAC;IAEM,MAAM,CAAC,KAAY,EAAA;QACzB,OAAO,AACN,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,IACf,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,IAClB,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,IAClB,IAAI,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CACrB,CAAC;IACH,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,CAAS,EAAA;QAC7B,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;YACX,OAAO,CAAC,CAAC;QACV,CAAC;QACD,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;YACb,OAAO,GAAG,CAAC;QACZ,CAAC;QACD,OAAO,CAAC,GAAG,CAAC,CAAC;IACd,CAAC","debugId":null}},
    {"offset": {"line": 1829, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/edits/edit.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/edits/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/edits/edit.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/edits/vs/editor/common/core/edits/edit.ts"],"sourcesContent":["\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\nexport abstract class BaseEdit<T extends BaseReplacement<T> = BaseReplacement<any>, TEdit extends BaseEdit<T, TEdit> = BaseEdit<T, any>> {\n\tconstructor(\n\t\tpublic readonly replacements: readonly T[],\n\t) {\n\t\tlet lastEndEx = -1;\n\t\tfor (const replacement of replacements) {\n\t\t\tif (!(replacement.replaceRange.start >= lastEndEx)) {\n\t\t\t\tthrow new BugIndicatingError(`Edits must be disjoint and sorted. Found ${replacement} after ${lastEndEx}`);\n\t\t\t}\n\t\t\tlastEndEx = replacement.replaceRange.endExclusive;\n\t\t}\n\t}\n\n\tprotected abstract _createNew(replacements: readonly T[]): TEdit;\n\n\tpublic toString() {\n\t\tconst edits = this.replacements.map(e => e.toString()).join(', ');\n\t\treturn `[${edits}]`;\n\t}\n\n\t/**\n\t * Normalizes the edit by removing empty replacements and joining touching replacements (if the replacements allow joining).\n\t * Two edits have an equal normalized edit if and only if they have the same effect on any input.\n\t *\n\t * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_normalize.drawio.png)\n\t *\n\t * Invariant:\n\t * ```\n\t * (forall base: TEdit.apply(base).equals(other.apply(base))) <-> this.normalize().equals(other.normalize())\n\t * ```\n\t * and\n\t * ```\n\t * forall base: TEdit.apply(base).equals(this.normalize().apply(base))\n\t * ```\n\t *\n\t */\n\tpublic normalize(): TEdit {\n\t\tconst newReplacements: T[] = [];\n\t\tlet lastReplacement: T | undefined;\n\t\tfor (const r of this.replacements) {\n\t\t\tif (r.getNewLength() === 0 && r.replaceRange.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastReplacement && lastReplacement.replaceRange.endExclusive === r.replaceRange.start) {\n\t\t\t\tconst joined = lastReplacement.tryJoinTouching(r);\n\t\t\t\tif (joined) {\n\t\t\t\t\tlastReplacement = joined;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lastReplacement) {\n\t\t\t\tnewReplacements.push(lastReplacement);\n\t\t\t}\n\t\t\tlastReplacement = r;\n\t\t}\n\n\t\tif (lastReplacement) {\n\t\t\tnewReplacements.push(lastReplacement);\n\t\t}\n\t\treturn this._createNew(newReplacements);\n\t}\n\n\t/**\n\t * Combines two edits into one with the same effect.\n\t *\n\t * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_compose.drawio.png)\n\t *\n\t * Invariant:\n\t * ```\n\t * other.apply(this.apply(s0)) = this.compose(other).apply(s0)\n\t * ```\n\t */\n\tpublic compose(other: TEdit): TEdit {\n\t\tconst edits1 = this.normalize();\n\t\tconst edits2 = other.normalize();\n\n\t\tif (edits1.isEmpty()) { return edits2; }\n\t\tif (edits2.isEmpty()) { return edits1; }\n\n\t\tconst edit1Queue = [...edits1.replacements];\n\t\tconst result: T[] = [];\n\n\t\tlet edit1ToEdit2 = 0;\n\n\t\tfor (const r2 of edits2.replacements) {\n\t\t\t// Copy over edit1 unmodified until it touches edit2.\n\t\t\twhile (true) {\n\t\t\t\tconst r1 = edit1Queue[0]!;\n\t\t\t\tif (!r1 || r1.replaceRange.start + edit1ToEdit2 + r1.getNewLength() >= r2.replaceRange.start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tedit1Queue.shift();\n\n\t\t\t\tresult.push(r1);\n\t\t\t\tedit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n\t\t\t}\n\n\t\t\tconst firstEdit1ToEdit2 = edit1ToEdit2;\n\t\t\tlet firstIntersecting: T | undefined; // or touching\n\t\t\tlet lastIntersecting: T | undefined; // or touching\n\n\t\t\twhile (true) {\n\t\t\t\tconst r1 = edit1Queue[0];\n\t\t\t\tif (!r1 || r1.replaceRange.start + edit1ToEdit2 > r2.replaceRange.endExclusive) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else we intersect, because the new end of edit1 is after or equal to our start\n\n\t\t\t\tif (!firstIntersecting) {\n\t\t\t\t\tfirstIntersecting = r1;\n\t\t\t\t}\n\t\t\t\tlastIntersecting = r1;\n\t\t\t\tedit1Queue.shift();\n\n\t\t\t\tedit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n\t\t\t}\n\n\t\t\tif (!firstIntersecting) {\n\t\t\t\tresult.push(r2.delta(-edit1ToEdit2));\n\t\t\t} else {\n\t\t\t\tconst newReplaceRangeStart = Math.min(firstIntersecting.replaceRange.start, r2.replaceRange.start - firstEdit1ToEdit2);\n\n\t\t\t\tconst prefixLength = r2.replaceRange.start - (firstIntersecting.replaceRange.start + firstEdit1ToEdit2);\n\t\t\t\tif (prefixLength > 0) {\n\t\t\t\t\tconst prefix = firstIntersecting.slice(OffsetRange.emptyAt(newReplaceRangeStart), new OffsetRange(0, prefixLength));\n\t\t\t\t\tresult.push(prefix);\n\t\t\t\t}\n\t\t\t\tif (!lastIntersecting) {\n\t\t\t\t\tthrow new BugIndicatingError(`Invariant violation: lastIntersecting is undefined`);\n\t\t\t\t}\n\t\t\t\tconst suffixLength = (lastIntersecting.replaceRange.endExclusive + edit1ToEdit2) - r2.replaceRange.endExclusive;\n\t\t\t\tif (suffixLength > 0) {\n\t\t\t\t\tconst e = lastIntersecting.slice(\n\t\t\t\t\t\tOffsetRange.ofStartAndLength(lastIntersecting.replaceRange.endExclusive, 0),\n\t\t\t\t\t\tnew OffsetRange(lastIntersecting.getNewLength() - suffixLength, lastIntersecting.getNewLength())\n\t\t\t\t\t);\n\t\t\t\t\tedit1Queue.unshift(e);\n\t\t\t\t\tedit1ToEdit2 -= e.getNewLength() - e.replaceRange.length;\n\t\t\t\t}\n\n\t\t\t\tconst newReplaceRange = new OffsetRange(\n\t\t\t\t\tnewReplaceRangeStart,\n\t\t\t\t\tr2.replaceRange.endExclusive - edit1ToEdit2\n\t\t\t\t);\n\t\t\t\tconst middle = r2.slice(newReplaceRange, new OffsetRange(0, r2.getNewLength()));\n\t\t\t\tresult.push(middle);\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst item = edit1Queue.shift();\n\t\t\tif (!item) { break; }\n\t\t\tresult.push(item);\n\t\t}\n\n\t\treturn this._createNew(result).normalize();\n\t}\n\n\t/**\n\t * Returns the range of each replacement in the applied value.\n\t*/\n\tpublic getNewRanges(): OffsetRange[] {\n\t\tconst ranges: OffsetRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.getNewLength()));\n\t\t\toffset += e.getLengthDelta();\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.replacements.length === 0;\n\t}\n}\n\nexport abstract class BaseReplacement<TSelf extends BaseReplacement<TSelf>> {\n\tconstructor(\n\t\t/**\n\t\t * The range to be replaced.\n\t\t*/\n\t\tpublic readonly replaceRange: OffsetRange,\n\t) { }\n\n\tpublic abstract getNewLength(): number;\n\n\t/**\n\t * Precondition: TEdit.range.endExclusive === other.range.start\n\t*/\n\tpublic abstract tryJoinTouching(other: TSelf): TSelf | undefined;\n\n\tpublic abstract slice(newReplaceRange: OffsetRange, rangeInReplacement?: OffsetRange): TSelf;\n\n\tpublic delta(offset: number): TSelf {\n\t\treturn this.slice(this.replaceRange.delta(offset), new OffsetRange(0, this.getNewLength()));\n\t}\n\n\tpublic getLengthDelta(): number {\n\t\treturn this.getNewLength() - this.replaceRange.length;\n\t}\n\n\tabstract equals(other: TSelf): boolean;\n\n\ttoString(): string {\n\t\treturn `{ ${this.replaceRange.toString()} -> ${this.getNewLength()} }`;\n\t}\n\n\tget isEmpty() {\n\t\treturn this.getNewLength() === 0 && this.replaceRange.length === 0;\n\t}\n\n\tgetRangeAfterReplace(): OffsetRange {\n\t\treturn new OffsetRange(this.replaceRange.start, this.replaceRange.start + this.getNewLength());\n\t}\n}\n","\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\nexport abstract class BaseEdit<T extends BaseReplacement<T> = BaseReplacement<any>, TEdit extends BaseEdit<T, TEdit> = BaseEdit<T, any>> {\n\tconstructor(\n\t\tpublic readonly replacements: readonly T[],\n\t) {\n\t\tlet lastEndEx = -1;\n\t\tfor (const replacement of replacements) {\n\t\t\tif (!(replacement.replaceRange.start >= lastEndEx)) {\n\t\t\t\tthrow new BugIndicatingError(`Edits must be disjoint and sorted. Found ${replacement} after ${lastEndEx}`);\n\t\t\t}\n\t\t\tlastEndEx = replacement.replaceRange.endExclusive;\n\t\t}\n\t}\n\n\tprotected abstract _createNew(replacements: readonly T[]): TEdit;\n\n\tpublic toString() {\n\t\tconst edits = this.replacements.map(e => e.toString()).join(', ');\n\t\treturn `[${edits}]`;\n\t}\n\n\t/**\n\t * Normalizes the edit by removing empty replacements and joining touching replacements (if the replacements allow joining).\n\t * Two edits have an equal normalized edit if and only if they have the same effect on any input.\n\t *\n\t * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_normalize.drawio.png)\n\t *\n\t * Invariant:\n\t * ```\n\t * (forall base: TEdit.apply(base).equals(other.apply(base))) <-> this.normalize().equals(other.normalize())\n\t * ```\n\t * and\n\t * ```\n\t * forall base: TEdit.apply(base).equals(this.normalize().apply(base))\n\t * ```\n\t *\n\t */\n\tpublic normalize(): TEdit {\n\t\tconst newReplacements: T[] = [];\n\t\tlet lastReplacement: T | undefined;\n\t\tfor (const r of this.replacements) {\n\t\t\tif (r.getNewLength() === 0 && r.replaceRange.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastReplacement && lastReplacement.replaceRange.endExclusive === r.replaceRange.start) {\n\t\t\t\tconst joined = lastReplacement.tryJoinTouching(r);\n\t\t\t\tif (joined) {\n\t\t\t\t\tlastReplacement = joined;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lastReplacement) {\n\t\t\t\tnewReplacements.push(lastReplacement);\n\t\t\t}\n\t\t\tlastReplacement = r;\n\t\t}\n\n\t\tif (lastReplacement) {\n\t\t\tnewReplacements.push(lastReplacement);\n\t\t}\n\t\treturn this._createNew(newReplacements);\n\t}\n\n\t/**\n\t * Combines two edits into one with the same effect.\n\t *\n\t * ![](https://raw.githubusercontent.com/microsoft/vscode/refs/heads/main/src/vs/editor/common/core/edits/docs/BaseEdit_compose.drawio.png)\n\t *\n\t * Invariant:\n\t * ```\n\t * other.apply(this.apply(s0)) = this.compose(other).apply(s0)\n\t * ```\n\t */\n\tpublic compose(other: TEdit): TEdit {\n\t\tconst edits1 = this.normalize();\n\t\tconst edits2 = other.normalize();\n\n\t\tif (edits1.isEmpty()) { return edits2; }\n\t\tif (edits2.isEmpty()) { return edits1; }\n\n\t\tconst edit1Queue = [...edits1.replacements];\n\t\tconst result: T[] = [];\n\n\t\tlet edit1ToEdit2 = 0;\n\n\t\tfor (const r2 of edits2.replacements) {\n\t\t\t// Copy over edit1 unmodified until it touches edit2.\n\t\t\twhile (true) {\n\t\t\t\tconst r1 = edit1Queue[0]!;\n\t\t\t\tif (!r1 || r1.replaceRange.start + edit1ToEdit2 + r1.getNewLength() >= r2.replaceRange.start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tedit1Queue.shift();\n\n\t\t\t\tresult.push(r1);\n\t\t\t\tedit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n\t\t\t}\n\n\t\t\tconst firstEdit1ToEdit2 = edit1ToEdit2;\n\t\t\tlet firstIntersecting: T | undefined; // or touching\n\t\t\tlet lastIntersecting: T | undefined; // or touching\n\n\t\t\twhile (true) {\n\t\t\t\tconst r1 = edit1Queue[0];\n\t\t\t\tif (!r1 || r1.replaceRange.start + edit1ToEdit2 > r2.replaceRange.endExclusive) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// else we intersect, because the new end of edit1 is after or equal to our start\n\n\t\t\t\tif (!firstIntersecting) {\n\t\t\t\t\tfirstIntersecting = r1;\n\t\t\t\t}\n\t\t\t\tlastIntersecting = r1;\n\t\t\t\tedit1Queue.shift();\n\n\t\t\t\tedit1ToEdit2 += r1.getNewLength() - r1.replaceRange.length;\n\t\t\t}\n\n\t\t\tif (!firstIntersecting) {\n\t\t\t\tresult.push(r2.delta(-edit1ToEdit2));\n\t\t\t} else {\n\t\t\t\tconst newReplaceRangeStart = Math.min(firstIntersecting.replaceRange.start, r2.replaceRange.start - firstEdit1ToEdit2);\n\n\t\t\t\tconst prefixLength = r2.replaceRange.start - (firstIntersecting.replaceRange.start + firstEdit1ToEdit2);\n\t\t\t\tif (prefixLength > 0) {\n\t\t\t\t\tconst prefix = firstIntersecting.slice(OffsetRange.emptyAt(newReplaceRangeStart), new OffsetRange(0, prefixLength));\n\t\t\t\t\tresult.push(prefix);\n\t\t\t\t}\n\t\t\t\tif (!lastIntersecting) {\n\t\t\t\t\tthrow new BugIndicatingError(`Invariant violation: lastIntersecting is undefined`);\n\t\t\t\t}\n\t\t\t\tconst suffixLength = (lastIntersecting.replaceRange.endExclusive + edit1ToEdit2) - r2.replaceRange.endExclusive;\n\t\t\t\tif (suffixLength > 0) {\n\t\t\t\t\tconst e = lastIntersecting.slice(\n\t\t\t\t\t\tOffsetRange.ofStartAndLength(lastIntersecting.replaceRange.endExclusive, 0),\n\t\t\t\t\t\tnew OffsetRange(lastIntersecting.getNewLength() - suffixLength, lastIntersecting.getNewLength())\n\t\t\t\t\t);\n\t\t\t\t\tedit1Queue.unshift(e);\n\t\t\t\t\tedit1ToEdit2 -= e.getNewLength() - e.replaceRange.length;\n\t\t\t\t}\n\n\t\t\t\tconst newReplaceRange = new OffsetRange(\n\t\t\t\t\tnewReplaceRangeStart,\n\t\t\t\t\tr2.replaceRange.endExclusive - edit1ToEdit2\n\t\t\t\t);\n\t\t\t\tconst middle = r2.slice(newReplaceRange, new OffsetRange(0, r2.getNewLength()));\n\t\t\t\tresult.push(middle);\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tconst item = edit1Queue.shift();\n\t\t\tif (!item) { break; }\n\t\t\tresult.push(item);\n\t\t}\n\n\t\treturn this._createNew(result).normalize();\n\t}\n\n\t/**\n\t * Returns the range of each replacement in the applied value.\n\t*/\n\tpublic getNewRanges(): OffsetRange[] {\n\t\tconst ranges: OffsetRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(OffsetRange.ofStartAndLength(e.replaceRange.start + offset, e.getNewLength()));\n\t\t\toffset += e.getLengthDelta();\n\t\t}\n\t\treturn ranges;\n\t}\n\n\tpublic isEmpty(): boolean {\n\t\treturn this.replacements.length === 0;\n\t}\n}\n\nexport abstract class BaseReplacement<TSelf extends BaseReplacement<TSelf>> {\n\tconstructor(\n\t\t/**\n\t\t * The range to be replaced.\n\t\t*/\n\t\tpublic readonly replaceRange: OffsetRange,\n\t) { }\n\n\tpublic abstract getNewLength(): number;\n\n\t/**\n\t * Precondition: TEdit.range.endExclusive === other.range.start\n\t*/\n\tpublic abstract tryJoinTouching(other: TSelf): TSelf | undefined;\n\n\tpublic abstract slice(newReplaceRange: OffsetRange, rangeInReplacement?: OffsetRange): TSelf;\n\n\tpublic delta(offset: number): TSelf {\n\t\treturn this.slice(this.replaceRange.delta(offset), new OffsetRange(0, this.getNewLength()));\n\t}\n\n\tpublic getLengthDelta(): number {\n\t\treturn this.getNewLength() - this.replaceRange.length;\n\t}\n\n\tabstract equals(other: TSelf): boolean;\n\n\ttoString(): string {\n\t\treturn `{ ${this.replaceRange.toString()} -> ${this.getNewLength()} }`;\n\t}\n\n\tget isEmpty() {\n\t\treturn this.getNewLength() === 0 && this.replaceRange.length === 0;\n\t}\n\n\tgetRangeAfterReplace(): OffsetRange {\n\t\treturn new OffsetRange(this.replaceRange.start, this.replaceRange.start + this.getNewLength());\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2016, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/edits/stringEdit.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/edits/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/edits/stringEdit.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/edits/vs/editor/common/core/edits/stringEdit.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { BaseEdit, BaseReplacement } from './edit.js';\n\n\nexport abstract class BaseStringEdit<T extends BaseStringReplacement<T> = BaseStringReplacement<any>, TEdit extends BaseStringEdit<T, TEdit> = BaseStringEdit<any, any>> extends BaseEdit<T, TEdit> {\n\n\tpublic apply(base: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tresultText.push(base.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(base.substring(pos));\n\t\treturn resultText.join('');\n\t}\n}\n\nexport abstract class BaseStringReplacement<T extends BaseStringReplacement<T> = BaseStringReplacement<any>> extends BaseReplacement<T> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newText: string\n\t) {\n\t\tsuper(range);\n\t}\n\n\tgetNewLength(): number { return this.newText.length; }\n\n\toverride toString(): string {\n\t\treturn `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;\n\t}\n\n\treplace(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\tremoveCommonSuffixPrefix(originalText: string): StringReplacement {\n\t\tconst oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tconst suffixLen = Math.min(\n\t\t\toldText.length - prefixLen,\n\t\t\tthis.newText.length - prefixLen,\n\t\t\tcommonSuffixLength(oldText, this.newText)\n\t\t);\n\n\t\tconst replaceRange = new OffsetRange(\n\t\t\tthis.replaceRange.start + prefixLen,\n\t\t\tthis.replaceRange.endExclusive - suffixLen,\n\t\t);\n\t\tconst newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);\n\n\t\treturn new StringReplacement(replaceRange, newText);\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): T {\n\t\treturn this.removeCommonSuffix(source).removeCommonPrefix(source);\n\t}\n\n\tpublic removeCommonPrefix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tif (prefixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\n\t\treturn this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));\n\t}\n\n\tpublic removeCommonSuffix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst suffixLen = commonSuffixLength(oldText, this.newText);\n\t\tif (suffixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\t\treturn this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));\n\t}\n\n\tpublic toJson(): ISerializedStringReplacement {\n\t\treturn ({\n\t\t\ttxt: this.newText,\n\t\t\tpos: this.replaceRange.start,\n\t\t\tlen: this.replaceRange.length,\n\t\t});\n\t}\n}\n\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class StringEdit extends BaseStringEdit<StringReplacement, StringEdit> {\n\tpublic static readonly empty = new StringEdit([]);\n\n\tpublic static compose(edits: readonly StringEdit[]): StringEdit {\n\t\tif (edits.length === 0) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(replacements: readonly StringReplacement[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n}\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport interface ISerializedStringReplacement {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class StringReplacement extends BaseStringReplacement<StringReplacement> {\n\tpublic static insert(offset: number, text: string): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): StringReplacement {\n\t\treturn new StringReplacement(range, text);\n\t}\n\n\toverride equals(other: StringReplacement): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;\n\t}\n\n\toverride tryJoinTouching(other: StringReplacement): StringReplacement | undefined {\n\t\treturn new StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);\n\t}\n\n\toverride slice(range: OffsetRange, rangeInReplacement?: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);\n\t}\n}\n\nexport function applyEditsToRanges(sortedRanges: OffsetRange[], edit: StringEdit): OffsetRange[] {\n\tsortedRanges = sortedRanges.slice();\n\n\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\tconst result: OffsetRange[] = [];\n\n\tlet offset = 0;\n\n\tfor (const e of edit.replacements) {\n\t\twhile (true) {\n\t\t\t// ranges before the current edit\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || r.endExclusive >= e.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tresult.push(r.delta(offset));\n\t\t}\n\n\t\tconst intersecting: OffsetRange[] = [];\n\t\twhile (true) {\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || !r.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tintersecting.push(r);\n\t\t}\n\n\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\tlet r = intersecting[i];\n\n\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\tr = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));\n\n\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t}\n\n\t\t\tif (i !== 0) {\n\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t}\n\n\t\t\t// We already took our offset into account.\n\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t// we have to remove it here.\n\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\tsortedRanges.unshift(r);\n\t\t}\n\n\t\toffset += e.newText.length - e.replaceRange.length;\n\t}\n\n\twhile (true) {\n\t\tconst r = sortedRanges[0];\n\t\tif (!r) {\n\t\t\tbreak;\n\t\t}\n\t\tsortedRanges.shift();\n\t\tresult.push(r.delta(offset));\n\t}\n\n\treturn result;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { BaseEdit, BaseReplacement } from './edit.js';\n\n\nexport abstract class BaseStringEdit<T extends BaseStringReplacement<T> = BaseStringReplacement<any>, TEdit extends BaseStringEdit<T, TEdit> = BaseStringEdit<any, any>> extends BaseEdit<T, TEdit> {\n\n\tpublic apply(base: string): string {\n\t\tconst resultText: string[] = [];\n\t\tlet pos = 0;\n\t\tfor (const edit of this.replacements) {\n\t\t\tresultText.push(base.substring(pos, edit.replaceRange.start));\n\t\t\tresultText.push(edit.newText);\n\t\t\tpos = edit.replaceRange.endExclusive;\n\t\t}\n\t\tresultText.push(base.substring(pos));\n\t\treturn resultText.join('');\n\t}\n}\n\nexport abstract class BaseStringReplacement<T extends BaseStringReplacement<T> = BaseStringReplacement<any>> extends BaseReplacement<T> {\n\tconstructor(\n\t\trange: OffsetRange,\n\t\tpublic readonly newText: string\n\t) {\n\t\tsuper(range);\n\t}\n\n\tgetNewLength(): number { return this.newText.length; }\n\n\toverride toString(): string {\n\t\treturn `${this.replaceRange} -> ${JSON.stringify(this.newText)}`;\n\t}\n\n\treplace(str: string): string {\n\t\treturn str.substring(0, this.replaceRange.start) + this.newText + str.substring(this.replaceRange.endExclusive);\n\t}\n\n\tremoveCommonSuffixPrefix(originalText: string): StringReplacement {\n\t\tconst oldText = originalText.substring(this.replaceRange.start, this.replaceRange.endExclusive);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tconst suffixLen = Math.min(\n\t\t\toldText.length - prefixLen,\n\t\t\tthis.newText.length - prefixLen,\n\t\t\tcommonSuffixLength(oldText, this.newText)\n\t\t);\n\n\t\tconst replaceRange = new OffsetRange(\n\t\t\tthis.replaceRange.start + prefixLen,\n\t\t\tthis.replaceRange.endExclusive - suffixLen,\n\t\t);\n\t\tconst newText = this.newText.substring(prefixLen, this.newText.length - suffixLen);\n\n\t\treturn new StringReplacement(replaceRange, newText);\n\t}\n\n\tpublic removeCommonSuffixAndPrefix(source: string): T {\n\t\treturn this.removeCommonSuffix(source).removeCommonPrefix(source);\n\t}\n\n\tpublic removeCommonPrefix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst prefixLen = commonPrefixLength(oldText, this.newText);\n\t\tif (prefixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\n\t\treturn this.slice(this.replaceRange.deltaStart(prefixLen), new OffsetRange(prefixLen, this.newText.length));\n\t}\n\n\tpublic removeCommonSuffix(source: string): T {\n\t\tconst oldText = this.replaceRange.substring(source);\n\n\t\tconst suffixLen = commonSuffixLength(oldText, this.newText);\n\t\tif (suffixLen === 0) {\n\t\t\treturn this as unknown as T;\n\t\t}\n\t\treturn this.slice(this.replaceRange.deltaEnd(-suffixLen), new OffsetRange(0, this.newText.length - suffixLen));\n\t}\n\n\tpublic toJson(): ISerializedStringReplacement {\n\t\treturn ({\n\t\t\ttxt: this.newText,\n\t\t\tpos: this.replaceRange.start,\n\t\t\tlen: this.replaceRange.length,\n\t\t});\n\t}\n}\n\n\n/**\n * Represents a set of replacements to a string.\n * All these replacements are applied at once.\n*/\nexport class StringEdit extends BaseStringEdit<StringReplacement, StringEdit> {\n\tpublic static readonly empty = new StringEdit([]);\n\n\tpublic static compose(edits: readonly StringEdit[]): StringEdit {\n\t\tif (edits.length === 0) {\n\t\t\treturn StringEdit.empty;\n\t\t}\n\t\tlet result = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tresult = result.compose(edits[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(replacements: readonly StringReplacement[]) {\n\t\tsuper(replacements);\n\t}\n\n\tprotected override _createNew(replacements: readonly StringReplacement[]): StringEdit {\n\t\treturn new StringEdit(replacements);\n\t}\n}\n\n/**\n * Warning: Be careful when changing this type, as it is used for serialization!\n*/\nexport interface ISerializedStringReplacement {\n\ttxt: string;\n\tpos: number;\n\tlen: number;\n}\n\nexport class StringReplacement extends BaseStringReplacement<StringReplacement> {\n\tpublic static insert(offset: number, text: string): StringReplacement {\n\t\treturn new StringReplacement(OffsetRange.emptyAt(offset), text);\n\t}\n\n\tpublic static replace(range: OffsetRange, text: string): StringReplacement {\n\t\treturn new StringReplacement(range, text);\n\t}\n\n\toverride equals(other: StringReplacement): boolean {\n\t\treturn this.replaceRange.equals(other.replaceRange) && this.newText === other.newText;\n\t}\n\n\toverride tryJoinTouching(other: StringReplacement): StringReplacement | undefined {\n\t\treturn new StringReplacement(this.replaceRange.joinRightTouching(other.replaceRange), this.newText + other.newText);\n\t}\n\n\toverride slice(range: OffsetRange, rangeInReplacement?: OffsetRange): StringReplacement {\n\t\treturn new StringReplacement(range, rangeInReplacement ? rangeInReplacement.substring(this.newText) : this.newText);\n\t}\n}\n\nexport function applyEditsToRanges(sortedRanges: OffsetRange[], edit: StringEdit): OffsetRange[] {\n\tsortedRanges = sortedRanges.slice();\n\n\t// treat edits as deletion of the replace range and then as insertion that extends the first range\n\tconst result: OffsetRange[] = [];\n\n\tlet offset = 0;\n\n\tfor (const e of edit.replacements) {\n\t\twhile (true) {\n\t\t\t// ranges before the current edit\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || r.endExclusive >= e.replaceRange.start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tresult.push(r.delta(offset));\n\t\t}\n\n\t\tconst intersecting: OffsetRange[] = [];\n\t\twhile (true) {\n\t\t\tconst r = sortedRanges[0];\n\t\t\tif (!r || !r.intersectsOrTouches(e.replaceRange)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsortedRanges.shift();\n\t\t\tintersecting.push(r);\n\t\t}\n\n\t\tfor (let i = intersecting.length - 1; i >= 0; i--) {\n\t\t\tlet r = intersecting[i];\n\n\t\t\tconst overlap = r.intersect(e.replaceRange)!.length;\n\t\t\tr = r.deltaEnd(-overlap + (i === 0 ? e.newText.length : 0));\n\n\t\t\tconst rangeAheadOfReplaceRange = r.start - e.replaceRange.start;\n\t\t\tif (rangeAheadOfReplaceRange > 0) {\n\t\t\t\tr = r.delta(-rangeAheadOfReplaceRange);\n\t\t\t}\n\n\t\t\tif (i !== 0) {\n\t\t\t\tr = r.delta(e.newText.length);\n\t\t\t}\n\n\t\t\t// We already took our offset into account.\n\t\t\t// Because we add r back to the queue (which then adds offset again),\n\t\t\t// we have to remove it here.\n\t\t\tr = r.delta(-(e.newText.length - e.replaceRange.length));\n\n\t\t\tsortedRanges.unshift(r);\n\t\t}\n\n\t\toffset += e.newText.length - e.replaceRange.length;\n\t}\n\n\twhile (true) {\n\t\tconst r = sortedRanges[0];\n\t\tif (!r) {\n\t\t\tbreak;\n\t\t}\n\t\tsortedRanges.shift();\n\t\tresult.push(r.delta(offset));\n\t}\n\n\treturn result;\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2194, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/lineRange.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/ranges/lineRange.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/vs/editor/common/core/ranges/lineRange.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from '../range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { Comparator, compareBy, numberComparator } from '../../../../base/common/arrays.js';\n\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n\tpublic static ofLength(startLineNumber: number, length: number): LineRange {\n\t\treturn new LineRange(startLineNumber, startLineNumber + length);\n\t}\n\n\tpublic static fromRangeInclusive(range: Range): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber + 1);\n\t}\n\n\tpublic static readonly compareByStart: Comparator<LineRange> = compareBy(l => l.startLineNumber, numberComparator);\n\n\t/**\n\t * @param lineRanges An array of arrays of of sorted line ranges.\n\t */\n\tpublic static joinMany(lineRanges: readonly (readonly LineRange[])[]): readonly LineRange[] {\n\t\tif (lineRanges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result = new LineRangeSet(lineRanges[0].slice());\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tresult = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n\t\t}\n\t\treturn result.ranges;\n\t}\n\n\tpublic static join(lineRanges: LineRange[]): LineRange {\n\t\tif (lineRanges.length === 0) {\n\t\t\tthrow new BugIndicatingError('lineRanges cannot be empty');\n\t\t}\n\t\tlet startLineNumber = lineRanges[0].startLineNumber;\n\t\tlet endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tstartLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n\t\t\tendLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n\t\t}\n\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic static deserialize(lineRange: ISerializedLineRange): LineRange {\n\t\treturn new LineRange(lineRange[0], lineRange[1]);\n\t}\n\n\t/**\n\t * The start line number.\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The end line number (exclusive).\n\t */\n\tpublic readonly endLineNumberExclusive: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tendLineNumberExclusive: number,\n\t) {\n\t\tif (startLineNumber > endLineNumberExclusive) {\n\t\t\tthrow new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n\t\t}\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumberExclusive = endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range contains the given line number.\n\t */\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range is empty.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Moves this line range by the given offset of line numbers.\n\t */\n\tpublic delta(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n\t}\n\n\tpublic deltaLength(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n\t}\n\n\t/**\n\t * The number of lines this line range spans.\n\t */\n\tpublic get length(): number {\n\t\treturn this.endLineNumberExclusive - this.startLineNumber;\n\t}\n\n\t/**\n\t * Creates a line range that combines this and the given line range.\n\t */\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n\t\t);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\t/**\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: LineRange): LineRange | undefined {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n\t\tconst endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n\t\tif (startLineNumber <= endLineNumberExclusive) {\n\t\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectsStrict(other: LineRange): boolean {\n\t\treturn this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic intersectsOrTouches(other: LineRange): boolean {\n\t\treturn this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n\t}\n\n\tpublic equals(b: LineRange): boolean {\n\t\treturn this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n\t}\n\n\tpublic toInclusiveRange(): Range | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n\t}\n\n\t/**\n\t * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n\t*/\n\tpublic toExclusiveRange(): Range {\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n\t}\n\n\tpublic mapToLineArray<T>(f: (lineNumber: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tresult.push(f(lineNumber));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (lineNumber: number) => void): void {\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tf(lineNumber);\n\t\t}\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic serialize(): ISerializedLineRange {\n\t\treturn [this.startLineNumber, this.endLineNumberExclusive];\n\t}\n\n\t/**\n\t * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n\t * @internal\n\t */\n\tpublic toOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n\t}\n\n\tpublic addMargin(marginTop: number, marginBottom: number): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.startLineNumber - marginTop,\n\t\t\tthis.endLineNumberExclusive + marginBottom\n\t\t);\n\t}\n}\n\nexport type ISerializedLineRange = [startLineNumber: number, endLineNumberExclusive: number];\n\n\nexport class LineRangeSet {\n\tconstructor(\n\t\t/**\n\t\t * Sorted by start line number.\n\t\t * No two line ranges are touching or intersecting.\n\t\t */\n\t\tprivate readonly _normalizedRanges: LineRange[] = []\n\t) {\n\t}\n\n\tget ranges(): readonly LineRange[] {\n\t\treturn this._normalizedRanges;\n\t}\n\n\taddRange(range: LineRange): void {\n\t\tif (range.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Idea: Find joinRange such that:\n\t\t// replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\t// If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n\t\t} else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n\t\t\t// Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx];\n\t\t\tthis._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n\t\t} else {\n\t\t\t// First and last element are different - we need to replace the entire range\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n\t\t}\n\t}\n\n\tcontains(lineNumber: number): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n\t}\n\n\tintersects(range: LineRange): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n\t}\n\n\tgetUnion(other: LineRangeSet): LineRangeSet {\n\t\tif (this._normalizedRanges.length === 0) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other._normalizedRanges.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\tlet current: LineRange | null = null;\n\t\twhile (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n\t\t\tlet next: LineRange | null = null;\n\t\t\tif (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\t\tconst lineRange1 = this._normalizedRanges[i1];\n\t\t\t\tconst lineRange2 = other._normalizedRanges[i2];\n\t\t\t\tif (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n\t\t\t\t\tnext = lineRange1;\n\t\t\t\t\ti1++;\n\t\t\t\t} else {\n\t\t\t\t\tnext = lineRange2;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t} else if (i1 < this._normalizedRanges.length) {\n\t\t\t\tnext = this._normalizedRanges[i1];\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\tnext = other._normalizedRanges[i2];\n\t\t\t\ti2++;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcurrent = next;\n\t\t\t} else {\n\t\t\t\tif (current.endLineNumberExclusive >= next.startLineNumber) {\n\t\t\t\t\t// merge\n\t\t\t\t\tcurrent = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n\t\t\t\t} else {\n\t\t\t\t\t// push\n\t\t\t\t\tresult.push(current);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (current !== null) {\n\t\t\tresult.push(current);\n\t\t}\n\t\treturn new LineRangeSet(result);\n\t}\n\n\t/**\n\t * Subtracts all ranges in this set from `range` and returns the result.\n\t */\n\tsubtractFrom(range: LineRange): LineRangeSet {\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\treturn new LineRangeSet([range]);\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tfor (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n\t\t\tconst r = this._normalizedRanges[i];\n\t\t\tif (r.startLineNumber > startLineNumber) {\n\t\t\t\tresult.push(new LineRange(startLineNumber, r.startLineNumber));\n\t\t\t}\n\t\t\tstartLineNumber = r.endLineNumberExclusive;\n\t\t}\n\t\tif (startLineNumber < range.endLineNumberExclusive) {\n\t\t\tresult.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\ttoString() {\n\t\treturn this._normalizedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\tgetIntersection(other: LineRangeSet): LineRangeSet {\n\t\tconst result: LineRange[] = [];\n\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\twhile (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\tconst r1 = this._normalizedRanges[i1];\n\t\t\tconst r2 = other._normalizedRanges[i2];\n\n\t\t\tconst i = r1.intersect(r2);\n\t\t\tif (i && !i.isEmpty) {\n\t\t\t\tresult.push(i);\n\t\t\t}\n\n\t\t\tif (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\tgetWithDelta(value: number): LineRangeSet {\n\t\treturn new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from '../range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { Comparator, compareBy, numberComparator } from '../../../../base/common/arrays.js';\n\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n\tpublic static ofLength(startLineNumber: number, length: number): LineRange {\n\t\treturn new LineRange(startLineNumber, startLineNumber + length);\n\t}\n\n\tpublic static fromRangeInclusive(range: Range): LineRange {\n\t\treturn new LineRange(range.startLineNumber, range.endLineNumber + 1);\n\t}\n\n\tpublic static readonly compareByStart: Comparator<LineRange> = compareBy(l => l.startLineNumber, numberComparator);\n\n\t/**\n\t * @param lineRanges An array of arrays of of sorted line ranges.\n\t */\n\tpublic static joinMany(lineRanges: readonly (readonly LineRange[])[]): readonly LineRange[] {\n\t\tif (lineRanges.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\tlet result = new LineRangeSet(lineRanges[0].slice());\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tresult = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n\t\t}\n\t\treturn result.ranges;\n\t}\n\n\tpublic static join(lineRanges: LineRange[]): LineRange {\n\t\tif (lineRanges.length === 0) {\n\t\t\tthrow new BugIndicatingError('lineRanges cannot be empty');\n\t\t}\n\t\tlet startLineNumber = lineRanges[0].startLineNumber;\n\t\tlet endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n\t\tfor (let i = 1; i < lineRanges.length; i++) {\n\t\t\tstartLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n\t\t\tendLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n\t\t}\n\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic static deserialize(lineRange: ISerializedLineRange): LineRange {\n\t\treturn new LineRange(lineRange[0], lineRange[1]);\n\t}\n\n\t/**\n\t * The start line number.\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The end line number (exclusive).\n\t */\n\tpublic readonly endLineNumberExclusive: number;\n\n\tconstructor(\n\t\tstartLineNumber: number,\n\t\tendLineNumberExclusive: number,\n\t) {\n\t\tif (startLineNumber > endLineNumberExclusive) {\n\t\t\tthrow new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n\t\t}\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumberExclusive = endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range contains the given line number.\n\t */\n\tpublic contains(lineNumber: number): boolean {\n\t\treturn this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Indicates if this line range is empty.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.startLineNumber === this.endLineNumberExclusive;\n\t}\n\n\t/**\n\t * Moves this line range by the given offset of line numbers.\n\t */\n\tpublic delta(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n\t}\n\n\tpublic deltaLength(offset: number): LineRange {\n\t\treturn new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n\t}\n\n\t/**\n\t * The number of lines this line range spans.\n\t */\n\tpublic get length(): number {\n\t\treturn this.endLineNumberExclusive - this.startLineNumber;\n\t}\n\n\t/**\n\t * Creates a line range that combines this and the given line range.\n\t */\n\tpublic join(other: LineRange): LineRange {\n\t\treturn new LineRange(\n\t\t\tMath.min(this.startLineNumber, other.startLineNumber),\n\t\t\tMath.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n\t\t);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n\t}\n\n\t/**\n\t * The resulting range is empty if the ranges do not intersect, but touch.\n\t * If the ranges don't even touch, the result is undefined.\n\t */\n\tpublic intersect(other: LineRange): LineRange | undefined {\n\t\tconst startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n\t\tconst endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n\t\tif (startLineNumber <= endLineNumberExclusive) {\n\t\t\treturn new LineRange(startLineNumber, endLineNumberExclusive);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic intersectsStrict(other: LineRange): boolean {\n\t\treturn this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n\t}\n\n\tpublic intersectsOrTouches(other: LineRange): boolean {\n\t\treturn this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n\t}\n\n\tpublic equals(b: LineRange): boolean {\n\t\treturn this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n\t}\n\n\tpublic toInclusiveRange(): Range | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n\t}\n\n\t/**\n\t * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n\t*/\n\tpublic toExclusiveRange(): Range {\n\t\treturn new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n\t}\n\n\tpublic mapToLineArray<T>(f: (lineNumber: number) => T): T[] {\n\t\tconst result: T[] = [];\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tresult.push(f(lineNumber));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic forEach(f: (lineNumber: number) => void): void {\n\t\tfor (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n\t\t\tf(lineNumber);\n\t\t}\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tpublic serialize(): ISerializedLineRange {\n\t\treturn [this.startLineNumber, this.endLineNumberExclusive];\n\t}\n\n\t/**\n\t * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n\t * @internal\n\t */\n\tpublic toOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n\t}\n\n\tpublic addMargin(marginTop: number, marginBottom: number): LineRange {\n\t\treturn new LineRange(\n\t\t\tthis.startLineNumber - marginTop,\n\t\t\tthis.endLineNumberExclusive + marginBottom\n\t\t);\n\t}\n}\n\nexport type ISerializedLineRange = [startLineNumber: number, endLineNumberExclusive: number];\n\n\nexport class LineRangeSet {\n\tconstructor(\n\t\t/**\n\t\t * Sorted by start line number.\n\t\t * No two line ranges are touching or intersecting.\n\t\t */\n\t\tprivate readonly _normalizedRanges: LineRange[] = []\n\t) {\n\t}\n\n\tget ranges(): readonly LineRange[] {\n\t\treturn this._normalizedRanges;\n\t}\n\n\taddRange(range: LineRange): void {\n\t\tif (range.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Idea: Find joinRange such that:\n\t\t// replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\t// If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n\t\t} else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n\t\t\t// Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx];\n\t\t\tthis._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n\t\t} else {\n\t\t\t// First and last element are different - we need to replace the entire range\n\t\t\tconst joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n\t\t\tthis._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n\t\t}\n\t}\n\n\tcontains(lineNumber: number): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n\t}\n\n\tintersects(range: LineRange): boolean {\n\t\tconst rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n\t\treturn !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n\t}\n\n\tgetUnion(other: LineRangeSet): LineRangeSet {\n\t\tif (this._normalizedRanges.length === 0) {\n\t\t\treturn other;\n\t\t}\n\t\tif (other._normalizedRanges.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\tlet current: LineRange | null = null;\n\t\twhile (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n\t\t\tlet next: LineRange | null = null;\n\t\t\tif (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\t\tconst lineRange1 = this._normalizedRanges[i1];\n\t\t\t\tconst lineRange2 = other._normalizedRanges[i2];\n\t\t\t\tif (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n\t\t\t\t\tnext = lineRange1;\n\t\t\t\t\ti1++;\n\t\t\t\t} else {\n\t\t\t\t\tnext = lineRange2;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t} else if (i1 < this._normalizedRanges.length) {\n\t\t\t\tnext = this._normalizedRanges[i1];\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\tnext = other._normalizedRanges[i2];\n\t\t\t\ti2++;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcurrent = next;\n\t\t\t} else {\n\t\t\t\tif (current.endLineNumberExclusive >= next.startLineNumber) {\n\t\t\t\t\t// merge\n\t\t\t\t\tcurrent = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n\t\t\t\t} else {\n\t\t\t\t\t// push\n\t\t\t\t\tresult.push(current);\n\t\t\t\t\tcurrent = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (current !== null) {\n\t\t\tresult.push(current);\n\t\t}\n\t\treturn new LineRangeSet(result);\n\t}\n\n\t/**\n\t * Subtracts all ranges in this set from `range` and returns the result.\n\t */\n\tsubtractFrom(range: LineRange): LineRangeSet {\n\t\t// idx of first element that touches range or that is after range\n\t\tconst joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n\t\t// idx of element after { last element that touches range or that is before range }\n\t\tconst joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n\n\t\tif (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n\t\t\treturn new LineRangeSet([range]);\n\t\t}\n\n\t\tconst result: LineRange[] = [];\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tfor (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n\t\t\tconst r = this._normalizedRanges[i];\n\t\t\tif (r.startLineNumber > startLineNumber) {\n\t\t\t\tresult.push(new LineRange(startLineNumber, r.startLineNumber));\n\t\t\t}\n\t\t\tstartLineNumber = r.endLineNumberExclusive;\n\t\t}\n\t\tif (startLineNumber < range.endLineNumberExclusive) {\n\t\t\tresult.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\ttoString() {\n\t\treturn this._normalizedRanges.map(r => r.toString()).join(', ');\n\t}\n\n\tgetIntersection(other: LineRangeSet): LineRangeSet {\n\t\tconst result: LineRange[] = [];\n\n\t\tlet i1 = 0;\n\t\tlet i2 = 0;\n\t\twhile (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n\t\t\tconst r1 = this._normalizedRanges[i1];\n\t\t\tconst r2 = other._normalizedRanges[i2];\n\n\t\t\tconst i = r1.intersect(r2);\n\t\t\tif (i && !i.isEmpty) {\n\t\t\t\tresult.push(i);\n\t\t\t}\n\n\t\t\tif (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n\t\t\t\ti1++;\n\t\t\t} else {\n\t\t\t\ti2++;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineRangeSet(result);\n\t}\n\n\tgetWithDelta(value: number): LineRangeSet {\n\t\treturn new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2496, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/text/textLength.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/text/textLength.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/vs/editor/common/core/text/textLength.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../ranges/lineRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\n\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nexport class TextLength {\n\tpublic static zero = new TextLength(0, 0);\n\n\tpublic static betweenPositions(position1: Position, position2: Position): TextLength {\n\t\tif (position1.lineNumber === position2.lineNumber) {\n\t\t\treturn new TextLength(0, position2.column - position1.column);\n\t\t} else {\n\t\t\treturn new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n\t\t}\n\t}\n\n\tpublic static fromPosition(pos: Position): TextLength {\n\t\treturn new TextLength(pos.lineNumber - 1, pos.column - 1);\n\t}\n\n\tpublic static ofRange(range: Range) {\n\t\treturn TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n\t}\n\n\tpublic static ofText(text: string): TextLength {\n\t\tlet line = 0;\n\t\tlet column = 0;\n\t\tfor (const c of text) {\n\t\t\tif (c === '\\n') {\n\t\t\t\tline++;\n\t\t\t\tcolumn = 0;\n\t\t\t} else {\n\t\t\t\tcolumn++;\n\t\t\t}\n\t\t}\n\t\treturn new TextLength(line, column);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineCount: number,\n\t\tpublic readonly columnCount: number\n\t) { }\n\n\tpublic isGreaterThanOrEqualTo(other: TextLength): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount > other.lineCount;\n\t\t}\n\t\treturn this.columnCount >= other.columnCount;\n\t}\n\n\tpublic add(other: TextLength): TextLength {\n\t\tif (other.lineCount === 0) {\n\t\t\treturn new TextLength(this.lineCount, this.columnCount + other.columnCount);\n\t\t} else {\n\t\t\treturn new TextLength(this.lineCount + other.lineCount, other.columnCount);\n\t\t}\n\t}\n\n\tpublic createRange(startPosition: Position): Range {\n\t\tif (this.lineCount === 0) {\n\t\t\treturn new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n\t\t} else {\n\t\t\treturn new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n\t\t}\n\t}\n\n\tpublic toRange(): Range {\n\t\treturn new Range(1, 1, this.lineCount + 1, this.columnCount + 1);\n\t}\n\n\tpublic toLineRange(): LineRange {\n\t\treturn LineRange.ofLength(1, this.lineCount + 1);\n\t}\n\n\tpublic addToPosition(position: Position): Position {\n\t\tif (this.lineCount === 0) {\n\t\t\treturn new Position(position.lineNumber, position.column + this.columnCount);\n\t\t} else {\n\t\t\treturn new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `${this.lineCount},${this.columnCount}`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../ranges/lineRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\n\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nexport class TextLength {\n\tpublic static zero = new TextLength(0, 0);\n\n\tpublic static betweenPositions(position1: Position, position2: Position): TextLength {\n\t\tif (position1.lineNumber === position2.lineNumber) {\n\t\t\treturn new TextLength(0, position2.column - position1.column);\n\t\t} else {\n\t\t\treturn new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n\t\t}\n\t}\n\n\tpublic static fromPosition(pos: Position): TextLength {\n\t\treturn new TextLength(pos.lineNumber - 1, pos.column - 1);\n\t}\n\n\tpublic static ofRange(range: Range) {\n\t\treturn TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n\t}\n\n\tpublic static ofText(text: string): TextLength {\n\t\tlet line = 0;\n\t\tlet column = 0;\n\t\tfor (const c of text) {\n\t\t\tif (c === '\\n') {\n\t\t\t\tline++;\n\t\t\t\tcolumn = 0;\n\t\t\t} else {\n\t\t\t\tcolumn++;\n\t\t\t}\n\t\t}\n\t\treturn new TextLength(line, column);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineCount: number,\n\t\tpublic readonly columnCount: number\n\t) { }\n\n\tpublic isGreaterThanOrEqualTo(other: TextLength): boolean {\n\t\tif (this.lineCount !== other.lineCount) {\n\t\t\treturn this.lineCount > other.lineCount;\n\t\t}\n\t\treturn this.columnCount >= other.columnCount;\n\t}\n\n\tpublic add(other: TextLength): TextLength {\n\t\tif (other.lineCount === 0) {\n\t\t\treturn new TextLength(this.lineCount, this.columnCount + other.columnCount);\n\t\t} else {\n\t\t\treturn new TextLength(this.lineCount + other.lineCount, other.columnCount);\n\t\t}\n\t}\n\n\tpublic createRange(startPosition: Position): Range {\n\t\tif (this.lineCount === 0) {\n\t\t\treturn new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n\t\t} else {\n\t\t\treturn new Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n\t\t}\n\t}\n\n\tpublic toRange(): Range {\n\t\treturn new Range(1, 1, this.lineCount + 1, this.columnCount + 1);\n\t}\n\n\tpublic toLineRange(): LineRange {\n\t\treturn LineRange.ofLength(1, this.lineCount + 1);\n\t}\n\n\tpublic addToPosition(position: Position): Position {\n\t\tif (this.lineCount === 0) {\n\t\t\treturn new Position(position.lineNumber, position.column + this.columnCount);\n\t\t} else {\n\t\t\treturn new Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `${this.lineCount},${this.columnCount}`;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2584, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/text/positionToOffsetImpl.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/text/positionToOffsetImpl.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/vs/editor/common/core/text/positionToOffsetImpl.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous } from '../../../../base/common/arraysFind.js';\nimport { StringEdit, StringReplacement } from '../edits/stringEdit.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextReplacement, TextEdit } from '../edits/textEdit.js';\nimport { TextLength } from '../text/textLength.js';\n\nexport abstract class PositionOffsetTransformerBase {\n\tabstract getOffset(position: Position): number;\n\n\tgetOffsetRange(range: Range): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.getOffset(range.getStartPosition()),\n\t\t\tthis.getOffset(range.getEndPosition())\n\t\t);\n\t}\n\n\tabstract getPosition(offset: number): Position;\n\n\tgetRange(offsetRange: OffsetRange): Range {\n\t\treturn Range.fromPositions(\n\t\t\tthis.getPosition(offsetRange.start),\n\t\t\tthis.getPosition(offsetRange.endExclusive)\n\t\t);\n\t}\n\n\tgetStringReplacement(edit: TextReplacement): StringReplacement {\n\t\treturn new Deps.deps.StringReplacement(this.getOffsetRange(edit.range), edit.text);\n\t}\n\n\tgetTextReplacement(edit: StringReplacement): TextReplacement {\n\t\treturn new Deps.deps.TextReplacement(this.getRange(edit.replaceRange), edit.newText);\n\t}\n\n\tgetTextEdit(edit: StringEdit): TextEdit {\n\t\tconst edits = edit.replacements.map(e => this.getTextReplacement(e));\n\t\treturn new Deps.deps.TextEdit(edits);\n\t}\n}\n\ninterface IDeps {\n\tStringEdit: typeof StringEdit;\n\tStringReplacement: typeof StringReplacement;\n\tTextReplacement: typeof TextReplacement;\n\tTextEdit: typeof TextEdit;\n\tTextLength: typeof TextLength;\n}\n\nclass Deps {\n\tstatic _deps: IDeps | undefined = undefined;\n\tstatic get deps(): IDeps {\n\t\tif (!this._deps) {\n\t\t\tthrow new Error('Dependencies not set. Call _setDependencies first.');\n\t\t}\n\t\treturn this._deps;\n\t}\n}\n\n/** This is to break circular module dependencies. */\nexport function _setPositionOffsetTransformerDependencies(deps: IDeps): void {\n\tDeps._deps = deps;\n}\n\nexport class PositionOffsetTransformer extends PositionOffsetTransformerBase {\n\tprivate readonly lineStartOffsetByLineIdx: number[];\n\tprivate readonly lineEndOffsetByLineIdx: number[];\n\n\tconstructor(public readonly text: string) {\n\t\tsuper();\n\n\t\tthis.lineStartOffsetByLineIdx = [];\n\t\tthis.lineEndOffsetByLineIdx = [];\n\n\t\tthis.lineStartOffsetByLineIdx.push(0);\n\t\tfor (let i = 0; i < text.length; i++) {\n\t\t\tif (text.charAt(i) === '\\n') {\n\t\t\t\tthis.lineStartOffsetByLineIdx.push(i + 1);\n\t\t\t\tif (i > 0 && text.charAt(i - 1) === '\\r') {\n\t\t\t\t\tthis.lineEndOffsetByLineIdx.push(i - 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lineEndOffsetByLineIdx.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.lineEndOffsetByLineIdx.push(text.length);\n\t}\n\n\toverride getOffset(position: Position): number {\n\t\tconst valPos = this._validatePosition(position);\n\t\treturn this.lineStartOffsetByLineIdx[valPos.lineNumber - 1] + valPos.column - 1;\n\t}\n\n\tprivate _validatePosition(position: Position): Position {\n\t\tif (position.lineNumber < 1) {\n\t\t\treturn new Position(1, 1);\n\t\t}\n\t\tconst lineCount = this.textLength.lineCount + 1;\n\t\tif (position.lineNumber > lineCount) {\n\t\t\tconst lineLength = this.getLineLength(lineCount);\n\t\t\treturn new Position(lineCount, lineLength + 1);\n\t\t}\n\t\tif (position.column < 1) {\n\t\t\treturn new Position(position.lineNumber, 1);\n\t\t}\n\t\tconst lineLength = this.getLineLength(position.lineNumber);\n\t\tif (position.column - 1 > lineLength) {\n\t\t\treturn new Position(position.lineNumber, lineLength + 1);\n\t\t}\n\t\treturn position;\n\t}\n\n\toverride getPosition(offset: number): Position {\n\t\tconst idx = findLastIdxMonotonous(this.lineStartOffsetByLineIdx, i => i <= offset);\n\t\tconst lineNumber = idx + 1;\n\t\tconst column = offset - this.lineStartOffsetByLineIdx[idx] + 1;\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tget textLength(): TextLength {\n\t\tconst lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n\t\treturn new Deps.deps.TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.lineEndOffsetByLineIdx[lineNumber - 1] - this.lineStartOffsetByLineIdx[lineNumber - 1];\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous } from '../../../../base/common/arraysFind.js';\nimport { StringEdit, StringReplacement } from '../edits/stringEdit.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextReplacement, TextEdit } from '../edits/textEdit.js';\nimport { TextLength } from '../text/textLength.js';\n\nexport abstract class PositionOffsetTransformerBase {\n\tabstract getOffset(position: Position): number;\n\n\tgetOffsetRange(range: Range): OffsetRange {\n\t\treturn new OffsetRange(\n\t\t\tthis.getOffset(range.getStartPosition()),\n\t\t\tthis.getOffset(range.getEndPosition())\n\t\t);\n\t}\n\n\tabstract getPosition(offset: number): Position;\n\n\tgetRange(offsetRange: OffsetRange): Range {\n\t\treturn Range.fromPositions(\n\t\t\tthis.getPosition(offsetRange.start),\n\t\t\tthis.getPosition(offsetRange.endExclusive)\n\t\t);\n\t}\n\n\tgetStringReplacement(edit: TextReplacement): StringReplacement {\n\t\treturn new Deps.deps.StringReplacement(this.getOffsetRange(edit.range), edit.text);\n\t}\n\n\tgetTextReplacement(edit: StringReplacement): TextReplacement {\n\t\treturn new Deps.deps.TextReplacement(this.getRange(edit.replaceRange), edit.newText);\n\t}\n\n\tgetTextEdit(edit: StringEdit): TextEdit {\n\t\tconst edits = edit.replacements.map(e => this.getTextReplacement(e));\n\t\treturn new Deps.deps.TextEdit(edits);\n\t}\n}\n\ninterface IDeps {\n\tStringEdit: typeof StringEdit;\n\tStringReplacement: typeof StringReplacement;\n\tTextReplacement: typeof TextReplacement;\n\tTextEdit: typeof TextEdit;\n\tTextLength: typeof TextLength;\n}\n\nclass Deps {\n\tstatic _deps: IDeps | undefined = undefined;\n\tstatic get deps(): IDeps {\n\t\tif (!this._deps) {\n\t\t\tthrow new Error('Dependencies not set. Call _setDependencies first.');\n\t\t}\n\t\treturn this._deps;\n\t}\n}\n\n/** This is to break circular module dependencies. */\nexport function _setPositionOffsetTransformerDependencies(deps: IDeps): void {\n\tDeps._deps = deps;\n}\n\nexport class PositionOffsetTransformer extends PositionOffsetTransformerBase {\n\tprivate readonly lineStartOffsetByLineIdx: number[];\n\tprivate readonly lineEndOffsetByLineIdx: number[];\n\n\tconstructor(public readonly text: string) {\n\t\tsuper();\n\n\t\tthis.lineStartOffsetByLineIdx = [];\n\t\tthis.lineEndOffsetByLineIdx = [];\n\n\t\tthis.lineStartOffsetByLineIdx.push(0);\n\t\tfor (let i = 0; i < text.length; i++) {\n\t\t\tif (text.charAt(i) === '\\n') {\n\t\t\t\tthis.lineStartOffsetByLineIdx.push(i + 1);\n\t\t\t\tif (i > 0 && text.charAt(i - 1) === '\\r') {\n\t\t\t\t\tthis.lineEndOffsetByLineIdx.push(i - 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lineEndOffsetByLineIdx.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.lineEndOffsetByLineIdx.push(text.length);\n\t}\n\n\toverride getOffset(position: Position): number {\n\t\tconst valPos = this._validatePosition(position);\n\t\treturn this.lineStartOffsetByLineIdx[valPos.lineNumber - 1] + valPos.column - 1;\n\t}\n\n\tprivate _validatePosition(position: Position): Position {\n\t\tif (position.lineNumber < 1) {\n\t\t\treturn new Position(1, 1);\n\t\t}\n\t\tconst lineCount = this.textLength.lineCount + 1;\n\t\tif (position.lineNumber > lineCount) {\n\t\t\tconst lineLength = this.getLineLength(lineCount);\n\t\t\treturn new Position(lineCount, lineLength + 1);\n\t\t}\n\t\tif (position.column < 1) {\n\t\t\treturn new Position(position.lineNumber, 1);\n\t\t}\n\t\tconst lineLength = this.getLineLength(position.lineNumber);\n\t\tif (position.column - 1 > lineLength) {\n\t\t\treturn new Position(position.lineNumber, lineLength + 1);\n\t\t}\n\t\treturn position;\n\t}\n\n\toverride getPosition(offset: number): Position {\n\t\tconst idx = findLastIdxMonotonous(this.lineStartOffsetByLineIdx, i => i <= offset);\n\t\tconst lineNumber = idx + 1;\n\t\tconst column = offset - this.lineStartOffsetByLineIdx[idx] + 1;\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tget textLength(): TextLength {\n\t\tconst lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n\t\treturn new Deps.deps.TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.lineEndOffsetByLineIdx[lineNumber - 1] - this.lineStartOffsetByLineIdx[lineNumber - 1];\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2694, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/text/abstractText.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/text/abstractText.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/vs/editor/common/core/text/abstractText.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from '../../../../base/common/assert.js';\nimport { Position } from '../position.js';\nimport { PositionOffsetTransformer } from './positionToOffsetImpl.js';\nimport { Range } from '../range.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { TextLength } from '../text/textLength.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\nexport abstract class AbstractText {\n\tabstract getValueOfRange(range: Range): string;\n\tabstract readonly length: TextLength;\n\n\tget endPositionExclusive(): Position {\n\t\treturn this.length.addToPosition(new Position(1, 1));\n\t}\n\n\tget lineRange(): LineRange {\n\t\treturn this.length.toLineRange();\n\t}\n\n\tgetValue(): string {\n\t\treturn this.getValueOfRange(this.length.toRange());\n\t}\n\n\tgetValueOfOffsetRange(range: OffsetRange): string {\n\t\treturn this.getValueOfRange(this.getTransformer().getRange(range));\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER)).length;\n\t}\n\n\tprivate _transformer: PositionOffsetTransformer | undefined = undefined;\n\n\tgetTransformer(): PositionOffsetTransformer {\n\t\tif (!this._transformer) {\n\t\t\tthis._transformer = new PositionOffsetTransformer(this.getValue());\n\t\t}\n\t\treturn this._transformer;\n\t}\n\n\tgetLineAt(lineNumber: number): string {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER));\n\t}\n}\n\nexport class LineBasedText extends AbstractText {\n\tconstructor(\n\t\tprivate readonly _getLineContent: (lineNumber: number) => string,\n\t\tprivate readonly _lineCount: number\n\t) {\n\t\tassert(_lineCount >= 1);\n\n\t\tsuper();\n\t}\n\n\toverride getValueOfRange(range: Range): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\t\tlet result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n\t\tfor (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n\t\t\tresult += '\\n' + this._getLineContent(i);\n\t\t}\n\t\tresult += '\\n' + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n\t\treturn result;\n\t}\n\n\toverride getLineLength(lineNumber: number): number {\n\t\treturn this._getLineContent(lineNumber).length;\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLine = this._getLineContent(this._lineCount);\n\t\treturn new TextLength(this._lineCount - 1, lastLine.length);\n\t}\n}\n\nexport class ArrayText extends LineBasedText {\n\tconstructor(lines: string[]) {\n\t\tsuper(\n\t\t\tlineNumber => lines[lineNumber - 1],\n\t\t\tlines.length\n\t\t);\n\t}\n}\n\nexport class StringText extends AbstractText {\n\tprivate readonly _t;\n\n\tconstructor(public readonly value: string) {\n\t\tsuper();\n\t\tthis._t = new PositionOffsetTransformer(this.value);\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\treturn this._t.getOffsetRange(range).substring(this.value);\n\t}\n\n\tget length(): TextLength {\n\t\treturn this._t.textLength;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assert } from '../../../../base/common/assert.js';\nimport { Position } from '../position.js';\nimport { PositionOffsetTransformer } from './positionToOffsetImpl.js';\nimport { Range } from '../range.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { TextLength } from '../text/textLength.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\n\nexport abstract class AbstractText {\n\tabstract getValueOfRange(range: Range): string;\n\tabstract readonly length: TextLength;\n\n\tget endPositionExclusive(): Position {\n\t\treturn this.length.addToPosition(new Position(1, 1));\n\t}\n\n\tget lineRange(): LineRange {\n\t\treturn this.length.toLineRange();\n\t}\n\n\tgetValue(): string {\n\t\treturn this.getValueOfRange(this.length.toRange());\n\t}\n\n\tgetValueOfOffsetRange(range: OffsetRange): string {\n\t\treturn this.getValueOfRange(this.getTransformer().getRange(range));\n\t}\n\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER)).length;\n\t}\n\n\tprivate _transformer: PositionOffsetTransformer | undefined = undefined;\n\n\tgetTransformer(): PositionOffsetTransformer {\n\t\tif (!this._transformer) {\n\t\t\tthis._transformer = new PositionOffsetTransformer(this.getValue());\n\t\t}\n\t\treturn this._transformer;\n\t}\n\n\tgetLineAt(lineNumber: number): string {\n\t\treturn this.getValueOfRange(new Range(lineNumber, 1, lineNumber, Number.MAX_SAFE_INTEGER));\n\t}\n}\n\nexport class LineBasedText extends AbstractText {\n\tconstructor(\n\t\tprivate readonly _getLineContent: (lineNumber: number) => string,\n\t\tprivate readonly _lineCount: number\n\t) {\n\t\tassert(_lineCount >= 1);\n\n\t\tsuper();\n\t}\n\n\toverride getValueOfRange(range: Range): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._getLineContent(range.startLineNumber).substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\t\tlet result = this._getLineContent(range.startLineNumber).substring(range.startColumn - 1);\n\t\tfor (let i = range.startLineNumber + 1; i < range.endLineNumber; i++) {\n\t\t\tresult += '\\n' + this._getLineContent(i);\n\t\t}\n\t\tresult += '\\n' + this._getLineContent(range.endLineNumber).substring(0, range.endColumn - 1);\n\t\treturn result;\n\t}\n\n\toverride getLineLength(lineNumber: number): number {\n\t\treturn this._getLineContent(lineNumber).length;\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLine = this._getLineContent(this._lineCount);\n\t\treturn new TextLength(this._lineCount - 1, lastLine.length);\n\t}\n}\n\nexport class ArrayText extends LineBasedText {\n\tconstructor(lines: string[]) {\n\t\tsuper(\n\t\t\tlineNumber => lines[lineNumber - 1],\n\t\t\tlines.length\n\t\t);\n\t}\n}\n\nexport class StringText extends AbstractText {\n\tprivate readonly _t;\n\n\tconstructor(public readonly value: string) {\n\t\tsuper();\n\t\tthis._t = new PositionOffsetTransformer(this.value);\n\t}\n\n\tgetValueOfRange(range: Range): string {\n\t\treturn this._t.getOffsetRange(range).substring(this.value);\n\t}\n\n\tget length(): TextLength {\n\t\treturn this._t.textLength;\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;AAEhG,OAAO,EAAE,MAAM,EAAE,MAAM,mCAAmC,CAAC;AAC3D,OAAO,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAC;AAC1C,OAAO,EAAE,yBAAyB,EAAE,MAAM,2BAA2B,CAAC;AACtE,OAAO,EAAE,KAAK,EAAE,MAAM,aAAa,CAAC;AAEpC,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;;;;;;AAG7C,MAAgB,YAAY;IAAlC,aAAA;QAwBS,IAAA,CAAA,YAAY,GAA0C,SAAS,CAAC;IAYzE,CAAC;IAhCA,IAAI,oBAAoB,GAAA;QACvB,OAAO,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,iMAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACtD,CAAC;IAED,IAAI,SAAS,GAAA;QACZ,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;IAClC,CAAC;IAED,QAAQ,GAAA;QACP,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC;IACpD,CAAC;IAED,qBAAqB,CAAC,KAAkB,EAAA;QACvC,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;IACpE,CAAC;IAED,aAAa,CAAC,UAAkB,EAAA;QAC/B,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,2LAAK,CAAC,UAAU,EAAE,CAAC,EAAE,UAAU,EAAE,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,MAAM,CAAC;IACnG,CAAC;IAID,cAAc,GAAA;QACb,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;YACxB,IAAI,CAAC,YAAY,GAAG,IAAI,sOAAyB,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QACpE,CAAC;QACD,OAAO,IAAI,CAAC,YAAY,CAAC;IAC1B,CAAC;IAED,SAAS,CAAC,UAAkB,EAAA;QAC3B,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,2LAAK,CAAC,UAAU,EAAE,CAAC,EAAE,UAAU,EAAE,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC;IAC5F,CAAC;CACD;AAEK,MAAO,aAAc,SAAQ,YAAY;IAC9C,YACkB,eAA+C,EAC/C,UAAkB,CAAA;YAEnC,mLAAM,EAAC,UAAU,IAAI,CAAC,CAAC,CAAC;QAExB,KAAK,EAAE,CAAC;QALS,IAAA,CAAA,eAAe,GAAf,eAAe,CAAgC;QAC/C,IAAA,CAAA,UAAU,GAAV,UAAU,CAAQ;IAKpC,CAAC;IAEQ,eAAe,CAAC,KAAY,EAAA;QACpC,IAAI,KAAK,CAAC,eAAe,KAAK,KAAK,CAAC,aAAa,EAAE,CAAC;YACnD,OAAO,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,EAAE,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;QAC1G,CAAC;QACD,IAAI,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;QAC1F,IAAK,IAAI,CAAC,GAAG,KAAK,CAAC,eAAe,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,aAAa,EAAE,CAAC,EAAE,CAAE,CAAC;YACtE,MAAM,IAAI,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;QAC1C,CAAC;QACD,MAAM,IAAI,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;QAC7F,OAAO,MAAM,CAAC;IACf,CAAC;IAEQ,aAAa,CAAC,UAAkB,EAAA;QACxC,OAAO,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC;IAChD,CAAC;IAED,IAAI,MAAM,GAAA;QACT,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACvD,OAAO,IAAI,6MAAU,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;IAC7D,CAAC;CACD;AAEK,MAAO,SAAU,SAAQ,aAAa;IAC3C,YAAY,KAAe,CAAA;QAC1B,KAAK,EACJ,UAAU,CAAC,EAAE,AAAC,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC,EACnC,KAAK,CAAC,MAAM,CACZ,CAAC;IACH,CAAC;CACD;AAEK,MAAO,UAAW,SAAQ,YAAY;IAG3C,YAA4B,KAAa,CAAA;QACxC,KAAK,EAAE,CAAC;QADmB,IAAA,CAAA,KAAK,GAAL,KAAK,CAAQ;QAExC,IAAI,CAAC,EAAE,GAAG,IAAI,sOAAyB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACrD,CAAC;IAED,eAAe,CAAC,KAAY,EAAA;QAC3B,OAAO,IAAI,CAAC,EAAE,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC5D,CAAC;IAED,IAAI,MAAM,GAAA;QACT,OAAO,IAAI,CAAC,EAAE,CAAC,UAAU,CAAC;IAC3B,CAAC;CACD","debugId":null}},
    {"offset": {"line": 2794, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/edits/textEdit.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/edits/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/edits/textEdit.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/edits/vs/editor/common/core/edits/textEdit.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { BaseStringEdit, StringReplacement } from './stringEdit.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextLength } from '../text/textLength.js';\nimport { AbstractText, StringText } from '../text/abstractText.js';\n\nexport class TextEdit {\n\tpublic static fromStringEdit(edit: BaseStringEdit, initialState: AbstractText): TextEdit {\n\t\tconst edits = edit.replacements.map(e => TextReplacement.fromStringReplacement(e, initialState));\n\t\treturn new TextEdit(edits);\n\t}\n\n\tpublic static fromParallelReplacementsUnsorted(replacements: readonly TextReplacement[]): TextEdit {\n\t\tconst r = replacements.slice().sort(compareBy(i => i.range, Range.compareRangesUsingStarts));\n\t\treturn new TextEdit(r);\n\t}\n\n\tconstructor(\n\t\tpublic readonly replacements: readonly TextReplacement[]\n\t) {\n\t\tassertFn(() => checkAdjacentItems(replacements, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n\t}\n\n\tmapPosition(position: Position): Position | Range {\n\t\tlet lineDelta = 0;\n\t\tlet curLine = 0;\n\t\tlet columnDeltaInCurLine = 0;\n\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst start = replacement.range.getStartPosition();\n\n\t\t\tif (position.isBeforeOrEqual(start)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst end = replacement.range.getEndPosition();\n\t\t\tconst len = TextLength.ofText(replacement.text);\n\t\t\tif (position.isBefore(end)) {\n\t\t\t\tconst startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t\t\t\tconst endPos = len.addToPosition(startPos);\n\t\t\t\treturn rangeFromPositions(startPos, endPos);\n\t\t\t}\n\n\t\t\tif (start.lineNumber + lineDelta !== curLine) {\n\t\t\t\tcolumnDeltaInCurLine = 0;\n\t\t\t}\n\n\t\t\tlineDelta += len.lineCount - (replacement.range.endLineNumber - replacement.range.startLineNumber);\n\n\t\t\tif (len.lineCount === 0) {\n\t\t\t\tif (end.lineNumber !== start.lineNumber) {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - start.column);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumnDeltaInCurLine = len.columnCount;\n\t\t\t}\n\t\t\tcurLine = end.lineNumber + lineDelta;\n\t\t}\n\n\t\treturn new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t}\n\n\tmapRange(range: Range): Range {\n\t\tfunction getStart(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getStartPosition();\n\t\t}\n\n\t\tfunction getEnd(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getEndPosition();\n\t\t}\n\n\t\tconst start = getStart(this.mapPosition(range.getStartPosition()));\n\t\tconst end = getEnd(this.mapPosition(range.getEndPosition()));\n\n\t\treturn rangeFromPositions(start, end);\n\t}\n\n\tapply(text: AbstractText): string {\n\t\tlet result = '';\n\t\tlet lastEditEnd = new Position(1, 1);\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst editRange = replacement.range;\n\t\t\tconst editStart = editRange.getStartPosition();\n\t\t\tconst editEnd = editRange.getEndPosition();\n\n\t\t\tconst r = rangeFromPositions(lastEditEnd, editStart);\n\t\t\tif (!r.isEmpty()) {\n\t\t\t\tresult += text.getValueOfRange(r);\n\t\t\t}\n\t\t\tresult += replacement.text;\n\t\t\tlastEditEnd = editEnd;\n\t\t}\n\t\tconst r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n\t\tif (!r.isEmpty()) {\n\t\t\tresult += text.getValueOfRange(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyToString(str: string): string {\n\t\tconst strText = new StringText(str);\n\t\treturn this.apply(strText);\n\t}\n\n\tgetNewRanges(): Range[] {\n\t\tconst newRanges: Range[] = [];\n\t\tlet previousEditEndLineNumber = 0;\n\t\tlet lineOffset = 0;\n\t\tlet columnOffset = 0;\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst textLength = TextLength.ofText(replacement.text);\n\t\t\tconst newRangeStart = Position.lift({\n\t\t\t\tlineNumber: replacement.range.startLineNumber + lineOffset,\n\t\t\t\tcolumn: replacement.range.startColumn + (replacement.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t\t});\n\t\t\tconst newRange = textLength.createRange(newRangeStart);\n\t\t\tnewRanges.push(newRange);\n\t\t\tlineOffset = newRange.endLineNumber - replacement.range.endLineNumber;\n\t\t\tcolumnOffset = newRange.endColumn - replacement.range.endColumn;\n\t\t\tpreviousEditEndLineNumber = replacement.range.endLineNumber;\n\t\t}\n\t\treturn newRanges;\n\t}\n\n\ttoReplacement(text: AbstractText): TextReplacement {\n\t\tif (this.replacements.length === 0) { throw new BugIndicatingError(); }\n\t\tif (this.replacements.length === 1) { return this.replacements[0]; }\n\n\t\tconst startPos = this.replacements[0].range.getStartPosition();\n\t\tconst endPos = this.replacements[this.replacements.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < this.replacements.length; i++) {\n\t\t\tconst curEdit = this.replacements[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < this.replacements.length - 1) {\n\t\t\t\tconst nextEdit = this.replacements[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = text.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\ttoString(text: AbstractText | string | undefined): string {\n\t\tif (text === undefined) {\n\t\t\treturn this.replacements.map(edit => edit.toString()).join('\\n');\n\t\t}\n\n\t\tif (typeof text === 'string') {\n\t\t\treturn this.toString(new StringText(text));\n\t\t}\n\n\t\tif (this.replacements.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.replacements.map(r => {\n\t\t\tconst maxLength = 10;\n\t\t\tconst originalText = text.getValueOfRange(r.range);\n\n\t\t\t// Get text before the edit\n\t\t\tconst beforeRange = Range.fromPositions(\n\t\t\t\tnew Position(Math.max(1, r.range.startLineNumber - 1), 1),\n\t\t\t\tr.range.getStartPosition()\n\t\t\t);\n\t\t\tlet beforeText = text.getValueOfRange(beforeRange);\n\t\t\tif (beforeText.length > maxLength) {\n\t\t\t\tbeforeText = '...' + beforeText.substring(beforeText.length - maxLength);\n\t\t\t}\n\n\t\t\t// Get text after the edit\n\t\t\tconst afterRange = Range.fromPositions(\n\t\t\t\tr.range.getEndPosition(),\n\t\t\t\tnew Position(r.range.endLineNumber + 1, 1)\n\t\t\t);\n\t\t\tlet afterText = text.getValueOfRange(afterRange);\n\t\t\tif (afterText.length > maxLength) {\n\t\t\t\tafterText = afterText.substring(0, maxLength) + '...';\n\t\t\t}\n\n\t\t\t// Format the replaced text\n\t\t\tlet replacedText = originalText;\n\t\t\tif (replacedText.length > maxLength) {\n\t\t\t\tconst halfMax = Math.floor(maxLength / 2);\n\t\t\t\treplacedText = replacedText.substring(0, halfMax) + '...' +\n\t\t\t\t\treplacedText.substring(replacedText.length - halfMax);\n\t\t\t}\n\n\t\t\t// Format the new text\n\t\t\tlet newText = r.text;\n\t\t\tif (newText.length > maxLength) {\n\t\t\t\tconst halfMax = Math.floor(maxLength / 2);\n\t\t\t\tnewText = newText.substring(0, halfMax) + '...' +\n\t\t\t\t\tnewText.substring(newText.length - halfMax);\n\t\t\t}\n\n\t\t\tif (replacedText.length === 0) {\n\t\t\t\t// allow-any-unicode-next-line\n\t\t\t\treturn `${beforeText}${newText}${afterText}`;\n\t\t\t}\n\t\t\t// allow-any-unicode-next-line\n\t\t\treturn `${beforeText}${replacedText}${newText}${afterText}`;\n\t\t}).join('\\n');\n\t}\n}\n\nexport class TextReplacement {\n\tpublic static joinReplacements(replacements: TextReplacement[], initialValue: AbstractText): TextReplacement {\n\t\tif (replacements.length === 0) { throw new BugIndicatingError(); }\n\t\tif (replacements.length === 1) { return replacements[0]; }\n\n\t\tconst startPos = replacements[0].range.getStartPosition();\n\t\tconst endPos = replacements[replacements.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < replacements.length; i++) {\n\t\t\tconst curEdit = replacements[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < replacements.length - 1) {\n\t\t\t\tconst nextEdit = replacements[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = initialValue.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tpublic static fromStringReplacement(replacement: StringReplacement, initialState: AbstractText): TextReplacement {\n\t\treturn new TextReplacement(initialState.getTransformer().getRange(replacement.replaceRange), replacement.newText);\n\t}\n\n\tpublic static delete(range: Range): TextReplacement {\n\t\treturn new TextReplacement(range, '');\n\t}\n\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string,\n\t) {\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.range.isEmpty() && this.text.length === 0;\n\t}\n\n\tstatic equals(first: TextReplacement, second: TextReplacement) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\t}\n\n\tpublic equals(other: TextReplacement): boolean {\n\t\treturn TextReplacement.equals(this, other);\n\t}\n\n\tpublic removeCommonPrefixAndSuffix(text: AbstractText): TextReplacement {\n\t\tconst prefix = this.removeCommonPrefix(text);\n\t\tconst suffix = prefix.removeCommonSuffix(text);\n\t\treturn suffix;\n\t}\n\n\tpublic removeCommonPrefix(text: AbstractText): TextReplacement {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonPrefixLen = commonPrefixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst start = TextLength.ofText(normalizedOriginalText.substring(0, commonPrefixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new TextReplacement(range, newText);\n\t}\n\n\tpublic removeCommonSuffix(text: AbstractText): TextReplacement {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonSuffixLen = commonSuffixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst end = TextLength.ofText(normalizedOriginalText.substring(0, normalizedOriginalText.length - commonSuffixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(0, normalizedModifiedText.length - commonSuffixLen);\n\t\tconst range = Range.fromPositions(this.range.getStartPosition(), end);\n\t\treturn new TextReplacement(range, newText);\n\t}\n\n\tpublic toString(): string {\n\t\tconst start = this.range.getStartPosition();\n\t\tconst end = this.range.getEndPosition();\n\t\treturn `(${start.lineNumber},${start.column} -> ${end.lineNumber},${end.column}): \"${this.text}\"`;\n\t}\n}\n\nfunction rangeFromPositions(start: Position, end: Position): Range {\n\tif (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n\t\treturn Range.fromPositions(end, end);\n\t} else if (!start.isBeforeOrEqual(end)) {\n\t\tthrow new BugIndicatingError('start must be before end');\n\t}\n\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { commonPrefixLength, commonSuffixLength } from '../../../../base/common/strings.js';\nimport { BaseStringEdit, StringReplacement } from './stringEdit.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextLength } from '../text/textLength.js';\nimport { AbstractText, StringText } from '../text/abstractText.js';\n\nexport class TextEdit {\n\tpublic static fromStringEdit(edit: BaseStringEdit, initialState: AbstractText): TextEdit {\n\t\tconst edits = edit.replacements.map(e => TextReplacement.fromStringReplacement(e, initialState));\n\t\treturn new TextEdit(edits);\n\t}\n\n\tpublic static fromParallelReplacementsUnsorted(replacements: readonly TextReplacement[]): TextEdit {\n\t\tconst r = replacements.slice().sort(compareBy(i => i.range, Range.compareRangesUsingStarts));\n\t\treturn new TextEdit(r);\n\t}\n\n\tconstructor(\n\t\tpublic readonly replacements: readonly TextReplacement[]\n\t) {\n\t\tassertFn(() => checkAdjacentItems(replacements, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n\t}\n\n\tmapPosition(position: Position): Position | Range {\n\t\tlet lineDelta = 0;\n\t\tlet curLine = 0;\n\t\tlet columnDeltaInCurLine = 0;\n\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst start = replacement.range.getStartPosition();\n\n\t\t\tif (position.isBeforeOrEqual(start)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst end = replacement.range.getEndPosition();\n\t\t\tconst len = TextLength.ofText(replacement.text);\n\t\t\tif (position.isBefore(end)) {\n\t\t\t\tconst startPos = new Position(start.lineNumber + lineDelta, start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t\t\t\tconst endPos = len.addToPosition(startPos);\n\t\t\t\treturn rangeFromPositions(startPos, endPos);\n\t\t\t}\n\n\t\t\tif (start.lineNumber + lineDelta !== curLine) {\n\t\t\t\tcolumnDeltaInCurLine = 0;\n\t\t\t}\n\n\t\t\tlineDelta += len.lineCount - (replacement.range.endLineNumber - replacement.range.startLineNumber);\n\n\t\t\tif (len.lineCount === 0) {\n\t\t\t\tif (end.lineNumber !== start.lineNumber) {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcolumnDeltaInCurLine += len.columnCount - (end.column - start.column);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumnDeltaInCurLine = len.columnCount;\n\t\t\t}\n\t\t\tcurLine = end.lineNumber + lineDelta;\n\t\t}\n\n\t\treturn new Position(position.lineNumber + lineDelta, position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0));\n\t}\n\n\tmapRange(range: Range): Range {\n\t\tfunction getStart(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getStartPosition();\n\t\t}\n\n\t\tfunction getEnd(p: Position | Range) {\n\t\t\treturn p instanceof Position ? p : p.getEndPosition();\n\t\t}\n\n\t\tconst start = getStart(this.mapPosition(range.getStartPosition()));\n\t\tconst end = getEnd(this.mapPosition(range.getEndPosition()));\n\n\t\treturn rangeFromPositions(start, end);\n\t}\n\n\tapply(text: AbstractText): string {\n\t\tlet result = '';\n\t\tlet lastEditEnd = new Position(1, 1);\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst editRange = replacement.range;\n\t\t\tconst editStart = editRange.getStartPosition();\n\t\t\tconst editEnd = editRange.getEndPosition();\n\n\t\t\tconst r = rangeFromPositions(lastEditEnd, editStart);\n\t\t\tif (!r.isEmpty()) {\n\t\t\t\tresult += text.getValueOfRange(r);\n\t\t\t}\n\t\t\tresult += replacement.text;\n\t\t\tlastEditEnd = editEnd;\n\t\t}\n\t\tconst r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n\t\tif (!r.isEmpty()) {\n\t\t\tresult += text.getValueOfRange(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyToString(str: string): string {\n\t\tconst strText = new StringText(str);\n\t\treturn this.apply(strText);\n\t}\n\n\tgetNewRanges(): Range[] {\n\t\tconst newRanges: Range[] = [];\n\t\tlet previousEditEndLineNumber = 0;\n\t\tlet lineOffset = 0;\n\t\tlet columnOffset = 0;\n\t\tfor (const replacement of this.replacements) {\n\t\t\tconst textLength = TextLength.ofText(replacement.text);\n\t\t\tconst newRangeStart = Position.lift({\n\t\t\t\tlineNumber: replacement.range.startLineNumber + lineOffset,\n\t\t\t\tcolumn: replacement.range.startColumn + (replacement.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n\t\t\t});\n\t\t\tconst newRange = textLength.createRange(newRangeStart);\n\t\t\tnewRanges.push(newRange);\n\t\t\tlineOffset = newRange.endLineNumber - replacement.range.endLineNumber;\n\t\t\tcolumnOffset = newRange.endColumn - replacement.range.endColumn;\n\t\t\tpreviousEditEndLineNumber = replacement.range.endLineNumber;\n\t\t}\n\t\treturn newRanges;\n\t}\n\n\ttoReplacement(text: AbstractText): TextReplacement {\n\t\tif (this.replacements.length === 0) { throw new BugIndicatingError(); }\n\t\tif (this.replacements.length === 1) { return this.replacements[0]; }\n\n\t\tconst startPos = this.replacements[0].range.getStartPosition();\n\t\tconst endPos = this.replacements[this.replacements.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < this.replacements.length; i++) {\n\t\t\tconst curEdit = this.replacements[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < this.replacements.length - 1) {\n\t\t\t\tconst nextEdit = this.replacements[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = text.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\ttoString(text: AbstractText | string | undefined): string {\n\t\tif (text === undefined) {\n\t\t\treturn this.replacements.map(edit => edit.toString()).join('\\n');\n\t\t}\n\n\t\tif (typeof text === 'string') {\n\t\t\treturn this.toString(new StringText(text));\n\t\t}\n\n\t\tif (this.replacements.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.replacements.map(r => {\n\t\t\tconst maxLength = 10;\n\t\t\tconst originalText = text.getValueOfRange(r.range);\n\n\t\t\t// Get text before the edit\n\t\t\tconst beforeRange = Range.fromPositions(\n\t\t\t\tnew Position(Math.max(1, r.range.startLineNumber - 1), 1),\n\t\t\t\tr.range.getStartPosition()\n\t\t\t);\n\t\t\tlet beforeText = text.getValueOfRange(beforeRange);\n\t\t\tif (beforeText.length > maxLength) {\n\t\t\t\tbeforeText = '...' + beforeText.substring(beforeText.length - maxLength);\n\t\t\t}\n\n\t\t\t// Get text after the edit\n\t\t\tconst afterRange = Range.fromPositions(\n\t\t\t\tr.range.getEndPosition(),\n\t\t\t\tnew Position(r.range.endLineNumber + 1, 1)\n\t\t\t);\n\t\t\tlet afterText = text.getValueOfRange(afterRange);\n\t\t\tif (afterText.length > maxLength) {\n\t\t\t\tafterText = afterText.substring(0, maxLength) + '...';\n\t\t\t}\n\n\t\t\t// Format the replaced text\n\t\t\tlet replacedText = originalText;\n\t\t\tif (replacedText.length > maxLength) {\n\t\t\t\tconst halfMax = Math.floor(maxLength / 2);\n\t\t\t\treplacedText = replacedText.substring(0, halfMax) + '...' +\n\t\t\t\t\treplacedText.substring(replacedText.length - halfMax);\n\t\t\t}\n\n\t\t\t// Format the new text\n\t\t\tlet newText = r.text;\n\t\t\tif (newText.length > maxLength) {\n\t\t\t\tconst halfMax = Math.floor(maxLength / 2);\n\t\t\t\tnewText = newText.substring(0, halfMax) + '...' +\n\t\t\t\t\tnewText.substring(newText.length - halfMax);\n\t\t\t}\n\n\t\t\tif (replacedText.length === 0) {\n\t\t\t\t// allow-any-unicode-next-line\n\t\t\t\treturn `${beforeText}${newText}${afterText}`;\n\t\t\t}\n\t\t\t// allow-any-unicode-next-line\n\t\t\treturn `${beforeText}${replacedText}${newText}${afterText}`;\n\t\t}).join('\\n');\n\t}\n}\n\nexport class TextReplacement {\n\tpublic static joinReplacements(replacements: TextReplacement[], initialValue: AbstractText): TextReplacement {\n\t\tif (replacements.length === 0) { throw new BugIndicatingError(); }\n\t\tif (replacements.length === 1) { return replacements[0]; }\n\n\t\tconst startPos = replacements[0].range.getStartPosition();\n\t\tconst endPos = replacements[replacements.length - 1].range.getEndPosition();\n\n\t\tlet newText = '';\n\n\t\tfor (let i = 0; i < replacements.length; i++) {\n\t\t\tconst curEdit = replacements[i];\n\t\t\tnewText += curEdit.text;\n\t\t\tif (i < replacements.length - 1) {\n\t\t\t\tconst nextEdit = replacements[i + 1];\n\t\t\t\tconst gapRange = Range.fromPositions(curEdit.range.getEndPosition(), nextEdit.range.getStartPosition());\n\t\t\t\tconst gapText = initialValue.getValueOfRange(gapRange);\n\t\t\t\tnewText += gapText;\n\t\t\t}\n\t\t}\n\t\treturn new TextReplacement(Range.fromPositions(startPos, endPos), newText);\n\t}\n\n\tpublic static fromStringReplacement(replacement: StringReplacement, initialState: AbstractText): TextReplacement {\n\t\treturn new TextReplacement(initialState.getTransformer().getRange(replacement.replaceRange), replacement.newText);\n\t}\n\n\tpublic static delete(range: Range): TextReplacement {\n\t\treturn new TextReplacement(range, '');\n\t}\n\n\tconstructor(\n\t\tpublic readonly range: Range,\n\t\tpublic readonly text: string,\n\t) {\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.range.isEmpty() && this.text.length === 0;\n\t}\n\n\tstatic equals(first: TextReplacement, second: TextReplacement) {\n\t\treturn first.range.equalsRange(second.range) && first.text === second.text;\n\t}\n\n\tpublic equals(other: TextReplacement): boolean {\n\t\treturn TextReplacement.equals(this, other);\n\t}\n\n\tpublic removeCommonPrefixAndSuffix(text: AbstractText): TextReplacement {\n\t\tconst prefix = this.removeCommonPrefix(text);\n\t\tconst suffix = prefix.removeCommonSuffix(text);\n\t\treturn suffix;\n\t}\n\n\tpublic removeCommonPrefix(text: AbstractText): TextReplacement {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonPrefixLen = commonPrefixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst start = TextLength.ofText(normalizedOriginalText.substring(0, commonPrefixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(commonPrefixLen);\n\t\tconst range = Range.fromPositions(start, this.range.getEndPosition());\n\t\treturn new TextReplacement(range, newText);\n\t}\n\n\tpublic removeCommonSuffix(text: AbstractText): TextReplacement {\n\t\tconst normalizedOriginalText = text.getValueOfRange(this.range).replaceAll('\\r\\n', '\\n');\n\t\tconst normalizedModifiedText = this.text.replaceAll('\\r\\n', '\\n');\n\n\t\tconst commonSuffixLen = commonSuffixLength(normalizedOriginalText, normalizedModifiedText);\n\t\tconst end = TextLength.ofText(normalizedOriginalText.substring(0, normalizedOriginalText.length - commonSuffixLen))\n\t\t\t.addToPosition(this.range.getStartPosition());\n\n\t\tconst newText = normalizedModifiedText.substring(0, normalizedModifiedText.length - commonSuffixLen);\n\t\tconst range = Range.fromPositions(this.range.getStartPosition(), end);\n\t\treturn new TextReplacement(range, newText);\n\t}\n\n\tpublic toString(): string {\n\t\tconst start = this.range.getStartPosition();\n\t\tconst end = this.range.getEndPosition();\n\t\treturn `(${start.lineNumber},${start.column} -> ${end.lineNumber},${end.column}): \"${this.text}\"`;\n\t}\n}\n\nfunction rangeFromPositions(start: Position, end: Position): Range {\n\tif (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n\t\treturn Range.fromPositions(end, end);\n\t} else if (!start.isBeforeOrEqual(end)) {\n\t\tthrow new BugIndicatingError('start must be before end');\n\t}\n\treturn new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3070, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/text/positionToOffset.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/text/positionToOffset.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/vs/editor/common/core/text/positionToOffset.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { StringEdit, StringReplacement } from '../edits/stringEdit.js';\nimport { TextEdit, TextReplacement } from '../edits/textEdit.js';\nimport { _setPositionOffsetTransformerDependencies } from './positionToOffsetImpl.js';\nimport { TextLength } from './textLength.js';\n\nexport { PositionOffsetTransformerBase, PositionOffsetTransformer } from './positionToOffsetImpl.js';\n\n_setPositionOffsetTransformerDependencies({\n\tStringEdit: StringEdit,\n\tStringReplacement: StringReplacement,\n\tTextReplacement: TextReplacement,\n\tTextEdit: TextEdit,\n\tTextLength: TextLength,\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { StringEdit, StringReplacement } from '../edits/stringEdit.js';\nimport { TextEdit, TextReplacement } from '../edits/textEdit.js';\nimport { _setPositionOffsetTransformerDependencies } from './positionToOffsetImpl.js';\nimport { TextLength } from './textLength.js';\n\nexport { PositionOffsetTransformerBase, PositionOffsetTransformer } from './positionToOffsetImpl.js';\n\n_setPositionOffsetTransformerDependencies({\n\tStringEdit: StringEdit,\n\tStringReplacement: StringReplacement,\n\tTextReplacement: TextReplacement,\n\tTextEdit: TextEdit,\n\tTextLength: TextLength,\n});\n"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,UAAU,EAAE,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;AACvE,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAC;AACjE,OAAO,EAAE,yCAAyC,EAAE,MAAM,2BAA2B,CAAC;AACtF,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;;;;;;IAI7C,sPAAyC,EAAC;IACzC,UAAU,EAAE,8MAAU;IACtB,iBAAiB,EAAE,qNAAiB;IACpC,eAAe,EAAE,iNAAe;IAChC,QAAQ,EAAE,0MAAQ;IAClB,UAAU,EAAE,6MAAU;CACtB,CAAC,CAAC","debugId":null}},
    {"offset": {"line": 3094, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/misc/eolCounter.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/misc/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/misc/eolCounter.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/misc/vs/editor/common/core/misc/eolCounter.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\n\nexport const enum StringEOL {\n\tUnknown = 0,\n\tInvalid = 3,\n\tLF = 1,\n\tCRLF = 2\n}\n\nexport function countEOL(text: string): [number, number, number, StringEOL] {\n\tlet eolCount = 0;\n\tlet firstLineLength = 0;\n\tlet lastLineStart = 0;\n\tlet eol: StringEOL = StringEOL.Unknown;\n\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\tconst chr = text.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\teol |= StringEOL.CRLF;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\teol |= StringEOL.Invalid;\n\t\t\t}\n\t\t\tlastLineStart = i + 1;\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t// \\n... case\n\t\t\teol |= StringEOL.LF;\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tlastLineStart = i + 1;\n\t\t}\n\t}\n\tif (eolCount === 0) {\n\t\tfirstLineLength = text.length;\n\t}\n\treturn [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\n\nexport const enum StringEOL {\n\tUnknown = 0,\n\tInvalid = 3,\n\tLF = 1,\n\tCRLF = 2\n}\n\nexport function countEOL(text: string): [number, number, number, StringEOL] {\n\tlet eolCount = 0;\n\tlet firstLineLength = 0;\n\tlet lastLineStart = 0;\n\tlet eol: StringEOL = StringEOL.Unknown;\n\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\tconst chr = text.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\teol |= StringEOL.CRLF;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\teol |= StringEOL.Invalid;\n\t\t\t}\n\t\t\tlastLineStart = i + 1;\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t// \\n... case\n\t\t\teol |= StringEOL.LF;\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tlastLineStart = i + 1;\n\t\t}\n\t}\n\tif (eolCount === 0) {\n\t\tfirstLineLength = text.length;\n\t}\n\treturn [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAW1F,SAAU,QAAQ,CAAC,IAAY;IACpC,IAAI,QAAQ,GAAG,CAAC,CAAC;IACjB,IAAI,eAAe,GAAG,CAAC,CAAC;IACxB,IAAI,aAAa,GAAG,CAAC,CAAC;IACtB,IAAI,GAAG,GAAA,EAAA,qBAAA,EAA+B,CAAC;IACvC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,CAAE,CAAC;QACjD,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAE/B,IAAI,GAAG,KAAA,GAAA,2BAAA,EAA4B,GAAE,CAAC;YACrC,IAAI,QAAQ,KAAK,CAAC,EAAE,CAAC;gBACpB,eAAe,GAAG,CAAC,CAAC;YACrB,CAAC;YACD,QAAQ,EAAE,CAAC;YACX,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,KAAA,GAAA,qBAAA,EAAsB,GAAE,CAAC;gBACjE,eAAe;gBACf,GAAG,IAAA,EAAA,kBAAA,EAAkB,CAAC;gBACtB,CAAC,EAAE,CAAC,CAAC,UAAU;YAChB,CAAC,MAAM,CAAC;gBACP,aAAa;gBACb,GAAG,IAAA,EAAA,qBAAA,EAAqB,CAAC;YAC1B,CAAC;YACD,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC,MAAM,IAAI,GAAG,KAAA,GAAA,qBAAA,EAAsB,GAAE,CAAC;YACtC,aAAa;YACb,GAAG,IAAA,EAAA,gBAAA,EAAgB,CAAC;YACpB,IAAI,QAAQ,KAAK,CAAC,EAAE,CAAC;gBACpB,eAAe,GAAG,CAAC,CAAC;YACrB,CAAC;YACD,QAAQ,EAAE,CAAC;YACX,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC;IACF,CAAC;IACD,IAAI,QAAQ,KAAK,CAAC,EAAE,CAAC;QACpB,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC;IAC/B,CAAC;IACD,OAAO;QAAC,QAAQ;QAAE,eAAe;QAAE,IAAI,CAAC,MAAM,GAAG,aAAa;QAAE,GAAG;KAAC,CAAC;AACtE,CAAC","debugId":null}},
    {"offset": {"line": 3146, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/textChange.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/textChange.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\n\nfunction escapeNewLine(str: string): string {\n\treturn (\n\t\tstr\n\t\t\t.replace(/\\n/g, '\\\\n')\n\t\t\t.replace(/\\r/g, '\\\\r')\n\t);\n}\n\nexport class TextChange {\n\n\tpublic get oldLength(): number {\n\t\treturn this.oldText.length;\n\t}\n\n\tpublic get oldEnd(): number {\n\t\treturn this.oldPosition + this.oldText.length;\n\t}\n\n\tpublic get newLength(): number {\n\t\treturn this.newText.length;\n\t}\n\n\tpublic get newEnd(): number {\n\t\treturn this.newPosition + this.newText.length;\n\t}\n\n\tconstructor(\n\t\tpublic readonly oldPosition: number,\n\t\tpublic readonly oldText: string,\n\t\tpublic readonly newPosition: number,\n\t\tpublic readonly newText: string\n\t) { }\n\n\tpublic toString(): string {\n\t\tif (this.oldText.length === 0) {\n\t\t\treturn `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n\t\t}\n\t\tif (this.newText.length === 0) {\n\t\t\treturn `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n\t\t}\n\t\treturn `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n\t}\n\n\tprivate static _writeStringSize(str: string): number {\n\t\treturn (\n\t\t\t4 + 2 * str.length\n\t\t);\n\t}\n\n\tprivate static _writeString(b: Uint8Array, str: string, offset: number): number {\n\t\tconst len = str.length;\n\t\tbuffer.writeUInt32BE(b, len, offset); offset += 4;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tbuffer.writeUInt16LE(b, str.charCodeAt(i), offset); offset += 2;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tprivate static _readString(b: Uint8Array, offset: number): string {\n\t\tconst len = buffer.readUInt32BE(b, offset); offset += 4;\n\t\treturn decodeUTF16LE(b, offset, len);\n\t}\n\n\tpublic writeSize(): number {\n\t\treturn (\n\t\t\t+ 4 // oldPosition\n\t\t\t+ 4 // newPosition\n\t\t\t+ TextChange._writeStringSize(this.oldText)\n\t\t\t+ TextChange._writeStringSize(this.newText)\n\t\t);\n\t}\n\n\tpublic write(b: Uint8Array, offset: number): number {\n\t\tbuffer.writeUInt32BE(b, this.oldPosition, offset); offset += 4;\n\t\tbuffer.writeUInt32BE(b, this.newPosition, offset); offset += 4;\n\t\toffset = TextChange._writeString(b, this.oldText, offset);\n\t\toffset = TextChange._writeString(b, this.newText, offset);\n\t\treturn offset;\n\t}\n\n\tpublic static read(b: Uint8Array, offset: number, dest: TextChange[]): number {\n\t\tconst oldPosition = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst newPosition = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst oldText = TextChange._readString(b, offset); offset += TextChange._writeStringSize(oldText);\n\t\tconst newText = TextChange._readString(b, offset); offset += TextChange._writeStringSize(newText);\n\t\tdest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n\t\treturn offset;\n\t}\n}\n\nexport function compressConsecutiveTextChanges(prevEdits: TextChange[] | null, currEdits: TextChange[]): TextChange[] {\n\tif (prevEdits === null || prevEdits.length === 0) {\n\t\treturn currEdits;\n\t}\n\tconst compressor = new TextChangeCompressor(prevEdits, currEdits);\n\treturn compressor.compress();\n}\n\nclass TextChangeCompressor {\n\n\tprivate _prevEdits: TextChange[];\n\tprivate _currEdits: TextChange[];\n\n\tprivate _result: TextChange[];\n\tprivate _resultLen: number;\n\n\tprivate _prevLen: number;\n\tprivate _prevDeltaOffset: number;\n\n\tprivate _currLen: number;\n\tprivate _currDeltaOffset: number;\n\n\tconstructor(prevEdits: TextChange[], currEdits: TextChange[]) {\n\t\tthis._prevEdits = prevEdits;\n\t\tthis._currEdits = currEdits;\n\n\t\tthis._result = [];\n\t\tthis._resultLen = 0;\n\n\t\tthis._prevLen = this._prevEdits.length;\n\t\tthis._prevDeltaOffset = 0;\n\n\t\tthis._currLen = this._currEdits.length;\n\t\tthis._currDeltaOffset = 0;\n\t}\n\n\tpublic compress(): TextChange[] {\n\t\tlet prevIndex = 0;\n\t\tlet currIndex = 0;\n\n\t\tlet prevEdit = this._getPrev(prevIndex);\n\t\tlet currEdit = this._getCurr(currIndex);\n\n\t\twhile (prevIndex < this._prevLen || currIndex < this._currLen) {\n\n\t\t\tif (prevEdit === null) {\n\t\t\t\tthis._acceptCurr(currEdit!);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit === null) {\n\t\t\t\tthis._acceptPrev(prevEdit);\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit.oldEnd <= prevEdit.newPosition) {\n\t\t\t\tthis._acceptCurr(currEdit);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (prevEdit.newEnd <= currEdit.oldPosition) {\n\t\t\t\tthis._acceptPrev(prevEdit);\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit.oldPosition < prevEdit.newPosition) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n\t\t\t\tthis._acceptCurr(e1);\n\t\t\t\tcurrEdit = e2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (prevEdit.newPosition < currEdit.oldPosition) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n\t\t\t\tthis._acceptPrev(e1);\n\t\t\t\tprevEdit = e2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// At this point, currEdit.oldPosition === prevEdit.newPosition\n\n\t\t\tlet mergePrev: TextChange;\n\t\t\tlet mergeCurr: TextChange;\n\n\t\t\tif (currEdit.oldEnd === prevEdit.newEnd) {\n\t\t\t\tmergePrev = prevEdit;\n\t\t\t\tmergeCurr = currEdit;\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t} else if (currEdit.oldEnd < prevEdit.newEnd) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n\t\t\t\tmergePrev = e1;\n\t\t\t\tmergeCurr = currEdit;\n\t\t\t\tprevEdit = e2;\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t} else {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n\t\t\t\tmergePrev = prevEdit;\n\t\t\t\tmergeCurr = e1;\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcurrEdit = e2;\n\t\t\t}\n\n\t\t\tthis._result[this._resultLen++] = new TextChange(\n\t\t\t\tmergePrev.oldPosition,\n\t\t\t\tmergePrev.oldText,\n\t\t\t\tmergeCurr.newPosition,\n\t\t\t\tmergeCurr.newText\n\t\t\t);\n\t\t\tthis._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n\t\t\tthis._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n\t\t}\n\n\t\tconst merged = TextChangeCompressor._merge(this._result);\n\t\tconst cleaned = TextChangeCompressor._removeNoOps(merged);\n\t\treturn cleaned;\n\t}\n\n\tprivate _acceptCurr(currEdit: TextChange): void {\n\t\tthis._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n\t\tthis._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n\t}\n\n\tprivate _getCurr(currIndex: number): TextChange | null {\n\t\treturn (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n\t}\n\n\tprivate _acceptPrev(prevEdit: TextChange): void {\n\t\tthis._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n\t\tthis._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n\t}\n\n\tprivate _getPrev(prevIndex: number): TextChange | null {\n\t\treturn (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n\t}\n\n\tprivate static _rebaseCurr(prevDeltaOffset: number, currEdit: TextChange): TextChange {\n\t\treturn new TextChange(\n\t\t\tcurrEdit.oldPosition - prevDeltaOffset,\n\t\t\tcurrEdit.oldText,\n\t\t\tcurrEdit.newPosition,\n\t\t\tcurrEdit.newText\n\t\t);\n\t}\n\n\tprivate static _rebasePrev(currDeltaOffset: number, prevEdit: TextChange): TextChange {\n\t\treturn new TextChange(\n\t\t\tprevEdit.oldPosition,\n\t\t\tprevEdit.oldText,\n\t\t\tprevEdit.newPosition + currDeltaOffset,\n\t\t\tprevEdit.newText\n\t\t);\n\t}\n\n\tprivate static _splitPrev(edit: TextChange, offset: number): [TextChange, TextChange] {\n\t\tconst preText = edit.newText.substr(0, offset);\n\t\tconst postText = edit.newText.substr(offset);\n\n\t\treturn [\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition,\n\t\t\t\tedit.oldText,\n\t\t\t\tedit.newPosition,\n\t\t\t\tpreText\n\t\t\t),\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldEnd,\n\t\t\t\t'',\n\t\t\t\tedit.newPosition + offset,\n\t\t\t\tpostText\n\t\t\t)\n\t\t];\n\t}\n\n\tprivate static _splitCurr(edit: TextChange, offset: number): [TextChange, TextChange] {\n\t\tconst preText = edit.oldText.substr(0, offset);\n\t\tconst postText = edit.oldText.substr(offset);\n\n\t\treturn [\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition,\n\t\t\t\tpreText,\n\t\t\t\tedit.newPosition,\n\t\t\t\tedit.newText\n\t\t\t),\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition + offset,\n\t\t\t\tpostText,\n\t\t\t\tedit.newEnd,\n\t\t\t\t''\n\t\t\t)\n\t\t];\n\t}\n\n\tprivate static _merge(edits: TextChange[]): TextChange[] {\n\t\tif (edits.length === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextChange[] = [];\n\t\tlet resultLen = 0;\n\n\t\tlet prev = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tconst curr = edits[i];\n\n\t\t\tif (prev.oldEnd === curr.oldPosition) {\n\t\t\t\t// Merge into `prev`\n\t\t\t\tprev = new TextChange(\n\t\t\t\t\tprev.oldPosition,\n\t\t\t\t\tprev.oldText + curr.oldText,\n\t\t\t\t\tprev.newPosition,\n\t\t\t\t\tprev.newText + curr.newText\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = prev;\n\t\t\t\tprev = curr;\n\t\t\t}\n\t\t}\n\t\tresult[resultLen++] = prev;\n\n\t\treturn result;\n\t}\n\n\tprivate static _removeNoOps(edits: TextChange[]): TextChange[] {\n\t\tif (edits.length === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextChange[] = [];\n\t\tlet resultLen = 0;\n\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst edit = edits[i];\n\n\t\t\tif (edit.oldText === edit.newText) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult[resultLen++] = edit;\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\n\nfunction escapeNewLine(str: string): string {\n\treturn (\n\t\tstr\n\t\t\t.replace(/\\n/g, '\\\\n')\n\t\t\t.replace(/\\r/g, '\\\\r')\n\t);\n}\n\nexport class TextChange {\n\n\tpublic get oldLength(): number {\n\t\treturn this.oldText.length;\n\t}\n\n\tpublic get oldEnd(): number {\n\t\treturn this.oldPosition + this.oldText.length;\n\t}\n\n\tpublic get newLength(): number {\n\t\treturn this.newText.length;\n\t}\n\n\tpublic get newEnd(): number {\n\t\treturn this.newPosition + this.newText.length;\n\t}\n\n\tconstructor(\n\t\tpublic readonly oldPosition: number,\n\t\tpublic readonly oldText: string,\n\t\tpublic readonly newPosition: number,\n\t\tpublic readonly newText: string\n\t) { }\n\n\tpublic toString(): string {\n\t\tif (this.oldText.length === 0) {\n\t\t\treturn `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n\t\t}\n\t\tif (this.newText.length === 0) {\n\t\t\treturn `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n\t\t}\n\t\treturn `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n\t}\n\n\tprivate static _writeStringSize(str: string): number {\n\t\treturn (\n\t\t\t4 + 2 * str.length\n\t\t);\n\t}\n\n\tprivate static _writeString(b: Uint8Array, str: string, offset: number): number {\n\t\tconst len = str.length;\n\t\tbuffer.writeUInt32BE(b, len, offset); offset += 4;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tbuffer.writeUInt16LE(b, str.charCodeAt(i), offset); offset += 2;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tprivate static _readString(b: Uint8Array, offset: number): string {\n\t\tconst len = buffer.readUInt32BE(b, offset); offset += 4;\n\t\treturn decodeUTF16LE(b, offset, len);\n\t}\n\n\tpublic writeSize(): number {\n\t\treturn (\n\t\t\t+ 4 // oldPosition\n\t\t\t+ 4 // newPosition\n\t\t\t+ TextChange._writeStringSize(this.oldText)\n\t\t\t+ TextChange._writeStringSize(this.newText)\n\t\t);\n\t}\n\n\tpublic write(b: Uint8Array, offset: number): number {\n\t\tbuffer.writeUInt32BE(b, this.oldPosition, offset); offset += 4;\n\t\tbuffer.writeUInt32BE(b, this.newPosition, offset); offset += 4;\n\t\toffset = TextChange._writeString(b, this.oldText, offset);\n\t\toffset = TextChange._writeString(b, this.newText, offset);\n\t\treturn offset;\n\t}\n\n\tpublic static read(b: Uint8Array, offset: number, dest: TextChange[]): number {\n\t\tconst oldPosition = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst newPosition = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst oldText = TextChange._readString(b, offset); offset += TextChange._writeStringSize(oldText);\n\t\tconst newText = TextChange._readString(b, offset); offset += TextChange._writeStringSize(newText);\n\t\tdest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n\t\treturn offset;\n\t}\n}\n\nexport function compressConsecutiveTextChanges(prevEdits: TextChange[] | null, currEdits: TextChange[]): TextChange[] {\n\tif (prevEdits === null || prevEdits.length === 0) {\n\t\treturn currEdits;\n\t}\n\tconst compressor = new TextChangeCompressor(prevEdits, currEdits);\n\treturn compressor.compress();\n}\n\nclass TextChangeCompressor {\n\n\tprivate _prevEdits: TextChange[];\n\tprivate _currEdits: TextChange[];\n\n\tprivate _result: TextChange[];\n\tprivate _resultLen: number;\n\n\tprivate _prevLen: number;\n\tprivate _prevDeltaOffset: number;\n\n\tprivate _currLen: number;\n\tprivate _currDeltaOffset: number;\n\n\tconstructor(prevEdits: TextChange[], currEdits: TextChange[]) {\n\t\tthis._prevEdits = prevEdits;\n\t\tthis._currEdits = currEdits;\n\n\t\tthis._result = [];\n\t\tthis._resultLen = 0;\n\n\t\tthis._prevLen = this._prevEdits.length;\n\t\tthis._prevDeltaOffset = 0;\n\n\t\tthis._currLen = this._currEdits.length;\n\t\tthis._currDeltaOffset = 0;\n\t}\n\n\tpublic compress(): TextChange[] {\n\t\tlet prevIndex = 0;\n\t\tlet currIndex = 0;\n\n\t\tlet prevEdit = this._getPrev(prevIndex);\n\t\tlet currEdit = this._getCurr(currIndex);\n\n\t\twhile (prevIndex < this._prevLen || currIndex < this._currLen) {\n\n\t\t\tif (prevEdit === null) {\n\t\t\t\tthis._acceptCurr(currEdit!);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit === null) {\n\t\t\t\tthis._acceptPrev(prevEdit);\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit.oldEnd <= prevEdit.newPosition) {\n\t\t\t\tthis._acceptCurr(currEdit);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (prevEdit.newEnd <= currEdit.oldPosition) {\n\t\t\t\tthis._acceptPrev(prevEdit);\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currEdit.oldPosition < prevEdit.newPosition) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n\t\t\t\tthis._acceptCurr(e1);\n\t\t\t\tcurrEdit = e2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (prevEdit.newPosition < currEdit.oldPosition) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n\t\t\t\tthis._acceptPrev(e1);\n\t\t\t\tprevEdit = e2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// At this point, currEdit.oldPosition === prevEdit.newPosition\n\n\t\t\tlet mergePrev: TextChange;\n\t\t\tlet mergeCurr: TextChange;\n\n\t\t\tif (currEdit.oldEnd === prevEdit.newEnd) {\n\t\t\t\tmergePrev = prevEdit;\n\t\t\t\tmergeCurr = currEdit;\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t} else if (currEdit.oldEnd < prevEdit.newEnd) {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n\t\t\t\tmergePrev = e1;\n\t\t\t\tmergeCurr = currEdit;\n\t\t\t\tprevEdit = e2;\n\t\t\t\tcurrEdit = this._getCurr(++currIndex);\n\t\t\t} else {\n\t\t\t\tconst [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n\t\t\t\tmergePrev = prevEdit;\n\t\t\t\tmergeCurr = e1;\n\t\t\t\tprevEdit = this._getPrev(++prevIndex);\n\t\t\t\tcurrEdit = e2;\n\t\t\t}\n\n\t\t\tthis._result[this._resultLen++] = new TextChange(\n\t\t\t\tmergePrev.oldPosition,\n\t\t\t\tmergePrev.oldText,\n\t\t\t\tmergeCurr.newPosition,\n\t\t\t\tmergeCurr.newText\n\t\t\t);\n\t\t\tthis._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n\t\t\tthis._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n\t\t}\n\n\t\tconst merged = TextChangeCompressor._merge(this._result);\n\t\tconst cleaned = TextChangeCompressor._removeNoOps(merged);\n\t\treturn cleaned;\n\t}\n\n\tprivate _acceptCurr(currEdit: TextChange): void {\n\t\tthis._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n\t\tthis._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n\t}\n\n\tprivate _getCurr(currIndex: number): TextChange | null {\n\t\treturn (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n\t}\n\n\tprivate _acceptPrev(prevEdit: TextChange): void {\n\t\tthis._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n\t\tthis._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n\t}\n\n\tprivate _getPrev(prevIndex: number): TextChange | null {\n\t\treturn (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n\t}\n\n\tprivate static _rebaseCurr(prevDeltaOffset: number, currEdit: TextChange): TextChange {\n\t\treturn new TextChange(\n\t\t\tcurrEdit.oldPosition - prevDeltaOffset,\n\t\t\tcurrEdit.oldText,\n\t\t\tcurrEdit.newPosition,\n\t\t\tcurrEdit.newText\n\t\t);\n\t}\n\n\tprivate static _rebasePrev(currDeltaOffset: number, prevEdit: TextChange): TextChange {\n\t\treturn new TextChange(\n\t\t\tprevEdit.oldPosition,\n\t\t\tprevEdit.oldText,\n\t\t\tprevEdit.newPosition + currDeltaOffset,\n\t\t\tprevEdit.newText\n\t\t);\n\t}\n\n\tprivate static _splitPrev(edit: TextChange, offset: number): [TextChange, TextChange] {\n\t\tconst preText = edit.newText.substr(0, offset);\n\t\tconst postText = edit.newText.substr(offset);\n\n\t\treturn [\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition,\n\t\t\t\tedit.oldText,\n\t\t\t\tedit.newPosition,\n\t\t\t\tpreText\n\t\t\t),\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldEnd,\n\t\t\t\t'',\n\t\t\t\tedit.newPosition + offset,\n\t\t\t\tpostText\n\t\t\t)\n\t\t];\n\t}\n\n\tprivate static _splitCurr(edit: TextChange, offset: number): [TextChange, TextChange] {\n\t\tconst preText = edit.oldText.substr(0, offset);\n\t\tconst postText = edit.oldText.substr(offset);\n\n\t\treturn [\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition,\n\t\t\t\tpreText,\n\t\t\t\tedit.newPosition,\n\t\t\t\tedit.newText\n\t\t\t),\n\t\t\tnew TextChange(\n\t\t\t\tedit.oldPosition + offset,\n\t\t\t\tpostText,\n\t\t\t\tedit.newEnd,\n\t\t\t\t''\n\t\t\t)\n\t\t];\n\t}\n\n\tprivate static _merge(edits: TextChange[]): TextChange[] {\n\t\tif (edits.length === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextChange[] = [];\n\t\tlet resultLen = 0;\n\n\t\tlet prev = edits[0];\n\t\tfor (let i = 1; i < edits.length; i++) {\n\t\t\tconst curr = edits[i];\n\n\t\t\tif (prev.oldEnd === curr.oldPosition) {\n\t\t\t\t// Merge into `prev`\n\t\t\t\tprev = new TextChange(\n\t\t\t\t\tprev.oldPosition,\n\t\t\t\t\tprev.oldText + curr.oldText,\n\t\t\t\t\tprev.newPosition,\n\t\t\t\t\tprev.newText + curr.newText\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = prev;\n\t\t\t\tprev = curr;\n\t\t\t}\n\t\t}\n\t\tresult[resultLen++] = prev;\n\n\t\treturn result;\n\t}\n\n\tprivate static _removeNoOps(edits: TextChange[]): TextChange[] {\n\t\tif (edits.length === 0) {\n\t\t\treturn edits;\n\t\t}\n\n\t\tconst result: TextChange[] = [];\n\t\tlet resultLen = 0;\n\n\t\tfor (let i = 0; i < edits.length; i++) {\n\t\t\tconst edit = edits[i];\n\n\t\t\tif (edit.oldText === edit.newText) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult[resultLen++] = edit;\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3396, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/2d/point.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/2d/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/2d/point.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/2d/vs/editor/common/core/2d/point.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport class Point {\n\tstatic equals(a: Point, b: Point): boolean {\n\t\treturn a.x === b.x && a.y === b.y;\n\t}\n\n\tconstructor(\n\t\tpublic readonly x: number,\n\t\tpublic readonly y: number,\n\t) { }\n\n\tpublic add(other: Point): Point {\n\t\treturn new Point(this.x + other.x, this.y + other.y);\n\t}\n\n\tpublic deltaX(delta: number): Point {\n\t\treturn new Point(this.x + delta, this.y);\n\t}\n\n\tpublic deltaY(delta: number): Point {\n\t\treturn new Point(this.x, this.y + delta);\n\t}\n\n\tpublic toString() {\n\t\treturn `(${this.x},${this.y})`;\n\t}\n\n\tpublic subtract(other: Point): Point {\n\t\treturn new Point(this.x - other.x, this.y - other.y);\n\t}\n\n\tpublic scale(factor: number): Point {\n\t\treturn new Point(this.x * factor, this.y * factor);\n\t}\n\n\tpublic mapComponents(map: (value: number) => number): Point {\n\t\treturn new Point(map(this.x), map(this.y));\n\t}\n\n\tpublic isZero(): boolean {\n\t\treturn this.x === 0 && this.y === 0;\n\t}\n\n\tpublic withThreshold(threshold: number): Point {\n\t\treturn this.mapComponents(axisVal => {\n\t\t\tif (axisVal > threshold) {\n\t\t\t\treturn axisVal - threshold;\n\t\t\t} else if (axisVal < -threshold) {\n\t\t\t\treturn axisVal + threshold;\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport class Point {\n\tstatic equals(a: Point, b: Point): boolean {\n\t\treturn a.x === b.x && a.y === b.y;\n\t}\n\n\tconstructor(\n\t\tpublic readonly x: number,\n\t\tpublic readonly y: number,\n\t) { }\n\n\tpublic add(other: Point): Point {\n\t\treturn new Point(this.x + other.x, this.y + other.y);\n\t}\n\n\tpublic deltaX(delta: number): Point {\n\t\treturn new Point(this.x + delta, this.y);\n\t}\n\n\tpublic deltaY(delta: number): Point {\n\t\treturn new Point(this.x, this.y + delta);\n\t}\n\n\tpublic toString() {\n\t\treturn `(${this.x},${this.y})`;\n\t}\n\n\tpublic subtract(other: Point): Point {\n\t\treturn new Point(this.x - other.x, this.y - other.y);\n\t}\n\n\tpublic scale(factor: number): Point {\n\t\treturn new Point(this.x * factor, this.y * factor);\n\t}\n\n\tpublic mapComponents(map: (value: number) => number): Point {\n\t\treturn new Point(map(this.x), map(this.y));\n\t}\n\n\tpublic isZero(): boolean {\n\t\treturn this.x === 0 && this.y === 0;\n\t}\n\n\tpublic withThreshold(threshold: number): Point {\n\t\treturn this.mapComponents(axisVal => {\n\t\t\tif (axisVal > threshold) {\n\t\t\t\treturn axisVal - threshold;\n\t\t\t} else if (axisVal < -threshold) {\n\t\t\t\treturn axisVal + threshold;\n\t\t\t}\n\t\t\treturn 0;\n\t\t});\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAE1F,MAAO,KAAK;IACjB,MAAM,CAAC,MAAM,CAAC,CAAQ,EAAE,CAAQ,EAAA;QAC/B,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACnC,CAAC;IAED,YACiB,CAAS,EACT,CAAS,CAAA;QADT,IAAA,CAAA,CAAC,GAAD,CAAC,CAAQ;QACT,IAAA,CAAA,CAAC,GAAD,CAAC,CAAQ;IACtB,CAAC;IAEE,GAAG,CAAC,KAAY,EAAA;QACtB,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACtD,CAAC;IAEM,MAAM,CAAC,KAAa,EAAA;QAC1B,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAC1C,CAAC;IAEM,MAAM,CAAC,KAAa,EAAA;QAC1B,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;IAC1C,CAAC;IAEM,QAAQ,GAAA;QACd,OAAO,CAAA,CAAA,EAAI,IAAI,CAAC,CAAC,CAAA,CAAA,EAAI,IAAI,CAAC,CAAC,CAAA,CAAA,CAAG,CAAC;IAChC,CAAC;IAEM,QAAQ,CAAC,KAAY,EAAA;QAC3B,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACtD,CAAC;IAEM,KAAK,CAAC,MAAc,EAAA;QAC1B,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,MAAM,EAAE,IAAI,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC;IACpD,CAAC;IAEM,aAAa,CAAC,GAA8B,EAAA;QAClD,OAAO,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5C,CAAC;IAEM,MAAM,GAAA;QACZ,OAAO,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC;IACrC,CAAC;IAEM,aAAa,CAAC,SAAiB,EAAA;QACrC,OAAO,IAAI,CAAC,aAAa,EAAC,OAAO,CAAC,EAAE;YACnC,IAAI,OAAO,GAAG,SAAS,EAAE,CAAC;gBACzB,OAAO,OAAO,GAAG,SAAS,CAAC;YAC5B,CAAC,MAAM,IAAI,OAAO,GAAG,CAAC,SAAS,EAAE,CAAC;gBACjC,OAAO,OAAO,GAAG,SAAS,CAAC;YAC5B,CAAC;YACD,OAAO,CAAC,CAAC;QACV,CAAC,CAAC,CAAC;IACJ,CAAC;CACD","debugId":null}},
    {"offset": {"line": 3450, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/editOperation.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/vs/editor/common/core/editOperation.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Position } from './position.js';\nimport { IRange, Range } from './range.js';\n\n/**\n * A single edit operation, that acts as a simple replace.\n * i.e. Replace text at `range` with `text` in model.\n */\nexport interface ISingleEditOperation {\n\t/**\n\t * The range to replace. This can be empty to emulate a simple insert.\n\t */\n\trange: IRange;\n\t/**\n\t * The text to replace with. This can be null to emulate a simple delete.\n\t */\n\ttext: string | null;\n\t/**\n\t * This indicates that this operation has \"insert\" semantics.\n\t * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.\n\t */\n\tforceMoveMarkers?: boolean;\n}\n\nexport class EditOperation {\n\n\tpublic static insert(position: Position, text: string): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n\t\t\ttext: text,\n\t\t\tforceMoveMarkers: true\n\t\t};\n\t}\n\n\tpublic static delete(range: Range): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: range,\n\t\t\ttext: null\n\t\t};\n\t}\n\n\tpublic static replace(range: Range, text: string | null): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: range,\n\t\t\ttext: text\n\t\t};\n\t}\n\n\tpublic static replaceMove(range: Range, text: string | null): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: range,\n\t\t\ttext: text,\n\t\t\tforceMoveMarkers: true\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Position } from './position.js';\nimport { IRange, Range } from './range.js';\n\n/**\n * A single edit operation, that acts as a simple replace.\n * i.e. Replace text at `range` with `text` in model.\n */\nexport interface ISingleEditOperation {\n\t/**\n\t * The range to replace. This can be empty to emulate a simple insert.\n\t */\n\trange: IRange;\n\t/**\n\t * The text to replace with. This can be null to emulate a simple delete.\n\t */\n\ttext: string | null;\n\t/**\n\t * This indicates that this operation has \"insert\" semantics.\n\t * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.\n\t */\n\tforceMoveMarkers?: boolean;\n}\n\nexport class EditOperation {\n\n\tpublic static insert(position: Position, text: string): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n\t\t\ttext: text,\n\t\t\tforceMoveMarkers: true\n\t\t};\n\t}\n\n\tpublic static delete(range: Range): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: range,\n\t\t\ttext: null\n\t\t};\n\t}\n\n\tpublic static replace(range: Range, text: string | null): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: range,\n\t\t\ttext: text\n\t\t};\n\t}\n\n\tpublic static replaceMove(range: Range, text: string | null): ISingleEditOperation {\n\t\treturn {\n\t\t\trange: range,\n\t\t\ttext: text,\n\t\t\tforceMoveMarkers: true\n\t\t};\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAGhG,OAAO,EAAU,KAAK,EAAE,MAAM,YAAY,CAAC;;AAsBrC,MAAO,aAAa;IAElB,MAAM,CAAC,MAAM,CAAC,QAAkB,EAAE,IAAY,EAAA;QACpD,OAAO;YACN,KAAK,EAAE,IAAI,2LAAK,CAAC,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,UAAU,EAAE,QAAQ,CAAC,MAAM,CAAC;YAC5F,IAAI,EAAE,IAAI;YACV,gBAAgB,EAAE,IAAI;SACtB,CAAC;IACH,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,KAAY,EAAA;QAChC,OAAO;YACN,KAAK,EAAE,KAAK;YACZ,IAAI,EAAE,IAAI;SACV,CAAC;IACH,CAAC;IAEM,MAAM,CAAC,OAAO,CAAC,KAAY,EAAE,IAAmB,EAAA;QACtD,OAAO;YACN,KAAK,EAAE,KAAK;YACZ,IAAI,EAAE,IAAI;SACV,CAAC;IACH,CAAC;IAEM,MAAM,CAAC,WAAW,CAAC,KAAY,EAAE,IAAmB,EAAA;QAC1D,OAAO;YACN,KAAK,EAAE,KAAK;YACZ,IAAI,EAAE,IAAI;YACV,gBAAgB,EAAE,IAAI;SACtB,CAAC;IACH,CAAC;CACD","debugId":null}},
    {"offset": {"line": 3491, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/text/getPositionOffsetTransformerFromTextModel.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/text/getPositionOffsetTransformerFromTextModel.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/text/vs/editor/common/core/text/getPositionOffsetTransformerFromTextModel.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextModel } from '../../model.js';\nimport { Position } from '../position.js';\nimport { PositionOffsetTransformerBase } from './positionToOffset.js';\n\nexport function getPositionOffsetTransformerFromTextModel(textModel: ITextModel): PositionOffsetTransformerBase {\n\treturn new PositionOffsetTransformerWithTextModel(textModel);\n}\n\nclass PositionOffsetTransformerWithTextModel extends PositionOffsetTransformerBase {\n\tconstructor(private readonly _textModel: ITextModel) {\n\t\tsuper();\n\t}\n\n\toverride getOffset(position: Position): number {\n\t\treturn this._textModel.getOffsetAt(position);\n\t}\n\n\toverride getPosition(offset: number): Position {\n\t\treturn this._textModel.getPositionAt(offset);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextModel } from '../../model.js';\nimport { Position } from '../position.js';\nimport { PositionOffsetTransformerBase } from './positionToOffset.js';\n\nexport function getPositionOffsetTransformerFromTextModel(textModel: ITextModel): PositionOffsetTransformerBase {\n\treturn new PositionOffsetTransformerWithTextModel(textModel);\n}\n\nclass PositionOffsetTransformerWithTextModel extends PositionOffsetTransformerBase {\n\tconstructor(private readonly _textModel: ITextModel) {\n\t\tsuper();\n\t}\n\n\toverride getOffset(position: Position): number {\n\t\treturn this._textModel.getOffsetAt(position);\n\t}\n\n\toverride getPosition(offset: number): Position {\n\t\treturn this._textModel.getPositionAt(offset);\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;AAIhG,OAAO,EAAE,6BAA6B,EAAE,MAAM,uBAAuB,CAAC;;AAEhE,SAAU,yCAAyC,CAAC,SAAqB;IAC9E,OAAO,IAAI,sCAAsC,CAAC,SAAS,CAAC,CAAC;AAC9D,CAAC;AAED,MAAM,sCAAuC,SAAQ,0OAA6B;IACjF,YAA6B,UAAsB,CAAA;QAClD,KAAK,EAAE,CAAC;QADoB,IAAA,CAAA,UAAU,GAAV,UAAU,CAAY;IAEnD,CAAC;IAEQ,SAAS,CAAC,QAAkB,EAAA;QACpC,OAAO,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAEQ,WAAW,CAAC,MAAc,EAAA;QAClC,OAAO,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;IAC9C,CAAC;CACD","debugId":null}},
    {"offset": {"line": 3520, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/rangeSingleLine.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/ranges/rangeSingleLine.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/vs/editor/common/core/ranges/rangeSingleLine.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ColumnRange } from './columnRange.js';\n\n/**\n * Represents a column range in a single line.\n*/\nexport class RangeSingleLine {\n\n\tconstructor(\n\t\t/** 1-based */\n\t\tpublic readonly lineNumber: number,\n\t\tpublic readonly columnRange: ColumnRange,\n\t) { }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ColumnRange } from './columnRange.js';\n\n/**\n * Represents a column range in a single line.\n*/\nexport class RangeSingleLine {\n\n\tconstructor(\n\t\t/** 1-based */\n\t\tpublic readonly lineNumber: number,\n\t\tpublic readonly columnRange: ColumnRange,\n\t) { }\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG,CAIhG;;EAEE;;;;AACI,MAAO,eAAe;IAE3B,YACC,YAAA,EAAc,CACE,UAAkB,EAClB,WAAwB,CAAA;QADxB,IAAA,CAAA,UAAU,GAAV,UAAU,CAAQ;QAClB,IAAA,CAAA,WAAW,GAAX,WAAW,CAAa;IACrC,CAAC;CACL","debugId":null}},
    {"offset": {"line": 3539, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/columnRange.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/ranges/columnRange.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/ranges/vs/editor/common/core/ranges/columnRange.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from '../range.js';\n\n/**\n * Represents a 1-based range of columns.\n * Use {@lik OffsetRange} to represent a 0-based range.\n*/\nexport class ColumnRange {\n\n\tconstructor(\n\t\t/** 1-based */\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumnExclusive: number\n\t) {\n\t\tif (startColumn > endColumnExclusive) {\n\t\t\tthrow new BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);\n\t\t}\n\t}\n\n\ttoRange(lineNumber: number): Range {\n\t\treturn new Range(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);\n\t}\n\n\tequals(other: ColumnRange): boolean {\n\t\treturn this.startColumn === other.startColumn\n\t\t\t&& this.endColumnExclusive === other.endColumnExclusive;\n\t}\n\n\ttoZeroBasedOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startColumn - 1, this.endColumnExclusive - 1);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from '../range.js';\n\n/**\n * Represents a 1-based range of columns.\n * Use {@lik OffsetRange} to represent a 0-based range.\n*/\nexport class ColumnRange {\n\n\tconstructor(\n\t\t/** 1-based */\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumnExclusive: number\n\t) {\n\t\tif (startColumn > endColumnExclusive) {\n\t\t\tthrow new BugIndicatingError(`startColumn ${startColumn} cannot be after endColumnExclusive ${endColumnExclusive}`);\n\t\t}\n\t}\n\n\ttoRange(lineNumber: number): Range {\n\t\treturn new Range(lineNumber, this.startColumn, lineNumber, this.endColumnExclusive);\n\t}\n\n\tequals(other: ColumnRange): boolean {\n\t\treturn this.startColumn === other.startColumn\n\t\t\t&& this.endColumnExclusive === other.endColumnExclusive;\n\t}\n\n\ttoZeroBasedOffsetRange(): OffsetRange {\n\t\treturn new OffsetRange(this.startColumn - 1, this.endColumnExclusive - 1);\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,kBAAkB,EAAE,MAAM,mCAAmC,CAAC;AACvE,OAAO,EAAE,WAAW,EAAE,MAAM,kBAAkB,CAAC;AAC/C,OAAO,EAAE,KAAK,EAAE,MAAM,aAAa,CAAC;;;;AAM9B,MAAO,WAAW;IAEvB,YACC,YAAA,EAAc,CACE,WAAmB,EACnB,kBAA0B,CAAA;QAD1B,IAAA,CAAA,WAAW,GAAX,WAAW,CAAQ;QACnB,IAAA,CAAA,kBAAkB,GAAlB,kBAAkB,CAAQ;QAE1C,IAAI,WAAW,GAAG,kBAAkB,EAAE,CAAC;YACtC,MAAM,IAAI,+LAAkB,CAAC,CAAA,YAAA,EAAe,WAAW,CAAA,oCAAA,EAAuC,kBAAkB,EAAE,CAAC,CAAC;QACrH,CAAC;IACF,CAAC;IAED,OAAO,CAAC,UAAkB,EAAA;QACzB,OAAO,IAAI,2LAAK,CAAC,UAAU,EAAE,IAAI,CAAC,WAAW,EAAE,UAAU,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;IACrF,CAAC;IAED,MAAM,CAAC,KAAkB,EAAA;QACxB,OAAO,IAAI,CAAC,WAAW,KAAK,KAAK,CAAC,WAAW,IACzC,IAAI,CAAC,kBAAkB,KAAK,KAAK,CAAC,kBAAkB,CAAC;IAC1D,CAAC;IAED,sBAAsB,GAAA;QACrB,OAAO,IAAI,iNAAW,CAAC,IAAI,CAAC,WAAW,GAAG,CAAC,EAAE,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC,CAAC;IAC3E,CAAC;CACD","debugId":null}},
    {"offset": {"line": 3574, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/edits/lineEdit.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/edits/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/edits/lineEdit.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/edits/vs/editor/common/core/edits/lineEdit.ts"],"sourcesContent":["\nimport { assert, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { splitLines } from '../../../../base/common/strings.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextReplacement } from './textEdit.js';\nimport { AbstractText } from '../text/abstractText.js';\n\nexport class LineEdit {\n\tpublic static readonly empty = new LineEdit([]);\n\n\tconstructor(\n\t\t/**\n\t\t * Have to be sorted by start line number and non-intersecting.\n\t\t*/\n\t\tpublic readonly replacements: readonly LineReplacement[]\n\t) {\n\t\tassert(checkAdjacentItems(replacements, (i1, i2) => i1.lineRange.endLineNumberExclusive <= i2.lineRange.startLineNumber));\n\t}\n\n\tpublic toString(): string {\n\t\treturn this.replacements.map(e => e.toString()).join(',');\n\t}\n\n\tpublic getNewLineRanges(): LineRange[] {\n\t\tconst ranges: LineRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(LineRange.ofLength(e.lineRange.startLineNumber + offset, e.newLines.length),);\n\t\t\toffset += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n}\n\nexport class LineReplacement {\n\n\tpublic static fromSingleTextEdit(edit: TextReplacement, initialValue: AbstractText): LineReplacement {\n\t\t// 1: ab[cde\n\t\t// 2: fghijk\n\t\t// 3: lmn]opq\n\n\t\t// replaced with\n\n\t\t// 1n: 123\n\t\t// 2n: 456\n\t\t// 3n: 789\n\n\t\t// simple solution: replace [1..4) with [1n..4n)\n\n\t\tconst newLines = splitLines(edit.text);\n\t\tlet startLineNumber = edit.range.startLineNumber;\n\t\tconst survivingFirstLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tnew Position(edit.range.startLineNumber, 1),\n\t\t\tedit.range.getStartPosition()\n\t\t));\n\t\tnewLines[0] = survivingFirstLineText + newLines[0];\n\n\t\tlet endLineNumberEx = edit.range.endLineNumber + 1;\n\t\tconst editEndLineNumberMaxColumn = initialValue.getTransformer().getLineLength(edit.range.endLineNumber) + 1;\n\t\tconst survivingEndLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tedit.range.getEndPosition(),\n\t\t\tnew Position(edit.range.endLineNumber, editEndLineNumberMaxColumn)\n\t\t));\n\t\tnewLines[newLines.length - 1] = newLines[newLines.length - 1] + survivingEndLineText;\n\n\t\t// Replacing [startLineNumber, endLineNumberEx) with newLines would be correct, however it might not be minimal.\n\n\t\tconst startBeforeNewLine = edit.range.startColumn === initialValue.getTransformer().getLineLength(edit.range.startLineNumber) + 1;\n\t\tconst endAfterNewLine = edit.range.endColumn === 1;\n\n\t\tif (startBeforeNewLine && newLines[0].length === survivingFirstLineText.length) {\n\t\t\t// the replacement would not delete any text on the first line\n\t\t\tstartLineNumber++;\n\t\t\tnewLines.shift();\n\t\t}\n\n\t\tif (newLines.length > 0 && startLineNumber < endLineNumberEx && endAfterNewLine && newLines[newLines.length - 1].length === survivingEndLineText.length) {\n\t\t\t// the replacement would not delete any text on the last line\n\t\t\tendLineNumberEx--;\n\t\t\tnewLines.pop();\n\t\t}\n\n\t\treturn new LineReplacement(new LineRange(startLineNumber, endLineNumberEx), newLines);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineRange: LineRange,\n\t\tpublic readonly newLines: readonly string[],\n\t) { }\n\n\tpublic toString(): string {\n\t\treturn `${this.lineRange}->${JSON.stringify(this.newLines)}`;\n\t}\n\n\tpublic toLineEdit(): LineEdit {\n\t\treturn new LineEdit([this]);\n\t}\n}\n","\nimport { assert, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { splitLines } from '../../../../base/common/strings.js';\nimport { LineRange } from '../ranges/lineRange.js';\nimport { Position } from '../position.js';\nimport { Range } from '../range.js';\nimport { TextReplacement } from './textEdit.js';\nimport { AbstractText } from '../text/abstractText.js';\n\nexport class LineEdit {\n\tpublic static readonly empty = new LineEdit([]);\n\n\tconstructor(\n\t\t/**\n\t\t * Have to be sorted by start line number and non-intersecting.\n\t\t*/\n\t\tpublic readonly replacements: readonly LineReplacement[]\n\t) {\n\t\tassert(checkAdjacentItems(replacements, (i1, i2) => i1.lineRange.endLineNumberExclusive <= i2.lineRange.startLineNumber));\n\t}\n\n\tpublic toString(): string {\n\t\treturn this.replacements.map(e => e.toString()).join(',');\n\t}\n\n\tpublic getNewLineRanges(): LineRange[] {\n\t\tconst ranges: LineRange[] = [];\n\t\tlet offset = 0;\n\t\tfor (const e of this.replacements) {\n\t\t\tranges.push(LineRange.ofLength(e.lineRange.startLineNumber + offset, e.newLines.length),);\n\t\t\toffset += e.newLines.length - e.lineRange.length;\n\t\t}\n\t\treturn ranges;\n\t}\n}\n\nexport class LineReplacement {\n\n\tpublic static fromSingleTextEdit(edit: TextReplacement, initialValue: AbstractText): LineReplacement {\n\t\t// 1: ab[cde\n\t\t// 2: fghijk\n\t\t// 3: lmn]opq\n\n\t\t// replaced with\n\n\t\t// 1n: 123\n\t\t// 2n: 456\n\t\t// 3n: 789\n\n\t\t// simple solution: replace [1..4) with [1n..4n)\n\n\t\tconst newLines = splitLines(edit.text);\n\t\tlet startLineNumber = edit.range.startLineNumber;\n\t\tconst survivingFirstLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tnew Position(edit.range.startLineNumber, 1),\n\t\t\tedit.range.getStartPosition()\n\t\t));\n\t\tnewLines[0] = survivingFirstLineText + newLines[0];\n\n\t\tlet endLineNumberEx = edit.range.endLineNumber + 1;\n\t\tconst editEndLineNumberMaxColumn = initialValue.getTransformer().getLineLength(edit.range.endLineNumber) + 1;\n\t\tconst survivingEndLineText = initialValue.getValueOfRange(Range.fromPositions(\n\t\t\tedit.range.getEndPosition(),\n\t\t\tnew Position(edit.range.endLineNumber, editEndLineNumberMaxColumn)\n\t\t));\n\t\tnewLines[newLines.length - 1] = newLines[newLines.length - 1] + survivingEndLineText;\n\n\t\t// Replacing [startLineNumber, endLineNumberEx) with newLines would be correct, however it might not be minimal.\n\n\t\tconst startBeforeNewLine = edit.range.startColumn === initialValue.getTransformer().getLineLength(edit.range.startLineNumber) + 1;\n\t\tconst endAfterNewLine = edit.range.endColumn === 1;\n\n\t\tif (startBeforeNewLine && newLines[0].length === survivingFirstLineText.length) {\n\t\t\t// the replacement would not delete any text on the first line\n\t\t\tstartLineNumber++;\n\t\t\tnewLines.shift();\n\t\t}\n\n\t\tif (newLines.length > 0 && startLineNumber < endLineNumberEx && endAfterNewLine && newLines[newLines.length - 1].length === survivingEndLineText.length) {\n\t\t\t// the replacement would not delete any text on the last line\n\t\t\tendLineNumberEx--;\n\t\t\tnewLines.pop();\n\t\t}\n\n\t\treturn new LineReplacement(new LineRange(startLineNumber, endLineNumberEx), newLines);\n\t}\n\n\tconstructor(\n\t\tpublic readonly lineRange: LineRange,\n\t\tpublic readonly newLines: readonly string[],\n\t) { }\n\n\tpublic toString(): string {\n\t\treturn `${this.lineRange}->${JSON.stringify(this.newLines)}`;\n\t}\n\n\tpublic toLineEdit(): LineEdit {\n\t\treturn new LineEdit([this]);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3663, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/core/2d/rect.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/2d/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/core/2d/rect.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/core/2d/vs/editor/common/core/2d/rect.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { Point } from './point.js';\n\nexport class Rect {\n\n\tpublic static fromPoints(topLeft: Point, bottomRight: Point): Rect {\n\t\treturn new Rect(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);\n\t}\n\n\tpublic static fromPointSize(point: Point, size: Point): Rect {\n\t\treturn new Rect(point.x, point.y, point.x + size.x, point.y + size.y);\n\t}\n\n\tpublic static fromLeftTopRightBottom(left: number, top: number, right: number, bottom: number): Rect {\n\t\treturn new Rect(left, top, right, bottom);\n\t}\n\n\tpublic static fromLeftTopWidthHeight(left: number, top: number, width: number, height: number): Rect {\n\t\treturn new Rect(left, top, left + width, top + height);\n\t}\n\n\tpublic static fromRanges(leftRight: OffsetRange, topBottom: OffsetRange): Rect {\n\t\treturn new Rect(leftRight.start, topBottom.start, leftRight.endExclusive, topBottom.endExclusive);\n\t}\n\n\tpublic static hull(rects: Rect[]): Rect {\n\t\tlet left = Number.MAX_SAFE_INTEGER;\n\t\tlet top = Number.MAX_SAFE_INTEGER;\n\t\tlet right = Number.MIN_SAFE_INTEGER;\n\t\tlet bottom = Number.MIN_SAFE_INTEGER;\n\n\t\tfor (const rect of rects) {\n\t\t\tleft = Math.min(left, rect.left);\n\t\t\ttop = Math.min(top, rect.top);\n\t\t\tright = Math.max(right, rect.right);\n\t\t\tbottom = Math.max(bottom, rect.bottom);\n\t\t}\n\n\t\treturn new Rect(left, top, right, bottom);\n\t}\n\n\tpublic get width() { return this.right - this.left; }\n\tpublic get height() { return this.bottom - this.top; }\n\n\tconstructor(\n\t\tpublic readonly left: number,\n\t\tpublic readonly top: number,\n\t\tpublic readonly right: number,\n\t\tpublic readonly bottom: number,\n\t) {\n\t\tif (left > right) {\n\t\t\tthrow new BugIndicatingError('Invalid arguments: Horizontally offset by ' + (left - right));\n\t\t}\n\t\tif (top > bottom) {\n\t\t\tthrow new BugIndicatingError('Invalid arguments: Vertically offset by ' + (top - bottom));\n\t\t}\n\t}\n\n\twithMargin(margin: number): Rect;\n\twithMargin(marginVertical: number, marginHorizontal: number): Rect;\n\twithMargin(marginTop: number, marginRight: number, marginBottom: number, marginLeft: number): Rect;\n\twithMargin(marginOrVerticalOrTop: number, rightOrHorizontal?: number, bottom?: number, left?: number): Rect {\n\t\tlet marginLeft, marginRight, marginTop, marginBottom;\n\n\t\t// Single margin value\n\t\tif (rightOrHorizontal === undefined && bottom === undefined && left === undefined) {\n\t\t\tmarginLeft = marginRight = marginTop = marginBottom = marginOrVerticalOrTop;\n\t\t}\n\t\t// Vertical and horizontal margins\n\t\telse if (bottom === undefined && left === undefined) {\n\t\t\tmarginLeft = marginRight = rightOrHorizontal!;\n\t\t\tmarginTop = marginBottom = marginOrVerticalOrTop;\n\t\t}\n\t\t// Individual margins for all sides\n\t\telse {\n\t\t\tmarginLeft = left!;\n\t\t\tmarginRight = rightOrHorizontal!;\n\t\t\tmarginTop = marginOrVerticalOrTop;\n\t\t\tmarginBottom = bottom!;\n\t\t}\n\n\t\treturn new Rect(\n\t\t\tthis.left - marginLeft,\n\t\t\tthis.top - marginTop,\n\t\t\tthis.right + marginRight,\n\t\t\tthis.bottom + marginBottom,\n\t\t);\n\t}\n\n\tintersectVertical(range: OffsetRange): Rect {\n\t\tconst newTop = Math.max(this.top, range.start);\n\t\tconst newBottom = Math.min(this.bottom, range.endExclusive);\n\t\treturn new Rect(\n\t\t\tthis.left,\n\t\t\tnewTop,\n\t\t\tthis.right,\n\t\t\tMath.max(newTop, newBottom),\n\t\t);\n\t}\n\n\tintersectHorizontal(range: OffsetRange): Rect {\n\t\tconst newLeft = Math.max(this.left, range.start);\n\t\tconst newRight = Math.min(this.right, range.endExclusive);\n\t\treturn new Rect(\n\t\t\tnewLeft,\n\t\t\tthis.top,\n\t\t\tMath.max(newLeft, newRight),\n\t\t\tthis.bottom,\n\t\t);\n\t}\n\n\ttoString(): string {\n\t\treturn `Rect{(${this.left},${this.top}), (${this.right},${this.bottom})}`;\n\t}\n\n\tintersect(parent: Rect): Rect | undefined {\n\t\tconst left = Math.max(this.left, parent.left);\n\t\tconst right = Math.min(this.right, parent.right);\n\t\tconst top = Math.max(this.top, parent.top);\n\t\tconst bottom = Math.min(this.bottom, parent.bottom);\n\n\t\tif (left > right || top > bottom) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn new Rect(left, top, right, bottom);\n\t}\n\n\tcontainsRect(other: Rect): boolean {\n\t\treturn this.left <= other.left\n\t\t\t&& this.top <= other.top\n\t\t\t&& this.right >= other.right\n\t\t\t&& this.bottom >= other.bottom;\n\t}\n\n\tcontainsPoint(point: Point): boolean {\n\t\treturn this.left <= point.x\n\t\t\t&& this.top <= point.y\n\t\t\t&& this.right >= point.x\n\t\t\t&& this.bottom >= point.y;\n\t}\n\n\tmoveToBeContainedIn(parent: Rect): Rect {\n\t\tconst width = this.width;\n\t\tconst height = this.height;\n\n\t\tlet left = this.left;\n\t\tlet top = this.top;\n\n\t\tif (left < parent.left) {\n\t\t\tleft = parent.left;\n\t\t} else if (left + width > parent.right) {\n\t\t\tleft = parent.right - width;\n\t\t}\n\n\t\tif (top < parent.top) {\n\t\t\ttop = parent.top;\n\t\t} else if (top + height > parent.bottom) {\n\t\t\ttop = parent.bottom - height;\n\t\t}\n\n\t\treturn new Rect(left, top, left + width, top + height);\n\t}\n\n\twithWidth(width: number): Rect {\n\t\treturn new Rect(this.left, this.top, this.left + width, this.bottom);\n\t}\n\n\twithHeight(height: number): Rect {\n\t\treturn new Rect(this.left, this.top, this.right, this.top + height);\n\t}\n\n\twithTop(top: number): Rect {\n\t\treturn new Rect(this.left, top, this.right, this.bottom);\n\t}\n\n\twithLeft(left: number): Rect {\n\t\treturn new Rect(left, this.top, this.right, this.bottom);\n\t}\n\n\ttranslateX(delta: number): Rect {\n\t\treturn new Rect(this.left + delta, this.top, this.right + delta, this.bottom);\n\t}\n\n\ttranslateY(delta: number): Rect {\n\t\treturn new Rect(this.left, this.top + delta, this.right, this.bottom + delta);\n\t}\n\n\tgetLeftBottom(): Point {\n\t\treturn new Point(this.left, this.bottom);\n\t}\n\n\tgetRightBottom(): Point {\n\t\treturn new Point(this.right, this.bottom);\n\t}\n\n\tgetRightTop(): Point {\n\t\treturn new Point(this.right, this.top);\n\t}\n\n\ttoStyles() {\n\t\treturn {\n\t\t\tposition: 'absolute',\n\t\t\tleft: `${this.left}px`,\n\t\t\ttop: `${this.top}px`,\n\t\t\twidth: `${this.width}px`,\n\t\t\theight: `${this.height}px`,\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../ranges/offsetRange.js';\nimport { Point } from './point.js';\n\nexport class Rect {\n\n\tpublic static fromPoints(topLeft: Point, bottomRight: Point): Rect {\n\t\treturn new Rect(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);\n\t}\n\n\tpublic static fromPointSize(point: Point, size: Point): Rect {\n\t\treturn new Rect(point.x, point.y, point.x + size.x, point.y + size.y);\n\t}\n\n\tpublic static fromLeftTopRightBottom(left: number, top: number, right: number, bottom: number): Rect {\n\t\treturn new Rect(left, top, right, bottom);\n\t}\n\n\tpublic static fromLeftTopWidthHeight(left: number, top: number, width: number, height: number): Rect {\n\t\treturn new Rect(left, top, left + width, top + height);\n\t}\n\n\tpublic static fromRanges(leftRight: OffsetRange, topBottom: OffsetRange): Rect {\n\t\treturn new Rect(leftRight.start, topBottom.start, leftRight.endExclusive, topBottom.endExclusive);\n\t}\n\n\tpublic static hull(rects: Rect[]): Rect {\n\t\tlet left = Number.MAX_SAFE_INTEGER;\n\t\tlet top = Number.MAX_SAFE_INTEGER;\n\t\tlet right = Number.MIN_SAFE_INTEGER;\n\t\tlet bottom = Number.MIN_SAFE_INTEGER;\n\n\t\tfor (const rect of rects) {\n\t\t\tleft = Math.min(left, rect.left);\n\t\t\ttop = Math.min(top, rect.top);\n\t\t\tright = Math.max(right, rect.right);\n\t\t\tbottom = Math.max(bottom, rect.bottom);\n\t\t}\n\n\t\treturn new Rect(left, top, right, bottom);\n\t}\n\n\tpublic get width() { return this.right - this.left; }\n\tpublic get height() { return this.bottom - this.top; }\n\n\tconstructor(\n\t\tpublic readonly left: number,\n\t\tpublic readonly top: number,\n\t\tpublic readonly right: number,\n\t\tpublic readonly bottom: number,\n\t) {\n\t\tif (left > right) {\n\t\t\tthrow new BugIndicatingError('Invalid arguments: Horizontally offset by ' + (left - right));\n\t\t}\n\t\tif (top > bottom) {\n\t\t\tthrow new BugIndicatingError('Invalid arguments: Vertically offset by ' + (top - bottom));\n\t\t}\n\t}\n\n\twithMargin(margin: number): Rect;\n\twithMargin(marginVertical: number, marginHorizontal: number): Rect;\n\twithMargin(marginTop: number, marginRight: number, marginBottom: number, marginLeft: number): Rect;\n\twithMargin(marginOrVerticalOrTop: number, rightOrHorizontal?: number, bottom?: number, left?: number): Rect {\n\t\tlet marginLeft, marginRight, marginTop, marginBottom;\n\n\t\t// Single margin value\n\t\tif (rightOrHorizontal === undefined && bottom === undefined && left === undefined) {\n\t\t\tmarginLeft = marginRight = marginTop = marginBottom = marginOrVerticalOrTop;\n\t\t}\n\t\t// Vertical and horizontal margins\n\t\telse if (bottom === undefined && left === undefined) {\n\t\t\tmarginLeft = marginRight = rightOrHorizontal!;\n\t\t\tmarginTop = marginBottom = marginOrVerticalOrTop;\n\t\t}\n\t\t// Individual margins for all sides\n\t\telse {\n\t\t\tmarginLeft = left!;\n\t\t\tmarginRight = rightOrHorizontal!;\n\t\t\tmarginTop = marginOrVerticalOrTop;\n\t\t\tmarginBottom = bottom!;\n\t\t}\n\n\t\treturn new Rect(\n\t\t\tthis.left - marginLeft,\n\t\t\tthis.top - marginTop,\n\t\t\tthis.right + marginRight,\n\t\t\tthis.bottom + marginBottom,\n\t\t);\n\t}\n\n\tintersectVertical(range: OffsetRange): Rect {\n\t\tconst newTop = Math.max(this.top, range.start);\n\t\tconst newBottom = Math.min(this.bottom, range.endExclusive);\n\t\treturn new Rect(\n\t\t\tthis.left,\n\t\t\tnewTop,\n\t\t\tthis.right,\n\t\t\tMath.max(newTop, newBottom),\n\t\t);\n\t}\n\n\tintersectHorizontal(range: OffsetRange): Rect {\n\t\tconst newLeft = Math.max(this.left, range.start);\n\t\tconst newRight = Math.min(this.right, range.endExclusive);\n\t\treturn new Rect(\n\t\t\tnewLeft,\n\t\t\tthis.top,\n\t\t\tMath.max(newLeft, newRight),\n\t\t\tthis.bottom,\n\t\t);\n\t}\n\n\ttoString(): string {\n\t\treturn `Rect{(${this.left},${this.top}), (${this.right},${this.bottom})}`;\n\t}\n\n\tintersect(parent: Rect): Rect | undefined {\n\t\tconst left = Math.max(this.left, parent.left);\n\t\tconst right = Math.min(this.right, parent.right);\n\t\tconst top = Math.max(this.top, parent.top);\n\t\tconst bottom = Math.min(this.bottom, parent.bottom);\n\n\t\tif (left > right || top > bottom) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn new Rect(left, top, right, bottom);\n\t}\n\n\tcontainsRect(other: Rect): boolean {\n\t\treturn this.left <= other.left\n\t\t\t&& this.top <= other.top\n\t\t\t&& this.right >= other.right\n\t\t\t&& this.bottom >= other.bottom;\n\t}\n\n\tcontainsPoint(point: Point): boolean {\n\t\treturn this.left <= point.x\n\t\t\t&& this.top <= point.y\n\t\t\t&& this.right >= point.x\n\t\t\t&& this.bottom >= point.y;\n\t}\n\n\tmoveToBeContainedIn(parent: Rect): Rect {\n\t\tconst width = this.width;\n\t\tconst height = this.height;\n\n\t\tlet left = this.left;\n\t\tlet top = this.top;\n\n\t\tif (left < parent.left) {\n\t\t\tleft = parent.left;\n\t\t} else if (left + width > parent.right) {\n\t\t\tleft = parent.right - width;\n\t\t}\n\n\t\tif (top < parent.top) {\n\t\t\ttop = parent.top;\n\t\t} else if (top + height > parent.bottom) {\n\t\t\ttop = parent.bottom - height;\n\t\t}\n\n\t\treturn new Rect(left, top, left + width, top + height);\n\t}\n\n\twithWidth(width: number): Rect {\n\t\treturn new Rect(this.left, this.top, this.left + width, this.bottom);\n\t}\n\n\twithHeight(height: number): Rect {\n\t\treturn new Rect(this.left, this.top, this.right, this.top + height);\n\t}\n\n\twithTop(top: number): Rect {\n\t\treturn new Rect(this.left, top, this.right, this.bottom);\n\t}\n\n\twithLeft(left: number): Rect {\n\t\treturn new Rect(left, this.top, this.right, this.bottom);\n\t}\n\n\ttranslateX(delta: number): Rect {\n\t\treturn new Rect(this.left + delta, this.top, this.right + delta, this.bottom);\n\t}\n\n\ttranslateY(delta: number): Rect {\n\t\treturn new Rect(this.left, this.top + delta, this.right, this.bottom + delta);\n\t}\n\n\tgetLeftBottom(): Point {\n\t\treturn new Point(this.left, this.bottom);\n\t}\n\n\tgetRightBottom(): Point {\n\t\treturn new Point(this.right, this.bottom);\n\t}\n\n\tgetRightTop(): Point {\n\t\treturn new Point(this.right, this.top);\n\t}\n\n\ttoStyles() {\n\t\treturn {\n\t\t\tposition: 'absolute',\n\t\t\tleft: `${this.left}px`,\n\t\t\ttop: `${this.top}px`,\n\t\t\twidth: `${this.width}px`,\n\t\t\theight: `${this.height}px`,\n\t\t};\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}