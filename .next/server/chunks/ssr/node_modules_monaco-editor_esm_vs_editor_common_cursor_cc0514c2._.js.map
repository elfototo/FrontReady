{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorColumnSelection.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorColumnSelection.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CursorConfiguration, ICursorSimpleModel, SingleCursorState, IColumnSelectData, SelectionStartKind } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\n\nexport class ColumnSelection {\n\n\tpublic static columnSelect(config: CursorConfiguration, model: ICursorSimpleModel, fromLineNumber: number, fromVisibleColumn: number, toLineNumber: number, toVisibleColumn: number): IColumnSelectResult {\n\t\tconst lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n\t\tconst reversed = (fromLineNumber > toLineNumber);\n\t\tconst isRTL = (fromVisibleColumn > toVisibleColumn);\n\t\tconst isLTR = (fromVisibleColumn < toVisibleColumn);\n\n\t\tconst result: SingleCursorState[] = [];\n\n\t\t// console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineNumber = fromLineNumber + (reversed ? -i : i);\n\n\t\t\tconst startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n\t\t\tconst endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n\t\t\tconst visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n\t\t\tconst visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n\n\t\t\t// console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n\n\t\t\tif (isLTR) {\n\t\t\t\tif (visibleStartColumn > toVisibleColumn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (visibleEndColumn < fromVisibleColumn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isRTL) {\n\t\t\t\tif (visibleEndColumn > fromVisibleColumn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (visibleStartColumn < toVisibleColumn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.push(new SingleCursorState(\n\t\t\t\tnew Range(lineNumber, startColumn, lineNumber, startColumn), SelectionStartKind.Simple, 0,\n\t\t\t\tnew Position(lineNumber, endColumn), 0\n\t\t\t));\n\t\t}\n\n\t\tif (result.length === 0) {\n\t\t\t// We are after all the lines, so add cursor at the end of each line\n\t\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\t\tconst lineNumber = fromLineNumber + (reversed ? -i : i);\n\t\t\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\t\t\tresult.push(new SingleCursorState(\n\t\t\t\t\tnew Range(lineNumber, maxColumn, lineNumber, maxColumn), SelectionStartKind.Simple, 0,\n\t\t\t\t\tnew Position(lineNumber, maxColumn), 0\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tviewStates: result,\n\t\t\treversed: reversed,\n\t\t\tfromLineNumber: fromLineNumber,\n\t\t\tfromVisualColumn: fromVisibleColumn,\n\t\t\ttoLineNumber: toLineNumber,\n\t\t\ttoVisualColumn: toVisibleColumn\n\t\t};\n\t}\n\n\tpublic static columnSelectLeft(config: CursorConfiguration, model: ICursorSimpleModel, prevColumnSelectData: IColumnSelectData): IColumnSelectResult {\n\t\tlet toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n\t\tif (toViewVisualColumn > 0) {\n\t\t\ttoViewVisualColumn--;\n\t\t}\n\n\t\treturn ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n\t}\n\n\tpublic static columnSelectRight(config: CursorConfiguration, model: ICursorSimpleModel, prevColumnSelectData: IColumnSelectData): IColumnSelectResult {\n\t\tlet maxVisualViewColumn = 0;\n\t\tconst minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n\t\tconst maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n\t\tfor (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n\t\t\tconst lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n\t\t\tconst lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n\t\t\tmaxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n\t\t}\n\n\t\tlet toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n\t\tif (toViewVisualColumn < maxVisualViewColumn) {\n\t\t\ttoViewVisualColumn++;\n\t\t}\n\n\t\treturn this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n\t}\n\n\tpublic static columnSelectUp(config: CursorConfiguration, model: ICursorSimpleModel, prevColumnSelectData: IColumnSelectData, isPaged: boolean): IColumnSelectResult {\n\t\tconst linesCount = isPaged ? config.pageSize : 1;\n\t\tconst toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n\t\treturn this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n\t}\n\n\tpublic static columnSelectDown(config: CursorConfiguration, model: ICursorSimpleModel, prevColumnSelectData: IColumnSelectData, isPaged: boolean): IColumnSelectResult {\n\t\tconst linesCount = isPaged ? config.pageSize : 1;\n\t\tconst toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n\t\treturn this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n\t}\n}\n\nexport interface IColumnSelectResult {\n\tviewStates: SingleCursorState[];\n\treversed: boolean;\n\tfromLineNumber: number;\n\tfromVisualColumn: number;\n\ttoLineNumber: number;\n\ttoVisualColumn: number;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CursorConfiguration, ICursorSimpleModel, SingleCursorState, IColumnSelectData, SelectionStartKind } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\n\nexport class ColumnSelection {\n\n\tpublic static columnSelect(config: CursorConfiguration, model: ICursorSimpleModel, fromLineNumber: number, fromVisibleColumn: number, toLineNumber: number, toVisibleColumn: number): IColumnSelectResult {\n\t\tconst lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n\t\tconst reversed = (fromLineNumber > toLineNumber);\n\t\tconst isRTL = (fromVisibleColumn > toVisibleColumn);\n\t\tconst isLTR = (fromVisibleColumn < toVisibleColumn);\n\n\t\tconst result: SingleCursorState[] = [];\n\n\t\t// console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n\n\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\tconst lineNumber = fromLineNumber + (reversed ? -i : i);\n\n\t\t\tconst startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n\t\t\tconst endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n\t\t\tconst visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n\t\t\tconst visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n\n\t\t\t// console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n\n\t\t\tif (isLTR) {\n\t\t\t\tif (visibleStartColumn > toVisibleColumn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (visibleEndColumn < fromVisibleColumn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isRTL) {\n\t\t\t\tif (visibleEndColumn > fromVisibleColumn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (visibleStartColumn < toVisibleColumn) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.push(new SingleCursorState(\n\t\t\t\tnew Range(lineNumber, startColumn, lineNumber, startColumn), SelectionStartKind.Simple, 0,\n\t\t\t\tnew Position(lineNumber, endColumn), 0\n\t\t\t));\n\t\t}\n\n\t\tif (result.length === 0) {\n\t\t\t// We are after all the lines, so add cursor at the end of each line\n\t\t\tfor (let i = 0; i < lineCount; i++) {\n\t\t\t\tconst lineNumber = fromLineNumber + (reversed ? -i : i);\n\t\t\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\t\t\tresult.push(new SingleCursorState(\n\t\t\t\t\tnew Range(lineNumber, maxColumn, lineNumber, maxColumn), SelectionStartKind.Simple, 0,\n\t\t\t\t\tnew Position(lineNumber, maxColumn), 0\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tviewStates: result,\n\t\t\treversed: reversed,\n\t\t\tfromLineNumber: fromLineNumber,\n\t\t\tfromVisualColumn: fromVisibleColumn,\n\t\t\ttoLineNumber: toLineNumber,\n\t\t\ttoVisualColumn: toVisibleColumn\n\t\t};\n\t}\n\n\tpublic static columnSelectLeft(config: CursorConfiguration, model: ICursorSimpleModel, prevColumnSelectData: IColumnSelectData): IColumnSelectResult {\n\t\tlet toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n\t\tif (toViewVisualColumn > 0) {\n\t\t\ttoViewVisualColumn--;\n\t\t}\n\n\t\treturn ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n\t}\n\n\tpublic static columnSelectRight(config: CursorConfiguration, model: ICursorSimpleModel, prevColumnSelectData: IColumnSelectData): IColumnSelectResult {\n\t\tlet maxVisualViewColumn = 0;\n\t\tconst minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n\t\tconst maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n\t\tfor (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n\t\t\tconst lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n\t\t\tconst lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n\t\t\tmaxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n\t\t}\n\n\t\tlet toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n\t\tif (toViewVisualColumn < maxVisualViewColumn) {\n\t\t\ttoViewVisualColumn++;\n\t\t}\n\n\t\treturn this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n\t}\n\n\tpublic static columnSelectUp(config: CursorConfiguration, model: ICursorSimpleModel, prevColumnSelectData: IColumnSelectData, isPaged: boolean): IColumnSelectResult {\n\t\tconst linesCount = isPaged ? config.pageSize : 1;\n\t\tconst toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n\t\treturn this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n\t}\n\n\tpublic static columnSelectDown(config: CursorConfiguration, model: ICursorSimpleModel, prevColumnSelectData: IColumnSelectData, isPaged: boolean): IColumnSelectResult {\n\t\tconst linesCount = isPaged ? config.pageSize : 1;\n\t\tconst toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n\t\treturn this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n\t}\n}\n\nexport interface IColumnSelectResult {\n\tviewStates: SingleCursorState[];\n\treversed: boolean;\n\tfromLineNumber: number;\n\tfromVisualColumn: number;\n\ttoLineNumber: number;\n\ttoVisualColumn: number;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorAtomicMoveOperations.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorAtomicMoveOperations.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\n\nexport const enum Direction {\n\tLeft,\n\tRight,\n\tNearest,\n}\n\nexport class AtomicTabMoveOperations {\n\t/**\n\t * Get the visible column at the position. If we get to a non-whitespace character first\n\t * or past the end of string then return -1.\n\t *\n\t * **Note** `position` and the return value are 0-based.\n\t */\n\tpublic static whitespaceVisibleColumn(lineContent: string, position: number, tabSize: number): [number, number, number] {\n\t\tconst lineLength = lineContent.length;\n\t\tlet visibleColumn = 0;\n\t\tlet prevTabStopPosition = -1;\n\t\tlet prevTabStopVisibleColumn = -1;\n\t\tfor (let i = 0; i < lineLength; i++) {\n\t\t\tif (i === position) {\n\t\t\t\treturn [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n\t\t\t}\n\t\t\tif (visibleColumn % tabSize === 0) {\n\t\t\t\tprevTabStopPosition = i;\n\t\t\t\tprevTabStopVisibleColumn = visibleColumn;\n\t\t\t}\n\t\t\tconst chCode = lineContent.charCodeAt(i);\n\t\t\tswitch (chCode) {\n\t\t\t\tcase CharCode.Space:\n\t\t\t\t\tvisibleColumn += 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\t// Skip to the next multiple of tabSize.\n\t\t\t\t\tvisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn [-1, -1, -1];\n\t\t\t}\n\t\t}\n\t\tif (position === lineLength) {\n\t\t\treturn [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n\t\t}\n\t\treturn [-1, -1, -1];\n\t}\n\n\t/**\n\t * Return the position that should result from a move left, right or to the\n\t * nearest tab, if atomic tabs are enabled. Left and right are used for the\n\t * arrow key movements, nearest is used for mouse selection. It returns\n\t * -1 if atomic tabs are not relevant and you should fall back to normal\n\t * behaviour.\n\t *\n\t * **Note**: `position` and the return value are 0-based.\n\t */\n\tpublic static atomicPosition(lineContent: string, position: number, tabSize: number, direction: Direction): number {\n\t\tconst lineLength = lineContent.length;\n\n\t\t// Get the 0-based visible column corresponding to the position, or return\n\t\t// -1 if it is not in the initial whitespace.\n\t\tconst [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n\n\t\tif (visibleColumn === -1) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Is the output left or right of the current position. The case for nearest\n\t\t// where it is the same as the current position is handled in the switch.\n\t\tlet left: boolean;\n\t\tswitch (direction) {\n\t\t\tcase Direction.Left:\n\t\t\t\tleft = true;\n\t\t\t\tbreak;\n\t\t\tcase Direction.Right:\n\t\t\t\tleft = false;\n\t\t\t\tbreak;\n\t\t\tcase Direction.Nearest:\n\t\t\t\t// The code below assumes the output position is either left or right\n\t\t\t\t// of the input position. If it is the same, return immediately.\n\t\t\t\tif (visibleColumn % tabSize === 0) {\n\t\t\t\t\treturn position;\n\t\t\t\t}\n\t\t\t\t// Go to the nearest indentation.\n\t\t\t\tleft = visibleColumn % tabSize <= (tabSize / 2);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// If going left, we can just use the info about the last tab stop position and\n\t\t// last tab stop visible column that we computed in the first walk over the whitespace.\n\t\tif (left) {\n\t\t\tif (prevTabStopPosition === -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// If the direction is left, we need to keep scanning right to ensure\n\t\t\t// that targetVisibleColumn + tabSize is before non-whitespace.\n\t\t\t// This is so that when we press left at the end of a partial\n\t\t\t// indentation it only goes one character. For example '      foo' with\n\t\t\t// tabSize 4, should jump from position 6 to position 5, not 4.\n\t\t\tlet currentVisibleColumn = prevTabStopVisibleColumn;\n\t\t\tfor (let i = prevTabStopPosition; i < lineLength; ++i) {\n\t\t\t\tif (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n\t\t\t\t\t// It is a full indentation.\n\t\t\t\t\treturn prevTabStopPosition;\n\t\t\t\t}\n\n\t\t\t\tconst chCode = lineContent.charCodeAt(i);\n\t\t\t\tswitch (chCode) {\n\t\t\t\t\tcase CharCode.Space:\n\t\t\t\t\t\tcurrentVisibleColumn += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\t\tcurrentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n\t\t\t\treturn prevTabStopPosition;\n\t\t\t}\n\t\t\t// It must have been a partial indentation.\n\t\t\treturn -1;\n\t\t}\n\n\t\t// We are going right.\n\t\tconst targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n\n\t\t// We can just continue from where whitespaceVisibleColumn got to.\n\t\tlet currentVisibleColumn = visibleColumn;\n\t\tfor (let i = position; i < lineLength; i++) {\n\t\t\tif (currentVisibleColumn === targetVisibleColumn) {\n\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\tconst chCode = lineContent.charCodeAt(i);\n\t\t\tswitch (chCode) {\n\t\t\t\tcase CharCode.Space:\n\t\t\t\t\tcurrentVisibleColumn += 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\tcurrentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t// This condition handles when the target column is at the end of the line.\n\t\tif (currentVisibleColumn === targetVisibleColumn) {\n\t\t\treturn lineLength;\n\t\t}\n\t\treturn -1;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\n\nexport const enum Direction {\n\tLeft,\n\tRight,\n\tNearest,\n}\n\nexport class AtomicTabMoveOperations {\n\t/**\n\t * Get the visible column at the position. If we get to a non-whitespace character first\n\t * or past the end of string then return -1.\n\t *\n\t * **Note** `position` and the return value are 0-based.\n\t */\n\tpublic static whitespaceVisibleColumn(lineContent: string, position: number, tabSize: number): [number, number, number] {\n\t\tconst lineLength = lineContent.length;\n\t\tlet visibleColumn = 0;\n\t\tlet prevTabStopPosition = -1;\n\t\tlet prevTabStopVisibleColumn = -1;\n\t\tfor (let i = 0; i < lineLength; i++) {\n\t\t\tif (i === position) {\n\t\t\t\treturn [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n\t\t\t}\n\t\t\tif (visibleColumn % tabSize === 0) {\n\t\t\t\tprevTabStopPosition = i;\n\t\t\t\tprevTabStopVisibleColumn = visibleColumn;\n\t\t\t}\n\t\t\tconst chCode = lineContent.charCodeAt(i);\n\t\t\tswitch (chCode) {\n\t\t\t\tcase CharCode.Space:\n\t\t\t\t\tvisibleColumn += 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\t// Skip to the next multiple of tabSize.\n\t\t\t\t\tvisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn [-1, -1, -1];\n\t\t\t}\n\t\t}\n\t\tif (position === lineLength) {\n\t\t\treturn [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n\t\t}\n\t\treturn [-1, -1, -1];\n\t}\n\n\t/**\n\t * Return the position that should result from a move left, right or to the\n\t * nearest tab, if atomic tabs are enabled. Left and right are used for the\n\t * arrow key movements, nearest is used for mouse selection. It returns\n\t * -1 if atomic tabs are not relevant and you should fall back to normal\n\t * behaviour.\n\t *\n\t * **Note**: `position` and the return value are 0-based.\n\t */\n\tpublic static atomicPosition(lineContent: string, position: number, tabSize: number, direction: Direction): number {\n\t\tconst lineLength = lineContent.length;\n\n\t\t// Get the 0-based visible column corresponding to the position, or return\n\t\t// -1 if it is not in the initial whitespace.\n\t\tconst [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n\n\t\tif (visibleColumn === -1) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Is the output left or right of the current position. The case for nearest\n\t\t// where it is the same as the current position is handled in the switch.\n\t\tlet left: boolean;\n\t\tswitch (direction) {\n\t\t\tcase Direction.Left:\n\t\t\t\tleft = true;\n\t\t\t\tbreak;\n\t\t\tcase Direction.Right:\n\t\t\t\tleft = false;\n\t\t\t\tbreak;\n\t\t\tcase Direction.Nearest:\n\t\t\t\t// The code below assumes the output position is either left or right\n\t\t\t\t// of the input position. If it is the same, return immediately.\n\t\t\t\tif (visibleColumn % tabSize === 0) {\n\t\t\t\t\treturn position;\n\t\t\t\t}\n\t\t\t\t// Go to the nearest indentation.\n\t\t\t\tleft = visibleColumn % tabSize <= (tabSize / 2);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// If going left, we can just use the info about the last tab stop position and\n\t\t// last tab stop visible column that we computed in the first walk over the whitespace.\n\t\tif (left) {\n\t\t\tif (prevTabStopPosition === -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// If the direction is left, we need to keep scanning right to ensure\n\t\t\t// that targetVisibleColumn + tabSize is before non-whitespace.\n\t\t\t// This is so that when we press left at the end of a partial\n\t\t\t// indentation it only goes one character. For example '      foo' with\n\t\t\t// tabSize 4, should jump from position 6 to position 5, not 4.\n\t\t\tlet currentVisibleColumn = prevTabStopVisibleColumn;\n\t\t\tfor (let i = prevTabStopPosition; i < lineLength; ++i) {\n\t\t\t\tif (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n\t\t\t\t\t// It is a full indentation.\n\t\t\t\t\treturn prevTabStopPosition;\n\t\t\t\t}\n\n\t\t\t\tconst chCode = lineContent.charCodeAt(i);\n\t\t\t\tswitch (chCode) {\n\t\t\t\t\tcase CharCode.Space:\n\t\t\t\t\t\tcurrentVisibleColumn += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\t\tcurrentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n\t\t\t\treturn prevTabStopPosition;\n\t\t\t}\n\t\t\t// It must have been a partial indentation.\n\t\t\treturn -1;\n\t\t}\n\n\t\t// We are going right.\n\t\tconst targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n\n\t\t// We can just continue from where whitespaceVisibleColumn got to.\n\t\tlet currentVisibleColumn = visibleColumn;\n\t\tfor (let i = position; i < lineLength; i++) {\n\t\t\tif (currentVisibleColumn === targetVisibleColumn) {\n\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\tconst chCode = lineContent.charCodeAt(i);\n\t\t\tswitch (chCode) {\n\t\t\t\tcase CharCode.Space:\n\t\t\t\t\tcurrentVisibleColumn += 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\tcurrentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t// This condition handles when the target column is at the end of the line.\n\t\tif (currentVisibleColumn === targetVisibleColumn) {\n\t\t\treturn lineLength;\n\t\t}\n\t\treturn -1;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorMoveOperations.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorMoveOperations.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport { Constants } from '../../../base/common/uint.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations, Direction } from './cursorAtomicMoveOperations.js';\nimport { CursorConfiguration, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { PositionAffinity } from '../model.js';\n\nexport class CursorPosition {\n\t_cursorPositionBrand: void = undefined;\n\n\tpublic readonly lineNumber: number;\n\tpublic readonly column: number;\n\tpublic readonly leftoverVisibleColumns: number;\n\n\tconstructor(lineNumber: number, column: number, leftoverVisibleColumns: number) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.column = column;\n\t\tthis.leftoverVisibleColumns = leftoverVisibleColumns;\n\t}\n}\n\nexport class MoveOperations {\n\tpublic static leftPosition(model: ICursorSimpleModel, position: Position): Position {\n\t\tif (position.column > model.getLineMinColumn(position.lineNumber)) {\n\t\t\treturn position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n\t\t} else if (position.lineNumber > 1) {\n\t\t\tconst newLineNumber = position.lineNumber - 1;\n\t\t\treturn new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n\t\t} else {\n\t\t\treturn position;\n\t\t}\n\t}\n\n\tprivate static leftPositionAtomicSoftTabs(model: ICursorSimpleModel, position: Position, tabSize: number): Position {\n\t\tif (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n\t\t\tconst minColumn = model.getLineMinColumn(position.lineNumber);\n\t\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\t\tconst newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, Direction.Left);\n\t\t\tif (newPosition !== -1 && newPosition + 1 >= minColumn) {\n\t\t\t\treturn new Position(position.lineNumber, newPosition + 1);\n\t\t\t}\n\t\t}\n\t\treturn this.leftPosition(model, position);\n\t}\n\n\tprivate static left(config: CursorConfiguration, model: ICursorSimpleModel, position: Position): CursorPosition {\n\t\tconst pos = config.stickyTabStops\n\t\t\t? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n\t\t\t: MoveOperations.leftPosition(model, position);\n\t\treturn new CursorPosition(pos.lineNumber, pos.column, 0);\n\t}\n\n\t/**\n\t * @param noOfColumns Must be either `1`\n\t * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n\t*/\n\tpublic static moveLeft(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, noOfColumns: number): SingleCursorState {\n\t\tlet lineNumber: number,\n\t\t\tcolumn: number;\n\n\t\tif (cursor.hasSelection() && !inSelectionMode) {\n\t\t\t// If the user has a selection and does not want to extend it,\n\t\t\t// put the cursor at the beginning of the selection.\n\t\t\tlineNumber = cursor.selection.startLineNumber;\n\t\t\tcolumn = cursor.selection.startColumn;\n\t\t} else {\n\t\t\t// This has no effect if noOfColumns === 1.\n\t\t\t// It is ok to do so in the half-line scenario.\n\t\t\tconst pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n\t\t\t// We clip the position before normalization, as normalization is not defined\n\t\t\t// for possibly negative columns.\n\t\t\tconst normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), PositionAffinity.Left);\n\t\t\tconst p = MoveOperations.left(config, model, normalizedPos);\n\n\t\t\tlineNumber = p.lineNumber;\n\t\t\tcolumn = p.column;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, column, 0);\n\t}\n\n\t/**\n\t * Adjusts the column so that it is within min/max of the line.\n\t*/\n\tprivate static clipPositionColumn(position: Position, model: ICursorSimpleModel): Position {\n\t\treturn new Position(\n\t\t\tposition.lineNumber,\n\t\t\tMoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber),\n\t\t\t\tmodel.getLineMaxColumn(position.lineNumber))\n\t\t);\n\t}\n\n\tprivate static clipRange(value: number, min: number, max: number): number {\n\t\tif (value < min) {\n\t\t\treturn min;\n\t\t}\n\t\tif (value > max) {\n\t\t\treturn max;\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic static rightPosition(model: ICursorSimpleModel, lineNumber: number, column: number): Position {\n\t\tif (column < model.getLineMaxColumn(lineNumber)) {\n\t\t\tcolumn = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n\t\t} else if (lineNumber < model.getLineCount()) {\n\t\t\tlineNumber = lineNumber + 1;\n\t\t\tcolumn = model.getLineMinColumn(lineNumber);\n\t\t}\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic static rightPositionAtomicSoftTabs(model: ICursorSimpleModel, lineNumber: number, column: number, tabSize: number, indentSize: number): Position {\n\t\tif (column < model.getLineIndentColumn(lineNumber)) {\n\t\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\t\tconst newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, Direction.Right);\n\t\t\tif (newPosition !== -1) {\n\t\t\t\treturn new Position(lineNumber, newPosition + 1);\n\t\t\t}\n\t\t}\n\t\treturn this.rightPosition(model, lineNumber, column);\n\t}\n\n\tpublic static right(config: CursorConfiguration, model: ICursorSimpleModel, position: Position): CursorPosition {\n\t\tconst pos = config.stickyTabStops\n\t\t\t? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n\t\t\t: MoveOperations.rightPosition(model, position.lineNumber, position.column);\n\t\treturn new CursorPosition(pos.lineNumber, pos.column, 0);\n\t}\n\n\tpublic static moveRight(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, noOfColumns: number): SingleCursorState {\n\t\tlet lineNumber: number,\n\t\t\tcolumn: number;\n\n\t\tif (cursor.hasSelection() && !inSelectionMode) {\n\t\t\t// If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n\t\t\tlineNumber = cursor.selection.endLineNumber;\n\t\t\tcolumn = cursor.selection.endColumn;\n\t\t} else {\n\t\t\tconst pos = cursor.position.delta(undefined, noOfColumns - 1);\n\t\t\tconst normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), PositionAffinity.Right);\n\t\t\tconst r = MoveOperations.right(config, model, normalizedPos);\n\t\t\tlineNumber = r.lineNumber;\n\t\t\tcolumn = r.column;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, column, 0);\n\t}\n\n\tpublic static vertical(config: CursorConfiguration, model: ICursorSimpleModel, lineNumber: number, column: number, leftoverVisibleColumns: number, newLineNumber: number, allowMoveOnEdgeLine: boolean, normalizationAffinity?: PositionAffinity): CursorPosition {\n\t\tconst currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n\t\tconst lineCount = model.getLineCount();\n\t\tconst wasOnFirstPosition = (lineNumber === 1 && column === 1);\n\t\tconst wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n\t\tconst wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n\n\t\tlineNumber = newLineNumber;\n\t\tif (lineNumber < 1) {\n\t\t\tlineNumber = 1;\n\t\t\tif (allowMoveOnEdgeLine) {\n\t\t\t\tcolumn = model.getLineMinColumn(lineNumber);\n\t\t\t} else {\n\t\t\t\tcolumn = Math.min(model.getLineMaxColumn(lineNumber), column);\n\t\t\t}\n\t\t} else if (lineNumber > lineCount) {\n\t\t\tlineNumber = lineCount;\n\t\t\tif (allowMoveOnEdgeLine) {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t} else {\n\t\t\t\tcolumn = Math.min(model.getLineMaxColumn(lineNumber), column);\n\t\t\t}\n\t\t} else {\n\t\t\tcolumn = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n\t\t}\n\n\t\tif (wasAtEdgePosition) {\n\t\t\tleftoverVisibleColumns = 0;\n\t\t} else {\n\t\t\tleftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n\t\t}\n\n\t\tif (normalizationAffinity !== undefined) {\n\t\t\tconst position = new Position(lineNumber, column);\n\t\t\tconst newPosition = model.normalizePosition(position, normalizationAffinity);\n\t\t\tleftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n\t\t\tlineNumber = newPosition.lineNumber;\n\t\t\tcolumn = newPosition.column;\n\t\t}\n\t\treturn new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n\t}\n\n\tpublic static down(config: CursorConfiguration, model: ICursorSimpleModel, lineNumber: number, column: number, leftoverVisibleColumns: number, count: number, allowMoveOnLastLine: boolean): CursorPosition {\n\t\treturn this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, PositionAffinity.RightOfInjectedText);\n\t}\n\n\tpublic static moveDown(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, linesCount: number): SingleCursorState {\n\t\tlet lineNumber: number,\n\t\t\tcolumn: number;\n\n\t\tif (cursor.hasSelection() && !inSelectionMode) {\n\t\t\t// If we are in selection mode, move down acts relative to the end of selection\n\t\t\tlineNumber = cursor.selection.endLineNumber;\n\t\t\tcolumn = cursor.selection.endColumn;\n\t\t} else {\n\t\t\tlineNumber = cursor.position.lineNumber;\n\t\t\tcolumn = cursor.position.column;\n\t\t}\n\n\t\tlet i = 0;\n\t\tlet r: CursorPosition;\n\t\tdo {\n\t\t\tr = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n\t\t\tconst np = model.normalizePosition(new Position(r.lineNumber, r.column), PositionAffinity.None);\n\t\t\tif (np.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (i++ < 10 && lineNumber + i < model.getLineCount());\n\n\t\treturn cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n\t}\n\n\tpublic static translateDown(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState): SingleCursorState {\n\t\tconst selection = cursor.selection;\n\n\t\tconst selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n\t\tconst position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n\n\t\treturn new SingleCursorState(\n\t\t\tnew Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column),\n\t\t\tSelectionStartKind.Simple,\n\t\t\tselectionStart.leftoverVisibleColumns,\n\t\t\tnew Position(position.lineNumber, position.column),\n\t\t\tposition.leftoverVisibleColumns\n\t\t);\n\t}\n\n\tpublic static up(config: CursorConfiguration, model: ICursorSimpleModel, lineNumber: number, column: number, leftoverVisibleColumns: number, count: number, allowMoveOnFirstLine: boolean): CursorPosition {\n\t\treturn this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, PositionAffinity.LeftOfInjectedText);\n\t}\n\n\tpublic static moveUp(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, linesCount: number): SingleCursorState {\n\t\tlet lineNumber: number,\n\t\t\tcolumn: number;\n\n\t\tif (cursor.hasSelection() && !inSelectionMode) {\n\t\t\t// If we are in selection mode, move up acts relative to the beginning of selection\n\t\t\tlineNumber = cursor.selection.startLineNumber;\n\t\t\tcolumn = cursor.selection.startColumn;\n\t\t} else {\n\t\t\tlineNumber = cursor.position.lineNumber;\n\t\t\tcolumn = cursor.position.column;\n\t\t}\n\n\t\tconst r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n\n\t\treturn cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n\t}\n\n\tpublic static translateUp(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState): SingleCursorState {\n\n\t\tconst selection = cursor.selection;\n\n\t\tconst selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n\t\tconst position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n\n\t\treturn new SingleCursorState(\n\t\t\tnew Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column),\n\t\t\tSelectionStartKind.Simple,\n\t\t\tselectionStart.leftoverVisibleColumns,\n\t\t\tnew Position(position.lineNumber, position.column),\n\t\t\tposition.leftoverVisibleColumns\n\t\t);\n\t}\n\n\tprivate static _isBlankLine(model: ICursorSimpleModel, lineNumber: number): boolean {\n\t\tif (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n\t\t\t// empty or contains only whitespace\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static moveToPrevBlankLine(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\tlet lineNumber = cursor.position.lineNumber;\n\n\t\t// If our current line is blank, move to the previous non-blank line\n\t\twhile (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n\t\t\tlineNumber--;\n\t\t}\n\n\t\t// Find the previous blank line\n\t\twhile (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n\t\t\tlineNumber--;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n\t}\n\n\tpublic static moveToNextBlankLine(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\tconst lineCount = model.getLineCount();\n\t\tlet lineNumber = cursor.position.lineNumber;\n\n\t\t// If our current line is blank, move to the next non-blank line\n\t\twhile (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n\t\t\tlineNumber++;\n\t\t}\n\n\t\t// Find the next blank line\n\t\twhile (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n\t\t\tlineNumber++;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n\t}\n\n\tpublic static moveToBeginningOfLine(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\tconst lineNumber = cursor.position.lineNumber;\n\t\tconst minColumn = model.getLineMinColumn(lineNumber);\n\t\tconst firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n\n\t\tlet column: number;\n\n\t\tconst relevantColumnNumber = cursor.position.column;\n\t\tif (relevantColumnNumber === firstNonBlankColumn) {\n\t\t\tcolumn = minColumn;\n\t\t} else {\n\t\t\tcolumn = firstNonBlankColumn;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, column, 0);\n\t}\n\n\tpublic static moveToEndOfLine(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, sticky: boolean): SingleCursorState {\n\t\tconst lineNumber = cursor.position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\t\treturn cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? Constants.MAX_SAFE_SMALL_INTEGER - maxColumn : 0);\n\t}\n\n\tpublic static moveToBeginningOfBuffer(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\treturn cursor.move(inSelectionMode, 1, 1, 0);\n\t}\n\n\tpublic static moveToEndOfBuffer(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\tconst lastLineNumber = model.getLineCount();\n\t\tconst lastColumn = model.getLineMaxColumn(lastLineNumber);\n\n\t\treturn cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport { Constants } from '../../../base/common/uint.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations, Direction } from './cursorAtomicMoveOperations.js';\nimport { CursorConfiguration, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { PositionAffinity } from '../model.js';\n\nexport class CursorPosition {\n\t_cursorPositionBrand: void = undefined;\n\n\tpublic readonly lineNumber: number;\n\tpublic readonly column: number;\n\tpublic readonly leftoverVisibleColumns: number;\n\n\tconstructor(lineNumber: number, column: number, leftoverVisibleColumns: number) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.column = column;\n\t\tthis.leftoverVisibleColumns = leftoverVisibleColumns;\n\t}\n}\n\nexport class MoveOperations {\n\tpublic static leftPosition(model: ICursorSimpleModel, position: Position): Position {\n\t\tif (position.column > model.getLineMinColumn(position.lineNumber)) {\n\t\t\treturn position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n\t\t} else if (position.lineNumber > 1) {\n\t\t\tconst newLineNumber = position.lineNumber - 1;\n\t\t\treturn new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n\t\t} else {\n\t\t\treturn position;\n\t\t}\n\t}\n\n\tprivate static leftPositionAtomicSoftTabs(model: ICursorSimpleModel, position: Position, tabSize: number): Position {\n\t\tif (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n\t\t\tconst minColumn = model.getLineMinColumn(position.lineNumber);\n\t\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\t\tconst newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, Direction.Left);\n\t\t\tif (newPosition !== -1 && newPosition + 1 >= minColumn) {\n\t\t\t\treturn new Position(position.lineNumber, newPosition + 1);\n\t\t\t}\n\t\t}\n\t\treturn this.leftPosition(model, position);\n\t}\n\n\tprivate static left(config: CursorConfiguration, model: ICursorSimpleModel, position: Position): CursorPosition {\n\t\tconst pos = config.stickyTabStops\n\t\t\t? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n\t\t\t: MoveOperations.leftPosition(model, position);\n\t\treturn new CursorPosition(pos.lineNumber, pos.column, 0);\n\t}\n\n\t/**\n\t * @param noOfColumns Must be either `1`\n\t * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n\t*/\n\tpublic static moveLeft(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, noOfColumns: number): SingleCursorState {\n\t\tlet lineNumber: number,\n\t\t\tcolumn: number;\n\n\t\tif (cursor.hasSelection() && !inSelectionMode) {\n\t\t\t// If the user has a selection and does not want to extend it,\n\t\t\t// put the cursor at the beginning of the selection.\n\t\t\tlineNumber = cursor.selection.startLineNumber;\n\t\t\tcolumn = cursor.selection.startColumn;\n\t\t} else {\n\t\t\t// This has no effect if noOfColumns === 1.\n\t\t\t// It is ok to do so in the half-line scenario.\n\t\t\tconst pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n\t\t\t// We clip the position before normalization, as normalization is not defined\n\t\t\t// for possibly negative columns.\n\t\t\tconst normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), PositionAffinity.Left);\n\t\t\tconst p = MoveOperations.left(config, model, normalizedPos);\n\n\t\t\tlineNumber = p.lineNumber;\n\t\t\tcolumn = p.column;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, column, 0);\n\t}\n\n\t/**\n\t * Adjusts the column so that it is within min/max of the line.\n\t*/\n\tprivate static clipPositionColumn(position: Position, model: ICursorSimpleModel): Position {\n\t\treturn new Position(\n\t\t\tposition.lineNumber,\n\t\t\tMoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber),\n\t\t\t\tmodel.getLineMaxColumn(position.lineNumber))\n\t\t);\n\t}\n\n\tprivate static clipRange(value: number, min: number, max: number): number {\n\t\tif (value < min) {\n\t\t\treturn min;\n\t\t}\n\t\tif (value > max) {\n\t\t\treturn max;\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic static rightPosition(model: ICursorSimpleModel, lineNumber: number, column: number): Position {\n\t\tif (column < model.getLineMaxColumn(lineNumber)) {\n\t\t\tcolumn = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n\t\t} else if (lineNumber < model.getLineCount()) {\n\t\t\tlineNumber = lineNumber + 1;\n\t\t\tcolumn = model.getLineMinColumn(lineNumber);\n\t\t}\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic static rightPositionAtomicSoftTabs(model: ICursorSimpleModel, lineNumber: number, column: number, tabSize: number, indentSize: number): Position {\n\t\tif (column < model.getLineIndentColumn(lineNumber)) {\n\t\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\t\tconst newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, Direction.Right);\n\t\t\tif (newPosition !== -1) {\n\t\t\t\treturn new Position(lineNumber, newPosition + 1);\n\t\t\t}\n\t\t}\n\t\treturn this.rightPosition(model, lineNumber, column);\n\t}\n\n\tpublic static right(config: CursorConfiguration, model: ICursorSimpleModel, position: Position): CursorPosition {\n\t\tconst pos = config.stickyTabStops\n\t\t\t? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n\t\t\t: MoveOperations.rightPosition(model, position.lineNumber, position.column);\n\t\treturn new CursorPosition(pos.lineNumber, pos.column, 0);\n\t}\n\n\tpublic static moveRight(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, noOfColumns: number): SingleCursorState {\n\t\tlet lineNumber: number,\n\t\t\tcolumn: number;\n\n\t\tif (cursor.hasSelection() && !inSelectionMode) {\n\t\t\t// If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n\t\t\tlineNumber = cursor.selection.endLineNumber;\n\t\t\tcolumn = cursor.selection.endColumn;\n\t\t} else {\n\t\t\tconst pos = cursor.position.delta(undefined, noOfColumns - 1);\n\t\t\tconst normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), PositionAffinity.Right);\n\t\t\tconst r = MoveOperations.right(config, model, normalizedPos);\n\t\t\tlineNumber = r.lineNumber;\n\t\t\tcolumn = r.column;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, column, 0);\n\t}\n\n\tpublic static vertical(config: CursorConfiguration, model: ICursorSimpleModel, lineNumber: number, column: number, leftoverVisibleColumns: number, newLineNumber: number, allowMoveOnEdgeLine: boolean, normalizationAffinity?: PositionAffinity): CursorPosition {\n\t\tconst currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n\t\tconst lineCount = model.getLineCount();\n\t\tconst wasOnFirstPosition = (lineNumber === 1 && column === 1);\n\t\tconst wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n\t\tconst wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n\n\t\tlineNumber = newLineNumber;\n\t\tif (lineNumber < 1) {\n\t\t\tlineNumber = 1;\n\t\t\tif (allowMoveOnEdgeLine) {\n\t\t\t\tcolumn = model.getLineMinColumn(lineNumber);\n\t\t\t} else {\n\t\t\t\tcolumn = Math.min(model.getLineMaxColumn(lineNumber), column);\n\t\t\t}\n\t\t} else if (lineNumber > lineCount) {\n\t\t\tlineNumber = lineCount;\n\t\t\tif (allowMoveOnEdgeLine) {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t} else {\n\t\t\t\tcolumn = Math.min(model.getLineMaxColumn(lineNumber), column);\n\t\t\t}\n\t\t} else {\n\t\t\tcolumn = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n\t\t}\n\n\t\tif (wasAtEdgePosition) {\n\t\t\tleftoverVisibleColumns = 0;\n\t\t} else {\n\t\t\tleftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n\t\t}\n\n\t\tif (normalizationAffinity !== undefined) {\n\t\t\tconst position = new Position(lineNumber, column);\n\t\t\tconst newPosition = model.normalizePosition(position, normalizationAffinity);\n\t\t\tleftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n\t\t\tlineNumber = newPosition.lineNumber;\n\t\t\tcolumn = newPosition.column;\n\t\t}\n\t\treturn new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n\t}\n\n\tpublic static down(config: CursorConfiguration, model: ICursorSimpleModel, lineNumber: number, column: number, leftoverVisibleColumns: number, count: number, allowMoveOnLastLine: boolean): CursorPosition {\n\t\treturn this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, PositionAffinity.RightOfInjectedText);\n\t}\n\n\tpublic static moveDown(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, linesCount: number): SingleCursorState {\n\t\tlet lineNumber: number,\n\t\t\tcolumn: number;\n\n\t\tif (cursor.hasSelection() && !inSelectionMode) {\n\t\t\t// If we are in selection mode, move down acts relative to the end of selection\n\t\t\tlineNumber = cursor.selection.endLineNumber;\n\t\t\tcolumn = cursor.selection.endColumn;\n\t\t} else {\n\t\t\tlineNumber = cursor.position.lineNumber;\n\t\t\tcolumn = cursor.position.column;\n\t\t}\n\n\t\tlet i = 0;\n\t\tlet r: CursorPosition;\n\t\tdo {\n\t\t\tr = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n\t\t\tconst np = model.normalizePosition(new Position(r.lineNumber, r.column), PositionAffinity.None);\n\t\t\tif (np.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (i++ < 10 && lineNumber + i < model.getLineCount());\n\n\t\treturn cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n\t}\n\n\tpublic static translateDown(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState): SingleCursorState {\n\t\tconst selection = cursor.selection;\n\n\t\tconst selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n\t\tconst position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n\n\t\treturn new SingleCursorState(\n\t\t\tnew Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column),\n\t\t\tSelectionStartKind.Simple,\n\t\t\tselectionStart.leftoverVisibleColumns,\n\t\t\tnew Position(position.lineNumber, position.column),\n\t\t\tposition.leftoverVisibleColumns\n\t\t);\n\t}\n\n\tpublic static up(config: CursorConfiguration, model: ICursorSimpleModel, lineNumber: number, column: number, leftoverVisibleColumns: number, count: number, allowMoveOnFirstLine: boolean): CursorPosition {\n\t\treturn this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, PositionAffinity.LeftOfInjectedText);\n\t}\n\n\tpublic static moveUp(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, linesCount: number): SingleCursorState {\n\t\tlet lineNumber: number,\n\t\t\tcolumn: number;\n\n\t\tif (cursor.hasSelection() && !inSelectionMode) {\n\t\t\t// If we are in selection mode, move up acts relative to the beginning of selection\n\t\t\tlineNumber = cursor.selection.startLineNumber;\n\t\t\tcolumn = cursor.selection.startColumn;\n\t\t} else {\n\t\t\tlineNumber = cursor.position.lineNumber;\n\t\t\tcolumn = cursor.position.column;\n\t\t}\n\n\t\tconst r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n\n\t\treturn cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n\t}\n\n\tpublic static translateUp(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState): SingleCursorState {\n\n\t\tconst selection = cursor.selection;\n\n\t\tconst selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n\t\tconst position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n\n\t\treturn new SingleCursorState(\n\t\t\tnew Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column),\n\t\t\tSelectionStartKind.Simple,\n\t\t\tselectionStart.leftoverVisibleColumns,\n\t\t\tnew Position(position.lineNumber, position.column),\n\t\t\tposition.leftoverVisibleColumns\n\t\t);\n\t}\n\n\tprivate static _isBlankLine(model: ICursorSimpleModel, lineNumber: number): boolean {\n\t\tif (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n\t\t\t// empty or contains only whitespace\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static moveToPrevBlankLine(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\tlet lineNumber = cursor.position.lineNumber;\n\n\t\t// If our current line is blank, move to the previous non-blank line\n\t\twhile (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n\t\t\tlineNumber--;\n\t\t}\n\n\t\t// Find the previous blank line\n\t\twhile (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n\t\t\tlineNumber--;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n\t}\n\n\tpublic static moveToNextBlankLine(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\tconst lineCount = model.getLineCount();\n\t\tlet lineNumber = cursor.position.lineNumber;\n\n\t\t// If our current line is blank, move to the next non-blank line\n\t\twhile (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n\t\t\tlineNumber++;\n\t\t}\n\n\t\t// Find the next blank line\n\t\twhile (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n\t\t\tlineNumber++;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n\t}\n\n\tpublic static moveToBeginningOfLine(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\tconst lineNumber = cursor.position.lineNumber;\n\t\tconst minColumn = model.getLineMinColumn(lineNumber);\n\t\tconst firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n\n\t\tlet column: number;\n\n\t\tconst relevantColumnNumber = cursor.position.column;\n\t\tif (relevantColumnNumber === firstNonBlankColumn) {\n\t\t\tcolumn = minColumn;\n\t\t} else {\n\t\t\tcolumn = firstNonBlankColumn;\n\t\t}\n\n\t\treturn cursor.move(inSelectionMode, lineNumber, column, 0);\n\t}\n\n\tpublic static moveToEndOfLine(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, sticky: boolean): SingleCursorState {\n\t\tconst lineNumber = cursor.position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\t\treturn cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? Constants.MAX_SAFE_SMALL_INTEGER - maxColumn : 0);\n\t}\n\n\tpublic static moveToBeginningOfBuffer(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\treturn cursor.move(inSelectionMode, 1, 1, 0);\n\t}\n\n\tpublic static moveToEndOfBuffer(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean): SingleCursorState {\n\t\tconst lastLineNumber = model.getLineCount();\n\t\tconst lastColumn = model.getLineMaxColumn(lastLineNumber);\n\n\t\treturn cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 551, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorDeleteOperations.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorDeleteOperations.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditorAutoClosingEditStrategy, EditorAutoClosingStrategy } from '../config/editorOptions.js';\nimport { CursorConfiguration, EditOperationResult, EditOperationType, ICursorSimpleModel, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ICommand } from '../editorCommon.js';\nimport { StandardAutoClosingPairConditional } from '../languages/languageConfiguration.js';\nimport { Position } from '../core/position.js';\n\nexport class DeleteOperations {\n\n\tpublic static deleteRight(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): [boolean, Array<ICommand | null>] {\n\t\tconst commands: Array<ICommand | null> = [];\n\t\tlet shouldPushStackElementBefore = (prevEditOperationType !== EditOperationType.DeletingRight);\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tconst deleteSelection = this.getDeleteRightRange(selection, model, config);\n\n\t\t\tif (deleteSelection.isEmpty()) {\n\t\t\t\t// Probably at end of file => ignore\n\t\t\t\tcommands[i] = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n\t\t\t\tshouldPushStackElementBefore = true;\n\t\t\t}\n\n\t\t\tcommands[i] = new ReplaceCommand(deleteSelection, '');\n\t\t}\n\t\treturn [shouldPushStackElementBefore, commands];\n\t}\n\n\tprivate static getDeleteRightRange(selection: Selection, model: ICursorSimpleModel, config: CursorConfiguration): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = selection.getPosition();\n\t\tconst rightOfPosition = MoveOperations.right(config, model, position);\n\n\t\tif (config.trimWhitespaceOnDelete && rightOfPosition.lineNumber !== position.lineNumber) {\n\t\t\t// Smart line join (deleting leading whitespace) is on\n\t\t\t// (and) Delete is happening at the end of a line\n\t\t\tconst currentLineHasContent = (model.getLineFirstNonWhitespaceColumn(position.lineNumber) > 0);\n\t\t\tconst firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(rightOfPosition.lineNumber);\n\t\t\tif (currentLineHasContent && firstNonWhitespaceColumn > 0) {\n\t\t\t\t// The next line has content\n\t\t\t\treturn new Range(\n\t\t\t\t\trightOfPosition.lineNumber,\n\t\t\t\t\tfirstNonWhitespaceColumn,\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\tposition.column\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(\n\t\t\trightOfPosition.lineNumber,\n\t\t\trightOfPosition.column,\n\t\t\tposition.lineNumber,\n\t\t\tposition.column\n\t\t);\n\t}\n\n\tpublic static isAutoClosingPairDelete(\n\t\tautoClosingDelete: EditorAutoClosingEditStrategy,\n\t\tautoClosingBrackets: EditorAutoClosingStrategy,\n\t\tautoClosingQuotes: EditorAutoClosingStrategy,\n\t\tautoClosingPairsOpen: Map<string, StandardAutoClosingPairConditional[]>,\n\t\tmodel: ICursorSimpleModel,\n\t\tselections: Selection[],\n\t\tautoClosedCharacters: Range[]\n\t): boolean {\n\t\tif (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n\t\t\treturn false;\n\t\t}\n\t\tif (autoClosingDelete === 'never') {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\n\t\t\tif (!selection.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\t\tif (position.column < 2 || position.column >= lineText.length + 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst character = lineText.charAt(position.column - 2);\n\n\t\t\tconst autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n\t\t\tif (!autoClosingPairCandidates) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (isQuote(character)) {\n\t\t\t\tif (autoClosingQuotes === 'never') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (autoClosingBrackets === 'never') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst afterCharacter = lineText.charAt(position.column - 1);\n\n\t\t\tlet foundAutoClosingPair = false;\n\t\t\tfor (const autoClosingPairCandidate of autoClosingPairCandidates) {\n\t\t\t\tif (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n\t\t\t\t\tfoundAutoClosingPair = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!foundAutoClosingPair) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Must delete the pair only if it was automatically inserted by the editor\n\t\t\tif (autoClosingDelete === 'auto') {\n\t\t\t\tlet found = false;\n\t\t\t\tfor (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n\t\t\t\t\tconst autoClosedCharacter = autoClosedCharacters[j];\n\t\t\t\t\tif (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static _runAutoClosingPairDelete(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): [boolean, ICommand[]] {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst position = selections[i].getPosition();\n\t\t\tconst deleteSelection = new Range(\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column - 1,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column + 1\n\t\t\t);\n\t\t\tcommands[i] = new ReplaceCommand(deleteSelection, '');\n\t\t}\n\t\treturn [true, commands];\n\t}\n\n\tpublic static deleteLeft(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], autoClosedCharacters: Range[]): [boolean, Array<ICommand | null>] {\n\t\tif (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n\t\t\treturn this._runAutoClosingPairDelete(config, model, selections);\n\t\t}\n\n\t\tconst commands: Array<ICommand | null> = [];\n\t\tlet shouldPushStackElementBefore = (prevEditOperationType !== EditOperationType.DeletingLeft);\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst deleteRange = DeleteOperations.getDeleteLeftRange(selections[i], model, config);\n\n\t\t\t// Ignore empty delete ranges, as they have no effect\n\t\t\t// They happen if the cursor is at the beginning of the file.\n\t\t\tif (deleteRange.isEmpty()) {\n\t\t\t\tcommands[i] = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n\t\t\t\tshouldPushStackElementBefore = true;\n\t\t\t}\n\n\t\t\tcommands[i] = new ReplaceCommand(deleteRange, '');\n\t\t}\n\t\treturn [shouldPushStackElementBefore, commands];\n\n\t}\n\n\tprivate static getDeleteLeftRange(selection: Selection, model: ICursorSimpleModel, config: CursorConfiguration): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = selection.getPosition();\n\n\t\t// Unintend when using tab stops and cursor is within indentation\n\t\tif (config.useTabStops && position.column > 1) {\n\t\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\n\t\t\tconst firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\t\t\tconst lastIndentationColumn = (\n\t\t\t\tfirstNonWhitespaceIndex === -1\n\t\t\t\t\t? /* entire string is whitespace */ lineContent.length + 1\n\t\t\t\t\t: firstNonWhitespaceIndex + 1\n\t\t\t);\n\n\t\t\tif (position.column <= lastIndentationColumn) {\n\t\t\t\tconst fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n\t\t\t\tconst toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n\t\t\t\tconst toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n\t\t\t\treturn new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n\t\t\t}\n\t\t}\n\n\t\treturn Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n\t}\n\n\tprivate static getPositionAfterDeleteLeft(position: Position, model: ICursorSimpleModel): Position {\n\t\tif (position.column > 1) {\n\t\t\t// Convert 1-based columns to 0-based offsets and back.\n\t\t\tconst idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n\t\t\treturn position.with(undefined, idx + 1);\n\t\t} else if (position.lineNumber > 1) {\n\t\t\tconst newLine = position.lineNumber - 1;\n\t\t\treturn new Position(newLine, model.getLineMaxColumn(newLine));\n\t\t} else {\n\t\t\treturn position;\n\t\t}\n\t}\n\n\tpublic static cut(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): EditOperationResult {\n\t\tconst commands: Array<ICommand | null> = [];\n\t\tlet lastCutRange: Range | null = null;\n\t\tselections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\tif (config.emptySelectionClipboard) {\n\t\t\t\t\t// This is a full line cut\n\n\t\t\t\t\tconst position = selection.getPosition();\n\n\t\t\t\t\tlet startLineNumber: number,\n\t\t\t\t\t\tstartColumn: number,\n\t\t\t\t\t\tendLineNumber: number,\n\t\t\t\t\t\tendColumn: number;\n\n\t\t\t\t\tif (position.lineNumber < model.getLineCount()) {\n\t\t\t\t\t\t// Cutting a line in the middle of the model\n\t\t\t\t\t\tstartLineNumber = position.lineNumber;\n\t\t\t\t\t\tstartColumn = 1;\n\t\t\t\t\t\tendLineNumber = position.lineNumber + 1;\n\t\t\t\t\t\tendColumn = 1;\n\t\t\t\t\t} else if (position.lineNumber > 1 && lastCutRange?.endLineNumber !== position.lineNumber) {\n\t\t\t\t\t\t// Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n\t\t\t\t\t\tstartLineNumber = position.lineNumber - 1;\n\t\t\t\t\t\tstartColumn = model.getLineMaxColumn(position.lineNumber - 1);\n\t\t\t\t\t\tendLineNumber = position.lineNumber;\n\t\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Cutting the single line that the model contains\n\t\t\t\t\t\tstartLineNumber = position.lineNumber;\n\t\t\t\t\t\tstartColumn = 1;\n\t\t\t\t\t\tendLineNumber = position.lineNumber;\n\t\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst deleteSelection = new Range(\n\t\t\t\t\t\tstartLineNumber,\n\t\t\t\t\t\tstartColumn,\n\t\t\t\t\t\tendLineNumber,\n\t\t\t\t\t\tendColumn\n\t\t\t\t\t);\n\t\t\t\t\tlastCutRange = deleteSelection;\n\n\t\t\t\t\tif (!deleteSelection.isEmpty()) {\n\t\t\t\t\t\tcommands[i] = new ReplaceCommand(deleteSelection, '');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands[i] = null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Cannot cut empty selection\n\t\t\t\t\tcommands[i] = null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands[i] = new ReplaceCommand(selection, '');\n\t\t\t}\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditorAutoClosingEditStrategy, EditorAutoClosingStrategy } from '../config/editorOptions.js';\nimport { CursorConfiguration, EditOperationResult, EditOperationType, ICursorSimpleModel, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ICommand } from '../editorCommon.js';\nimport { StandardAutoClosingPairConditional } from '../languages/languageConfiguration.js';\nimport { Position } from '../core/position.js';\n\nexport class DeleteOperations {\n\n\tpublic static deleteRight(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): [boolean, Array<ICommand | null>] {\n\t\tconst commands: Array<ICommand | null> = [];\n\t\tlet shouldPushStackElementBefore = (prevEditOperationType !== EditOperationType.DeletingRight);\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tconst deleteSelection = this.getDeleteRightRange(selection, model, config);\n\n\t\t\tif (deleteSelection.isEmpty()) {\n\t\t\t\t// Probably at end of file => ignore\n\t\t\t\tcommands[i] = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n\t\t\t\tshouldPushStackElementBefore = true;\n\t\t\t}\n\n\t\t\tcommands[i] = new ReplaceCommand(deleteSelection, '');\n\t\t}\n\t\treturn [shouldPushStackElementBefore, commands];\n\t}\n\n\tprivate static getDeleteRightRange(selection: Selection, model: ICursorSimpleModel, config: CursorConfiguration): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = selection.getPosition();\n\t\tconst rightOfPosition = MoveOperations.right(config, model, position);\n\n\t\tif (config.trimWhitespaceOnDelete && rightOfPosition.lineNumber !== position.lineNumber) {\n\t\t\t// Smart line join (deleting leading whitespace) is on\n\t\t\t// (and) Delete is happening at the end of a line\n\t\t\tconst currentLineHasContent = (model.getLineFirstNonWhitespaceColumn(position.lineNumber) > 0);\n\t\t\tconst firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(rightOfPosition.lineNumber);\n\t\t\tif (currentLineHasContent && firstNonWhitespaceColumn > 0) {\n\t\t\t\t// The next line has content\n\t\t\t\treturn new Range(\n\t\t\t\t\trightOfPosition.lineNumber,\n\t\t\t\t\tfirstNonWhitespaceColumn,\n\t\t\t\t\tposition.lineNumber,\n\t\t\t\t\tposition.column\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(\n\t\t\trightOfPosition.lineNumber,\n\t\t\trightOfPosition.column,\n\t\t\tposition.lineNumber,\n\t\t\tposition.column\n\t\t);\n\t}\n\n\tpublic static isAutoClosingPairDelete(\n\t\tautoClosingDelete: EditorAutoClosingEditStrategy,\n\t\tautoClosingBrackets: EditorAutoClosingStrategy,\n\t\tautoClosingQuotes: EditorAutoClosingStrategy,\n\t\tautoClosingPairsOpen: Map<string, StandardAutoClosingPairConditional[]>,\n\t\tmodel: ICursorSimpleModel,\n\t\tselections: Selection[],\n\t\tautoClosedCharacters: Range[]\n\t): boolean {\n\t\tif (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n\t\t\treturn false;\n\t\t}\n\t\tif (autoClosingDelete === 'never') {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\n\t\t\tif (!selection.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\t\tif (position.column < 2 || position.column >= lineText.length + 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst character = lineText.charAt(position.column - 2);\n\n\t\t\tconst autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n\t\t\tif (!autoClosingPairCandidates) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (isQuote(character)) {\n\t\t\t\tif (autoClosingQuotes === 'never') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (autoClosingBrackets === 'never') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst afterCharacter = lineText.charAt(position.column - 1);\n\n\t\t\tlet foundAutoClosingPair = false;\n\t\t\tfor (const autoClosingPairCandidate of autoClosingPairCandidates) {\n\t\t\t\tif (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n\t\t\t\t\tfoundAutoClosingPair = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!foundAutoClosingPair) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Must delete the pair only if it was automatically inserted by the editor\n\t\t\tif (autoClosingDelete === 'auto') {\n\t\t\t\tlet found = false;\n\t\t\t\tfor (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n\t\t\t\t\tconst autoClosedCharacter = autoClosedCharacters[j];\n\t\t\t\t\tif (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static _runAutoClosingPairDelete(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): [boolean, ICommand[]] {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst position = selections[i].getPosition();\n\t\t\tconst deleteSelection = new Range(\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column - 1,\n\t\t\t\tposition.lineNumber,\n\t\t\t\tposition.column + 1\n\t\t\t);\n\t\t\tcommands[i] = new ReplaceCommand(deleteSelection, '');\n\t\t}\n\t\treturn [true, commands];\n\t}\n\n\tpublic static deleteLeft(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], autoClosedCharacters: Range[]): [boolean, Array<ICommand | null>] {\n\t\tif (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n\t\t\treturn this._runAutoClosingPairDelete(config, model, selections);\n\t\t}\n\n\t\tconst commands: Array<ICommand | null> = [];\n\t\tlet shouldPushStackElementBefore = (prevEditOperationType !== EditOperationType.DeletingLeft);\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst deleteRange = DeleteOperations.getDeleteLeftRange(selections[i], model, config);\n\n\t\t\t// Ignore empty delete ranges, as they have no effect\n\t\t\t// They happen if the cursor is at the beginning of the file.\n\t\t\tif (deleteRange.isEmpty()) {\n\t\t\t\tcommands[i] = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n\t\t\t\tshouldPushStackElementBefore = true;\n\t\t\t}\n\n\t\t\tcommands[i] = new ReplaceCommand(deleteRange, '');\n\t\t}\n\t\treturn [shouldPushStackElementBefore, commands];\n\n\t}\n\n\tprivate static getDeleteLeftRange(selection: Selection, model: ICursorSimpleModel, config: CursorConfiguration): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = selection.getPosition();\n\n\t\t// Unintend when using tab stops and cursor is within indentation\n\t\tif (config.useTabStops && position.column > 1) {\n\t\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\n\t\t\tconst firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\t\t\tconst lastIndentationColumn = (\n\t\t\t\tfirstNonWhitespaceIndex === -1\n\t\t\t\t\t? /* entire string is whitespace */ lineContent.length + 1\n\t\t\t\t\t: firstNonWhitespaceIndex + 1\n\t\t\t);\n\n\t\t\tif (position.column <= lastIndentationColumn) {\n\t\t\t\tconst fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n\t\t\t\tconst toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n\t\t\t\tconst toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n\t\t\t\treturn new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n\t\t\t}\n\t\t}\n\n\t\treturn Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n\t}\n\n\tprivate static getPositionAfterDeleteLeft(position: Position, model: ICursorSimpleModel): Position {\n\t\tif (position.column > 1) {\n\t\t\t// Convert 1-based columns to 0-based offsets and back.\n\t\t\tconst idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n\t\t\treturn position.with(undefined, idx + 1);\n\t\t} else if (position.lineNumber > 1) {\n\t\t\tconst newLine = position.lineNumber - 1;\n\t\t\treturn new Position(newLine, model.getLineMaxColumn(newLine));\n\t\t} else {\n\t\t\treturn position;\n\t\t}\n\t}\n\n\tpublic static cut(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): EditOperationResult {\n\t\tconst commands: Array<ICommand | null> = [];\n\t\tlet lastCutRange: Range | null = null;\n\t\tselections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\tif (config.emptySelectionClipboard) {\n\t\t\t\t\t// This is a full line cut\n\n\t\t\t\t\tconst position = selection.getPosition();\n\n\t\t\t\t\tlet startLineNumber: number,\n\t\t\t\t\t\tstartColumn: number,\n\t\t\t\t\t\tendLineNumber: number,\n\t\t\t\t\t\tendColumn: number;\n\n\t\t\t\t\tif (position.lineNumber < model.getLineCount()) {\n\t\t\t\t\t\t// Cutting a line in the middle of the model\n\t\t\t\t\t\tstartLineNumber = position.lineNumber;\n\t\t\t\t\t\tstartColumn = 1;\n\t\t\t\t\t\tendLineNumber = position.lineNumber + 1;\n\t\t\t\t\t\tendColumn = 1;\n\t\t\t\t\t} else if (position.lineNumber > 1 && lastCutRange?.endLineNumber !== position.lineNumber) {\n\t\t\t\t\t\t// Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n\t\t\t\t\t\tstartLineNumber = position.lineNumber - 1;\n\t\t\t\t\t\tstartColumn = model.getLineMaxColumn(position.lineNumber - 1);\n\t\t\t\t\t\tendLineNumber = position.lineNumber;\n\t\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Cutting the single line that the model contains\n\t\t\t\t\t\tstartLineNumber = position.lineNumber;\n\t\t\t\t\t\tstartColumn = 1;\n\t\t\t\t\t\tendLineNumber = position.lineNumber;\n\t\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst deleteSelection = new Range(\n\t\t\t\t\t\tstartLineNumber,\n\t\t\t\t\t\tstartColumn,\n\t\t\t\t\t\tendLineNumber,\n\t\t\t\t\t\tendColumn\n\t\t\t\t\t);\n\t\t\t\t\tlastCutRange = deleteSelection;\n\n\t\t\t\t\tif (!deleteSelection.isEmpty()) {\n\t\t\t\t\t\tcommands[i] = new ReplaceCommand(deleteSelection, '');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommands[i] = null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Cannot cut empty selection\n\t\t\t\t\tcommands[i] = null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommands[i] = new ReplaceCommand(selection, '');\n\t\t\t}\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 792, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorWordOperations.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorWordOperations.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EditorAutoClosingEditStrategy, EditorAutoClosingStrategy } from '../config/editorOptions.js';\nimport { CursorConfiguration, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { WordCharacterClass, WordCharacterClassifier, IntlWordSegmentData, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ITextModel } from '../model.js';\nimport { IWordAtPosition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from '../languages/languageConfiguration.js';\n\ninterface IFindWordResult {\n\t/**\n\t * The index where the word starts.\n\t */\n\tstart: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\tend: number;\n\t/**\n\t * The word type.\n\t */\n\twordType: WordType;\n\t/**\n\t * The reason the word ended.\n\t */\n\tnextCharClass: WordCharacterClass;\n}\n\nconst enum WordType {\n\tNone = 0,\n\tRegular = 1,\n\tSeparator = 2\n}\n\nexport const enum WordNavigationType {\n\tWordStart = 0,\n\tWordStartFast = 1,\n\tWordEnd = 2,\n\tWordAccessibility = 3 // Respect chrome definition of a word\n}\n\nexport interface DeleteWordContext {\n\twordSeparators: WordCharacterClassifier;\n\tmodel: ITextModel;\n\tselection: Selection;\n\twhitespaceHeuristics: boolean;\n\tautoClosingDelete: EditorAutoClosingEditStrategy;\n\tautoClosingBrackets: EditorAutoClosingStrategy;\n\tautoClosingQuotes: EditorAutoClosingStrategy;\n\tautoClosingPairs: AutoClosingPairs;\n\tautoClosedCharacters: Range[];\n}\n\nexport class WordOperations {\n\n\tprivate static _createWord(lineContent: string, wordType: WordType, nextCharClass: WordCharacterClass, start: number, end: number): IFindWordResult {\n\t\t// console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n\t\treturn { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _createIntlWord(intlWord: IntlWordSegmentData, nextCharClass: WordCharacterClass): IFindWordResult {\n\t\t// console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n\t\treturn { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: WordType.Regular, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _findPreviousWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindPreviousWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n\n\t\tfor (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(previousIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findEndOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n\n\t\tconst len = lineContent.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprivate static _findNextWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindNextWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\t\tconst len = lineContent.length;\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n\n\t\tfor (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(nextIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findStartOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n\n\t\tfor (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static moveWordLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType, hasMulticursor: boolean): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (column === 1) {\n\t\t\tif (lineNumber > 1) {\n\t\t\t\tlineNumber = lineNumber - 1;\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordStartFast) {\n\t\t\tif (\n\t\t\t\t!hasMulticursor // avoid having multiple cursors stop at different locations when doing word start\n\t\t\t\t&& prevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t\t&& prevWordOnLine.end - prevWordOnLine.start === 1\n\t\t\t\t&& prevWordOnLine.nextCharClass === WordCharacterClass.Regular\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\twhile (\n\t\t\t\tprevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t) {\n\t\t\t\t// Skip over words made up of only separators\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\t// We are stopping at the ending of words\n\n\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t}\n\n\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n\t}\n\n\tpublic static _moveWordPartLeft(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === 1) {\n\t\t\treturn (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column - 1; column > 1; column--) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left === CharCode.Underline && right !== CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left === CharCode.Dash && right !== CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, 1);\n\t}\n\n\tpublic static moveWordRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tlet movedDown = false;\n\t\tif (column === model.getLineMaxColumn(lineNumber)) {\n\t\t\tif (lineNumber < model.getLineCount()) {\n\t\t\t\tmovedDown = true;\n\t\t\t\tlineNumber = lineNumber + 1;\n\t\t\t\tcolumn = 1;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine && nextWordOnLine.wordType === WordType.Separator) {\n\t\t\t\tif (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === WordCharacterClass.Regular) {\n\t\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else if (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\tif (movedDown) {\n\t\t\t\t// If we move to the next line, pretend that the cursor is right before the first character.\n\t\t\t\t// This is needed when the first word starts right at the first character - and in order not to miss it,\n\t\t\t\t// we need to start before.\n\t\t\t\tcolumn = 0;\n\t\t\t}\n\n\t\t\twhile (\n\t\t\t\tnextWordOnLine\n\t\t\t\t&& (nextWordOnLine.wordType === WordType.Separator\n\t\t\t\t\t|| nextWordOnLine.start + 1 <= column\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator\n\t\t\t\t// Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic static _moveWordPartRight(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === maxColumn) {\n\t\t\treturn (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column + 1; column < maxColumn; column++) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left !== CharCode.Underline && right === CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left !== CharCode.Dash && right === CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, maxColumn);\n\t}\n\n\tprotected static _deleteWordLeftWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 2;\n\t\tconst lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n\t\tif (lastNonWhitespace + 1 < startIndex) {\n\t\t\treturn new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordLeft(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tif (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n\t\t\tconst position = ctx.selection.getPosition();\n\t\t\treturn new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (lineNumber === 1 && column === 1) {\n\t\t\t// Ignore deleting at beginning of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordLeftWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static deleteInsideWord(wordSeparators: WordCharacterClassifier, model: ITextModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tconst r = this._deleteInsideWordWhitespace(model, position);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\treturn this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n\t}\n\n\tprivate static _charAtIsWhitespace(str: string, index: number): boolean {\n\t\tconst charCode = str.charCodeAt(index);\n\t\treturn (charCode === CharCode.Space || charCode === CharCode.Tab);\n\t}\n\n\tprivate static _deleteInsideWordWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineContentLength = lineContent.length;\n\n\t\tif (lineContentLength === 0) {\n\t\t\t// empty line\n\t\t\treturn null;\n\t\t}\n\n\t\tlet leftIndex = Math.max(position.column - 2, 0);\n\t\tif (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n\t\t\t// touches a non-whitespace character to the left\n\t\t\treturn null;\n\t\t}\n\n\t\tlet rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n\t\tif (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n\t\t\t// touches a non-whitespace character to the right\n\t\t\treturn null;\n\t\t}\n\n\t\t// walk over whitespace to the left\n\t\twhile (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n\t\t\tleftIndex--;\n\t\t}\n\n\t\t// walk over whitespace to the right\n\t\twhile (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n\t\t\trightIndex++;\n\t\t}\n\n\t\treturn new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n\t}\n\n\tprivate static _deleteInsideWordDetermineDeleteRange(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Range {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineLength = lineContent.length;\n\t\tif (lineLength === 0) {\n\t\t\t// empty line\n\t\t\tif (position.lineNumber > 1) {\n\t\t\t\treturn new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n\t\t\t} else {\n\t\t\t\tif (position.lineNumber < model.getLineCount()) {\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\t// empty model\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst touchesWord = (word: IFindWordResult) => {\n\t\t\treturn (word.start + 1 <= position.column && position.column <= word.end + 1);\n\t\t};\n\t\tconst createRangeWithPosition = (startColumn: number, endColumn: number) => {\n\t\t\tstartColumn = Math.min(startColumn, position.column);\n\t\t\tendColumn = Math.max(endColumn, position.column);\n\t\t\treturn new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n\t\t};\n\t\tconst deleteWordAndAdjacentWhitespace = (word: IFindWordResult) => {\n\t\t\tlet startColumn = word.start + 1;\n\t\t\tlet endColumn = word.end + 1;\n\t\t\tlet expandedToTheRight = false;\n\t\t\twhile (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n\t\t\t\texpandedToTheRight = true;\n\t\t\t\tendColumn++;\n\t\t\t}\n\t\t\tif (!expandedToTheRight) {\n\t\t\t\twhile (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn createRangeWithPosition(startColumn, endColumn);\n\t\t};\n\n\t\tconst prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWordOnLine && touchesWord(prevWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(prevWordOnLine);\n\t\t}\n\t\tconst nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWordOnLine && touchesWord(nextWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(nextWordOnLine);\n\t\t}\n\t\tif (prevWordOnLine && nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n\t\t}\n\t\tif (prevWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n\t\t}\n\t\tif (nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n\t\t}\n\n\t\treturn createRangeWithPosition(1, lineLength + 1);\n\t}\n\n\tpublic static _deleteWordPartLeft(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartLeft(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _findFirstNonWhitespaceChar(str: string, startIndex: number): number {\n\t\tconst len = str.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst ch = str.charAt(chIndex);\n\t\t\tif (ch !== ' ' && ch !== '\\t') {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprotected static _deleteWordRightWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 1;\n\t\tconst firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n\t\tif (startIndex + 1 < firstNonWhitespace) {\n\t\t\t// bingo\n\t\t\treturn new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordRight(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tconst lineCount = model.getLineCount();\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\t\tif (lineNumber === lineCount && column === maxColumn) {\n\t\t\t// Ignore deleting at end of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordRightWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static _deleteWordPartRight(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartRight(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _createWordAtPosition(model: ITextModel, lineNumber: number, word: IFindWordResult): IWordAtPosition {\n\t\tconst range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n\t\treturn {\n\t\t\tword: model.getValueInRange(range),\n\t\t\tstartColumn: range.startColumn,\n\t\t\tendColumn: range.endColumn\n\t\t};\n\t}\n\n\tpublic static getWordAtPosition(model: ITextModel, _wordSeparators: string, _intlSegmenterLocales: string[], position: Position): IWordAtPosition | null {\n\t\tconst wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n\t\t}\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static word(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, position: Position): SingleCursorState {\n\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (!inSelectionMode) {\n\t\t\t// Entering word selection for the first time\n\t\t\tlet startColumn: number;\n\t\t\tlet endColumn: number;\n\n\t\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\t\t// isTouchingPrevWord\n\t\t\t\tstartColumn = prevWord.start + 1;\n\t\t\t\tendColumn = prevWord.end + 1;\n\t\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\t\t// isTouchingNextWord\n\t\t\t\tstartColumn = nextWord.start + 1;\n\t\t\t\tendColumn = nextWord.end + 1;\n\t\t\t} else {\n\t\t\t\tif (prevWord) {\n\t\t\t\t\tstartColumn = prevWord.end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstartColumn = 1;\n\t\t\t\t}\n\t\t\t\tif (nextWord) {\n\t\t\t\t\tendColumn = nextWord.start + 1;\n\t\t\t\t} else {\n\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SingleCursorState(\n\t\t\t\tnew Range(position.lineNumber, startColumn, position.lineNumber, endColumn), SelectionStartKind.Word, 0,\n\t\t\t\tnew Position(position.lineNumber, endColumn), 0\n\t\t\t);\n\t\t}\n\n\t\tlet startColumn: number;\n\t\tlet endColumn: number;\n\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n\t\t\t// isInsidePrevWord\n\t\t\tstartColumn = prevWord.start + 1;\n\t\t\tendColumn = prevWord.end + 1;\n\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n\t\t\t// isInsideNextWord\n\t\t\tstartColumn = nextWord.start + 1;\n\t\t\tendColumn = nextWord.end + 1;\n\t\t} else {\n\t\t\tstartColumn = position.column;\n\t\t\tendColumn = position.column;\n\t\t}\n\n\t\tconst lineNumber = position.lineNumber;\n\t\tlet column: number;\n\t\tif (cursor.selectionStart.containsPosition(position)) {\n\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t} else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n\t\t\tcolumn = startColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t\t}\n\t\t} else {\n\t\t\tcolumn = endColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.startColumn;\n\t\t\t}\n\t\t}\n\n\t\treturn cursor.move(true, lineNumber, column, 0);\n\t}\n}\n\nexport class WordPartOperations extends WordOperations {\n\tpublic static deleteWordPartLeft(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingEnds);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static deleteWordPartRight(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingStarts);\n\t\treturn candidates[0];\n\t}\n\n\tpublic static moveWordPartLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, hasMulticursor: boolean): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordStart, hasMulticursor),\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordEnd, hasMulticursor),\n\t\t\tWordOperations._moveWordPartLeft(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static moveWordPartRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordStart),\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordEnd),\n\t\t\tWordOperations._moveWordPartRight(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[0];\n\t}\n}\n\nfunction enforceDefined<T>(arr: Array<T | undefined | null>): T[] {\n\treturn <T[]>arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EditorAutoClosingEditStrategy, EditorAutoClosingStrategy } from '../config/editorOptions.js';\nimport { CursorConfiguration, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { WordCharacterClass, WordCharacterClassifier, IntlWordSegmentData, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ITextModel } from '../model.js';\nimport { IWordAtPosition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from '../languages/languageConfiguration.js';\n\ninterface IFindWordResult {\n\t/**\n\t * The index where the word starts.\n\t */\n\tstart: number;\n\t/**\n\t * The index where the word ends.\n\t */\n\tend: number;\n\t/**\n\t * The word type.\n\t */\n\twordType: WordType;\n\t/**\n\t * The reason the word ended.\n\t */\n\tnextCharClass: WordCharacterClass;\n}\n\nconst enum WordType {\n\tNone = 0,\n\tRegular = 1,\n\tSeparator = 2\n}\n\nexport const enum WordNavigationType {\n\tWordStart = 0,\n\tWordStartFast = 1,\n\tWordEnd = 2,\n\tWordAccessibility = 3 // Respect chrome definition of a word\n}\n\nexport interface DeleteWordContext {\n\twordSeparators: WordCharacterClassifier;\n\tmodel: ITextModel;\n\tselection: Selection;\n\twhitespaceHeuristics: boolean;\n\tautoClosingDelete: EditorAutoClosingEditStrategy;\n\tautoClosingBrackets: EditorAutoClosingStrategy;\n\tautoClosingQuotes: EditorAutoClosingStrategy;\n\tautoClosingPairs: AutoClosingPairs;\n\tautoClosedCharacters: Range[];\n}\n\nexport class WordOperations {\n\n\tprivate static _createWord(lineContent: string, wordType: WordType, nextCharClass: WordCharacterClass, start: number, end: number): IFindWordResult {\n\t\t// console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n\t\treturn { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _createIntlWord(intlWord: IntlWordSegmentData, nextCharClass: WordCharacterClass): IFindWordResult {\n\t\t// console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n\t\treturn { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: WordType.Regular, nextCharClass: nextCharClass };\n\t}\n\n\tprivate static _findPreviousWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindPreviousWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n\n\t\tfor (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(previousIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findEndOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n\n\t\tconst len = lineContent.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprivate static _findNextWordOnLine(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): IFindWordResult | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\treturn this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n\t}\n\n\tprivate static _doFindNextWordOnLine(lineContent: string, wordSeparators: WordCharacterClassifier, position: Position): IFindWordResult | null {\n\t\tlet wordType = WordType.None;\n\t\tconst len = lineContent.length;\n\n\t\tconst nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n\n\t\tfor (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (nextIntlWord && chIndex === nextIntlWord.index) {\n\t\t\t\treturn this._createIntlWord(nextIntlWord, chClass);\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Regular) {\n\t\t\t\tif (wordType === WordType.Separator) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Regular;\n\t\t\t} else if (chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\tif (wordType === WordType.Regular) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t\twordType = WordType.Separator;\n\t\t\t} else if (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\tif (wordType !== WordType.None) {\n\t\t\t\t\treturn this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (wordType !== WordType.None) {\n\t\t\treturn this._createWord(lineContent, wordType, WordCharacterClass.Whitespace, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findStartOfWord(lineContent: string, wordSeparators: WordCharacterClassifier, wordType: WordType, startIndex: number): number {\n\n\t\tconst previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n\n\t\tfor (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n\t\t\tconst chCode = lineContent.charCodeAt(chIndex);\n\t\t\tconst chClass = wordSeparators.get(chCode);\n\n\t\t\tif (previousIntlWord && chIndex === previousIntlWord.index) {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\n\t\t\tif (chClass === WordCharacterClass.Whitespace) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Regular && chClass === WordCharacterClass.WordSeparator) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t\tif (wordType === WordType.Separator && chClass === WordCharacterClass.Regular) {\n\t\t\t\treturn chIndex + 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic static moveWordLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType, hasMulticursor: boolean): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (column === 1) {\n\t\t\tif (lineNumber > 1) {\n\t\t\t\tlineNumber = lineNumber - 1;\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordStartFast) {\n\t\t\tif (\n\t\t\t\t!hasMulticursor // avoid having multiple cursors stop at different locations when doing word start\n\t\t\t\t&& prevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t\t&& prevWordOnLine.end - prevWordOnLine.start === 1\n\t\t\t\t&& prevWordOnLine.nextCharClass === WordCharacterClass.Regular\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\tif (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\twhile (\n\t\t\t\tprevWordOnLine\n\t\t\t\t&& prevWordOnLine.wordType === WordType.Separator\n\t\t\t) {\n\t\t\t\t// Skip over words made up of only separators\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\n\t\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n\t\t}\n\n\t\t// We are stopping at the ending of words\n\n\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t}\n\n\t\treturn new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n\t}\n\n\tpublic static _moveWordPartLeft(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === 1) {\n\t\t\treturn (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column - 1; column > 1; column--) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left === CharCode.Underline && right !== CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left === CharCode.Dash && right !== CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, 1);\n\t}\n\n\tpublic static moveWordRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, wordNavigationType: WordNavigationType): Position {\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tlet movedDown = false;\n\t\tif (column === model.getLineMaxColumn(lineNumber)) {\n\t\t\tif (lineNumber < model.getLineCount()) {\n\t\t\t\tmovedDown = true;\n\t\t\t\tlineNumber = lineNumber + 1;\n\t\t\t\tcolumn = 1;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine && nextWordOnLine.wordType === WordType.Separator) {\n\t\t\t\tif (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === WordCharacterClass.Regular) {\n\t\t\t\t\t// Skip over a word made up of one single separator and followed by a regular character\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else if (wordNavigationType === WordNavigationType.WordAccessibility) {\n\t\t\tif (movedDown) {\n\t\t\t\t// If we move to the next line, pretend that the cursor is right before the first character.\n\t\t\t\t// This is needed when the first word starts right at the first character - and in order not to miss it,\n\t\t\t\t// we need to start before.\n\t\t\t\tcolumn = 0;\n\t\t\t}\n\n\t\t\twhile (\n\t\t\t\tnextWordOnLine\n\t\t\t\t&& (nextWordOnLine.wordType === WordType.Separator\n\t\t\t\t\t|| nextWordOnLine.start + 1 <= column\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Skip over a word made up of one single separator\n\t\t\t\t// Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic static _moveWordPartRight(model: ICursorSimpleModel, position: Position): Position {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\n\t\tif (position.column === maxColumn) {\n\t\t\treturn (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n\t\t}\n\n\t\tconst lineContent = model.getLineContent(lineNumber);\n\t\tfor (let column = position.column + 1; column < maxColumn; column++) {\n\t\t\tconst left = lineContent.charCodeAt(column - 2);\n\t\t\tconst right = lineContent.charCodeAt(column - 1);\n\n\t\t\tif (left !== CharCode.Underline && right === CharCode.Underline) {\n\t\t\t\t// snake_case_variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (left !== CharCode.Dash && right === CharCode.Dash) {\n\t\t\t\t// kebab-case-variables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// camelCaseVariables\n\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t}\n\n\t\t\tif (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n\t\t\t\t// thisIsACamelCaseWithOneLetterWords\n\t\t\t\tif (column + 1 < maxColumn) {\n\t\t\t\t\tconst rightRight = lineContent.charCodeAt(column);\n\t\t\t\t\tif (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n\t\t\t\t\t\treturn new Position(lineNumber, column);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, maxColumn);\n\t}\n\n\tprotected static _deleteWordLeftWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 2;\n\t\tconst lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n\t\tif (lastNonWhitespace + 1 < startIndex) {\n\t\t\treturn new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordLeft(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tif (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n\t\t\tconst position = ctx.selection.getPosition();\n\t\t\treturn new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tif (lineNumber === 1 && column === 1) {\n\t\t\t// Ignore deleting at beginning of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordLeftWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordStart) {\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n\t\t\t\tprevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n\t\t\t}\n\t\t\tif (prevWordOnLine) {\n\t\t\t\tcolumn = prevWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column > 1) {\n\t\t\t\t\tcolumn = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber--;\n\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static deleteInsideWord(wordSeparators: WordCharacterClassifier, model: ITextModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tconst r = this._deleteInsideWordWhitespace(model, position);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\treturn this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n\t}\n\n\tprivate static _charAtIsWhitespace(str: string, index: number): boolean {\n\t\tconst charCode = str.charCodeAt(index);\n\t\treturn (charCode === CharCode.Space || charCode === CharCode.Tab);\n\t}\n\n\tprivate static _deleteInsideWordWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineContentLength = lineContent.length;\n\n\t\tif (lineContentLength === 0) {\n\t\t\t// empty line\n\t\t\treturn null;\n\t\t}\n\n\t\tlet leftIndex = Math.max(position.column - 2, 0);\n\t\tif (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n\t\t\t// touches a non-whitespace character to the left\n\t\t\treturn null;\n\t\t}\n\n\t\tlet rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n\t\tif (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n\t\t\t// touches a non-whitespace character to the right\n\t\t\treturn null;\n\t\t}\n\n\t\t// walk over whitespace to the left\n\t\twhile (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n\t\t\tleftIndex--;\n\t\t}\n\n\t\t// walk over whitespace to the right\n\t\twhile (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n\t\t\trightIndex++;\n\t\t}\n\n\t\treturn new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n\t}\n\n\tprivate static _deleteInsideWordDetermineDeleteRange(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Range {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst lineLength = lineContent.length;\n\t\tif (lineLength === 0) {\n\t\t\t// empty line\n\t\t\tif (position.lineNumber > 1) {\n\t\t\t\treturn new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n\t\t\t} else {\n\t\t\t\tif (position.lineNumber < model.getLineCount()) {\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\t// empty model\n\t\t\t\t\treturn new Range(position.lineNumber, 1, position.lineNumber, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst touchesWord = (word: IFindWordResult) => {\n\t\t\treturn (word.start + 1 <= position.column && position.column <= word.end + 1);\n\t\t};\n\t\tconst createRangeWithPosition = (startColumn: number, endColumn: number) => {\n\t\t\tstartColumn = Math.min(startColumn, position.column);\n\t\t\tendColumn = Math.max(endColumn, position.column);\n\t\t\treturn new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n\t\t};\n\t\tconst deleteWordAndAdjacentWhitespace = (word: IFindWordResult) => {\n\t\t\tlet startColumn = word.start + 1;\n\t\t\tlet endColumn = word.end + 1;\n\t\t\tlet expandedToTheRight = false;\n\t\t\twhile (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n\t\t\t\texpandedToTheRight = true;\n\t\t\t\tendColumn++;\n\t\t\t}\n\t\t\tif (!expandedToTheRight) {\n\t\t\t\twhile (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn createRangeWithPosition(startColumn, endColumn);\n\t\t};\n\n\t\tconst prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWordOnLine && touchesWord(prevWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(prevWordOnLine);\n\t\t}\n\t\tconst nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWordOnLine && touchesWord(nextWordOnLine)) {\n\t\t\treturn deleteWordAndAdjacentWhitespace(nextWordOnLine);\n\t\t}\n\t\tif (prevWordOnLine && nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n\t\t}\n\t\tif (prevWordOnLine) {\n\t\t\treturn createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n\t\t}\n\t\tif (nextWordOnLine) {\n\t\t\treturn createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n\t\t}\n\n\t\treturn createRangeWithPosition(1, lineLength + 1);\n\t}\n\n\tpublic static _deleteWordPartLeft(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartLeft(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _findFirstNonWhitespaceChar(str: string, startIndex: number): number {\n\t\tconst len = str.length;\n\t\tfor (let chIndex = startIndex; chIndex < len; chIndex++) {\n\t\t\tconst ch = str.charAt(chIndex);\n\t\t\tif (ch !== ' ' && ch !== '\\t') {\n\t\t\t\treturn chIndex;\n\t\t\t}\n\t\t}\n\t\treturn len;\n\t}\n\n\tprotected static _deleteWordRightWhitespace(model: ICursorSimpleModel, position: Position): Range | null {\n\t\tconst lineContent = model.getLineContent(position.lineNumber);\n\t\tconst startIndex = position.column - 1;\n\t\tconst firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n\t\tif (startIndex + 1 < firstNonWhitespace) {\n\t\t\t// bingo\n\t\t\treturn new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static deleteWordRight(ctx: DeleteWordContext, wordNavigationType: WordNavigationType): Range | null {\n\t\tconst wordSeparators = ctx.wordSeparators;\n\t\tconst model = ctx.model;\n\t\tconst selection = ctx.selection;\n\t\tconst whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n\t\tlet lineNumber = position.lineNumber;\n\t\tlet column = position.column;\n\n\t\tconst lineCount = model.getLineCount();\n\t\tconst maxColumn = model.getLineMaxColumn(lineNumber);\n\t\tif (lineNumber === lineCount && column === maxColumn) {\n\t\t\t// Ignore deleting at end of file\n\t\t\treturn null;\n\t\t}\n\n\t\tif (whitespaceHeuristics) {\n\t\t\tconst r = this._deleteWordRightWhitespace(model, position);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tlet nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (wordNavigationType === WordNavigationType.WordEnd) {\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.end + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n\t\t\t}\n\t\t\tif (nextWordOnLine) {\n\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t} else {\n\t\t\t\tif (column < maxColumn || lineNumber === lineCount) {\n\t\t\t\t\tcolumn = maxColumn;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber++;\n\t\t\t\t\tnextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\t\t\t\t\tif (nextWordOnLine) {\n\t\t\t\t\t\tcolumn = nextWordOnLine.start + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn = model.getLineMaxColumn(lineNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Range(lineNumber, column, position.lineNumber, position.column);\n\t}\n\n\tpublic static _deleteWordPartRight(model: ICursorSimpleModel, selection: Selection): Range {\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn selection;\n\t\t}\n\n\t\tconst pos = selection.getPosition();\n\t\tconst toPosition = WordOperations._moveWordPartRight(model, pos);\n\t\treturn new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n\t}\n\n\tprivate static _createWordAtPosition(model: ITextModel, lineNumber: number, word: IFindWordResult): IWordAtPosition {\n\t\tconst range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n\t\treturn {\n\t\t\tword: model.getValueInRange(range),\n\t\t\tstartColumn: range.startColumn,\n\t\t\tendColumn: range.endColumn\n\t\t};\n\t}\n\n\tpublic static getWordAtPosition(model: ITextModel, _wordSeparators: string, _intlSegmenterLocales: string[], position: Position): IWordAtPosition | null {\n\t\tconst wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n\t\t}\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\t\tif (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\treturn WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static word(config: CursorConfiguration, model: ICursorSimpleModel, cursor: SingleCursorState, inSelectionMode: boolean, position: Position): SingleCursorState {\n\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n\t\tconst prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\t\tconst nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n\t\tif (!inSelectionMode) {\n\t\t\t// Entering word selection for the first time\n\t\t\tlet startColumn: number;\n\t\t\tlet endColumn: number;\n\n\t\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n\t\t\t\t// isTouchingPrevWord\n\t\t\t\tstartColumn = prevWord.start + 1;\n\t\t\t\tendColumn = prevWord.end + 1;\n\t\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n\t\t\t\t// isTouchingNextWord\n\t\t\t\tstartColumn = nextWord.start + 1;\n\t\t\t\tendColumn = nextWord.end + 1;\n\t\t\t} else {\n\t\t\t\tif (prevWord) {\n\t\t\t\t\tstartColumn = prevWord.end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstartColumn = 1;\n\t\t\t\t}\n\t\t\t\tif (nextWord) {\n\t\t\t\t\tendColumn = nextWord.start + 1;\n\t\t\t\t} else {\n\t\t\t\t\tendColumn = model.getLineMaxColumn(position.lineNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SingleCursorState(\n\t\t\t\tnew Range(position.lineNumber, startColumn, position.lineNumber, endColumn), SelectionStartKind.Word, 0,\n\t\t\t\tnew Position(position.lineNumber, endColumn), 0\n\t\t\t);\n\t\t}\n\n\t\tlet startColumn: number;\n\t\tlet endColumn: number;\n\n\t\tif (prevWord && prevWord.wordType === WordType.Regular && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n\t\t\t// isInsidePrevWord\n\t\t\tstartColumn = prevWord.start + 1;\n\t\t\tendColumn = prevWord.end + 1;\n\t\t} else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n\t\t\t// isInsideNextWord\n\t\t\tstartColumn = nextWord.start + 1;\n\t\t\tendColumn = nextWord.end + 1;\n\t\t} else {\n\t\t\tstartColumn = position.column;\n\t\t\tendColumn = position.column;\n\t\t}\n\n\t\tconst lineNumber = position.lineNumber;\n\t\tlet column: number;\n\t\tif (cursor.selectionStart.containsPosition(position)) {\n\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t} else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n\t\t\tcolumn = startColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.endColumn;\n\t\t\t}\n\t\t} else {\n\t\t\tcolumn = endColumn;\n\t\t\tconst possiblePosition = new Position(lineNumber, column);\n\t\t\tif (cursor.selectionStart.containsPosition(possiblePosition)) {\n\t\t\t\tcolumn = cursor.selectionStart.startColumn;\n\t\t\t}\n\t\t}\n\n\t\treturn cursor.move(true, lineNumber, column, 0);\n\t}\n}\n\nexport class WordPartOperations extends WordOperations {\n\tpublic static deleteWordPartLeft(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordLeft(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingEnds);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static deleteWordPartRight(ctx: DeleteWordContext): Range {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordStart),\n\t\t\tWordOperations.deleteWordRight(ctx, WordNavigationType.WordEnd),\n\t\t\tWordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n\t\t]);\n\t\tcandidates.sort(Range.compareRangesUsingStarts);\n\t\treturn candidates[0];\n\t}\n\n\tpublic static moveWordPartLeft(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position, hasMulticursor: boolean): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordStart, hasMulticursor),\n\t\t\tWordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordEnd, hasMulticursor),\n\t\t\tWordOperations._moveWordPartLeft(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[2];\n\t}\n\n\tpublic static moveWordPartRight(wordSeparators: WordCharacterClassifier, model: ICursorSimpleModel, position: Position): Position {\n\t\tconst candidates = enforceDefined([\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordStart),\n\t\t\tWordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordEnd),\n\t\t\tWordOperations._moveWordPartRight(model, position)\n\t\t]);\n\t\tcandidates.sort(Position.compare);\n\t\treturn candidates[0];\n\t}\n}\n\nfunction enforceDefined<T>(arr: Array<T | undefined | null>): T[] {\n\treturn <T[]>arr.filter(el => Boolean(el));\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1489, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorMoveCommands.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorMoveCommands.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, ICursorSimpleModel, PartialCursorState, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { IPosition, Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { ICommandMetadata } from '../../../platform/commands/common/commands.js';\nimport { IViewModel } from '../viewModel.js';\nimport { TextDirection } from '../model.js';\n\nexport class CursorMoveCommands {\n\n\tpublic static addCursorDown(viewModel: IViewModel, cursors: CursorState[], useLogicalLine: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tlet resultLen = 0;\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n\t\t\tif (useLogicalLine) {\n\t\t\t\tresult[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static addCursorUp(viewModel: IViewModel, cursors: CursorState[], useLogicalLine: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tlet resultLen = 0;\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n\t\t\tif (useLogicalLine) {\n\t\t\t\tresult[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static moveToBeginningOfLine(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _moveToLineStart(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean): PartialCursorState {\n\t\tconst currentViewStateColumn = cursor.viewState.position.column;\n\t\tconst currentModelStateColumn = cursor.modelState.position.column;\n\t\tconst isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n\n\t\tconst currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n\t\tconst firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n\t\tconst isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n\n\t\tif (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n\t\t\treturn this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n\t\t} else {\n\t\t\treturn this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n\t\t}\n\t}\n\n\tprivate static _moveToLineStartByView(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean): PartialCursorState {\n\t\treturn CursorState.fromViewState(\n\t\t\tMoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)\n\t\t);\n\t}\n\n\tprivate static _moveToLineStartByModel(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean): PartialCursorState {\n\t\treturn CursorState.fromModelState(\n\t\t\tMoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)\n\t\t);\n\t}\n\n\tpublic static moveToEndOfLine(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, sticky: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _moveToLineEnd(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, sticky: boolean): PartialCursorState {\n\t\tconst viewStatePosition = cursor.viewState.position;\n\t\tconst viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n\t\tconst isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n\n\t\tconst modelStatePosition = cursor.modelState.position;\n\t\tconst modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n\t\tconst isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n\n\t\tif (isEndOfViewLine || isEndLineOfWrappedLine) {\n\t\t\treturn this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n\t\t} else {\n\t\t\treturn this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n\t\t}\n\t}\n\n\tprivate static _moveToLineEndByView(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, sticky: boolean): PartialCursorState {\n\t\treturn CursorState.fromViewState(\n\t\t\tMoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky)\n\t\t);\n\t}\n\n\tprivate static _moveToLineEndByModel(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, sticky: boolean): PartialCursorState {\n\t\treturn CursorState.fromModelState(\n\t\t\tMoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky)\n\t\t);\n\t}\n\n\tpublic static expandLineSelection(viewModel: IViewModel, cursors: CursorState[]): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\n\t\t\tconst startLineNumber = cursor.modelState.selection.startLineNumber;\n\t\t\tconst lineCount = viewModel.model.getLineCount();\n\n\t\t\tlet endLineNumber = cursor.modelState.selection.endLineNumber;\n\t\t\tlet endColumn: number;\n\t\t\tif (endLineNumber === lineCount) {\n\t\t\t\tendColumn = viewModel.model.getLineMaxColumn(lineCount);\n\t\t\t} else {\n\t\t\t\tendLineNumber++;\n\t\t\t\tendColumn = 1;\n\t\t\t}\n\n\t\t\tresult[i] = CursorState.fromModelState(new SingleCursorState(\n\t\t\t\tnew Range(startLineNumber, 1, startLineNumber, 1), SelectionStartKind.Simple, 0,\n\t\t\t\tnew Position(endLineNumber, endColumn), 0\n\t\t\t));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static moveToBeginningOfBuffer(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static moveToEndOfBuffer(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static selectAll(viewModel: IViewModel, cursor: CursorState): PartialCursorState {\n\t\tconst lineCount = viewModel.model.getLineCount();\n\t\tconst maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n\n\t\treturn CursorState.fromModelState(new SingleCursorState(\n\t\t\tnew Range(1, 1, 1, 1), SelectionStartKind.Simple, 0,\n\t\t\tnew Position(lineCount, maxColumn), 0\n\t\t));\n\t}\n\n\tpublic static line(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, _position: IPosition, _viewPosition: IPosition | undefined): PartialCursorState {\n\t\tconst position = viewModel.model.validatePosition(_position);\n\t\tconst viewPosition = (\n\t\t\t_viewPosition\n\t\t\t\t? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n\t\t\t\t: viewModel.coordinatesConverter.convertModelPositionToViewPosition(position)\n\t\t);\n\n\t\tif (!inSelectionMode) {\n\t\t\t// Entering line selection for the first time\n\t\t\tconst lineCount = viewModel.model.getLineCount();\n\n\t\t\tlet selectToLineNumber = position.lineNumber + 1;\n\t\t\tlet selectToColumn = 1;\n\t\t\tif (selectToLineNumber > lineCount) {\n\t\t\t\tselectToLineNumber = lineCount;\n\t\t\t\tselectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n\t\t\t}\n\n\t\t\treturn CursorState.fromModelState(new SingleCursorState(\n\t\t\t\tnew Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), SelectionStartKind.Line, 0,\n\t\t\t\tnew Position(selectToLineNumber, selectToColumn), 0\n\t\t\t));\n\t\t}\n\n\t\t// Continuing line selection\n\t\tconst enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n\n\t\tif (position.lineNumber < enteringLineNumber) {\n\n\t\t\treturn CursorState.fromViewState(cursor.viewState.move(\n\t\t\t\ttrue, viewPosition.lineNumber, 1, 0\n\t\t\t));\n\n\t\t} else if (position.lineNumber > enteringLineNumber) {\n\n\t\t\tconst lineCount = viewModel.getLineCount();\n\n\t\t\tlet selectToViewLineNumber = viewPosition.lineNumber + 1;\n\t\t\tlet selectToViewColumn = 1;\n\t\t\tif (selectToViewLineNumber > lineCount) {\n\t\t\t\tselectToViewLineNumber = lineCount;\n\t\t\t\tselectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n\t\t\t}\n\n\t\t\treturn CursorState.fromViewState(cursor.viewState.move(\n\t\t\t\ttrue, selectToViewLineNumber, selectToViewColumn, 0\n\t\t\t));\n\n\t\t} else {\n\n\t\t\tconst endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n\t\t\treturn CursorState.fromModelState(cursor.modelState.move(\n\t\t\t\ttrue, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0\n\t\t\t));\n\n\t\t}\n\t}\n\n\tpublic static word(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, _position: IPosition): PartialCursorState {\n\t\tconst position = viewModel.model.validatePosition(_position);\n\t\treturn CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n\t}\n\n\tpublic static cancelSelection(viewModel: IViewModel, cursor: CursorState): PartialCursorState {\n\t\tif (!cursor.modelState.hasSelection()) {\n\t\t\treturn new CursorState(cursor.modelState, cursor.viewState);\n\t\t}\n\n\t\tconst lineNumber = cursor.viewState.position.lineNumber;\n\t\tconst column = cursor.viewState.position.column;\n\n\t\treturn CursorState.fromViewState(new SingleCursorState(\n\t\t\tnew Range(lineNumber, column, lineNumber, column), SelectionStartKind.Simple, 0,\n\t\t\tnew Position(lineNumber, column), 0\n\t\t));\n\t}\n\n\tpublic static moveTo(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, _position: IPosition, _viewPosition: IPosition | undefined): PartialCursorState {\n\t\tif (inSelectionMode) {\n\t\t\tif (cursor.modelState.selectionStartKind === SelectionStartKind.Word) {\n\t\t\t\treturn this.word(viewModel, cursor, inSelectionMode, _position);\n\t\t\t}\n\t\t\tif (cursor.modelState.selectionStartKind === SelectionStartKind.Line) {\n\t\t\t\treturn this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n\t\t\t}\n\t\t}\n\t\tconst position = viewModel.model.validatePosition(_position);\n\t\tconst viewPosition = (\n\t\t\t_viewPosition\n\t\t\t\t? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n\t\t\t\t: viewModel.coordinatesConverter.convertModelPositionToViewPosition(position)\n\t\t);\n\t\treturn CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n\t}\n\n\tpublic static simpleMove(viewModel: IViewModel, cursors: CursorState[], direction: CursorMove.SimpleMoveDirection, inSelectionMode: boolean, value: number, unit: CursorMove.Unit): PartialCursorState[] | null {\n\t\tswitch (direction) {\n\t\t\tcase CursorMove.Direction.Left: {\n\t\t\t\tif (unit === CursorMove.Unit.HalfLine) {\n\t\t\t\t\t// Move left by half the current line length\n\t\t\t\t\treturn this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n\t\t\t\t} else {\n\t\t\t\t\t// Move left by `moveParams.value` columns\n\t\t\t\t\treturn this._moveLeft(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.Right: {\n\t\t\t\tif (unit === CursorMove.Unit.HalfLine) {\n\t\t\t\t\t// Move right by half the current line length\n\t\t\t\t\treturn this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n\t\t\t\t} else {\n\t\t\t\t\t// Move right by `moveParams.value` columns\n\t\t\t\t\treturn this._moveRight(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.Up: {\n\t\t\t\tif (unit === CursorMove.Unit.WrappedLine) {\n\t\t\t\t\t// Move up by view lines\n\t\t\t\t\treturn this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t} else {\n\t\t\t\t\t// Move up by model lines\n\t\t\t\t\treturn this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.Down: {\n\t\t\t\tif (unit === CursorMove.Unit.WrappedLine) {\n\t\t\t\t\t// Move down by view lines\n\t\t\t\t\treturn this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t} else {\n\t\t\t\t\t// Move down by model lines\n\t\t\t\t\treturn this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.PrevBlankLine: {\n\t\t\t\tif (unit === CursorMove.Unit.WrappedLine) {\n\t\t\t\t\treturn cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n\t\t\t\t} else {\n\t\t\t\t\treturn cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.NextBlankLine: {\n\t\t\t\tif (unit === CursorMove.Unit.WrappedLine) {\n\t\t\t\t\treturn cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n\t\t\t\t} else {\n\t\t\t\t\treturn cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineStart: {\n\t\t\t\t// Move to the beginning of the current view line\n\t\t\t\treturn this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter: {\n\t\t\t\t// Move to the first non-whitespace column of the current view line\n\t\t\t\treturn this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineColumnCenter: {\n\t\t\t\t// Move to the \"center\" of the current view line\n\t\t\t\treturn this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineEnd: {\n\t\t\t\t// Move to the end of the current view line\n\t\t\t\treturn this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter: {\n\t\t\t\t// Move to the last non-whitespace column of the current view line\n\t\t\t\treturn this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\n\t}\n\n\tpublic static viewportMove(viewModel: IViewModel, cursors: CursorState[], direction: CursorMove.ViewportDirection, inSelectionMode: boolean, value: number): PartialCursorState[] | null {\n\t\tconst visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n\t\tconst visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n\t\tswitch (direction) {\n\t\t\tcase CursorMove.Direction.ViewPortTop: {\n\t\t\t\t// Move to the nth line start in the viewport (from the top)\n\t\t\t\tconst modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n\t\t\t\tconst modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n\t\t\t\treturn [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n\t\t\t}\n\t\t\tcase CursorMove.Direction.ViewPortBottom: {\n\t\t\t\t// Move to the nth line start in the viewport (from the bottom)\n\t\t\t\tconst modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n\t\t\t\tconst modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n\t\t\t\treturn [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n\t\t\t}\n\t\t\tcase CursorMove.Direction.ViewPortCenter: {\n\t\t\t\t// Move to the line start in the viewport center\n\t\t\t\tconst modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n\t\t\t\tconst modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n\t\t\t\treturn [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n\t\t\t}\n\t\t\tcase CursorMove.Direction.ViewPortIfOutside: {\n\t\t\t\t// Move to a position inside the viewport\n\t\t\t\tconst result: PartialCursorState[] = [];\n\t\t\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\t\t\tconst cursor = cursors[i];\n\t\t\t\t\tresult[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static findPositionInViewportIfOutside(viewModel: IViewModel, cursor: CursorState, visibleViewRange: Range, inSelectionMode: boolean): PartialCursorState {\n\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\n\t\tif (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n\t\t\t// Nothing to do, cursor is in viewport\n\t\t\treturn new CursorState(cursor.modelState, cursor.viewState);\n\n\t\t} else {\n\t\t\tlet newViewLineNumber: number;\n\t\t\tif (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n\t\t\t\tnewViewLineNumber = visibleViewRange.endLineNumber - 1;\n\t\t\t} else if (viewLineNumber < visibleViewRange.startLineNumber) {\n\t\t\t\tnewViewLineNumber = visibleViewRange.startLineNumber;\n\t\t\t} else {\n\t\t\t\tnewViewLineNumber = viewLineNumber;\n\t\t\t}\n\t\t\tconst position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n\t\t\treturn CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n\t\t}\n\t}\n\n\t/**\n\t * Find the nth line start included in the range (from the start).\n\t */\n\tprivate static _firstLineNumberInRange(model: ICursorSimpleModel, range: Range, count: number): number {\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tif (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n\t\t\t// Move on to the second line if the first line start is not included in the range\n\t\t\tstartLineNumber++;\n\t\t}\n\n\t\treturn Math.min(range.endLineNumber, startLineNumber + count - 1);\n\t}\n\n\t/**\n\t * Find the nth line start included in the range (from the end).\n\t */\n\tprivate static _lastLineNumberInRange(model: ICursorSimpleModel, range: Range, count: number): number {\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tif (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n\t\t\t// Move on to the second line if the first line start is not included in the range\n\t\t\tstartLineNumber++;\n\t\t}\n\n\t\treturn Math.max(startLineNumber, range.endLineNumber - count + 1);\n\t}\n\n\tprivate static _moveLeft(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, noOfColumns: number): PartialCursorState[] {\n\t\treturn cursors.map(cursor => {\n\t\t\tconst direction = viewModel.getTextDirection(cursor.viewState.position.lineNumber);\n\t\t\tconst isRtl = direction === TextDirection.RTL;\n\n\t\t\treturn CursorState.fromViewState(\n\t\t\t\tisRtl\n\t\t\t\t\t? MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)\n\t\t\t\t\t: MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate static _moveHalfLineLeft(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n\t\t\tresult[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveRight(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, noOfColumns: number): PartialCursorState[] {\n\t\treturn cursors.map(cursor => {\n\t\t\tconst direction = viewModel.getTextDirection(cursor.viewState.position.lineNumber);\n\t\t\tconst isRtl = direction === TextDirection.RTL;\n\n\t\t\treturn CursorState.fromViewState(\n\t\t\t\tisRtl\n\t\t\t\t\t? MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)\n\t\t\t\t\t: MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate static _moveHalfLineRight(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n\t\t\tresult[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveDownByViewLines(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, linesCount: number): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveDownByModelLines(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, linesCount: number): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveUpByViewLines(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, linesCount: number): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveUpByModelLines(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, linesCount: number): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewPosition(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, toViewLineNumber: number, toViewColumn: number): PartialCursorState {\n\t\treturn CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n\t}\n\n\tprivate static _moveToModelPosition(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, toModelLineNumber: number, toModelColumn: number): PartialCursorState {\n\t\treturn CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n\t}\n\n\tprivate static _moveToViewMinColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewFirstNonWhitespaceColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewCenterColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewMaxColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewLastNonWhitespaceColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport namespace CursorMove {\n\n\tconst isCursorMoveArgs = function (arg: any): boolean {\n\t\tif (!types.isObject(arg)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst cursorMoveArg: RawArguments = arg;\n\n\t\tif (!types.isString(cursorMoveArg.to)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\texport const metadata: ICommandMetadata = {\n\t\tdescription: 'Move cursor to a logical position in the view',\n\t\targs: [\n\t\t\t{\n\t\t\t\tname: 'Cursor move argument object',\n\t\t\t\tdescription: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n\t\t\t\tconstraint: isCursorMoveArgs,\n\t\t\t\tschema: {\n\t\t\t\t\t'type': 'object',\n\t\t\t\t\t'required': ['to'],\n\t\t\t\t\t'properties': {\n\t\t\t\t\t\t'to': {\n\t\t\t\t\t\t\t'type': 'string',\n\t\t\t\t\t\t\t'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'by': {\n\t\t\t\t\t\t\t'type': 'string',\n\t\t\t\t\t\t\t'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\t'type': 'number',\n\t\t\t\t\t\t\t'default': 1\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'select': {\n\t\t\t\t\t\t\t'type': 'boolean',\n\t\t\t\t\t\t\t'default': false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t};\n\n\t/**\n\t * Positions in the view for cursor move command.\n\t */\n\texport const RawDirection = {\n\t\tLeft: 'left',\n\t\tRight: 'right',\n\t\tUp: 'up',\n\t\tDown: 'down',\n\n\t\tPrevBlankLine: 'prevBlankLine',\n\t\tNextBlankLine: 'nextBlankLine',\n\n\t\tWrappedLineStart: 'wrappedLineStart',\n\t\tWrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n\t\tWrappedLineColumnCenter: 'wrappedLineColumnCenter',\n\t\tWrappedLineEnd: 'wrappedLineEnd',\n\t\tWrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n\n\t\tViewPortTop: 'viewPortTop',\n\t\tViewPortCenter: 'viewPortCenter',\n\t\tViewPortBottom: 'viewPortBottom',\n\n\t\tViewPortIfOutside: 'viewPortIfOutside'\n\t};\n\n\t/**\n\t * Units for Cursor move 'by' argument\n\t */\n\texport const RawUnit = {\n\t\tLine: 'line',\n\t\tWrappedLine: 'wrappedLine',\n\t\tCharacter: 'character',\n\t\tHalfLine: 'halfLine'\n\t};\n\n\t/**\n\t * Arguments for Cursor move command\n\t */\n\texport interface RawArguments {\n\t\tto: string;\n\t\tselect?: boolean;\n\t\tby?: string;\n\t\tvalue?: number;\n\t}\n\n\texport function parse(args: Partial<RawArguments>): ParsedArguments | null {\n\t\tif (!args.to) {\n\t\t\t// illegal arguments\n\t\t\treturn null;\n\t\t}\n\n\t\tlet direction: Direction;\n\t\tswitch (args.to) {\n\t\t\tcase RawDirection.Left:\n\t\t\t\tdirection = Direction.Left;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.Right:\n\t\t\t\tdirection = Direction.Right;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.Up:\n\t\t\t\tdirection = Direction.Up;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.Down:\n\t\t\t\tdirection = Direction.Down;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.PrevBlankLine:\n\t\t\t\tdirection = Direction.PrevBlankLine;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.NextBlankLine:\n\t\t\t\tdirection = Direction.NextBlankLine;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineStart:\n\t\t\t\tdirection = Direction.WrappedLineStart;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n\t\t\t\tdirection = Direction.WrappedLineFirstNonWhitespaceCharacter;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineColumnCenter:\n\t\t\t\tdirection = Direction.WrappedLineColumnCenter;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineEnd:\n\t\t\t\tdirection = Direction.WrappedLineEnd;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineLastNonWhitespaceCharacter:\n\t\t\t\tdirection = Direction.WrappedLineLastNonWhitespaceCharacter;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.ViewPortTop:\n\t\t\t\tdirection = Direction.ViewPortTop;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.ViewPortBottom:\n\t\t\t\tdirection = Direction.ViewPortBottom;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.ViewPortCenter:\n\t\t\t\tdirection = Direction.ViewPortCenter;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.ViewPortIfOutside:\n\t\t\t\tdirection = Direction.ViewPortIfOutside;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// illegal arguments\n\t\t\t\treturn null;\n\t\t}\n\n\t\tlet unit = Unit.None;\n\t\tswitch (args.by) {\n\t\t\tcase RawUnit.Line:\n\t\t\t\tunit = Unit.Line;\n\t\t\t\tbreak;\n\t\t\tcase RawUnit.WrappedLine:\n\t\t\t\tunit = Unit.WrappedLine;\n\t\t\t\tbreak;\n\t\t\tcase RawUnit.Character:\n\t\t\t\tunit = Unit.Character;\n\t\t\t\tbreak;\n\t\t\tcase RawUnit.HalfLine:\n\t\t\t\tunit = Unit.HalfLine;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn {\n\t\t\tdirection: direction,\n\t\t\tunit: unit,\n\t\t\tselect: (!!args.select),\n\t\t\tvalue: (args.value || 1)\n\t\t};\n\t}\n\n\texport interface ParsedArguments {\n\t\tdirection: Direction;\n\t\tunit: Unit;\n\t\tselect: boolean;\n\t\tvalue: number;\n\t}\n\n\texport interface SimpleMoveArguments {\n\t\tdirection: SimpleMoveDirection;\n\t\tunit: Unit;\n\t\tselect: boolean;\n\t\tvalue: number;\n\t}\n\n\texport const enum Direction {\n\t\tLeft,\n\t\tRight,\n\t\tUp,\n\t\tDown,\n\t\tPrevBlankLine,\n\t\tNextBlankLine,\n\n\t\tWrappedLineStart,\n\t\tWrappedLineFirstNonWhitespaceCharacter,\n\t\tWrappedLineColumnCenter,\n\t\tWrappedLineEnd,\n\t\tWrappedLineLastNonWhitespaceCharacter,\n\n\t\tViewPortTop,\n\t\tViewPortCenter,\n\t\tViewPortBottom,\n\n\t\tViewPortIfOutside,\n\t}\n\n\texport type SimpleMoveDirection = (\n\t\tDirection.Left\n\t\t| Direction.Right\n\t\t| Direction.Up\n\t\t| Direction.Down\n\t\t| Direction.PrevBlankLine\n\t\t| Direction.NextBlankLine\n\t\t| Direction.WrappedLineStart\n\t\t| Direction.WrappedLineFirstNonWhitespaceCharacter\n\t\t| Direction.WrappedLineColumnCenter\n\t\t| Direction.WrappedLineEnd\n\t\t| Direction.WrappedLineLastNonWhitespaceCharacter\n\t);\n\n\texport type ViewportDirection = (\n\t\tDirection.ViewPortTop\n\t\t| Direction.ViewPortCenter\n\t\t| Direction.ViewPortBottom\n\t\t| Direction.ViewPortIfOutside\n\t);\n\n\texport const enum Unit {\n\t\tNone,\n\t\tLine,\n\t\tWrappedLine,\n\t\tCharacter,\n\t\tHalfLine,\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, ICursorSimpleModel, PartialCursorState, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { IPosition, Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { ICommandMetadata } from '../../../platform/commands/common/commands.js';\nimport { IViewModel } from '../viewModel.js';\nimport { TextDirection } from '../model.js';\n\nexport class CursorMoveCommands {\n\n\tpublic static addCursorDown(viewModel: IViewModel, cursors: CursorState[], useLogicalLine: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tlet resultLen = 0;\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n\t\t\tif (useLogicalLine) {\n\t\t\t\tresult[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static addCursorUp(viewModel: IViewModel, cursors: CursorState[], useLogicalLine: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tlet resultLen = 0;\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n\t\t\tif (useLogicalLine) {\n\t\t\t\tresult[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static moveToBeginningOfLine(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _moveToLineStart(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean): PartialCursorState {\n\t\tconst currentViewStateColumn = cursor.viewState.position.column;\n\t\tconst currentModelStateColumn = cursor.modelState.position.column;\n\t\tconst isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n\n\t\tconst currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n\t\tconst firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n\t\tconst isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n\n\t\tif (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n\t\t\treturn this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n\t\t} else {\n\t\t\treturn this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n\t\t}\n\t}\n\n\tprivate static _moveToLineStartByView(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean): PartialCursorState {\n\t\treturn CursorState.fromViewState(\n\t\t\tMoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)\n\t\t);\n\t}\n\n\tprivate static _moveToLineStartByModel(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean): PartialCursorState {\n\t\treturn CursorState.fromModelState(\n\t\t\tMoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)\n\t\t);\n\t}\n\n\tpublic static moveToEndOfLine(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, sticky: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _moveToLineEnd(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, sticky: boolean): PartialCursorState {\n\t\tconst viewStatePosition = cursor.viewState.position;\n\t\tconst viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n\t\tconst isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n\n\t\tconst modelStatePosition = cursor.modelState.position;\n\t\tconst modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n\t\tconst isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n\n\t\tif (isEndOfViewLine || isEndLineOfWrappedLine) {\n\t\t\treturn this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n\t\t} else {\n\t\t\treturn this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n\t\t}\n\t}\n\n\tprivate static _moveToLineEndByView(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, sticky: boolean): PartialCursorState {\n\t\treturn CursorState.fromViewState(\n\t\t\tMoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky)\n\t\t);\n\t}\n\n\tprivate static _moveToLineEndByModel(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, sticky: boolean): PartialCursorState {\n\t\treturn CursorState.fromModelState(\n\t\t\tMoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky)\n\t\t);\n\t}\n\n\tpublic static expandLineSelection(viewModel: IViewModel, cursors: CursorState[]): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\n\t\t\tconst startLineNumber = cursor.modelState.selection.startLineNumber;\n\t\t\tconst lineCount = viewModel.model.getLineCount();\n\n\t\t\tlet endLineNumber = cursor.modelState.selection.endLineNumber;\n\t\t\tlet endColumn: number;\n\t\t\tif (endLineNumber === lineCount) {\n\t\t\t\tendColumn = viewModel.model.getLineMaxColumn(lineCount);\n\t\t\t} else {\n\t\t\t\tendLineNumber++;\n\t\t\t\tendColumn = 1;\n\t\t\t}\n\n\t\t\tresult[i] = CursorState.fromModelState(new SingleCursorState(\n\t\t\t\tnew Range(startLineNumber, 1, startLineNumber, 1), SelectionStartKind.Simple, 0,\n\t\t\t\tnew Position(endLineNumber, endColumn), 0\n\t\t\t));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static moveToBeginningOfBuffer(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static moveToEndOfBuffer(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static selectAll(viewModel: IViewModel, cursor: CursorState): PartialCursorState {\n\t\tconst lineCount = viewModel.model.getLineCount();\n\t\tconst maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n\n\t\treturn CursorState.fromModelState(new SingleCursorState(\n\t\t\tnew Range(1, 1, 1, 1), SelectionStartKind.Simple, 0,\n\t\t\tnew Position(lineCount, maxColumn), 0\n\t\t));\n\t}\n\n\tpublic static line(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, _position: IPosition, _viewPosition: IPosition | undefined): PartialCursorState {\n\t\tconst position = viewModel.model.validatePosition(_position);\n\t\tconst viewPosition = (\n\t\t\t_viewPosition\n\t\t\t\t? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n\t\t\t\t: viewModel.coordinatesConverter.convertModelPositionToViewPosition(position)\n\t\t);\n\n\t\tif (!inSelectionMode) {\n\t\t\t// Entering line selection for the first time\n\t\t\tconst lineCount = viewModel.model.getLineCount();\n\n\t\t\tlet selectToLineNumber = position.lineNumber + 1;\n\t\t\tlet selectToColumn = 1;\n\t\t\tif (selectToLineNumber > lineCount) {\n\t\t\t\tselectToLineNumber = lineCount;\n\t\t\t\tselectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n\t\t\t}\n\n\t\t\treturn CursorState.fromModelState(new SingleCursorState(\n\t\t\t\tnew Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), SelectionStartKind.Line, 0,\n\t\t\t\tnew Position(selectToLineNumber, selectToColumn), 0\n\t\t\t));\n\t\t}\n\n\t\t// Continuing line selection\n\t\tconst enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n\n\t\tif (position.lineNumber < enteringLineNumber) {\n\n\t\t\treturn CursorState.fromViewState(cursor.viewState.move(\n\t\t\t\ttrue, viewPosition.lineNumber, 1, 0\n\t\t\t));\n\n\t\t} else if (position.lineNumber > enteringLineNumber) {\n\n\t\t\tconst lineCount = viewModel.getLineCount();\n\n\t\t\tlet selectToViewLineNumber = viewPosition.lineNumber + 1;\n\t\t\tlet selectToViewColumn = 1;\n\t\t\tif (selectToViewLineNumber > lineCount) {\n\t\t\t\tselectToViewLineNumber = lineCount;\n\t\t\t\tselectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n\t\t\t}\n\n\t\t\treturn CursorState.fromViewState(cursor.viewState.move(\n\t\t\t\ttrue, selectToViewLineNumber, selectToViewColumn, 0\n\t\t\t));\n\n\t\t} else {\n\n\t\t\tconst endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n\t\t\treturn CursorState.fromModelState(cursor.modelState.move(\n\t\t\t\ttrue, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0\n\t\t\t));\n\n\t\t}\n\t}\n\n\tpublic static word(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, _position: IPosition): PartialCursorState {\n\t\tconst position = viewModel.model.validatePosition(_position);\n\t\treturn CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n\t}\n\n\tpublic static cancelSelection(viewModel: IViewModel, cursor: CursorState): PartialCursorState {\n\t\tif (!cursor.modelState.hasSelection()) {\n\t\t\treturn new CursorState(cursor.modelState, cursor.viewState);\n\t\t}\n\n\t\tconst lineNumber = cursor.viewState.position.lineNumber;\n\t\tconst column = cursor.viewState.position.column;\n\n\t\treturn CursorState.fromViewState(new SingleCursorState(\n\t\t\tnew Range(lineNumber, column, lineNumber, column), SelectionStartKind.Simple, 0,\n\t\t\tnew Position(lineNumber, column), 0\n\t\t));\n\t}\n\n\tpublic static moveTo(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, _position: IPosition, _viewPosition: IPosition | undefined): PartialCursorState {\n\t\tif (inSelectionMode) {\n\t\t\tif (cursor.modelState.selectionStartKind === SelectionStartKind.Word) {\n\t\t\t\treturn this.word(viewModel, cursor, inSelectionMode, _position);\n\t\t\t}\n\t\t\tif (cursor.modelState.selectionStartKind === SelectionStartKind.Line) {\n\t\t\t\treturn this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n\t\t\t}\n\t\t}\n\t\tconst position = viewModel.model.validatePosition(_position);\n\t\tconst viewPosition = (\n\t\t\t_viewPosition\n\t\t\t\t? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n\t\t\t\t: viewModel.coordinatesConverter.convertModelPositionToViewPosition(position)\n\t\t);\n\t\treturn CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n\t}\n\n\tpublic static simpleMove(viewModel: IViewModel, cursors: CursorState[], direction: CursorMove.SimpleMoveDirection, inSelectionMode: boolean, value: number, unit: CursorMove.Unit): PartialCursorState[] | null {\n\t\tswitch (direction) {\n\t\t\tcase CursorMove.Direction.Left: {\n\t\t\t\tif (unit === CursorMove.Unit.HalfLine) {\n\t\t\t\t\t// Move left by half the current line length\n\t\t\t\t\treturn this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n\t\t\t\t} else {\n\t\t\t\t\t// Move left by `moveParams.value` columns\n\t\t\t\t\treturn this._moveLeft(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.Right: {\n\t\t\t\tif (unit === CursorMove.Unit.HalfLine) {\n\t\t\t\t\t// Move right by half the current line length\n\t\t\t\t\treturn this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n\t\t\t\t} else {\n\t\t\t\t\t// Move right by `moveParams.value` columns\n\t\t\t\t\treturn this._moveRight(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.Up: {\n\t\t\t\tif (unit === CursorMove.Unit.WrappedLine) {\n\t\t\t\t\t// Move up by view lines\n\t\t\t\t\treturn this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t} else {\n\t\t\t\t\t// Move up by model lines\n\t\t\t\t\treturn this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.Down: {\n\t\t\t\tif (unit === CursorMove.Unit.WrappedLine) {\n\t\t\t\t\t// Move down by view lines\n\t\t\t\t\treturn this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t} else {\n\t\t\t\t\t// Move down by model lines\n\t\t\t\t\treturn this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.PrevBlankLine: {\n\t\t\t\tif (unit === CursorMove.Unit.WrappedLine) {\n\t\t\t\t\treturn cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n\t\t\t\t} else {\n\t\t\t\t\treturn cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.NextBlankLine: {\n\t\t\t\tif (unit === CursorMove.Unit.WrappedLine) {\n\t\t\t\t\treturn cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n\t\t\t\t} else {\n\t\t\t\t\treturn cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineStart: {\n\t\t\t\t// Move to the beginning of the current view line\n\t\t\t\treturn this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter: {\n\t\t\t\t// Move to the first non-whitespace column of the current view line\n\t\t\t\treturn this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineColumnCenter: {\n\t\t\t\t// Move to the \"center\" of the current view line\n\t\t\t\treturn this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineEnd: {\n\t\t\t\t// Move to the end of the current view line\n\t\t\t\treturn this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tcase CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter: {\n\t\t\t\t// Move to the last non-whitespace column of the current view line\n\t\t\t\treturn this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\n\t}\n\n\tpublic static viewportMove(viewModel: IViewModel, cursors: CursorState[], direction: CursorMove.ViewportDirection, inSelectionMode: boolean, value: number): PartialCursorState[] | null {\n\t\tconst visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n\t\tconst visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n\t\tswitch (direction) {\n\t\t\tcase CursorMove.Direction.ViewPortTop: {\n\t\t\t\t// Move to the nth line start in the viewport (from the top)\n\t\t\t\tconst modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n\t\t\t\tconst modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n\t\t\t\treturn [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n\t\t\t}\n\t\t\tcase CursorMove.Direction.ViewPortBottom: {\n\t\t\t\t// Move to the nth line start in the viewport (from the bottom)\n\t\t\t\tconst modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n\t\t\t\tconst modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n\t\t\t\treturn [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n\t\t\t}\n\t\t\tcase CursorMove.Direction.ViewPortCenter: {\n\t\t\t\t// Move to the line start in the viewport center\n\t\t\t\tconst modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n\t\t\t\tconst modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n\t\t\t\treturn [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n\t\t\t}\n\t\t\tcase CursorMove.Direction.ViewPortIfOutside: {\n\t\t\t\t// Move to a position inside the viewport\n\t\t\t\tconst result: PartialCursorState[] = [];\n\t\t\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\t\t\tconst cursor = cursors[i];\n\t\t\t\t\tresult[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static findPositionInViewportIfOutside(viewModel: IViewModel, cursor: CursorState, visibleViewRange: Range, inSelectionMode: boolean): PartialCursorState {\n\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\n\t\tif (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n\t\t\t// Nothing to do, cursor is in viewport\n\t\t\treturn new CursorState(cursor.modelState, cursor.viewState);\n\n\t\t} else {\n\t\t\tlet newViewLineNumber: number;\n\t\t\tif (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n\t\t\t\tnewViewLineNumber = visibleViewRange.endLineNumber - 1;\n\t\t\t} else if (viewLineNumber < visibleViewRange.startLineNumber) {\n\t\t\t\tnewViewLineNumber = visibleViewRange.startLineNumber;\n\t\t\t} else {\n\t\t\t\tnewViewLineNumber = viewLineNumber;\n\t\t\t}\n\t\t\tconst position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n\t\t\treturn CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n\t\t}\n\t}\n\n\t/**\n\t * Find the nth line start included in the range (from the start).\n\t */\n\tprivate static _firstLineNumberInRange(model: ICursorSimpleModel, range: Range, count: number): number {\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tif (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n\t\t\t// Move on to the second line if the first line start is not included in the range\n\t\t\tstartLineNumber++;\n\t\t}\n\n\t\treturn Math.min(range.endLineNumber, startLineNumber + count - 1);\n\t}\n\n\t/**\n\t * Find the nth line start included in the range (from the end).\n\t */\n\tprivate static _lastLineNumberInRange(model: ICursorSimpleModel, range: Range, count: number): number {\n\t\tlet startLineNumber = range.startLineNumber;\n\t\tif (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n\t\t\t// Move on to the second line if the first line start is not included in the range\n\t\t\tstartLineNumber++;\n\t\t}\n\n\t\treturn Math.max(startLineNumber, range.endLineNumber - count + 1);\n\t}\n\n\tprivate static _moveLeft(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, noOfColumns: number): PartialCursorState[] {\n\t\treturn cursors.map(cursor => {\n\t\t\tconst direction = viewModel.getTextDirection(cursor.viewState.position.lineNumber);\n\t\t\tconst isRtl = direction === TextDirection.RTL;\n\n\t\t\treturn CursorState.fromViewState(\n\t\t\t\tisRtl\n\t\t\t\t\t? MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)\n\t\t\t\t\t: MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate static _moveHalfLineLeft(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n\t\t\tresult[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveRight(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, noOfColumns: number): PartialCursorState[] {\n\t\treturn cursors.map(cursor => {\n\t\t\tconst direction = viewModel.getTextDirection(cursor.viewState.position.lineNumber);\n\t\t\tconst isRtl = direction === TextDirection.RTL;\n\n\t\t\treturn CursorState.fromViewState(\n\t\t\t\tisRtl\n\t\t\t\t\t? MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)\n\t\t\t\t\t: MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate static _moveHalfLineRight(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst halfLine = Math.round(viewModel.getLineLength(viewLineNumber) / 2);\n\t\t\tresult[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveDownByViewLines(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, linesCount: number): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveDownByModelLines(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, linesCount: number): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveUpByViewLines(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, linesCount: number): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveUpByModelLines(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean, linesCount: number): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tresult[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewPosition(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, toViewLineNumber: number, toViewColumn: number): PartialCursorState {\n\t\treturn CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n\t}\n\n\tprivate static _moveToModelPosition(viewModel: IViewModel, cursor: CursorState, inSelectionMode: boolean, toModelLineNumber: number, toModelColumn: number): PartialCursorState {\n\t\treturn CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n\t}\n\n\tprivate static _moveToViewMinColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewFirstNonWhitespaceColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewCenterColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewMaxColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _moveToViewLastNonWhitespaceColumn(viewModel: IViewModel, cursors: CursorState[], inSelectionMode: boolean): PartialCursorState[] {\n\t\tconst result: PartialCursorState[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tconst cursor = cursors[i];\n\t\t\tconst viewLineNumber = cursor.viewState.position.lineNumber;\n\t\t\tconst viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n\t\t\tresult[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport namespace CursorMove {\n\n\tconst isCursorMoveArgs = function (arg: any): boolean {\n\t\tif (!types.isObject(arg)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst cursorMoveArg: RawArguments = arg;\n\n\t\tif (!types.isString(cursorMoveArg.to)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\texport const metadata: ICommandMetadata = {\n\t\tdescription: 'Move cursor to a logical position in the view',\n\t\targs: [\n\t\t\t{\n\t\t\t\tname: 'Cursor move argument object',\n\t\t\t\tdescription: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n\t\t\t\tconstraint: isCursorMoveArgs,\n\t\t\t\tschema: {\n\t\t\t\t\t'type': 'object',\n\t\t\t\t\t'required': ['to'],\n\t\t\t\t\t'properties': {\n\t\t\t\t\t\t'to': {\n\t\t\t\t\t\t\t'type': 'string',\n\t\t\t\t\t\t\t'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'by': {\n\t\t\t\t\t\t\t'type': 'string',\n\t\t\t\t\t\t\t'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\t'type': 'number',\n\t\t\t\t\t\t\t'default': 1\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'select': {\n\t\t\t\t\t\t\t'type': 'boolean',\n\t\t\t\t\t\t\t'default': false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t};\n\n\t/**\n\t * Positions in the view for cursor move command.\n\t */\n\texport const RawDirection = {\n\t\tLeft: 'left',\n\t\tRight: 'right',\n\t\tUp: 'up',\n\t\tDown: 'down',\n\n\t\tPrevBlankLine: 'prevBlankLine',\n\t\tNextBlankLine: 'nextBlankLine',\n\n\t\tWrappedLineStart: 'wrappedLineStart',\n\t\tWrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n\t\tWrappedLineColumnCenter: 'wrappedLineColumnCenter',\n\t\tWrappedLineEnd: 'wrappedLineEnd',\n\t\tWrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n\n\t\tViewPortTop: 'viewPortTop',\n\t\tViewPortCenter: 'viewPortCenter',\n\t\tViewPortBottom: 'viewPortBottom',\n\n\t\tViewPortIfOutside: 'viewPortIfOutside'\n\t};\n\n\t/**\n\t * Units for Cursor move 'by' argument\n\t */\n\texport const RawUnit = {\n\t\tLine: 'line',\n\t\tWrappedLine: 'wrappedLine',\n\t\tCharacter: 'character',\n\t\tHalfLine: 'halfLine'\n\t};\n\n\t/**\n\t * Arguments for Cursor move command\n\t */\n\texport interface RawArguments {\n\t\tto: string;\n\t\tselect?: boolean;\n\t\tby?: string;\n\t\tvalue?: number;\n\t}\n\n\texport function parse(args: Partial<RawArguments>): ParsedArguments | null {\n\t\tif (!args.to) {\n\t\t\t// illegal arguments\n\t\t\treturn null;\n\t\t}\n\n\t\tlet direction: Direction;\n\t\tswitch (args.to) {\n\t\t\tcase RawDirection.Left:\n\t\t\t\tdirection = Direction.Left;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.Right:\n\t\t\t\tdirection = Direction.Right;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.Up:\n\t\t\t\tdirection = Direction.Up;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.Down:\n\t\t\t\tdirection = Direction.Down;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.PrevBlankLine:\n\t\t\t\tdirection = Direction.PrevBlankLine;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.NextBlankLine:\n\t\t\t\tdirection = Direction.NextBlankLine;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineStart:\n\t\t\t\tdirection = Direction.WrappedLineStart;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n\t\t\t\tdirection = Direction.WrappedLineFirstNonWhitespaceCharacter;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineColumnCenter:\n\t\t\t\tdirection = Direction.WrappedLineColumnCenter;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineEnd:\n\t\t\t\tdirection = Direction.WrappedLineEnd;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.WrappedLineLastNonWhitespaceCharacter:\n\t\t\t\tdirection = Direction.WrappedLineLastNonWhitespaceCharacter;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.ViewPortTop:\n\t\t\t\tdirection = Direction.ViewPortTop;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.ViewPortBottom:\n\t\t\t\tdirection = Direction.ViewPortBottom;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.ViewPortCenter:\n\t\t\t\tdirection = Direction.ViewPortCenter;\n\t\t\t\tbreak;\n\t\t\tcase RawDirection.ViewPortIfOutside:\n\t\t\t\tdirection = Direction.ViewPortIfOutside;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// illegal arguments\n\t\t\t\treturn null;\n\t\t}\n\n\t\tlet unit = Unit.None;\n\t\tswitch (args.by) {\n\t\t\tcase RawUnit.Line:\n\t\t\t\tunit = Unit.Line;\n\t\t\t\tbreak;\n\t\t\tcase RawUnit.WrappedLine:\n\t\t\t\tunit = Unit.WrappedLine;\n\t\t\t\tbreak;\n\t\t\tcase RawUnit.Character:\n\t\t\t\tunit = Unit.Character;\n\t\t\t\tbreak;\n\t\t\tcase RawUnit.HalfLine:\n\t\t\t\tunit = Unit.HalfLine;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn {\n\t\t\tdirection: direction,\n\t\t\tunit: unit,\n\t\t\tselect: (!!args.select),\n\t\t\tvalue: (args.value || 1)\n\t\t};\n\t}\n\n\texport interface ParsedArguments {\n\t\tdirection: Direction;\n\t\tunit: Unit;\n\t\tselect: boolean;\n\t\tvalue: number;\n\t}\n\n\texport interface SimpleMoveArguments {\n\t\tdirection: SimpleMoveDirection;\n\t\tunit: Unit;\n\t\tselect: boolean;\n\t\tvalue: number;\n\t}\n\n\texport const enum Direction {\n\t\tLeft,\n\t\tRight,\n\t\tUp,\n\t\tDown,\n\t\tPrevBlankLine,\n\t\tNextBlankLine,\n\n\t\tWrappedLineStart,\n\t\tWrappedLineFirstNonWhitespaceCharacter,\n\t\tWrappedLineColumnCenter,\n\t\tWrappedLineEnd,\n\t\tWrappedLineLastNonWhitespaceCharacter,\n\n\t\tViewPortTop,\n\t\tViewPortCenter,\n\t\tViewPortBottom,\n\n\t\tViewPortIfOutside,\n\t}\n\n\texport type SimpleMoveDirection = (\n\t\tDirection.Left\n\t\t| Direction.Right\n\t\t| Direction.Up\n\t\t| Direction.Down\n\t\t| Direction.PrevBlankLine\n\t\t| Direction.NextBlankLine\n\t\t| Direction.WrappedLineStart\n\t\t| Direction.WrappedLineFirstNonWhitespaceCharacter\n\t\t| Direction.WrappedLineColumnCenter\n\t\t| Direction.WrappedLineEnd\n\t\t| Direction.WrappedLineLastNonWhitespaceCharacter\n\t);\n\n\texport type ViewportDirection = (\n\t\tDirection.ViewPortTop\n\t\t| Direction.ViewPortCenter\n\t\t| Direction.ViewPortBottom\n\t\t| Direction.ViewPortIfOutside\n\t);\n\n\texport const enum Unit {\n\t\tNone,\n\t\tLine,\n\t\tWrappedLine,\n\t\tCharacter,\n\t\tHalfLine,\n\t}\n\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2185, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeEditOperations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorTypeEditOperations.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorTypeEditOperations.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection, ReplaceOvertypeCommand, ReplaceOvertypeCommandOnCompositionEnd } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorConfiguration, EditOperationResult, EditOperationType, ICursorSimpleModel, isQuote } from '../cursorCommon.js';\nimport { WordCharacterClass, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Position } from '../core/position.js';\nimport { ICommand, ICursorStateComputerData, IEditOperationBuilder } from '../editorCommon.js';\nimport { ITextModel } from '../model.js';\nimport { EnterAction, IndentAction, StandardAutoClosingPairConditional } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { IElectricAction } from '../languages/supports/electricCharacter.js';\nimport { EditorAutoClosingStrategy, EditorAutoIndentStrategy } from '../config/editorOptions.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nimport { CompositionOutcome } from './cursorTypeOperations.js';\n\nexport class AutoIndentOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n\t\t\tconst indentationForSelections: { selection: Selection; indentation: string }[] = [];\n\t\t\tfor (const selection of selections) {\n\t\t\t\tconst indentation = this._findActualIndentationForSelection(config, model, selection, ch);\n\t\t\t\tif (indentation === null) {\n\t\t\t\t\t// Auto indentation failed\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tindentationForSelections.push({ selection, indentation });\n\t\t\t}\n\t\t\tconst autoClosingPairClose = AutoClosingOpenCharTypeOperation.getAutoClosingPairClose(config, model, selections, ch, false);\n\t\t\treturn this._getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _isAutoIndentType(config: CursorConfiguration, model: ITextModel, selections: Selection[]): boolean {\n\t\tif (config.autoIndent < EditorAutoIndentStrategy.Full) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tif (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _findActualIndentationForSelection(config: CursorConfiguration, model: ITextModel, selection: Selection, ch: string): string | null {\n\t\tconst actualIndentation = getIndentActionForType(config, model, selection, ch, {\n\t\t\tshiftIndent: (indentation) => {\n\t\t\t\treturn shiftIndent(config, indentation);\n\t\t\t},\n\t\t\tunshiftIndent: (indentation) => {\n\t\t\t\treturn unshiftIndent(config, indentation);\n\t\t\t},\n\t\t}, config.languageConfigurationService);\n\n\t\tif (actualIndentation === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currentIndentation = getIndentationAtPosition(model, selection.startLineNumber, selection.startColumn);\n\t\tif (actualIndentation === config.normalizeIndentation(currentIndentation)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn actualIndentation;\n\t}\n\n\tprivate static _getIndentationAndAutoClosingPairEdits(config: CursorConfiguration, model: ITextModel, indentationForSelections: { selection: Selection; indentation: string }[], ch: string, autoClosingPairClose: string | null): EditOperationResult {\n\t\tconst commands: ICommand[] = indentationForSelections.map(({ selection, indentation }) => {\n\t\t\tif (autoClosingPairClose !== null) {\n\t\t\t\t// Apply both auto closing pair edits and auto indentation edits\n\t\t\t\tconst indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, false);\n\t\t\t\treturn new TypeWithIndentationAndAutoClosingCommand(indentationEdit, selection, ch, autoClosingPairClose);\n\t\t\t} else {\n\t\t\t\t// Apply only auto indentation edits\n\t\t\t\tconst indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, true);\n\t\t\t\treturn typeCommand(indentationEdit.range, indentationEdit.text, false);\n\t\t\t}\n\t\t});\n\t\tconst editOptions = { shouldPushStackElementBefore: true, shouldPushStackElementAfter: false };\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, editOptions);\n\t}\n\n\tprivate static _getEditFromIndentationAndSelection(config: CursorConfiguration, model: ITextModel, indentation: string, selection: Selection, ch: string, includeChInEdit: boolean = true): { range: Range; text: string } {\n\t\tconst startLineNumber = selection.startLineNumber;\n\t\tconst firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(startLineNumber);\n\t\tlet text: string = config.normalizeIndentation(indentation);\n\t\tif (firstNonWhitespaceColumn !== 0) {\n\t\t\tconst startLine = model.getLineContent(startLineNumber);\n\t\t\ttext += startLine.substring(firstNonWhitespaceColumn - 1, selection.startColumn - 1);\n\t\t}\n\t\ttext += includeChInEdit ? ch : '';\n\t\tconst range = new Range(startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n\t\treturn { range, text };\n\t}\n}\n\nexport class AutoClosingOvertypeOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): EditOperationResult | undefined {\n\t\tif (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n\t\t\treturn this._runAutoClosingOvertype(prevEditOperationType, selections, ch);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runAutoClosingOvertype(prevEditOperationType: EditOperationType, selections: Selection[], ch: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\t\t\tconst typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n\t\t\tcommands[i] = new ReplaceCommand(typeSelection, ch);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, EditOperationType.TypingOther),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class AutoClosingOvertypeWithInterceptorsOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): EditOperationResult | undefined {\n\t\tif (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n\t\t\t// Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n\t\t\tconst commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n\t\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n}\n\nexport class AutoClosingOpenCharTypeOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, chIsAlreadyTyped: boolean, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition) {\n\t\t\tconst autoClosingPairClose = this.getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped);\n\t\t\tif (autoClosingPairClose !== null) {\n\t\t\t\treturn this._runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runAutoClosingOpenCharType(selections: Selection[], ch: string, chIsAlreadyTyped: boolean, autoClosingPairClose: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tcommands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tpublic static getAutoClosingPairClose(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, chIsAlreadyTyped: boolean): string | null {\n\t\tfor (const selection of selections) {\n\t\t\tif (!selection.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// This method is called both when typing (regularly) and when composition ends\n\t\t// This means that we need to work with a text buffer where sometimes `ch` is not\n\t\t// there (it is being typed right now) or with a text buffer where `ch` has already been typed\n\t\t//\n\t\t// In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n\t\t// with two conceptual positions, the position before `ch` and the position after `ch`\n\t\t//\n\t\tconst positions: { lineNumber: number; beforeColumn: number; afterColumn: number }[] = selections.map((s) => {\n\t\t\tconst position = s.getPosition();\n\t\t\tif (chIsAlreadyTyped) {\n\t\t\t\treturn { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n\t\t\t} else {\n\t\t\t\treturn { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n\t\t\t}\n\t\t});\n\t\t// Find the longest auto-closing open pair in case of multiple ending in `ch`\n\t\t// e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n\t\tconst pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n\t\tif (!pair) {\n\t\t\treturn null;\n\t\t}\n\t\tlet autoCloseConfig: EditorAutoClosingStrategy;\n\t\tlet shouldAutoCloseBefore: (ch: string) => boolean;\n\n\t\tconst chIsQuote = isQuote(ch);\n\t\tif (chIsQuote) {\n\t\t\tautoCloseConfig = config.autoClosingQuotes;\n\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n\t\t} else {\n\t\t\tconst pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n\t\t\tif (pairIsForComments) {\n\t\t\t\tautoCloseConfig = config.autoClosingComments;\n\t\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n\t\t\t} else {\n\t\t\t\tautoCloseConfig = config.autoClosingBrackets;\n\t\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n\t\t\t}\n\t\t}\n\t\tif (autoCloseConfig === 'never') {\n\t\t\treturn null;\n\t\t}\n\t\t// Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n\t\t// e.g. when having [(,)] and [(*,*)]\n\t\t// - when typing (, the resulting state is (|)\n\t\t// - when typing *, the desired resulting state is (*|*), not (*|*))\n\t\tconst containedPair = this._findContainedAutoClosingPair(config, pair);\n\t\tconst containedPairClose = containedPair ? containedPair.close : '';\n\t\tlet isContainedPairPresent = true;\n\n\t\tfor (const position of positions) {\n\t\t\tconst { lineNumber, beforeColumn, afterColumn } = position;\n\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\tconst lineBefore = lineText.substring(0, beforeColumn - 1);\n\t\t\tconst lineAfter = lineText.substring(afterColumn - 1);\n\n\t\t\tif (!lineAfter.startsWith(containedPairClose)) {\n\t\t\t\tisContainedPairPresent = false;\n\t\t\t}\n\t\t\t// Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n\t\t\tif (lineAfter.length > 0) {\n\t\t\t\tconst characterAfter = lineAfter.charAt(0);\n\t\t\t\tconst isBeforeCloseBrace = this._isBeforeClosingBrace(config, lineAfter);\n\t\t\t\tif (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Do not auto-close ' or \" after a word character\n\t\t\tif (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n\t\t\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n\t\t\t\tif (lineBefore.length > 0) {\n\t\t\t\t\tconst characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n\t\t\t\t\tif (wordSeparators.get(characterBefore) === WordCharacterClass.Regular) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!model.tokenization.isCheapToTokenize(lineNumber)) {\n\t\t\t\t// Do not force tokenization\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodel.tokenization.forceTokenization(lineNumber);\n\t\t\tconst lineTokens = model.tokenization.getLineTokens(lineNumber);\n\t\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n\t\t\tif (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Typing for example a quote could either start a new string, in which case auto-closing is desirable\n\t\t\t// or it could end a previously started string, in which case auto-closing is not desirable\n\t\t\t//\n\t\t\t// In certain cases, it is really not possible to look at the previous token to determine\n\t\t\t// what would happen. That's why we do something really unusual, we pretend to type a different\n\t\t\t// character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n\t\t\t// character, are we in a string (i.e. the quote would most likely end a string) or not?\n\t\t\t//\n\t\t\tconst neutralCharacter = pair.findNeutralCharacter();\n\t\t\tif (neutralCharacter) {\n\t\t\t\tconst tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n\t\t\t\tif (!pair.isOK(tokenType)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isContainedPairPresent) {\n\t\t\treturn pair.close.substring(0, pair.close.length - containedPairClose.length);\n\t\t} else {\n\t\t\treturn pair.close;\n\t\t}\n\t}\n\n\t/**\n\t * Find another auto-closing pair that is contained by the one passed in.\n\t *\n\t * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n\t * this method will find [(,)] as a containment pair for [(*,*)]\n\t */\n\tprivate static _findContainedAutoClosingPair(config: CursorConfiguration, pair: StandardAutoClosingPairConditional): StandardAutoClosingPairConditional | null {\n\t\tif (pair.open.length <= 1) {\n\t\t\treturn null;\n\t\t}\n\t\tconst lastChar = pair.close.charAt(pair.close.length - 1);\n\t\t// get candidates with the same last character as close\n\t\tconst candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n\t\tlet result: StandardAutoClosingPairConditional | null = null;\n\t\tfor (const candidate of candidates) {\n\t\t\tif (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n\t\t\t\tif (!result || candidate.open.length > result.open.length) {\n\t\t\t\t\tresult = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Determine if typing `ch` at all `positions` in the `model` results in an\n\t * auto closing open sequence being typed.\n\t *\n\t * Auto closing open sequences can consist of multiple characters, which\n\t * can lead to ambiguities. In such a case, the longest auto-closing open\n\t * sequence is returned.\n\t */\n\tprivate static _findAutoClosingPairOpen(config: CursorConfiguration, model: ITextModel, positions: Position[], ch: string): StandardAutoClosingPairConditional | null {\n\t\tconst candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n\t\tif (!candidates) {\n\t\t\treturn null;\n\t\t}\n\t\t// Determine which auto-closing pair it is\n\t\tlet result: StandardAutoClosingPairConditional | null = null;\n\t\tfor (const candidate of candidates) {\n\t\t\tif (result === null || candidate.open.length > result.open.length) {\n\t\t\t\tlet candidateIsMatch = true;\n\t\t\t\tfor (const position of positions) {\n\t\t\t\t\tconst relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n\t\t\t\t\tif (relevantText + ch !== candidate.open) {\n\t\t\t\t\t\tcandidateIsMatch = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (candidateIsMatch) {\n\t\t\t\t\tresult = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _isBeforeClosingBrace(config: CursorConfiguration, lineAfter: string) {\n\t\t// If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n\t\tconst nextChar = lineAfter.charAt(0);\n\t\tconst potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n\t\tconst potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n\n\t\tconst isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n\t\tconst isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n\n\t\treturn !isBeforeStartingBrace && isBeforeClosingBrace;\n\t}\n}\n\nexport class CompositionEndOvertypeOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, compositions: CompositionOutcome[]): EditOperationResult | null {\n\t\tconst isOvertypeMode = config.inputMode === 'overtype';\n\t\tif (!isOvertypeMode) {\n\t\t\treturn null;\n\t\t}\n\t\tconst commands = compositions.map(composition => new ReplaceOvertypeCommandOnCompositionEnd(composition.insertedTextRange));\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class SurroundSelectionOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n\t\t\treturn this._runSurroundSelectionType(config, selections, ch);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runSurroundSelectionType(config: CursorConfiguration, selections: Selection[], ch: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst closeCharacter = config.surroundingPairs[ch];\n\t\t\tcommands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n\n\tprivate static _isSurroundSelectionType(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): boolean {\n\t\tif (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst isTypingAQuoteCharacter = isQuote(ch);\n\t\tfor (const selection of selections) {\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet selectionContainsOnlyWhitespace = true;\n\t\t\tfor (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tconst startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n\t\t\t\tconst endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n\t\t\t\tconst selectedText = lineText.substring(startIndex, endIndex);\n\t\t\t\tif (/[^ \\t]/.test(selectedText)) {\n\t\t\t\t\t// this selected text contains something other than whitespace\n\t\t\t\t\tselectionContainsOnlyWhitespace = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (selectionContainsOnlyWhitespace) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n\t\t\t\tconst selectionText = model.getValueInRange(selection);\n\t\t\t\tif (isQuote(selectionText)) {\n\t\t\t\t\t// Typing a quote character on top of another quote character\n\t\t\t\t\t// => disable surround selection type\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport class InterceptorElectricCharOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\t// Electric characters make sense only when dealing with a single cursor,\n\t\t// as multiple cursors typing brackets for example would interfer with bracket matching\n\t\tif (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n\t\t\tconst r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _isTypeInterceptorElectricChar(config: CursorConfiguration, model: ITextModel, selections: Selection[]) {\n\t\tif (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _typeInterceptorElectricChar(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selection: Selection, ch: string): EditOperationResult | null {\n\t\tif (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tconst position = selection.getPosition();\n\t\tmodel.tokenization.forceTokenization(position.lineNumber);\n\t\tconst lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n\t\tlet electricAction: IElectricAction | null;\n\t\ttry {\n\t\t\telectricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t\treturn null;\n\t\t}\n\t\tif (!electricAction) {\n\t\t\treturn null;\n\t\t}\n\t\tif (electricAction.matchOpenBracket) {\n\t\t\tconst endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n\t\t\tconst match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n\t\t\t\tlineNumber: position.lineNumber,\n\t\t\t\tcolumn: endColumn\n\t\t\t}, 500 /* give at most 500ms to compute */);\n\t\t\tif (match) {\n\t\t\t\tif (match.startLineNumber === position.lineNumber) {\n\t\t\t\t\t// matched something on the same line => no change in indentation\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst matchLine = model.getLineContent(match.startLineNumber);\n\t\t\t\tconst matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n\t\t\t\tconst newIndentation = config.normalizeIndentation(matchLineIndentation);\n\t\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\t\t\tconst lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n\t\t\t\tconst prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n\t\t\t\tconst typeText = newIndentation + prefix + ch;\n\t\t\t\tconst typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n\t\t\t\tconst command = new ReplaceCommand(typeSelection, typeText);\n\t\t\t\treturn new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n\t\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\t\tshouldPushStackElementAfter: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\nexport class SimpleCharacterTypeOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, prevEditOperationType: EditOperationType, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult {\n\t\t// A simple character type\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst ChosenReplaceCommand = config.inputMode === 'overtype' && !isDoingComposition ? ReplaceOvertypeCommand : ReplaceCommand;\n\t\t\tcommands[i] = new ChosenReplaceCommand(selections[i], ch);\n\t\t}\n\n\t\tconst opType = getTypingOperation(ch, prevEditOperationType);\n\t\treturn new EditOperationResult(opType, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class EnterOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && ch === '\\n') {\n\t\t\tconst commands: ICommand[] = [];\n\t\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\t\tcommands[i] = this._enter(config, model, false, selections[i]);\n\t\t\t}\n\t\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _enter(config: CursorConfiguration, model: ITextModel, keepPosition: boolean, range: Range): ICommand {\n\t\tif (config.autoIndent === EditorAutoIndentStrategy.None) {\n\t\t\treturn typeCommand(range, '\\n', keepPosition);\n\t\t}\n\t\tif (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === EditorAutoIndentStrategy.Keep) {\n\t\t\tconst lineText = model.getLineContent(range.startLineNumber);\n\t\t\tconst indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n\t\t}\n\t\tconst r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n\t\tif (r) {\n\t\t\tif (r.indentAction === IndentAction.None) {\n\t\t\t\t// Nothing special\n\t\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n\n\t\t\t} else if (r.indentAction === IndentAction.Indent) {\n\t\t\t\t// Indent once\n\t\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n\n\t\t\t} else if (r.indentAction === IndentAction.IndentOutdent) {\n\t\t\t\t// Ultra special\n\t\t\t\tconst normalIndent = config.normalizeIndentation(r.indentation);\n\t\t\t\tconst increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n\t\t\t\tconst typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n\t\t\t\tif (keepPosition) {\n\t\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n\t\t\t\t} else {\n\t\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n\t\t\t\t}\n\t\t\t} else if (r.indentAction === IndentAction.Outdent) {\n\t\t\t\tconst actualIndentation = unshiftIndent(config, r.indentation);\n\t\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n\t\t\t}\n\t\t}\n\n\t\tconst lineText = model.getLineContent(range.startLineNumber);\n\t\tconst indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\n\t\tif (config.autoIndent >= EditorAutoIndentStrategy.Full) {\n\t\t\tconst ir = getIndentForEnter(config.autoIndent, model, range, {\n\t\t\t\tunshiftIndent: (indent) => {\n\t\t\t\t\treturn unshiftIndent(config, indent);\n\t\t\t\t},\n\t\t\t\tshiftIndent: (indent) => {\n\t\t\t\t\treturn shiftIndent(config, indent);\n\t\t\t\t},\n\t\t\t\tnormalizeIndentation: (indent) => {\n\t\t\t\t\treturn config.normalizeIndentation(indent);\n\t\t\t\t}\n\t\t\t}, config.languageConfigurationService);\n\n\t\t\tif (ir) {\n\t\t\t\tlet oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n\t\t\t\tconst oldEndColumn = range.endColumn;\n\t\t\t\tconst newLineContent = model.getLineContent(range.endLineNumber);\n\t\t\t\tconst firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n\t\t\t\tif (firstNonWhitespace >= 0) {\n\t\t\t\t\trange = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n\t\t\t\t} else {\n\t\t\t\t\trange = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n\t\t\t\t}\n\t\t\t\tif (keepPosition) {\n\t\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n\t\t\t\t} else {\n\t\t\t\t\tlet offset = 0;\n\t\t\t\t\tif (oldEndColumn <= firstNonWhitespace + 1) {\n\t\t\t\t\t\tif (!config.insertSpaces) {\n\t\t\t\t\t\t\toldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n\t\t\t\t\t}\n\t\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n\t}\n\n\n\tpublic static lineInsertBefore(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tlet lineNumber = selections[i].positionLineNumber;\n\t\t\tif (lineNumber === 1) {\n\t\t\t\tcommands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n\t\t\t} else {\n\t\t\t\tlineNumber--;\n\t\t\t\tconst column = model.getLineMaxColumn(lineNumber);\n\n\t\t\t\tcommands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineInsertAfter(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst lineNumber = selections[i].positionLineNumber;\n\t\t\tconst column = model.getLineMaxColumn(lineNumber);\n\t\t\tcommands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineBreakInsert(config: CursorConfiguration, model: ITextModel, selections: Selection[]): ICommand[] {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = this._enter(config, model, true, selections[i]);\n\t\t}\n\t\treturn commands;\n\t}\n}\n\nexport class PasteOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]) {\n\t\tconst distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n\t\tif (distributedPaste) {\n\t\t\tselections = selections.sort(Range.compareRangesUsingStarts);\n\t\t\treturn this._distributedPaste(config, model, selections, distributedPaste);\n\t\t} else {\n\t\t\treturn this._simplePaste(config, model, selections, text, pasteOnNewLine);\n\t\t}\n\t}\n\n\tprivate static _distributePasteToCursors(config: CursorConfiguration, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]): string[] | null {\n\t\tif (pasteOnNewLine) {\n\t\t\treturn null;\n\t\t}\n\t\tif (selections.length === 1) {\n\t\t\treturn null;\n\t\t}\n\t\tif (multicursorText && multicursorText.length === selections.length) {\n\t\t\treturn multicursorText;\n\t\t}\n\t\tif (config.multiCursorPaste === 'spread') {\n\t\t\t// Try to spread the pasted text in case the line count matches the cursor count\n\t\t\t// Remove trailing \\n if present\n\t\t\tif (text.charCodeAt(text.length - 1) === CharCode.LineFeed) {\n\t\t\t\ttext = text.substring(0, text.length - 1);\n\t\t\t}\n\t\t\t// Remove trailing \\r if present\n\t\t\tif (text.charCodeAt(text.length - 1) === CharCode.CarriageReturn) {\n\t\t\t\ttext = text.substring(0, text.length - 1);\n\t\t\t}\n\t\t\tconst lines = strings.splitLines(text);\n\t\t\tif (lines.length === selections.length) {\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static _distributedPaste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string[]): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst shouldOvertypeOnPaste = config.overtypeOnPaste && config.inputMode === 'overtype';\n\t\t\tconst ChosenReplaceCommand = shouldOvertypeOnPaste ? ReplaceOvertypeCommand : ReplaceCommand;\n\t\t\tcommands[i] = new ChosenReplaceCommand(selections[i], text[i]);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n\n\tprivate static _simplePaste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\t\t\tif (pasteOnNewLine && !selection.isEmpty()) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine) {\n\t\t\t\t// Paste entire line at the beginning of line\n\t\t\t\tconst typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n\t\t\t\tcommands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n\t\t\t} else {\n\t\t\t\tconst shouldOvertypeOnPaste = config.overtypeOnPaste && config.inputMode === 'overtype';\n\t\t\t\tconst ChosenReplaceCommand = shouldOvertypeOnPaste ? ReplaceOvertypeCommand : ReplaceCommand;\n\t\t\t\tcommands[i] = new ChosenReplaceCommand(selection, text);\n\t\t\t}\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n}\n\nexport class CompositionOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number) {\n\t\tconst commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, EditOperationType.TypingOther),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tprivate static _compositionType(model: ITextModel, selection: Selection, text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number): ICommand | null {\n\t\tif (!selection.isEmpty()) {\n\t\t\t// looks like https://github.com/microsoft/vscode/issues/2773\n\t\t\t// where a cursor operation occurred before a canceled composition\n\t\t\t// => ignore composition\n\t\t\treturn null;\n\t\t}\n\t\tconst pos = selection.getPosition();\n\t\tconst startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n\t\tconst endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n\t\tconst range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n\t\treturn new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n\t}\n}\n\nexport class TypeWithoutInterceptorsOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, selections: Selection[], str: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], str);\n\t\t}\n\t\tconst opType = getTypingOperation(str, prevEditOperationType);\n\t\treturn new EditOperationResult(opType, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class TabOperation {\n\n\tpublic static getCommands(config: CursorConfiguration, model: ITextModel, selections: Selection[]) {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\tconst lineText = model.getLineContent(selection.startLineNumber);\n\t\t\t\tif (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n\t\t\t\t\tlet goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n\t\t\t\t\tgoodIndent = goodIndent || '\\t';\n\t\t\t\t\tconst possibleTypeText = config.normalizeIndentation(goodIndent);\n\t\t\t\t\tif (!lineText.startsWith(possibleTypeText)) {\n\t\t\t\t\t\tcommands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n\t\t\t} else {\n\t\t\t\tif (selection.startLineNumber === selection.endLineNumber) {\n\t\t\t\t\tconst lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n\t\t\t\t\tif (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n\t\t\t\t\t\t// This is a single line selection that is not the entire line\n\t\t\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommands[i] = new ShiftCommand(selection, {\n\t\t\t\t\tisUnshift: false,\n\t\t\t\t\ttabSize: config.tabSize,\n\t\t\t\t\tindentSize: config.indentSize,\n\t\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\t\tuseTabStops: config.useTabStops,\n\t\t\t\t\tautoIndent: config.autoIndent\n\t\t\t\t}, config.languageConfigurationService);\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tprivate static _goodIndentForLine(config: CursorConfiguration, model: ITextModel, lineNumber: number): string | null {\n\t\tlet action: IndentAction | EnterAction | null = null;\n\t\tlet indentation: string = '';\n\t\tconst expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n\t\tif (expectedIndentAction) {\n\t\t\taction = expectedIndentAction.action;\n\t\t\tindentation = expectedIndentAction.indentation;\n\t\t} else if (lineNumber > 1) {\n\t\t\tlet lastLineNumber: number;\n\t\t\tfor (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n\t\t\t\tconst lineText = model.getLineContent(lastLineNumber);\n\t\t\t\tconst nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n\t\t\t\tif (nonWhitespaceIdx >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastLineNumber < 1) {\n\t\t\t\t// No previous line with content found\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst maxColumn = model.getLineMaxColumn(lastLineNumber);\n\t\t\tconst expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n\t\t\tif (expectedEnterAction) {\n\t\t\t\tindentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n\t\t\t}\n\t\t}\n\t\tif (action) {\n\t\t\tif (action === IndentAction.Indent) {\n\t\t\t\tindentation = shiftIndent(config, indentation);\n\t\t\t}\n\t\t\tif (action === IndentAction.Outdent) {\n\t\t\t\tindentation = unshiftIndent(config, indentation);\n\t\t\t}\n\t\t\tindentation = config.normalizeIndentation(indentation);\n\t\t}\n\t\tif (!indentation) {\n\t\t\treturn null;\n\t\t}\n\t\treturn indentation;\n\t}\n\n\tprivate static _replaceJumpToNextIndent(config: CursorConfiguration, model: ICursorSimpleModel, selection: Selection, insertsAutoWhitespace: boolean): ReplaceCommand {\n\t\tlet typeText = '';\n\t\tconst position = selection.getStartPosition();\n\t\tif (config.insertSpaces) {\n\t\t\tconst visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n\t\t\tconst indentSize = config.indentSize;\n\t\t\tconst spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n\t\t\tfor (let i = 0; i < spacesCnt; i++) {\n\t\t\t\ttypeText += ' ';\n\t\t\t}\n\t\t} else {\n\t\t\ttypeText = '\\t';\n\t\t}\n\t\treturn new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n\t}\n}\n\nexport class BaseTypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n\n\tprivate readonly _openCharacter: string;\n\tprivate readonly _closeCharacter: string;\n\tpublic closeCharacterRange: Range | null;\n\tpublic enclosingRange: Range | null;\n\n\tconstructor(selection: Selection, text: string, lineNumberDeltaOffset: number, columnDeltaOffset: number, openCharacter: string, closeCharacter: string) {\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset);\n\t\tthis._openCharacter = openCharacter;\n\t\tthis._closeCharacter = closeCharacter;\n\t\tthis.closeCharacterRange = null;\n\t\tthis.enclosingRange = null;\n\t}\n\n\tprotected _computeCursorStateWithRange(model: ITextModel, range: Range, helper: ICursorStateComputerData): Selection {\n\t\tthis.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n\t\tthis.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n\t\treturn super.computeCursorState(model, helper);\n\t}\n}\n\nclass TypeWithAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n\n\tconstructor(selection: Selection, openCharacter: string, insertOpenCharacter: boolean, closeCharacter: string) {\n\t\tconst text = (insertOpenCharacter ? openCharacter : '') + closeCharacter;\n\t\tconst lineNumberDeltaOffset = 0;\n\t\tconst columnDeltaOffset = -closeCharacter.length;\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n\t}\n\n\tpublic override computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tconst inverseEditOperations = helper.getInverseEditOperations();\n\t\tconst range = inverseEditOperations[0].range;\n\t\treturn this._computeCursorStateWithRange(model, range, helper);\n\t}\n}\n\nclass TypeWithIndentationAndAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n\n\tprivate readonly _autoIndentationEdit: { range: Range; text: string };\n\tprivate readonly _autoClosingEdit: { range: Range; text: string };\n\n\tconstructor(autoIndentationEdit: { range: Range; text: string }, selection: Selection, openCharacter: string, closeCharacter: string) {\n\t\tconst text = openCharacter + closeCharacter;\n\t\tconst lineNumberDeltaOffset = 0;\n\t\tconst columnDeltaOffset = openCharacter.length;\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n\t\tthis._autoIndentationEdit = autoIndentationEdit;\n\t\tthis._autoClosingEdit = { range: selection, text };\n\t}\n\n\tpublic override getEditOperations(model: ITextModel, builder: IEditOperationBuilder): void {\n\t\tbuilder.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text);\n\t\tbuilder.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);\n\t}\n\n\tpublic override computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tconst inverseEditOperations = helper.getInverseEditOperations();\n\t\tif (inverseEditOperations.length !== 2) {\n\t\t\tthrow new Error('There should be two inverse edit operations!');\n\t\t}\n\t\tconst range1 = inverseEditOperations[0].range;\n\t\tconst range2 = inverseEditOperations[1].range;\n\t\tconst range = range1.plusRange(range2);\n\t\treturn this._computeCursorStateWithRange(model, range, helper);\n\t}\n}\n\nfunction getTypingOperation(typedText: string, previousTypingOperation: EditOperationType): EditOperationType {\n\tif (typedText === ' ') {\n\t\treturn previousTypingOperation === EditOperationType.TypingFirstSpace\n\t\t\t|| previousTypingOperation === EditOperationType.TypingConsecutiveSpace\n\t\t\t? EditOperationType.TypingConsecutiveSpace\n\t\t\t: EditOperationType.TypingFirstSpace;\n\t}\n\n\treturn EditOperationType.TypingOther;\n}\n\nfunction shouldPushStackElementBetween(previousTypingOperation: EditOperationType, typingOperation: EditOperationType): boolean {\n\tif (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n\t\t// Always set an undo stop before non-type operations\n\t\treturn true;\n\t}\n\tif (previousTypingOperation === EditOperationType.TypingFirstSpace) {\n\t\t// `abc |d`: No undo stop\n\t\t// `abc  |d`: Undo stop\n\t\treturn false;\n\t}\n\t// Insert undo stop between different operation types\n\treturn normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\n\nfunction normalizeOperationType(type: EditOperationType): EditOperationType | 'space' {\n\treturn (type === EditOperationType.TypingConsecutiveSpace || type === EditOperationType.TypingFirstSpace)\n\t\t? 'space'\n\t\t: type;\n}\n\nfunction isTypingOperation(type: EditOperationType): boolean {\n\treturn type === EditOperationType.TypingOther\n\t\t|| type === EditOperationType.TypingFirstSpace\n\t\t|| type === EditOperationType.TypingConsecutiveSpace;\n}\n\nfunction isAutoClosingOvertype(config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): boolean {\n\tif (config.autoClosingOvertype === 'never') {\n\t\treturn false;\n\t}\n\tif (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n\t\treturn false;\n\t}\n\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\tconst selection = selections[i];\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tconst position = selection.getPosition();\n\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\tconst afterCharacter = lineText.charAt(position.column - 1);\n\t\tif (afterCharacter !== ch) {\n\t\t\treturn false;\n\t\t}\n\t\t// Do not over-type quotes after a backslash\n\t\tconst chIsQuote = isQuote(ch);\n\t\tconst beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : CharCode.Null;\n\t\tif (beforeCharacter === CharCode.Backslash && chIsQuote) {\n\t\t\treturn false;\n\t\t}\n\t\t// Must over-type a closing character typed by the editor\n\t\tif (config.autoClosingOvertype === 'auto') {\n\t\t\tlet found = false;\n\t\t\tfor (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n\t\t\t\tconst autoClosedCharacter = autoClosedCharacters[j];\n\t\t\t\tif (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction typeCommand(range: Range, text: string, keepPosition: boolean): ICommand {\n\tif (keepPosition) {\n\t\treturn new ReplaceCommandWithoutChangingPosition(range, text, true);\n\t} else {\n\t\treturn new ReplaceCommand(range, text, true);\n\t}\n}\n\nexport function shiftIndent(config: CursorConfiguration, indentation: string, count?: number): string {\n\tcount = count || 1;\n\treturn ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\n\nexport function unshiftIndent(config: CursorConfiguration, indentation: string, count?: number): string {\n\tcount = count || 1;\n\treturn ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\n\nexport function shouldSurroundChar(config: CursorConfiguration, ch: string): boolean {\n\tif (isQuote(ch)) {\n\t\treturn (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n\t} else {\n\t\t// Character is a bracket\n\t\treturn (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection, ReplaceOvertypeCommand, ReplaceOvertypeCommandOnCompositionEnd } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorConfiguration, EditOperationResult, EditOperationType, ICursorSimpleModel, isQuote } from '../cursorCommon.js';\nimport { WordCharacterClass, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Position } from '../core/position.js';\nimport { ICommand, ICursorStateComputerData, IEditOperationBuilder } from '../editorCommon.js';\nimport { ITextModel } from '../model.js';\nimport { EnterAction, IndentAction, StandardAutoClosingPairConditional } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { IElectricAction } from '../languages/supports/electricCharacter.js';\nimport { EditorAutoClosingStrategy, EditorAutoIndentStrategy } from '../config/editorOptions.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nimport { CompositionOutcome } from './cursorTypeOperations.js';\n\nexport class AutoIndentOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n\t\t\tconst indentationForSelections: { selection: Selection; indentation: string }[] = [];\n\t\t\tfor (const selection of selections) {\n\t\t\t\tconst indentation = this._findActualIndentationForSelection(config, model, selection, ch);\n\t\t\t\tif (indentation === null) {\n\t\t\t\t\t// Auto indentation failed\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tindentationForSelections.push({ selection, indentation });\n\t\t\t}\n\t\t\tconst autoClosingPairClose = AutoClosingOpenCharTypeOperation.getAutoClosingPairClose(config, model, selections, ch, false);\n\t\t\treturn this._getIndentationAndAutoClosingPairEdits(config, model, indentationForSelections, ch, autoClosingPairClose);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _isAutoIndentType(config: CursorConfiguration, model: ITextModel, selections: Selection[]): boolean {\n\t\tif (config.autoIndent < EditorAutoIndentStrategy.Full) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tif (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _findActualIndentationForSelection(config: CursorConfiguration, model: ITextModel, selection: Selection, ch: string): string | null {\n\t\tconst actualIndentation = getIndentActionForType(config, model, selection, ch, {\n\t\t\tshiftIndent: (indentation) => {\n\t\t\t\treturn shiftIndent(config, indentation);\n\t\t\t},\n\t\t\tunshiftIndent: (indentation) => {\n\t\t\t\treturn unshiftIndent(config, indentation);\n\t\t\t},\n\t\t}, config.languageConfigurationService);\n\n\t\tif (actualIndentation === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currentIndentation = getIndentationAtPosition(model, selection.startLineNumber, selection.startColumn);\n\t\tif (actualIndentation === config.normalizeIndentation(currentIndentation)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn actualIndentation;\n\t}\n\n\tprivate static _getIndentationAndAutoClosingPairEdits(config: CursorConfiguration, model: ITextModel, indentationForSelections: { selection: Selection; indentation: string }[], ch: string, autoClosingPairClose: string | null): EditOperationResult {\n\t\tconst commands: ICommand[] = indentationForSelections.map(({ selection, indentation }) => {\n\t\t\tif (autoClosingPairClose !== null) {\n\t\t\t\t// Apply both auto closing pair edits and auto indentation edits\n\t\t\t\tconst indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, false);\n\t\t\t\treturn new TypeWithIndentationAndAutoClosingCommand(indentationEdit, selection, ch, autoClosingPairClose);\n\t\t\t} else {\n\t\t\t\t// Apply only auto indentation edits\n\t\t\t\tconst indentationEdit = this._getEditFromIndentationAndSelection(config, model, indentation, selection, ch, true);\n\t\t\t\treturn typeCommand(indentationEdit.range, indentationEdit.text, false);\n\t\t\t}\n\t\t});\n\t\tconst editOptions = { shouldPushStackElementBefore: true, shouldPushStackElementAfter: false };\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, editOptions);\n\t}\n\n\tprivate static _getEditFromIndentationAndSelection(config: CursorConfiguration, model: ITextModel, indentation: string, selection: Selection, ch: string, includeChInEdit: boolean = true): { range: Range; text: string } {\n\t\tconst startLineNumber = selection.startLineNumber;\n\t\tconst firstNonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(startLineNumber);\n\t\tlet text: string = config.normalizeIndentation(indentation);\n\t\tif (firstNonWhitespaceColumn !== 0) {\n\t\t\tconst startLine = model.getLineContent(startLineNumber);\n\t\t\ttext += startLine.substring(firstNonWhitespaceColumn - 1, selection.startColumn - 1);\n\t\t}\n\t\ttext += includeChInEdit ? ch : '';\n\t\tconst range = new Range(startLineNumber, 1, selection.endLineNumber, selection.endColumn);\n\t\treturn { range, text };\n\t}\n}\n\nexport class AutoClosingOvertypeOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): EditOperationResult | undefined {\n\t\tif (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n\t\t\treturn this._runAutoClosingOvertype(prevEditOperationType, selections, ch);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runAutoClosingOvertype(prevEditOperationType: EditOperationType, selections: Selection[], ch: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\t\t\tconst typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n\t\t\tcommands[i] = new ReplaceCommand(typeSelection, ch);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, EditOperationType.TypingOther),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class AutoClosingOvertypeWithInterceptorsOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): EditOperationResult | undefined {\n\t\tif (isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n\t\t\t// Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n\t\t\tconst commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n\t\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n}\n\nexport class AutoClosingOpenCharTypeOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, chIsAlreadyTyped: boolean, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition) {\n\t\t\tconst autoClosingPairClose = this.getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped);\n\t\t\tif (autoClosingPairClose !== null) {\n\t\t\t\treturn this._runAutoClosingOpenCharType(selections, ch, chIsAlreadyTyped, autoClosingPairClose);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runAutoClosingOpenCharType(selections: Selection[], ch: string, chIsAlreadyTyped: boolean, autoClosingPairClose: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tcommands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tpublic static getAutoClosingPairClose(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, chIsAlreadyTyped: boolean): string | null {\n\t\tfor (const selection of selections) {\n\t\t\tif (!selection.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// This method is called both when typing (regularly) and when composition ends\n\t\t// This means that we need to work with a text buffer where sometimes `ch` is not\n\t\t// there (it is being typed right now) or with a text buffer where `ch` has already been typed\n\t\t//\n\t\t// In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n\t\t// with two conceptual positions, the position before `ch` and the position after `ch`\n\t\t//\n\t\tconst positions: { lineNumber: number; beforeColumn: number; afterColumn: number }[] = selections.map((s) => {\n\t\t\tconst position = s.getPosition();\n\t\t\tif (chIsAlreadyTyped) {\n\t\t\t\treturn { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n\t\t\t} else {\n\t\t\t\treturn { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n\t\t\t}\n\t\t});\n\t\t// Find the longest auto-closing open pair in case of multiple ending in `ch`\n\t\t// e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n\t\tconst pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n\t\tif (!pair) {\n\t\t\treturn null;\n\t\t}\n\t\tlet autoCloseConfig: EditorAutoClosingStrategy;\n\t\tlet shouldAutoCloseBefore: (ch: string) => boolean;\n\n\t\tconst chIsQuote = isQuote(ch);\n\t\tif (chIsQuote) {\n\t\t\tautoCloseConfig = config.autoClosingQuotes;\n\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n\t\t} else {\n\t\t\tconst pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n\t\t\tif (pairIsForComments) {\n\t\t\t\tautoCloseConfig = config.autoClosingComments;\n\t\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n\t\t\t} else {\n\t\t\t\tautoCloseConfig = config.autoClosingBrackets;\n\t\t\t\tshouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n\t\t\t}\n\t\t}\n\t\tif (autoCloseConfig === 'never') {\n\t\t\treturn null;\n\t\t}\n\t\t// Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n\t\t// e.g. when having [(,)] and [(*,*)]\n\t\t// - when typing (, the resulting state is (|)\n\t\t// - when typing *, the desired resulting state is (*|*), not (*|*))\n\t\tconst containedPair = this._findContainedAutoClosingPair(config, pair);\n\t\tconst containedPairClose = containedPair ? containedPair.close : '';\n\t\tlet isContainedPairPresent = true;\n\n\t\tfor (const position of positions) {\n\t\t\tconst { lineNumber, beforeColumn, afterColumn } = position;\n\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\tconst lineBefore = lineText.substring(0, beforeColumn - 1);\n\t\t\tconst lineAfter = lineText.substring(afterColumn - 1);\n\n\t\t\tif (!lineAfter.startsWith(containedPairClose)) {\n\t\t\t\tisContainedPairPresent = false;\n\t\t\t}\n\t\t\t// Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n\t\t\tif (lineAfter.length > 0) {\n\t\t\t\tconst characterAfter = lineAfter.charAt(0);\n\t\t\t\tconst isBeforeCloseBrace = this._isBeforeClosingBrace(config, lineAfter);\n\t\t\t\tif (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Do not auto-close ' or \" after a word character\n\t\t\tif (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n\t\t\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n\t\t\t\tif (lineBefore.length > 0) {\n\t\t\t\t\tconst characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n\t\t\t\t\tif (wordSeparators.get(characterBefore) === WordCharacterClass.Regular) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!model.tokenization.isCheapToTokenize(lineNumber)) {\n\t\t\t\t// Do not force tokenization\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmodel.tokenization.forceTokenization(lineNumber);\n\t\t\tconst lineTokens = model.tokenization.getLineTokens(lineNumber);\n\t\t\tconst scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n\t\t\tif (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Typing for example a quote could either start a new string, in which case auto-closing is desirable\n\t\t\t// or it could end a previously started string, in which case auto-closing is not desirable\n\t\t\t//\n\t\t\t// In certain cases, it is really not possible to look at the previous token to determine\n\t\t\t// what would happen. That's why we do something really unusual, we pretend to type a different\n\t\t\t// character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n\t\t\t// character, are we in a string (i.e. the quote would most likely end a string) or not?\n\t\t\t//\n\t\t\tconst neutralCharacter = pair.findNeutralCharacter();\n\t\t\tif (neutralCharacter) {\n\t\t\t\tconst tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n\t\t\t\tif (!pair.isOK(tokenType)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isContainedPairPresent) {\n\t\t\treturn pair.close.substring(0, pair.close.length - containedPairClose.length);\n\t\t} else {\n\t\t\treturn pair.close;\n\t\t}\n\t}\n\n\t/**\n\t * Find another auto-closing pair that is contained by the one passed in.\n\t *\n\t * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n\t * this method will find [(,)] as a containment pair for [(*,*)]\n\t */\n\tprivate static _findContainedAutoClosingPair(config: CursorConfiguration, pair: StandardAutoClosingPairConditional): StandardAutoClosingPairConditional | null {\n\t\tif (pair.open.length <= 1) {\n\t\t\treturn null;\n\t\t}\n\t\tconst lastChar = pair.close.charAt(pair.close.length - 1);\n\t\t// get candidates with the same last character as close\n\t\tconst candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n\t\tlet result: StandardAutoClosingPairConditional | null = null;\n\t\tfor (const candidate of candidates) {\n\t\t\tif (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n\t\t\t\tif (!result || candidate.open.length > result.open.length) {\n\t\t\t\t\tresult = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Determine if typing `ch` at all `positions` in the `model` results in an\n\t * auto closing open sequence being typed.\n\t *\n\t * Auto closing open sequences can consist of multiple characters, which\n\t * can lead to ambiguities. In such a case, the longest auto-closing open\n\t * sequence is returned.\n\t */\n\tprivate static _findAutoClosingPairOpen(config: CursorConfiguration, model: ITextModel, positions: Position[], ch: string): StandardAutoClosingPairConditional | null {\n\t\tconst candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n\t\tif (!candidates) {\n\t\t\treturn null;\n\t\t}\n\t\t// Determine which auto-closing pair it is\n\t\tlet result: StandardAutoClosingPairConditional | null = null;\n\t\tfor (const candidate of candidates) {\n\t\t\tif (result === null || candidate.open.length > result.open.length) {\n\t\t\t\tlet candidateIsMatch = true;\n\t\t\t\tfor (const position of positions) {\n\t\t\t\t\tconst relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n\t\t\t\t\tif (relevantText + ch !== candidate.open) {\n\t\t\t\t\t\tcandidateIsMatch = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (candidateIsMatch) {\n\t\t\t\t\tresult = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _isBeforeClosingBrace(config: CursorConfiguration, lineAfter: string) {\n\t\t// If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n\t\tconst nextChar = lineAfter.charAt(0);\n\t\tconst potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n\t\tconst potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n\n\t\tconst isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n\t\tconst isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n\n\t\treturn !isBeforeStartingBrace && isBeforeClosingBrace;\n\t}\n}\n\nexport class CompositionEndOvertypeOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, compositions: CompositionOutcome[]): EditOperationResult | null {\n\t\tconst isOvertypeMode = config.inputMode === 'overtype';\n\t\tif (!isOvertypeMode) {\n\t\t\treturn null;\n\t\t}\n\t\tconst commands = compositions.map(composition => new ReplaceOvertypeCommandOnCompositionEnd(composition.insertedTextRange));\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class SurroundSelectionOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n\t\t\treturn this._runSurroundSelectionType(config, selections, ch);\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _runSurroundSelectionType(config: CursorConfiguration, selections: Selection[], ch: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst closeCharacter = config.surroundingPairs[ch];\n\t\t\tcommands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n\n\tprivate static _isSurroundSelectionType(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): boolean {\n\t\tif (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst isTypingAQuoteCharacter = isQuote(ch);\n\t\tfor (const selection of selections) {\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlet selectionContainsOnlyWhitespace = true;\n\t\t\tfor (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tconst startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n\t\t\t\tconst endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n\t\t\t\tconst selectedText = lineText.substring(startIndex, endIndex);\n\t\t\t\tif (/[^ \\t]/.test(selectedText)) {\n\t\t\t\t\t// this selected text contains something other than whitespace\n\t\t\t\t\tselectionContainsOnlyWhitespace = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (selectionContainsOnlyWhitespace) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n\t\t\t\tconst selectionText = model.getValueInRange(selection);\n\t\t\t\tif (isQuote(selectionText)) {\n\t\t\t\t\t// Typing a quote character on top of another quote character\n\t\t\t\t\t// => disable surround selection type\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport class InterceptorElectricCharOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\t// Electric characters make sense only when dealing with a single cursor,\n\t\t// as multiple cursors typing brackets for example would interfer with bracket matching\n\t\tif (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n\t\t\tconst r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _isTypeInterceptorElectricChar(config: CursorConfiguration, model: ITextModel, selections: Selection[]) {\n\t\tif (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _typeInterceptorElectricChar(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selection: Selection, ch: string): EditOperationResult | null {\n\t\tif (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tconst position = selection.getPosition();\n\t\tmodel.tokenization.forceTokenization(position.lineNumber);\n\t\tconst lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n\t\tlet electricAction: IElectricAction | null;\n\t\ttry {\n\t\t\telectricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t\treturn null;\n\t\t}\n\t\tif (!electricAction) {\n\t\t\treturn null;\n\t\t}\n\t\tif (electricAction.matchOpenBracket) {\n\t\t\tconst endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n\t\t\tconst match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n\t\t\t\tlineNumber: position.lineNumber,\n\t\t\t\tcolumn: endColumn\n\t\t\t}, 500 /* give at most 500ms to compute */);\n\t\t\tif (match) {\n\t\t\t\tif (match.startLineNumber === position.lineNumber) {\n\t\t\t\t\t// matched something on the same line => no change in indentation\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst matchLine = model.getLineContent(match.startLineNumber);\n\t\t\t\tconst matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n\t\t\t\tconst newIndentation = config.normalizeIndentation(matchLineIndentation);\n\t\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\t\t\tconst lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n\t\t\t\tconst prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n\t\t\t\tconst typeText = newIndentation + prefix + ch;\n\t\t\t\tconst typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n\t\t\t\tconst command = new ReplaceCommand(typeSelection, typeText);\n\t\t\t\treturn new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n\t\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\t\tshouldPushStackElementAfter: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\nexport class SimpleCharacterTypeOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, prevEditOperationType: EditOperationType, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult {\n\t\t// A simple character type\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst ChosenReplaceCommand = config.inputMode === 'overtype' && !isDoingComposition ? ReplaceOvertypeCommand : ReplaceCommand;\n\t\t\tcommands[i] = new ChosenReplaceCommand(selections[i], ch);\n\t\t}\n\n\t\tconst opType = getTypingOperation(ch, prevEditOperationType);\n\t\treturn new EditOperationResult(opType, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class EnterOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string, isDoingComposition: boolean): EditOperationResult | undefined {\n\t\tif (!isDoingComposition && ch === '\\n') {\n\t\t\tconst commands: ICommand[] = [];\n\t\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\t\tcommands[i] = this._enter(config, model, false, selections[i]);\n\t\t\t}\n\t\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tprivate static _enter(config: CursorConfiguration, model: ITextModel, keepPosition: boolean, range: Range): ICommand {\n\t\tif (config.autoIndent === EditorAutoIndentStrategy.None) {\n\t\t\treturn typeCommand(range, '\\n', keepPosition);\n\t\t}\n\t\tif (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === EditorAutoIndentStrategy.Keep) {\n\t\t\tconst lineText = model.getLineContent(range.startLineNumber);\n\t\t\tconst indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n\t\t}\n\t\tconst r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n\t\tif (r) {\n\t\t\tif (r.indentAction === IndentAction.None) {\n\t\t\t\t// Nothing special\n\t\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n\n\t\t\t} else if (r.indentAction === IndentAction.Indent) {\n\t\t\t\t// Indent once\n\t\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n\n\t\t\t} else if (r.indentAction === IndentAction.IndentOutdent) {\n\t\t\t\t// Ultra special\n\t\t\t\tconst normalIndent = config.normalizeIndentation(r.indentation);\n\t\t\t\tconst increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n\t\t\t\tconst typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n\t\t\t\tif (keepPosition) {\n\t\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n\t\t\t\t} else {\n\t\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n\t\t\t\t}\n\t\t\t} else if (r.indentAction === IndentAction.Outdent) {\n\t\t\t\tconst actualIndentation = unshiftIndent(config, r.indentation);\n\t\t\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n\t\t\t}\n\t\t}\n\n\t\tconst lineText = model.getLineContent(range.startLineNumber);\n\t\tconst indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\n\t\tif (config.autoIndent >= EditorAutoIndentStrategy.Full) {\n\t\t\tconst ir = getIndentForEnter(config.autoIndent, model, range, {\n\t\t\t\tunshiftIndent: (indent) => {\n\t\t\t\t\treturn unshiftIndent(config, indent);\n\t\t\t\t},\n\t\t\t\tshiftIndent: (indent) => {\n\t\t\t\t\treturn shiftIndent(config, indent);\n\t\t\t\t},\n\t\t\t\tnormalizeIndentation: (indent) => {\n\t\t\t\t\treturn config.normalizeIndentation(indent);\n\t\t\t\t}\n\t\t\t}, config.languageConfigurationService);\n\n\t\t\tif (ir) {\n\t\t\t\tlet oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n\t\t\t\tconst oldEndColumn = range.endColumn;\n\t\t\t\tconst newLineContent = model.getLineContent(range.endLineNumber);\n\t\t\t\tconst firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n\t\t\t\tif (firstNonWhitespace >= 0) {\n\t\t\t\t\trange = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n\t\t\t\t} else {\n\t\t\t\t\trange = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n\t\t\t\t}\n\t\t\t\tif (keepPosition) {\n\t\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n\t\t\t\t} else {\n\t\t\t\t\tlet offset = 0;\n\t\t\t\t\tif (oldEndColumn <= firstNonWhitespace + 1) {\n\t\t\t\t\t\tif (!config.insertSpaces) {\n\t\t\t\t\t\t\toldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n\t\t\t\t\t}\n\t\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n\t}\n\n\n\tpublic static lineInsertBefore(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tlet lineNumber = selections[i].positionLineNumber;\n\t\t\tif (lineNumber === 1) {\n\t\t\t\tcommands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n\t\t\t} else {\n\t\t\t\tlineNumber--;\n\t\t\t\tconst column = model.getLineMaxColumn(lineNumber);\n\n\t\t\t\tcommands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineInsertAfter(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst lineNumber = selections[i].positionLineNumber;\n\t\t\tconst column = model.getLineMaxColumn(lineNumber);\n\t\t\tcommands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineBreakInsert(config: CursorConfiguration, model: ITextModel, selections: Selection[]): ICommand[] {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = this._enter(config, model, true, selections[i]);\n\t\t}\n\t\treturn commands;\n\t}\n}\n\nexport class PasteOperation {\n\n\tpublic static getEdits(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]) {\n\t\tconst distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n\t\tif (distributedPaste) {\n\t\t\tselections = selections.sort(Range.compareRangesUsingStarts);\n\t\t\treturn this._distributedPaste(config, model, selections, distributedPaste);\n\t\t} else {\n\t\t\treturn this._simplePaste(config, model, selections, text, pasteOnNewLine);\n\t\t}\n\t}\n\n\tprivate static _distributePasteToCursors(config: CursorConfiguration, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]): string[] | null {\n\t\tif (pasteOnNewLine) {\n\t\t\treturn null;\n\t\t}\n\t\tif (selections.length === 1) {\n\t\t\treturn null;\n\t\t}\n\t\tif (multicursorText && multicursorText.length === selections.length) {\n\t\t\treturn multicursorText;\n\t\t}\n\t\tif (config.multiCursorPaste === 'spread') {\n\t\t\t// Try to spread the pasted text in case the line count matches the cursor count\n\t\t\t// Remove trailing \\n if present\n\t\t\tif (text.charCodeAt(text.length - 1) === CharCode.LineFeed) {\n\t\t\t\ttext = text.substring(0, text.length - 1);\n\t\t\t}\n\t\t\t// Remove trailing \\r if present\n\t\t\tif (text.charCodeAt(text.length - 1) === CharCode.CarriageReturn) {\n\t\t\t\ttext = text.substring(0, text.length - 1);\n\t\t\t}\n\t\t\tconst lines = strings.splitLines(text);\n\t\t\tif (lines.length === selections.length) {\n\t\t\t\treturn lines;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static _distributedPaste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string[]): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst shouldOvertypeOnPaste = config.overtypeOnPaste && config.inputMode === 'overtype';\n\t\t\tconst ChosenReplaceCommand = shouldOvertypeOnPaste ? ReplaceOvertypeCommand : ReplaceCommand;\n\t\t\tcommands[i] = new ChosenReplaceCommand(selections[i], text[i]);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n\n\tprivate static _simplePaste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\t\t\tif (pasteOnNewLine && !selection.isEmpty()) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine) {\n\t\t\t\t// Paste entire line at the beginning of line\n\t\t\t\tconst typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n\t\t\t\tcommands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n\t\t\t} else {\n\t\t\t\tconst shouldOvertypeOnPaste = config.overtypeOnPaste && config.inputMode === 'overtype';\n\t\t\t\tconst ChosenReplaceCommand = shouldOvertypeOnPaste ? ReplaceOvertypeCommand : ReplaceCommand;\n\t\t\t\tcommands[i] = new ChosenReplaceCommand(selection, text);\n\t\t\t}\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n}\n\nexport class CompositionOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number) {\n\t\tconst commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, EditOperationType.TypingOther),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tprivate static _compositionType(model: ITextModel, selection: Selection, text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number): ICommand | null {\n\t\tif (!selection.isEmpty()) {\n\t\t\t// looks like https://github.com/microsoft/vscode/issues/2773\n\t\t\t// where a cursor operation occurred before a canceled composition\n\t\t\t// => ignore composition\n\t\t\treturn null;\n\t\t}\n\t\tconst pos = selection.getPosition();\n\t\tconst startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n\t\tconst endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n\t\tconst range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n\t\treturn new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n\t}\n}\n\nexport class TypeWithoutInterceptorsOperation {\n\n\tpublic static getEdits(prevEditOperationType: EditOperationType, selections: Selection[], str: string): EditOperationResult {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], str);\n\t\t}\n\t\tconst opType = getTypingOperation(str, prevEditOperationType);\n\t\treturn new EditOperationResult(opType, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n}\n\nexport class TabOperation {\n\n\tpublic static getCommands(config: CursorConfiguration, model: ITextModel, selections: Selection[]) {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\tconst lineText = model.getLineContent(selection.startLineNumber);\n\t\t\t\tif (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n\t\t\t\t\tlet goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n\t\t\t\t\tgoodIndent = goodIndent || '\\t';\n\t\t\t\t\tconst possibleTypeText = config.normalizeIndentation(goodIndent);\n\t\t\t\t\tif (!lineText.startsWith(possibleTypeText)) {\n\t\t\t\t\t\tcommands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n\t\t\t} else {\n\t\t\t\tif (selection.startLineNumber === selection.endLineNumber) {\n\t\t\t\t\tconst lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n\t\t\t\t\tif (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n\t\t\t\t\t\t// This is a single line selection that is not the entire line\n\t\t\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcommands[i] = new ShiftCommand(selection, {\n\t\t\t\t\tisUnshift: false,\n\t\t\t\t\ttabSize: config.tabSize,\n\t\t\t\t\tindentSize: config.indentSize,\n\t\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\t\tuseTabStops: config.useTabStops,\n\t\t\t\t\tautoIndent: config.autoIndent\n\t\t\t\t}, config.languageConfigurationService);\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tprivate static _goodIndentForLine(config: CursorConfiguration, model: ITextModel, lineNumber: number): string | null {\n\t\tlet action: IndentAction | EnterAction | null = null;\n\t\tlet indentation: string = '';\n\t\tconst expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n\t\tif (expectedIndentAction) {\n\t\t\taction = expectedIndentAction.action;\n\t\t\tindentation = expectedIndentAction.indentation;\n\t\t} else if (lineNumber > 1) {\n\t\t\tlet lastLineNumber: number;\n\t\t\tfor (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n\t\t\t\tconst lineText = model.getLineContent(lastLineNumber);\n\t\t\t\tconst nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n\t\t\t\tif (nonWhitespaceIdx >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastLineNumber < 1) {\n\t\t\t\t// No previous line with content found\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst maxColumn = model.getLineMaxColumn(lastLineNumber);\n\t\t\tconst expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n\t\t\tif (expectedEnterAction) {\n\t\t\t\tindentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n\t\t\t}\n\t\t}\n\t\tif (action) {\n\t\t\tif (action === IndentAction.Indent) {\n\t\t\t\tindentation = shiftIndent(config, indentation);\n\t\t\t}\n\t\t\tif (action === IndentAction.Outdent) {\n\t\t\t\tindentation = unshiftIndent(config, indentation);\n\t\t\t}\n\t\t\tindentation = config.normalizeIndentation(indentation);\n\t\t}\n\t\tif (!indentation) {\n\t\t\treturn null;\n\t\t}\n\t\treturn indentation;\n\t}\n\n\tprivate static _replaceJumpToNextIndent(config: CursorConfiguration, model: ICursorSimpleModel, selection: Selection, insertsAutoWhitespace: boolean): ReplaceCommand {\n\t\tlet typeText = '';\n\t\tconst position = selection.getStartPosition();\n\t\tif (config.insertSpaces) {\n\t\t\tconst visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n\t\t\tconst indentSize = config.indentSize;\n\t\t\tconst spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n\t\t\tfor (let i = 0; i < spacesCnt; i++) {\n\t\t\t\ttypeText += ' ';\n\t\t\t}\n\t\t} else {\n\t\t\ttypeText = '\\t';\n\t\t}\n\t\treturn new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n\t}\n}\n\nexport class BaseTypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n\n\tprivate readonly _openCharacter: string;\n\tprivate readonly _closeCharacter: string;\n\tpublic closeCharacterRange: Range | null;\n\tpublic enclosingRange: Range | null;\n\n\tconstructor(selection: Selection, text: string, lineNumberDeltaOffset: number, columnDeltaOffset: number, openCharacter: string, closeCharacter: string) {\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset);\n\t\tthis._openCharacter = openCharacter;\n\t\tthis._closeCharacter = closeCharacter;\n\t\tthis.closeCharacterRange = null;\n\t\tthis.enclosingRange = null;\n\t}\n\n\tprotected _computeCursorStateWithRange(model: ITextModel, range: Range, helper: ICursorStateComputerData): Selection {\n\t\tthis.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n\t\tthis.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n\t\treturn super.computeCursorState(model, helper);\n\t}\n}\n\nclass TypeWithAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n\n\tconstructor(selection: Selection, openCharacter: string, insertOpenCharacter: boolean, closeCharacter: string) {\n\t\tconst text = (insertOpenCharacter ? openCharacter : '') + closeCharacter;\n\t\tconst lineNumberDeltaOffset = 0;\n\t\tconst columnDeltaOffset = -closeCharacter.length;\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n\t}\n\n\tpublic override computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tconst inverseEditOperations = helper.getInverseEditOperations();\n\t\tconst range = inverseEditOperations[0].range;\n\t\treturn this._computeCursorStateWithRange(model, range, helper);\n\t}\n}\n\nclass TypeWithIndentationAndAutoClosingCommand extends BaseTypeWithAutoClosingCommand {\n\n\tprivate readonly _autoIndentationEdit: { range: Range; text: string };\n\tprivate readonly _autoClosingEdit: { range: Range; text: string };\n\n\tconstructor(autoIndentationEdit: { range: Range; text: string }, selection: Selection, openCharacter: string, closeCharacter: string) {\n\t\tconst text = openCharacter + closeCharacter;\n\t\tconst lineNumberDeltaOffset = 0;\n\t\tconst columnDeltaOffset = openCharacter.length;\n\t\tsuper(selection, text, lineNumberDeltaOffset, columnDeltaOffset, openCharacter, closeCharacter);\n\t\tthis._autoIndentationEdit = autoIndentationEdit;\n\t\tthis._autoClosingEdit = { range: selection, text };\n\t}\n\n\tpublic override getEditOperations(model: ITextModel, builder: IEditOperationBuilder): void {\n\t\tbuilder.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text);\n\t\tbuilder.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);\n\t}\n\n\tpublic override computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection {\n\t\tconst inverseEditOperations = helper.getInverseEditOperations();\n\t\tif (inverseEditOperations.length !== 2) {\n\t\t\tthrow new Error('There should be two inverse edit operations!');\n\t\t}\n\t\tconst range1 = inverseEditOperations[0].range;\n\t\tconst range2 = inverseEditOperations[1].range;\n\t\tconst range = range1.plusRange(range2);\n\t\treturn this._computeCursorStateWithRange(model, range, helper);\n\t}\n}\n\nfunction getTypingOperation(typedText: string, previousTypingOperation: EditOperationType): EditOperationType {\n\tif (typedText === ' ') {\n\t\treturn previousTypingOperation === EditOperationType.TypingFirstSpace\n\t\t\t|| previousTypingOperation === EditOperationType.TypingConsecutiveSpace\n\t\t\t? EditOperationType.TypingConsecutiveSpace\n\t\t\t: EditOperationType.TypingFirstSpace;\n\t}\n\n\treturn EditOperationType.TypingOther;\n}\n\nfunction shouldPushStackElementBetween(previousTypingOperation: EditOperationType, typingOperation: EditOperationType): boolean {\n\tif (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n\t\t// Always set an undo stop before non-type operations\n\t\treturn true;\n\t}\n\tif (previousTypingOperation === EditOperationType.TypingFirstSpace) {\n\t\t// `abc |d`: No undo stop\n\t\t// `abc  |d`: Undo stop\n\t\treturn false;\n\t}\n\t// Insert undo stop between different operation types\n\treturn normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\n\nfunction normalizeOperationType(type: EditOperationType): EditOperationType | 'space' {\n\treturn (type === EditOperationType.TypingConsecutiveSpace || type === EditOperationType.TypingFirstSpace)\n\t\t? 'space'\n\t\t: type;\n}\n\nfunction isTypingOperation(type: EditOperationType): boolean {\n\treturn type === EditOperationType.TypingOther\n\t\t|| type === EditOperationType.TypingFirstSpace\n\t\t|| type === EditOperationType.TypingConsecutiveSpace;\n}\n\nfunction isAutoClosingOvertype(config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): boolean {\n\tif (config.autoClosingOvertype === 'never') {\n\t\treturn false;\n\t}\n\tif (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n\t\treturn false;\n\t}\n\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\tconst selection = selections[i];\n\t\tif (!selection.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tconst position = selection.getPosition();\n\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\tconst afterCharacter = lineText.charAt(position.column - 1);\n\t\tif (afterCharacter !== ch) {\n\t\t\treturn false;\n\t\t}\n\t\t// Do not over-type quotes after a backslash\n\t\tconst chIsQuote = isQuote(ch);\n\t\tconst beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : CharCode.Null;\n\t\tif (beforeCharacter === CharCode.Backslash && chIsQuote) {\n\t\t\treturn false;\n\t\t}\n\t\t// Must over-type a closing character typed by the editor\n\t\tif (config.autoClosingOvertype === 'auto') {\n\t\t\tlet found = false;\n\t\t\tfor (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n\t\t\t\tconst autoClosedCharacter = autoClosedCharacters[j];\n\t\t\t\tif (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction typeCommand(range: Range, text: string, keepPosition: boolean): ICommand {\n\tif (keepPosition) {\n\t\treturn new ReplaceCommandWithoutChangingPosition(range, text, true);\n\t} else {\n\t\treturn new ReplaceCommand(range, text, true);\n\t}\n}\n\nexport function shiftIndent(config: CursorConfiguration, indentation: string, count?: number): string {\n\tcount = count || 1;\n\treturn ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\n\nexport function unshiftIndent(config: CursorConfiguration, indentation: string, count?: number): string {\n\tcount = count || 1;\n\treturn ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n}\n\nexport function shouldSurroundChar(config: CursorConfiguration, ch: string): boolean {\n\tif (isQuote(ch)) {\n\t\treturn (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n\t} else {\n\t\t// Character is a bracket\n\t\treturn (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3196, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorTypeOperations.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorTypeOperations.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorConfiguration, EditOperationResult, EditOperationType, ICursorSimpleModel, isQuote } from '../cursorCommon.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Position } from '../core/position.js';\nimport { ICommand } from '../editorCommon.js';\nimport { ITextModel } from '../model.js';\nimport { AutoClosingOpenCharTypeOperation, AutoClosingOvertypeOperation, AutoClosingOvertypeWithInterceptorsOperation, AutoIndentOperation, CompositionOperation, CompositionEndOvertypeOperation, EnterOperation, InterceptorElectricCharOperation, PasteOperation, shouldSurroundChar, SimpleCharacterTypeOperation, SurroundSelectionOperation, TabOperation, TypeWithoutInterceptorsOperation } from './cursorTypeEditOperations.js';\n\nexport class TypeOperations {\n\n\tpublic static indent(config: CursorConfiguration, model: ICursorSimpleModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ShiftCommand(selections[i], {\n\t\t\t\tisUnshift: false,\n\t\t\t\ttabSize: config.tabSize,\n\t\t\t\tindentSize: config.indentSize,\n\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\tuseTabStops: config.useTabStops,\n\t\t\t\tautoIndent: config.autoIndent\n\t\t\t}, config.languageConfigurationService);\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static outdent(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): ICommand[] {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ShiftCommand(selections[i], {\n\t\t\t\tisUnshift: true,\n\t\t\t\ttabSize: config.tabSize,\n\t\t\t\tindentSize: config.indentSize,\n\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\tuseTabStops: config.useTabStops,\n\t\t\t\tautoIndent: config.autoIndent\n\t\t\t}, config.languageConfigurationService);\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static paste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]): EditOperationResult {\n\t\treturn PasteOperation.getEdits(config, model, selections, text, pasteOnNewLine, multicursorText);\n\t}\n\n\tpublic static tab(config: CursorConfiguration, model: ITextModel, selections: Selection[]): ICommand[] {\n\t\treturn TabOperation.getCommands(config, model, selections);\n\t}\n\n\tpublic static compositionType(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number): EditOperationResult {\n\t\treturn CompositionOperation.getEdits(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta);\n\t}\n\n\t/**\n\t * This is very similar with typing, but the character is already in the text buffer!\n\t */\n\tpublic static compositionEndWithInterceptors(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, compositions: CompositionOutcome[] | null, selections: Selection[], autoClosedCharacters: Range[]): EditOperationResult | null {\n\t\tif (!compositions) {\n\t\t\t// could not deduce what the composition did\n\t\t\treturn null;\n\t\t}\n\n\t\tlet insertedText: string | null = null;\n\t\tfor (const composition of compositions) {\n\t\t\tif (insertedText === null) {\n\t\t\t\tinsertedText = composition.insertedText;\n\t\t\t} else if (insertedText !== composition.insertedText) {\n\t\t\t\t// not all selections agree on what was typed\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (!insertedText || insertedText.length !== 1) {\n\t\t\t// we're only interested in the case where a single character was inserted\n\t\t\treturn CompositionEndOvertypeOperation.getEdits(config, compositions);\n\t\t}\n\n\t\tconst ch = insertedText;\n\n\t\tlet hasDeletion = false;\n\t\tfor (const composition of compositions) {\n\t\t\tif (composition.deletedText.length !== 0) {\n\t\t\t\thasDeletion = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hasDeletion) {\n\t\t\t// Check if this could have been a surround selection\n\n\t\t\tif (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst isTypingAQuoteCharacter = isQuote(ch);\n\n\t\t\tfor (const composition of compositions) {\n\t\t\t\tif (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n\t\t\t\t\t// more text was deleted than was selected, so this could not have been a surround selection\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (/^[ \\t]+$/.test(composition.deletedText)) {\n\t\t\t\t\t// deleted text was only whitespace\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n\t\t\t\t\t// deleted text was a quote\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst positions: Position[] = [];\n\t\t\tfor (const selection of selections) {\n\t\t\t\tif (!selection.isEmpty()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpositions.push(selection.getPosition());\n\t\t\t}\n\n\t\t\tif (positions.length !== compositions.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst commands: ICommand[] = [];\n\t\t\tfor (let i = 0, len = positions.length; i < len; i++) {\n\t\t\t\tcommands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n\t\t\t}\n\t\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false\n\t\t\t});\n\t\t}\n\n\t\tconst autoClosingOvertypeEdits = AutoClosingOvertypeWithInterceptorsOperation.getEdits(config, model, selections, autoClosedCharacters, ch);\n\t\tif (autoClosingOvertypeEdits !== undefined) {\n\t\t\treturn autoClosingOvertypeEdits;\n\t\t}\n\n\t\tconst autoClosingOpenCharEdits = AutoClosingOpenCharTypeOperation.getEdits(config, model, selections, ch, true, false);\n\t\tif (autoClosingOpenCharEdits !== undefined) {\n\t\t\treturn autoClosingOpenCharEdits;\n\t\t}\n\n\t\treturn CompositionEndOvertypeOperation.getEdits(config, compositions);\n\t}\n\n\tpublic static typeWithInterceptors(isDoingComposition: boolean, prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): EditOperationResult {\n\n\t\tconst enterEdits = EnterOperation.getEdits(config, model, selections, ch, isDoingComposition);\n\t\tif (enterEdits !== undefined) {\n\t\t\treturn enterEdits;\n\t\t}\n\n\t\tconst autoIndentEdits = AutoIndentOperation.getEdits(config, model, selections, ch, isDoingComposition);\n\t\tif (autoIndentEdits !== undefined) {\n\t\t\treturn autoIndentEdits;\n\t\t}\n\n\t\tconst autoClosingOverTypeEdits = AutoClosingOvertypeOperation.getEdits(prevEditOperationType, config, model, selections, autoClosedCharacters, ch);\n\t\tif (autoClosingOverTypeEdits !== undefined) {\n\t\t\treturn autoClosingOverTypeEdits;\n\t\t}\n\n\t\tconst autoClosingOpenCharEdits = AutoClosingOpenCharTypeOperation.getEdits(config, model, selections, ch, false, isDoingComposition);\n\t\tif (autoClosingOpenCharEdits !== undefined) {\n\t\t\treturn autoClosingOpenCharEdits;\n\t\t}\n\n\t\tconst surroundSelectionEdits = SurroundSelectionOperation.getEdits(config, model, selections, ch, isDoingComposition);\n\t\tif (surroundSelectionEdits !== undefined) {\n\t\t\treturn surroundSelectionEdits;\n\t\t}\n\n\t\tconst interceptorElectricCharOperation = InterceptorElectricCharOperation.getEdits(prevEditOperationType, config, model, selections, ch, isDoingComposition);\n\t\tif (interceptorElectricCharOperation !== undefined) {\n\t\t\treturn interceptorElectricCharOperation;\n\t\t}\n\n\t\treturn SimpleCharacterTypeOperation.getEdits(config, prevEditOperationType, selections, ch, isDoingComposition);\n\t}\n\n\tpublic static typeWithoutInterceptors(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], str: string): EditOperationResult {\n\t\treturn TypeWithoutInterceptorsOperation.getEdits(prevEditOperationType, selections, str);\n\t}\n}\n\nexport class CompositionOutcome {\n\tconstructor(\n\t\tpublic readonly deletedText: string,\n\t\tpublic readonly deletedSelectionStart: number,\n\t\tpublic readonly deletedSelectionEnd: number,\n\t\tpublic readonly insertedText: string,\n\t\tpublic readonly insertedSelectionStart: number,\n\t\tpublic readonly insertedSelectionEnd: number,\n\t\tpublic readonly insertedTextRange: Range,\n\t) { }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorConfiguration, EditOperationResult, EditOperationType, ICursorSimpleModel, isQuote } from '../cursorCommon.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Position } from '../core/position.js';\nimport { ICommand } from '../editorCommon.js';\nimport { ITextModel } from '../model.js';\nimport { AutoClosingOpenCharTypeOperation, AutoClosingOvertypeOperation, AutoClosingOvertypeWithInterceptorsOperation, AutoIndentOperation, CompositionOperation, CompositionEndOvertypeOperation, EnterOperation, InterceptorElectricCharOperation, PasteOperation, shouldSurroundChar, SimpleCharacterTypeOperation, SurroundSelectionOperation, TabOperation, TypeWithoutInterceptorsOperation } from './cursorTypeEditOperations.js';\n\nexport class TypeOperations {\n\n\tpublic static indent(config: CursorConfiguration, model: ICursorSimpleModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ShiftCommand(selections[i], {\n\t\t\t\tisUnshift: false,\n\t\t\t\ttabSize: config.tabSize,\n\t\t\t\tindentSize: config.indentSize,\n\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\tuseTabStops: config.useTabStops,\n\t\t\t\tautoIndent: config.autoIndent\n\t\t\t}, config.languageConfigurationService);\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static outdent(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): ICommand[] {\n\t\tconst commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ShiftCommand(selections[i], {\n\t\t\t\tisUnshift: true,\n\t\t\t\ttabSize: config.tabSize,\n\t\t\t\tindentSize: config.indentSize,\n\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\tuseTabStops: config.useTabStops,\n\t\t\t\tautoIndent: config.autoIndent\n\t\t\t}, config.languageConfigurationService);\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static paste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]): EditOperationResult {\n\t\treturn PasteOperation.getEdits(config, model, selections, text, pasteOnNewLine, multicursorText);\n\t}\n\n\tpublic static tab(config: CursorConfiguration, model: ITextModel, selections: Selection[]): ICommand[] {\n\t\treturn TabOperation.getCommands(config, model, selections);\n\t}\n\n\tpublic static compositionType(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number): EditOperationResult {\n\t\treturn CompositionOperation.getEdits(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta);\n\t}\n\n\t/**\n\t * This is very similar with typing, but the character is already in the text buffer!\n\t */\n\tpublic static compositionEndWithInterceptors(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, compositions: CompositionOutcome[] | null, selections: Selection[], autoClosedCharacters: Range[]): EditOperationResult | null {\n\t\tif (!compositions) {\n\t\t\t// could not deduce what the composition did\n\t\t\treturn null;\n\t\t}\n\n\t\tlet insertedText: string | null = null;\n\t\tfor (const composition of compositions) {\n\t\t\tif (insertedText === null) {\n\t\t\t\tinsertedText = composition.insertedText;\n\t\t\t} else if (insertedText !== composition.insertedText) {\n\t\t\t\t// not all selections agree on what was typed\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (!insertedText || insertedText.length !== 1) {\n\t\t\t// we're only interested in the case where a single character was inserted\n\t\t\treturn CompositionEndOvertypeOperation.getEdits(config, compositions);\n\t\t}\n\n\t\tconst ch = insertedText;\n\n\t\tlet hasDeletion = false;\n\t\tfor (const composition of compositions) {\n\t\t\tif (composition.deletedText.length !== 0) {\n\t\t\t\thasDeletion = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hasDeletion) {\n\t\t\t// Check if this could have been a surround selection\n\n\t\t\tif (!shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst isTypingAQuoteCharacter = isQuote(ch);\n\n\t\t\tfor (const composition of compositions) {\n\t\t\t\tif (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n\t\t\t\t\t// more text was deleted than was selected, so this could not have been a surround selection\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (/^[ \\t]+$/.test(composition.deletedText)) {\n\t\t\t\t\t// deleted text was only whitespace\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n\t\t\t\t\t// deleted text was a quote\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst positions: Position[] = [];\n\t\t\tfor (const selection of selections) {\n\t\t\t\tif (!selection.isEmpty()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpositions.push(selection.getPosition());\n\t\t\t}\n\n\t\t\tif (positions.length !== compositions.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst commands: ICommand[] = [];\n\t\t\tfor (let i = 0, len = positions.length; i < len; i++) {\n\t\t\t\tcommands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n\t\t\t}\n\t\t\treturn new EditOperationResult(EditOperationType.TypingOther, commands, {\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false\n\t\t\t});\n\t\t}\n\n\t\tconst autoClosingOvertypeEdits = AutoClosingOvertypeWithInterceptorsOperation.getEdits(config, model, selections, autoClosedCharacters, ch);\n\t\tif (autoClosingOvertypeEdits !== undefined) {\n\t\t\treturn autoClosingOvertypeEdits;\n\t\t}\n\n\t\tconst autoClosingOpenCharEdits = AutoClosingOpenCharTypeOperation.getEdits(config, model, selections, ch, true, false);\n\t\tif (autoClosingOpenCharEdits !== undefined) {\n\t\t\treturn autoClosingOpenCharEdits;\n\t\t}\n\n\t\treturn CompositionEndOvertypeOperation.getEdits(config, compositions);\n\t}\n\n\tpublic static typeWithInterceptors(isDoingComposition: boolean, prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): EditOperationResult {\n\n\t\tconst enterEdits = EnterOperation.getEdits(config, model, selections, ch, isDoingComposition);\n\t\tif (enterEdits !== undefined) {\n\t\t\treturn enterEdits;\n\t\t}\n\n\t\tconst autoIndentEdits = AutoIndentOperation.getEdits(config, model, selections, ch, isDoingComposition);\n\t\tif (autoIndentEdits !== undefined) {\n\t\t\treturn autoIndentEdits;\n\t\t}\n\n\t\tconst autoClosingOverTypeEdits = AutoClosingOvertypeOperation.getEdits(prevEditOperationType, config, model, selections, autoClosedCharacters, ch);\n\t\tif (autoClosingOverTypeEdits !== undefined) {\n\t\t\treturn autoClosingOverTypeEdits;\n\t\t}\n\n\t\tconst autoClosingOpenCharEdits = AutoClosingOpenCharTypeOperation.getEdits(config, model, selections, ch, false, isDoingComposition);\n\t\tif (autoClosingOpenCharEdits !== undefined) {\n\t\t\treturn autoClosingOpenCharEdits;\n\t\t}\n\n\t\tconst surroundSelectionEdits = SurroundSelectionOperation.getEdits(config, model, selections, ch, isDoingComposition);\n\t\tif (surroundSelectionEdits !== undefined) {\n\t\t\treturn surroundSelectionEdits;\n\t\t}\n\n\t\tconst interceptorElectricCharOperation = InterceptorElectricCharOperation.getEdits(prevEditOperationType, config, model, selections, ch, isDoingComposition);\n\t\tif (interceptorElectricCharOperation !== undefined) {\n\t\t\treturn interceptorElectricCharOperation;\n\t\t}\n\n\t\treturn SimpleCharacterTypeOperation.getEdits(config, prevEditOperationType, selections, ch, isDoingComposition);\n\t}\n\n\tpublic static typeWithoutInterceptors(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], str: string): EditOperationResult {\n\t\treturn TypeWithoutInterceptorsOperation.getEdits(prevEditOperationType, selections, str);\n\t}\n}\n\nexport class CompositionOutcome {\n\tconstructor(\n\t\tpublic readonly deletedText: string,\n\t\tpublic readonly deletedSelectionStart: number,\n\t\tpublic readonly deletedSelectionEnd: number,\n\t\tpublic readonly insertedText: string,\n\t\tpublic readonly insertedSelectionStart: number,\n\t\tpublic readonly insertedSelectionEnd: number,\n\t\tpublic readonly insertedTextRange: Range,\n\t) { }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3377, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/oneCursor.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/oneCursor.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CursorState, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { PositionAffinity, TrackedRangeStickiness } from '../model.js';\n\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n\n\tpublic modelState!: SingleCursorState;\n\tpublic viewState!: SingleCursorState;\n\n\tprivate _selTrackedRange: string | null;\n\tprivate _trackSelection: boolean;\n\n\tconstructor(context: CursorContext) {\n\t\tthis._selTrackedRange = null;\n\t\tthis._trackSelection = true;\n\n\t\tthis._setState(\n\t\t\tcontext,\n\t\t\tnew SingleCursorState(new Range(1, 1, 1, 1), SelectionStartKind.Simple, 0, new Position(1, 1), 0),\n\t\t\tnew SingleCursorState(new Range(1, 1, 1, 1), SelectionStartKind.Simple, 0, new Position(1, 1), 0)\n\t\t);\n\t}\n\n\tpublic dispose(context: CursorContext): void {\n\t\tthis._removeTrackedRange(context);\n\t}\n\n\tpublic startTrackingSelection(context: CursorContext): void {\n\t\tthis._trackSelection = true;\n\t\tthis._updateTrackedRange(context);\n\t}\n\n\tpublic stopTrackingSelection(context: CursorContext): void {\n\t\tthis._trackSelection = false;\n\t\tthis._removeTrackedRange(context);\n\t}\n\n\tprivate _updateTrackedRange(context: CursorContext): void {\n\t\tif (!this._trackSelection) {\n\t\t\t// don't track the selection\n\t\t\treturn;\n\t\t}\n\t\tthis._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t}\n\n\tprivate _removeTrackedRange(context: CursorContext): void {\n\t\tthis._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t}\n\n\tpublic asCursorState(): CursorState {\n\t\treturn new CursorState(this.modelState, this.viewState);\n\t}\n\n\tpublic readSelectionFromMarkers(context: CursorContext): Selection {\n\t\tconst range = context.model._getTrackedRange(this._selTrackedRange!)!;\n\n\t\tif (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n\t\t\t// Avoid selecting text when recovering from markers\n\t\t\treturn Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n\t\t}\n\n\t\treturn Selection.fromRange(range, this.modelState.selection.getDirection());\n\t}\n\n\tpublic ensureValidState(context: CursorContext): void {\n\t\tthis._setState(context, this.modelState, this.viewState);\n\t}\n\n\tpublic setState(context: CursorContext, modelState: SingleCursorState | null, viewState: SingleCursorState | null): void {\n\t\tthis._setState(context, modelState, viewState);\n\t}\n\n\tprivate static _validatePositionWithCache(viewModel: ICursorSimpleModel, position: Position, cacheInput: Position, cacheOutput: Position): Position {\n\t\tif (position.equals(cacheInput)) {\n\t\t\treturn cacheOutput;\n\t\t}\n\t\treturn viewModel.normalizePosition(position, PositionAffinity.None);\n\t}\n\n\tprivate static _validateViewState(viewModel: ICursorSimpleModel, viewState: SingleCursorState): SingleCursorState {\n\t\tconst position = viewState.position;\n\t\tconst sStartPosition = viewState.selectionStart.getStartPosition();\n\t\tconst sEndPosition = viewState.selectionStart.getEndPosition();\n\n\t\tconst validPosition = viewModel.normalizePosition(position, PositionAffinity.None);\n\t\tconst validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n\t\tconst validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n\n\t\tif (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n\t\t\t// fast path: the state is valid\n\t\t\treturn viewState;\n\t\t}\n\n\t\treturn new SingleCursorState(\n\t\t\tRange.fromPositions(validSStartPosition, validSEndPosition),\n\t\t\tviewState.selectionStartKind,\n\t\t\tviewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column,\n\t\t\tvalidPosition,\n\t\t\tviewState.leftoverVisibleColumns + position.column - validPosition.column,\n\t\t);\n\t}\n\n\tprivate _setState(context: CursorContext, modelState: SingleCursorState | null, viewState: SingleCursorState | null): void {\n\t\tif (viewState) {\n\t\t\tviewState = Cursor._validateViewState(context.viewModel, viewState);\n\t\t}\n\n\t\tif (!modelState) {\n\t\t\tif (!viewState) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// We only have the view state => compute the model state\n\t\t\tconst selectionStart = context.model.validateRange(\n\t\t\t\tcontext.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart)\n\t\t\t);\n\n\t\t\tconst position = context.model.validatePosition(\n\t\t\t\tcontext.coordinatesConverter.convertViewPositionToModelPosition(viewState.position)\n\t\t\t);\n\n\t\t\tmodelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n\t\t} else {\n\t\t\t// Validate new model state\n\t\t\tconst selectionStart = context.model.validateRange(modelState.selectionStart);\n\t\t\tconst selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n\n\t\t\tconst position = context.model.validatePosition(\n\t\t\t\tmodelState.position\n\t\t\t);\n\t\t\tconst leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n\n\t\t\tmodelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n\t\t}\n\n\t\tif (!viewState) {\n\t\t\t// We only have the model state => compute the view state\n\t\t\tconst viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n\t\t\tconst viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n\t\t\tconst viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n\t\t\tconst viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n\t\t\tviewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n\t\t} else {\n\t\t\t// Validate new view state\n\t\t\tconst viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n\t\t\tconst viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n\t\t\tviewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n\t\t}\n\n\t\tthis.modelState = modelState;\n\t\tthis.viewState = viewState;\n\n\t\tthis._updateTrackedRange(context);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CursorState, ICursorSimpleModel, SelectionStartKind, SingleCursorState } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { PositionAffinity, TrackedRangeStickiness } from '../model.js';\n\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n\n\tpublic modelState!: SingleCursorState;\n\tpublic viewState!: SingleCursorState;\n\n\tprivate _selTrackedRange: string | null;\n\tprivate _trackSelection: boolean;\n\n\tconstructor(context: CursorContext) {\n\t\tthis._selTrackedRange = null;\n\t\tthis._trackSelection = true;\n\n\t\tthis._setState(\n\t\t\tcontext,\n\t\t\tnew SingleCursorState(new Range(1, 1, 1, 1), SelectionStartKind.Simple, 0, new Position(1, 1), 0),\n\t\t\tnew SingleCursorState(new Range(1, 1, 1, 1), SelectionStartKind.Simple, 0, new Position(1, 1), 0)\n\t\t);\n\t}\n\n\tpublic dispose(context: CursorContext): void {\n\t\tthis._removeTrackedRange(context);\n\t}\n\n\tpublic startTrackingSelection(context: CursorContext): void {\n\t\tthis._trackSelection = true;\n\t\tthis._updateTrackedRange(context);\n\t}\n\n\tpublic stopTrackingSelection(context: CursorContext): void {\n\t\tthis._trackSelection = false;\n\t\tthis._removeTrackedRange(context);\n\t}\n\n\tprivate _updateTrackedRange(context: CursorContext): void {\n\t\tif (!this._trackSelection) {\n\t\t\t// don't track the selection\n\t\t\treturn;\n\t\t}\n\t\tthis._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t}\n\n\tprivate _removeTrackedRange(context: CursorContext): void {\n\t\tthis._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t}\n\n\tpublic asCursorState(): CursorState {\n\t\treturn new CursorState(this.modelState, this.viewState);\n\t}\n\n\tpublic readSelectionFromMarkers(context: CursorContext): Selection {\n\t\tconst range = context.model._getTrackedRange(this._selTrackedRange!)!;\n\n\t\tif (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n\t\t\t// Avoid selecting text when recovering from markers\n\t\t\treturn Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n\t\t}\n\n\t\treturn Selection.fromRange(range, this.modelState.selection.getDirection());\n\t}\n\n\tpublic ensureValidState(context: CursorContext): void {\n\t\tthis._setState(context, this.modelState, this.viewState);\n\t}\n\n\tpublic setState(context: CursorContext, modelState: SingleCursorState | null, viewState: SingleCursorState | null): void {\n\t\tthis._setState(context, modelState, viewState);\n\t}\n\n\tprivate static _validatePositionWithCache(viewModel: ICursorSimpleModel, position: Position, cacheInput: Position, cacheOutput: Position): Position {\n\t\tif (position.equals(cacheInput)) {\n\t\t\treturn cacheOutput;\n\t\t}\n\t\treturn viewModel.normalizePosition(position, PositionAffinity.None);\n\t}\n\n\tprivate static _validateViewState(viewModel: ICursorSimpleModel, viewState: SingleCursorState): SingleCursorState {\n\t\tconst position = viewState.position;\n\t\tconst sStartPosition = viewState.selectionStart.getStartPosition();\n\t\tconst sEndPosition = viewState.selectionStart.getEndPosition();\n\n\t\tconst validPosition = viewModel.normalizePosition(position, PositionAffinity.None);\n\t\tconst validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n\t\tconst validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n\n\t\tif (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n\t\t\t// fast path: the state is valid\n\t\t\treturn viewState;\n\t\t}\n\n\t\treturn new SingleCursorState(\n\t\t\tRange.fromPositions(validSStartPosition, validSEndPosition),\n\t\t\tviewState.selectionStartKind,\n\t\t\tviewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column,\n\t\t\tvalidPosition,\n\t\t\tviewState.leftoverVisibleColumns + position.column - validPosition.column,\n\t\t);\n\t}\n\n\tprivate _setState(context: CursorContext, modelState: SingleCursorState | null, viewState: SingleCursorState | null): void {\n\t\tif (viewState) {\n\t\t\tviewState = Cursor._validateViewState(context.viewModel, viewState);\n\t\t}\n\n\t\tif (!modelState) {\n\t\t\tif (!viewState) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// We only have the view state => compute the model state\n\t\t\tconst selectionStart = context.model.validateRange(\n\t\t\t\tcontext.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart)\n\t\t\t);\n\n\t\t\tconst position = context.model.validatePosition(\n\t\t\t\tcontext.coordinatesConverter.convertViewPositionToModelPosition(viewState.position)\n\t\t\t);\n\n\t\t\tmodelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n\t\t} else {\n\t\t\t// Validate new model state\n\t\t\tconst selectionStart = context.model.validateRange(modelState.selectionStart);\n\t\t\tconst selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n\n\t\t\tconst position = context.model.validatePosition(\n\t\t\t\tmodelState.position\n\t\t\t);\n\t\t\tconst leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n\n\t\t\tmodelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n\t\t}\n\n\t\tif (!viewState) {\n\t\t\t// We only have the model state => compute the view state\n\t\t\tconst viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n\t\t\tconst viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n\t\t\tconst viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n\t\t\tconst viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n\t\t\tviewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n\t\t} else {\n\t\t\t// Validate new view state\n\t\t\tconst viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n\t\t\tconst viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n\t\t\tviewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n\t\t}\n\n\t\tthis.modelState = modelState;\n\t\tthis.viewState = viewState;\n\n\t\tthis._updateTrackedRange(context);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3497, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorCollection.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorCollection.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from '../../../base/common/arrays.js';\nimport { findLastMax, findFirstMin } from '../../../base/common/arraysFind.js';\nimport { CursorState, PartialCursorState } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { ISelection, Selection } from '../core/selection.js';\n\nexport class CursorCollection {\n\n\tprivate context: CursorContext;\n\n\t/**\n\t * `cursors[0]` is the primary cursor, thus `cursors.length >= 1` is always true.\n\t * `cursors.slice(1)` are secondary cursors.\n\t*/\n\tprivate cursors: Cursor[];\n\n\t// An index which identifies the last cursor that was added / moved (think Ctrl+drag)\n\t// This index refers to `cursors.slice(1)`, i.e. after removing the primary cursor.\n\tprivate lastAddedCursorIndex: number;\n\n\tconstructor(context: CursorContext) {\n\t\tthis.context = context;\n\t\tthis.cursors = [new Cursor(context)];\n\t\tthis.lastAddedCursorIndex = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.dispose(this.context);\n\t\t}\n\t}\n\n\tpublic startTrackingSelections(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.startTrackingSelection(this.context);\n\t\t}\n\t}\n\n\tpublic stopTrackingSelections(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.stopTrackingSelection(this.context);\n\t\t}\n\t}\n\n\tpublic updateContext(context: CursorContext): void {\n\t\tthis.context = context;\n\t}\n\n\tpublic ensureValidState(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.ensureValidState(this.context);\n\t\t}\n\t}\n\n\tpublic readSelectionFromMarkers(): Selection[] {\n\t\treturn this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n\t}\n\n\tpublic getAll(): CursorState[] {\n\t\treturn this.cursors.map(c => c.asCursorState());\n\t}\n\n\tpublic getViewPositions(): Position[] {\n\t\treturn this.cursors.map(c => c.viewState.position);\n\t}\n\n\tpublic getTopMostViewPosition(): Position {\n\t\treturn findFirstMin(\n\t\t\tthis.cursors,\n\t\t\tcompareBy(c => c.viewState.position, Position.compare)\n\t\t)!.viewState.position;\n\t}\n\n\tpublic getBottomMostViewPosition(): Position {\n\t\treturn findLastMax(\n\t\t\tthis.cursors,\n\t\t\tcompareBy(c => c.viewState.position, Position.compare)\n\t\t)!.viewState.position;\n\t}\n\n\tpublic getSelections(): Selection[] {\n\t\treturn this.cursors.map(c => c.modelState.selection);\n\t}\n\n\tpublic getViewSelections(): Selection[] {\n\t\treturn this.cursors.map(c => c.viewState.selection);\n\t}\n\n\tpublic setSelections(selections: ISelection[]): void {\n\t\tthis.setStates(CursorState.fromModelSelections(selections));\n\t}\n\n\tpublic getPrimaryCursor(): CursorState {\n\t\treturn this.cursors[0].asCursorState();\n\t}\n\n\tpublic setStates(states: PartialCursorState[] | null): void {\n\t\tif (states === null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n\t\tthis._setSecondaryStates(states.slice(1));\n\t}\n\n\t/**\n\t * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n\t */\n\tprivate _setSecondaryStates(secondaryStates: PartialCursorState[]): void {\n\t\tconst secondaryCursorsLength = this.cursors.length - 1;\n\t\tconst secondaryStatesLength = secondaryStates.length;\n\n\t\tif (secondaryCursorsLength < secondaryStatesLength) {\n\t\t\tconst createCnt = secondaryStatesLength - secondaryCursorsLength;\n\t\t\tfor (let i = 0; i < createCnt; i++) {\n\t\t\t\tthis._addSecondaryCursor();\n\t\t\t}\n\t\t} else if (secondaryCursorsLength > secondaryStatesLength) {\n\t\t\tconst removeCnt = secondaryCursorsLength - secondaryStatesLength;\n\t\t\tfor (let i = 0; i < removeCnt; i++) {\n\t\t\t\tthis._removeSecondaryCursor(this.cursors.length - 2);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < secondaryStatesLength; i++) {\n\t\t\tthis.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n\t\t}\n\t}\n\n\tpublic killSecondaryCursors(): void {\n\t\tthis._setSecondaryStates([]);\n\t}\n\n\tprivate _addSecondaryCursor(): void {\n\t\tthis.cursors.push(new Cursor(this.context));\n\t\tthis.lastAddedCursorIndex = this.cursors.length - 1;\n\t}\n\n\tpublic getLastAddedCursorIndex(): number {\n\t\tif (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.lastAddedCursorIndex;\n\t}\n\n\tprivate _removeSecondaryCursor(removeIndex: number): void {\n\t\tif (this.lastAddedCursorIndex >= removeIndex + 1) {\n\t\t\tthis.lastAddedCursorIndex--;\n\t\t}\n\t\tthis.cursors[removeIndex + 1].dispose(this.context);\n\t\tthis.cursors.splice(removeIndex + 1, 1);\n\t}\n\n\tpublic normalize(): void {\n\t\tif (this.cursors.length === 1) {\n\t\t\treturn;\n\t\t}\n\t\tconst cursors = this.cursors.slice(0);\n\n\t\tinterface SortedCursor {\n\t\t\tindex: number;\n\t\t\tselection: Selection;\n\t\t}\n\t\tconst sortedCursors: SortedCursor[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tsortedCursors.push({\n\t\t\t\tindex: i,\n\t\t\t\tselection: cursors[i].modelState.selection,\n\t\t\t});\n\t\t}\n\n\t\tsortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n\n\t\tfor (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n\t\t\tconst current = sortedCursors[sortedCursorIndex];\n\t\t\tconst next = sortedCursors[sortedCursorIndex + 1];\n\n\t\t\tconst currentSelection = current.selection;\n\t\t\tconst nextSelection = next.selection;\n\n\t\t\tif (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet shouldMergeCursors: boolean;\n\t\t\tif (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n\t\t\t\t// Merge touching cursors if one of them is collapsed\n\t\t\t\tshouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n\t\t\t} else {\n\t\t\t\t// Merge only overlapping cursors (i.e. allow touching ranges)\n\t\t\t\tshouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n\t\t\t}\n\n\t\t\tif (shouldMergeCursors) {\n\t\t\t\tconst winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n\t\t\t\tconst looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n\n\t\t\t\tconst looserIndex = sortedCursors[looserSortedCursorIndex].index;\n\t\t\t\tconst winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n\n\t\t\t\tconst looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n\t\t\t\tconst winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n\n\t\t\t\tif (!looserSelection.equalsSelection(winnerSelection)) {\n\t\t\t\t\tconst resultingRange = looserSelection.plusRange(winnerSelection);\n\t\t\t\t\tconst looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n\t\t\t\t\tconst winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n\n\t\t\t\t\t// Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n\t\t\t\t\tlet resultingSelectionIsLTR: boolean;\n\t\t\t\t\tif (looserIndex === this.lastAddedCursorIndex) {\n\t\t\t\t\t\tresultingSelectionIsLTR = looserSelectionIsLTR;\n\t\t\t\t\t\tthis.lastAddedCursorIndex = winnerIndex;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Winner takes it all\n\t\t\t\t\t\tresultingSelectionIsLTR = winnerSelectionIsLTR;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet resultingSelection: Selection;\n\t\t\t\t\tif (resultingSelectionIsLTR) {\n\t\t\t\t\t\tresultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n\t\t\t\t\t}\n\n\t\t\t\t\tsortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n\t\t\t\t\tconst resultingState = CursorState.fromModelSelection(resultingSelection);\n\t\t\t\t\tcursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n\t\t\t\t}\n\n\t\t\t\tfor (const sortedCursor of sortedCursors) {\n\t\t\t\t\tif (sortedCursor.index > looserIndex) {\n\t\t\t\t\t\tsortedCursor.index--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcursors.splice(looserIndex, 1);\n\t\t\t\tsortedCursors.splice(looserSortedCursorIndex, 1);\n\t\t\t\tthis._removeSecondaryCursor(looserIndex - 1);\n\n\t\t\t\tsortedCursorIndex--;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy } from '../../../base/common/arrays.js';\nimport { findLastMax, findFirstMin } from '../../../base/common/arraysFind.js';\nimport { CursorState, PartialCursorState } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { ISelection, Selection } from '../core/selection.js';\n\nexport class CursorCollection {\n\n\tprivate context: CursorContext;\n\n\t/**\n\t * `cursors[0]` is the primary cursor, thus `cursors.length >= 1` is always true.\n\t * `cursors.slice(1)` are secondary cursors.\n\t*/\n\tprivate cursors: Cursor[];\n\n\t// An index which identifies the last cursor that was added / moved (think Ctrl+drag)\n\t// This index refers to `cursors.slice(1)`, i.e. after removing the primary cursor.\n\tprivate lastAddedCursorIndex: number;\n\n\tconstructor(context: CursorContext) {\n\t\tthis.context = context;\n\t\tthis.cursors = [new Cursor(context)];\n\t\tthis.lastAddedCursorIndex = 0;\n\t}\n\n\tpublic dispose(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.dispose(this.context);\n\t\t}\n\t}\n\n\tpublic startTrackingSelections(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.startTrackingSelection(this.context);\n\t\t}\n\t}\n\n\tpublic stopTrackingSelections(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.stopTrackingSelection(this.context);\n\t\t}\n\t}\n\n\tpublic updateContext(context: CursorContext): void {\n\t\tthis.context = context;\n\t}\n\n\tpublic ensureValidState(): void {\n\t\tfor (const cursor of this.cursors) {\n\t\t\tcursor.ensureValidState(this.context);\n\t\t}\n\t}\n\n\tpublic readSelectionFromMarkers(): Selection[] {\n\t\treturn this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n\t}\n\n\tpublic getAll(): CursorState[] {\n\t\treturn this.cursors.map(c => c.asCursorState());\n\t}\n\n\tpublic getViewPositions(): Position[] {\n\t\treturn this.cursors.map(c => c.viewState.position);\n\t}\n\n\tpublic getTopMostViewPosition(): Position {\n\t\treturn findFirstMin(\n\t\t\tthis.cursors,\n\t\t\tcompareBy(c => c.viewState.position, Position.compare)\n\t\t)!.viewState.position;\n\t}\n\n\tpublic getBottomMostViewPosition(): Position {\n\t\treturn findLastMax(\n\t\t\tthis.cursors,\n\t\t\tcompareBy(c => c.viewState.position, Position.compare)\n\t\t)!.viewState.position;\n\t}\n\n\tpublic getSelections(): Selection[] {\n\t\treturn this.cursors.map(c => c.modelState.selection);\n\t}\n\n\tpublic getViewSelections(): Selection[] {\n\t\treturn this.cursors.map(c => c.viewState.selection);\n\t}\n\n\tpublic setSelections(selections: ISelection[]): void {\n\t\tthis.setStates(CursorState.fromModelSelections(selections));\n\t}\n\n\tpublic getPrimaryCursor(): CursorState {\n\t\treturn this.cursors[0].asCursorState();\n\t}\n\n\tpublic setStates(states: PartialCursorState[] | null): void {\n\t\tif (states === null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n\t\tthis._setSecondaryStates(states.slice(1));\n\t}\n\n\t/**\n\t * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n\t */\n\tprivate _setSecondaryStates(secondaryStates: PartialCursorState[]): void {\n\t\tconst secondaryCursorsLength = this.cursors.length - 1;\n\t\tconst secondaryStatesLength = secondaryStates.length;\n\n\t\tif (secondaryCursorsLength < secondaryStatesLength) {\n\t\t\tconst createCnt = secondaryStatesLength - secondaryCursorsLength;\n\t\t\tfor (let i = 0; i < createCnt; i++) {\n\t\t\t\tthis._addSecondaryCursor();\n\t\t\t}\n\t\t} else if (secondaryCursorsLength > secondaryStatesLength) {\n\t\t\tconst removeCnt = secondaryCursorsLength - secondaryStatesLength;\n\t\t\tfor (let i = 0; i < removeCnt; i++) {\n\t\t\t\tthis._removeSecondaryCursor(this.cursors.length - 2);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < secondaryStatesLength; i++) {\n\t\t\tthis.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n\t\t}\n\t}\n\n\tpublic killSecondaryCursors(): void {\n\t\tthis._setSecondaryStates([]);\n\t}\n\n\tprivate _addSecondaryCursor(): void {\n\t\tthis.cursors.push(new Cursor(this.context));\n\t\tthis.lastAddedCursorIndex = this.cursors.length - 1;\n\t}\n\n\tpublic getLastAddedCursorIndex(): number {\n\t\tif (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.lastAddedCursorIndex;\n\t}\n\n\tprivate _removeSecondaryCursor(removeIndex: number): void {\n\t\tif (this.lastAddedCursorIndex >= removeIndex + 1) {\n\t\t\tthis.lastAddedCursorIndex--;\n\t\t}\n\t\tthis.cursors[removeIndex + 1].dispose(this.context);\n\t\tthis.cursors.splice(removeIndex + 1, 1);\n\t}\n\n\tpublic normalize(): void {\n\t\tif (this.cursors.length === 1) {\n\t\t\treturn;\n\t\t}\n\t\tconst cursors = this.cursors.slice(0);\n\n\t\tinterface SortedCursor {\n\t\t\tindex: number;\n\t\t\tselection: Selection;\n\t\t}\n\t\tconst sortedCursors: SortedCursor[] = [];\n\t\tfor (let i = 0, len = cursors.length; i < len; i++) {\n\t\t\tsortedCursors.push({\n\t\t\t\tindex: i,\n\t\t\t\tselection: cursors[i].modelState.selection,\n\t\t\t});\n\t\t}\n\n\t\tsortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n\n\t\tfor (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n\t\t\tconst current = sortedCursors[sortedCursorIndex];\n\t\t\tconst next = sortedCursors[sortedCursorIndex + 1];\n\n\t\t\tconst currentSelection = current.selection;\n\t\t\tconst nextSelection = next.selection;\n\n\t\t\tif (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet shouldMergeCursors: boolean;\n\t\t\tif (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n\t\t\t\t// Merge touching cursors if one of them is collapsed\n\t\t\t\tshouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n\t\t\t} else {\n\t\t\t\t// Merge only overlapping cursors (i.e. allow touching ranges)\n\t\t\t\tshouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n\t\t\t}\n\n\t\t\tif (shouldMergeCursors) {\n\t\t\t\tconst winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n\t\t\t\tconst looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n\n\t\t\t\tconst looserIndex = sortedCursors[looserSortedCursorIndex].index;\n\t\t\t\tconst winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n\n\t\t\t\tconst looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n\t\t\t\tconst winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n\n\t\t\t\tif (!looserSelection.equalsSelection(winnerSelection)) {\n\t\t\t\t\tconst resultingRange = looserSelection.plusRange(winnerSelection);\n\t\t\t\t\tconst looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n\t\t\t\t\tconst winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n\n\t\t\t\t\t// Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n\t\t\t\t\tlet resultingSelectionIsLTR: boolean;\n\t\t\t\t\tif (looserIndex === this.lastAddedCursorIndex) {\n\t\t\t\t\t\tresultingSelectionIsLTR = looserSelectionIsLTR;\n\t\t\t\t\t\tthis.lastAddedCursorIndex = winnerIndex;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Winner takes it all\n\t\t\t\t\t\tresultingSelectionIsLTR = winnerSelectionIsLTR;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet resultingSelection: Selection;\n\t\t\t\t\tif (resultingSelectionIsLTR) {\n\t\t\t\t\t\tresultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n\t\t\t\t\t}\n\n\t\t\t\t\tsortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n\t\t\t\t\tconst resultingState = CursorState.fromModelSelection(resultingSelection);\n\t\t\t\t\tcursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n\t\t\t\t}\n\n\t\t\t\tfor (const sortedCursor of sortedCursors) {\n\t\t\t\t\tif (sortedCursor.index > looserIndex) {\n\t\t\t\t\t\tsortedCursor.index--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcursors.splice(looserIndex, 1);\n\t\t\t\tsortedCursors.splice(looserSortedCursorIndex, 1);\n\t\t\t\tthis._removeSecondaryCursor(looserIndex - 1);\n\n\t\t\t\tsortedCursorIndex--;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3699, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursorContext.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursorContext.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextModel } from '../model.js';\nimport { CursorConfiguration, ICursorSimpleModel } from '../cursorCommon.js';\nimport { ICoordinatesConverter } from '../coordinatesConverter.js';\n\nexport class CursorContext {\n\t_cursorContextBrand: void = undefined;\n\n\tpublic readonly model: ITextModel;\n\tpublic readonly viewModel: ICursorSimpleModel;\n\tpublic readonly coordinatesConverter: ICoordinatesConverter;\n\tpublic readonly cursorConfig: CursorConfiguration;\n\n\tconstructor(model: ITextModel, viewModel: ICursorSimpleModel, coordinatesConverter: ICoordinatesConverter, cursorConfig: CursorConfiguration) {\n\t\tthis.model = model;\n\t\tthis.viewModel = viewModel;\n\t\tthis.coordinatesConverter = coordinatesConverter;\n\t\tthis.cursorConfig = cursorConfig;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextModel } from '../model.js';\nimport { CursorConfiguration, ICursorSimpleModel } from '../cursorCommon.js';\nimport { ICoordinatesConverter } from '../coordinatesConverter.js';\n\nexport class CursorContext {\n\t_cursorContextBrand: void = undefined;\n\n\tpublic readonly model: ITextModel;\n\tpublic readonly viewModel: ICursorSimpleModel;\n\tpublic readonly coordinatesConverter: ICoordinatesConverter;\n\tpublic readonly cursorConfig: CursorConfiguration;\n\n\tconstructor(model: ITextModel, viewModel: ICursorSimpleModel, coordinatesConverter: ICoordinatesConverter, cursorConfig: CursorConfiguration) {\n\t\tthis.model = model;\n\t\tthis.viewModel = viewModel;\n\t\tthis.coordinatesConverter = coordinatesConverter;\n\t\tthis.cursorConfig = cursorConfig;\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAM1F,MAAO,aAAa;IAQzB,YAAY,KAAiB,EAAE,SAA6B,EAAE,oBAA2C,EAAE,YAAiC,CAAA;QAP5I,IAAA,CAAA,mBAAmB,GAAS,SAAS,CAAC;QAQrC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;QACjD,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IAClC,CAAC;CACD","debugId":null}},
    {"offset": {"line": 3719, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/cursor/cursor.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/cursor/vs/editor/common/cursor/cursor.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorConfiguration, CursorState, EditOperationResult, EditOperationType, IColumnSelectData, PartialCursorState, ICursorSimpleModel } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CursorChangeReason } from '../cursorEvents.js';\nimport { CompositionOutcome, TypeOperations } from './cursorTypeOperations.js';\nimport { BaseTypeWithAutoClosingCommand } from './cursorTypeEditOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range, IRange } from '../core/range.js';\nimport { ISelection, Selection, SelectionDirection } from '../core/selection.js';\nimport * as editorCommon from '../editorCommon.js';\nimport { ITextModel, TrackedRangeStickiness, IModelDeltaDecoration, ICursorStateComputer, IIdentifiedSingleEditOperation, IValidEditOperation } from '../model.js';\nimport { RawContentChangedType, ModelInjectedTextChangedEvent, InternalModelContentChangeEvent } from '../textModelEvents.js';\nimport { VerticalRevealType, ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent, ViewModelEventsCollector } from '../viewModelEventDispatcher.js';\nimport { TextModelEditSource, EditSources } from '../textModelEditSource.js';\nimport { ICoordinatesConverter } from '../coordinatesConverter.js';\n\nexport class CursorsController extends Disposable {\n\n\tprivate readonly _model: ITextModel;\n\tprivate _knownModelVersionId: number;\n\tprivate readonly _viewModel: ICursorSimpleModel;\n\tprivate readonly _coordinatesConverter: ICoordinatesConverter;\n\tpublic context: CursorContext;\n\tprivate _cursors: CursorCollection;\n\n\tprivate _hasFocus: boolean;\n\tprivate _isHandling: boolean;\n\tprivate _compositionState: CompositionState | null;\n\tprivate _columnSelectData: IColumnSelectData | null;\n\tprivate _autoClosedActions: AutoClosedAction[];\n\tprivate _prevEditOperationType: EditOperationType;\n\n\tconstructor(model: ITextModel, viewModel: ICursorSimpleModel, coordinatesConverter: ICoordinatesConverter, cursorConfig: CursorConfiguration) {\n\t\tsuper();\n\t\tthis._model = model;\n\t\tthis._knownModelVersionId = this._model.getVersionId();\n\t\tthis._viewModel = viewModel;\n\t\tthis._coordinatesConverter = coordinatesConverter;\n\t\tthis.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n\t\tthis._cursors = new CursorCollection(this.context);\n\n\t\tthis._hasFocus = false;\n\t\tthis._isHandling = false;\n\t\tthis._compositionState = null;\n\t\tthis._columnSelectData = null;\n\t\tthis._autoClosedActions = [];\n\t\tthis._prevEditOperationType = EditOperationType.Other;\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._cursors.dispose();\n\t\tthis._autoClosedActions = dispose(this._autoClosedActions);\n\t\tsuper.dispose();\n\t}\n\n\tpublic updateConfiguration(cursorConfig: CursorConfiguration): void {\n\t\tthis.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n\t\tthis._cursors.updateContext(this.context);\n\t}\n\n\tpublic onLineMappingChanged(eventsCollector: ViewModelEventsCollector): void {\n\t\tif (this._knownModelVersionId !== this._model.getVersionId()) {\n\t\t\t// There are model change events that I didn't yet receive.\n\t\t\t//\n\t\t\t// This can happen when editing the model, and the view model receives the change events first,\n\t\t\t// and the view model emits line mapping changed events, all before the cursor gets a chance to\n\t\t\t// recover from markers.\n\t\t\t//\n\t\t\t// The model change listener above will be called soon and we'll ensure a valid cursor state there.\n\t\t\treturn;\n\t\t}\n\t\t// Ensure valid state\n\t\tthis.setStates(eventsCollector, 'viewModel', CursorChangeReason.NotSet, this.getCursorStates());\n\t}\n\n\tpublic setHasFocus(hasFocus: boolean): void {\n\t\tthis._hasFocus = hasFocus;\n\t}\n\n\tprivate _validateAutoClosedActions(): void {\n\t\tif (this._autoClosedActions.length > 0) {\n\t\t\tconst selections: Range[] = this._cursors.getSelections();\n\t\t\tfor (let i = 0; i < this._autoClosedActions.length; i++) {\n\t\t\t\tconst autoClosedAction = this._autoClosedActions[i];\n\t\t\t\tif (!autoClosedAction.isValid(selections)) {\n\t\t\t\t\tautoClosedAction.dispose();\n\t\t\t\t\tthis._autoClosedActions.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ------ some getters/setters\n\n\tpublic getPrimaryCursorState(): CursorState {\n\t\treturn this._cursors.getPrimaryCursor();\n\t}\n\n\tpublic getLastAddedCursorIndex(): number {\n\t\treturn this._cursors.getLastAddedCursorIndex();\n\t}\n\n\tpublic getCursorStates(): CursorState[] {\n\t\treturn this._cursors.getAll();\n\t}\n\n\tpublic setStates(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, reason: CursorChangeReason, states: PartialCursorState[] | null): boolean {\n\t\tlet reachedMaxCursorCount = false;\n\t\tconst multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n\t\tif (states !== null && states.length > multiCursorLimit) {\n\t\t\tstates = states.slice(0, multiCursorLimit);\n\t\t\treachedMaxCursorCount = true;\n\t\t}\n\n\t\tconst oldState = CursorModelState.from(this._model, this);\n\n\t\tthis._cursors.setStates(states);\n\t\tthis._cursors.normalize();\n\t\tthis._columnSelectData = null;\n\n\t\tthis._validateAutoClosedActions();\n\n\t\treturn this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n\t}\n\n\tpublic setCursorColumnSelectData(columnSelectData: IColumnSelectData): void {\n\t\tthis._columnSelectData = columnSelectData;\n\t}\n\n\tpublic revealAll(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, minimalReveal: boolean, verticalType: VerticalRevealType, revealHorizontal: boolean, scrollType: editorCommon.ScrollType): void {\n\t\tconst viewPositions = this._cursors.getViewPositions();\n\n\t\tlet revealViewRange: Range | null = null;\n\t\tlet revealViewSelections: Selection[] | null = null;\n\t\tif (viewPositions.length > 1) {\n\t\t\trevealViewSelections = this._cursors.getViewSelections();\n\t\t} else {\n\t\t\trevealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n\t\t}\n\n\t\teventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n\t}\n\n\tpublic revealPrimary(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, minimalReveal: boolean, verticalType: VerticalRevealType, revealHorizontal: boolean, scrollType: editorCommon.ScrollType): void {\n\t\tconst primaryCursor = this._cursors.getPrimaryCursor();\n\t\tconst revealViewSelections = [primaryCursor.viewState.selection];\n\t\teventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n\t}\n\n\tpublic saveState(): editorCommon.ICursorState[] {\n\n\t\tconst result: editorCommon.ICursorState[] = [];\n\n\t\tconst selections = this._cursors.getSelections();\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tresult.push({\n\t\t\t\tinSelectionMode: !selection.isEmpty(),\n\t\t\t\tselectionStart: {\n\t\t\t\t\tlineNumber: selection.selectionStartLineNumber,\n\t\t\t\t\tcolumn: selection.selectionStartColumn,\n\t\t\t\t},\n\t\t\t\tposition: {\n\t\t\t\t\tlineNumber: selection.positionLineNumber,\n\t\t\t\t\tcolumn: selection.positionColumn,\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic restoreState(eventsCollector: ViewModelEventsCollector, states: editorCommon.ICursorState[]): void {\n\n\t\tconst desiredSelections: ISelection[] = [];\n\n\t\tfor (let i = 0, len = states.length; i < len; i++) {\n\t\t\tconst state = states[i];\n\n\t\t\tlet positionLineNumber = 1;\n\t\t\tlet positionColumn = 1;\n\n\t\t\t// Avoid missing properties on the literal\n\t\t\tif (state.position && state.position.lineNumber) {\n\t\t\t\tpositionLineNumber = state.position.lineNumber;\n\t\t\t}\n\t\t\tif (state.position && state.position.column) {\n\t\t\t\tpositionColumn = state.position.column;\n\t\t\t}\n\n\t\t\tlet selectionStartLineNumber = positionLineNumber;\n\t\t\tlet selectionStartColumn = positionColumn;\n\n\t\t\t// Avoid missing properties on the literal\n\t\t\tif (state.selectionStart && state.selectionStart.lineNumber) {\n\t\t\t\tselectionStartLineNumber = state.selectionStart.lineNumber;\n\t\t\t}\n\t\t\tif (state.selectionStart && state.selectionStart.column) {\n\t\t\t\tselectionStartColumn = state.selectionStart.column;\n\t\t\t}\n\n\t\t\tdesiredSelections.push({\n\t\t\t\tselectionStartLineNumber: selectionStartLineNumber,\n\t\t\t\tselectionStartColumn: selectionStartColumn,\n\t\t\t\tpositionLineNumber: positionLineNumber,\n\t\t\t\tpositionColumn: positionColumn\n\t\t\t});\n\t\t}\n\n\t\tthis.setStates(eventsCollector, 'restoreState', CursorChangeReason.NotSet, CursorState.fromModelSelections(desiredSelections));\n\t\tthis.revealAll(eventsCollector, 'restoreState', false, VerticalRevealType.Simple, true, editorCommon.ScrollType.Immediate);\n\t}\n\n\tpublic onModelContentChanged(eventsCollector: ViewModelEventsCollector, event: InternalModelContentChangeEvent | ModelInjectedTextChangedEvent): void {\n\t\tif (event instanceof ModelInjectedTextChangedEvent) {\n\t\t\t// If injected texts change, the view positions of all cursors need to be updated.\n\t\t\tif (this._isHandling) {\n\t\t\t\t// The view positions will be updated when handling finishes\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// setStates might remove markers, which could trigger a decoration change.\n\t\t\t// If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n\t\t\t// and an endless recursion happens.\n\t\t\t// _isHandling prevents that.\n\t\t\tthis._isHandling = true;\n\t\t\ttry {\n\t\t\t\tthis.setStates(eventsCollector, 'modelChange', CursorChangeReason.NotSet, this.getCursorStates());\n\t\t\t} finally {\n\t\t\t\tthis._isHandling = false;\n\t\t\t}\n\t\t} else {\n\t\t\tconst e = event.rawContentChangedEvent;\n\t\t\tthis._knownModelVersionId = e.versionId;\n\t\t\tif (this._isHandling) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst hadFlushEvent = e.containsEvent(RawContentChangedType.Flush);\n\t\t\tthis._prevEditOperationType = EditOperationType.Other;\n\n\t\t\tif (hadFlushEvent) {\n\t\t\t\t// a model.setValue() was called\n\t\t\t\tthis._cursors.dispose();\n\t\t\t\tthis._cursors = new CursorCollection(this.context);\n\t\t\t\tthis._validateAutoClosedActions();\n\t\t\t\tthis._emitStateChangedIfNecessary(eventsCollector, 'model', CursorChangeReason.ContentFlush, null, false);\n\t\t\t} else {\n\t\t\t\tif (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n\t\t\t\t\tconst cursorState = CursorState.fromModelSelections(e.resultingSelection);\n\t\t\t\t\tif (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? CursorChangeReason.Undo : e.isRedoing ? CursorChangeReason.Redo : CursorChangeReason.RecoverFromMarkers, cursorState)) {\n\t\t\t\t\t\tthis.revealAll(eventsCollector, 'modelChange', false, VerticalRevealType.Simple, true, editorCommon.ScrollType.Smooth);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n\t\t\t\t\tthis.setStates(eventsCollector, 'modelChange', CursorChangeReason.RecoverFromMarkers, CursorState.fromModelSelections(selectionsFromMarkers));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getSelection(): Selection {\n\t\treturn this._cursors.getPrimaryCursor().modelState.selection;\n\t}\n\n\tpublic getTopMostViewPosition(): Position {\n\t\treturn this._cursors.getTopMostViewPosition();\n\t}\n\n\tpublic getBottomMostViewPosition(): Position {\n\t\treturn this._cursors.getBottomMostViewPosition();\n\t}\n\n\tpublic getCursorColumnSelectData(): IColumnSelectData {\n\t\tif (this._columnSelectData) {\n\t\t\treturn this._columnSelectData;\n\t\t}\n\t\tconst primaryCursor = this._cursors.getPrimaryCursor();\n\t\tconst viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n\t\tconst viewPosition = primaryCursor.viewState.position;\n\t\treturn {\n\t\t\tisReal: false,\n\t\t\tfromViewLineNumber: viewSelectionStart.lineNumber,\n\t\t\tfromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n\t\t\ttoViewLineNumber: viewPosition.lineNumber,\n\t\t\ttoViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n\t\t};\n\t}\n\n\tpublic getSelections(): Selection[] {\n\t\treturn this._cursors.getSelections();\n\t}\n\n\tpublic setSelections(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, selections: readonly ISelection[], reason: CursorChangeReason): void {\n\t\tthis.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n\t}\n\n\tpublic getPrevEditOperationType(): EditOperationType {\n\t\treturn this._prevEditOperationType;\n\t}\n\n\tpublic setPrevEditOperationType(type: EditOperationType): void {\n\t\tthis._prevEditOperationType = type;\n\t}\n\n\t// ------ auxiliary handling logic\n\n\tprivate _pushAutoClosedAction(autoClosedCharactersRanges: Range[], autoClosedEnclosingRanges: Range[]): void {\n\t\tconst autoClosedCharactersDeltaDecorations: IModelDeltaDecoration[] = [];\n\t\tconst autoClosedEnclosingDeltaDecorations: IModelDeltaDecoration[] = [];\n\n\t\tfor (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n\t\t\tautoClosedCharactersDeltaDecorations.push({\n\t\t\t\trange: autoClosedCharactersRanges[i],\n\t\t\t\toptions: {\n\t\t\t\t\tdescription: 'auto-closed-character',\n\t\t\t\t\tinlineClassName: 'auto-closed-character',\n\t\t\t\t\tstickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n\t\t\t\t}\n\t\t\t});\n\t\t\tautoClosedEnclosingDeltaDecorations.push({\n\t\t\t\trange: autoClosedEnclosingRanges[i],\n\t\t\t\toptions: {\n\t\t\t\t\tdescription: 'auto-closed-enclosing',\n\t\t\t\t\tstickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n\t\tconst autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n\t\tthis._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n\t}\n\n\tprivate _executeEditOperation(opResult: EditOperationResult | null, editReason: TextModelEditSource): void {\n\n\t\tif (!opResult) {\n\t\t\t// Nothing to execute\n\t\t\treturn;\n\t\t}\n\n\t\tif (opResult.shouldPushStackElementBefore) {\n\t\t\tthis._model.pushStackElement();\n\t\t}\n\n\t\tconst result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands, editReason);\n\t\tif (result) {\n\t\t\t// The commands were applied correctly\n\t\t\tthis._interpretCommandResult(result);\n\n\t\t\t// Check for auto-closing closed characters\n\t\t\tconst autoClosedCharactersRanges: Range[] = [];\n\t\t\tconst autoClosedEnclosingRanges: Range[] = [];\n\n\t\t\tfor (let i = 0; i < opResult.commands.length; i++) {\n\t\t\t\tconst command = opResult.commands[i];\n\t\t\t\tif (command instanceof BaseTypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n\t\t\t\t\tautoClosedCharactersRanges.push(command.closeCharacterRange);\n\t\t\t\t\tautoClosedEnclosingRanges.push(command.enclosingRange);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (autoClosedCharactersRanges.length > 0) {\n\t\t\t\tthis._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n\t\t\t}\n\n\t\t\tthis._prevEditOperationType = opResult.type;\n\t\t}\n\n\t\tif (opResult.shouldPushStackElementAfter) {\n\t\t\tthis._model.pushStackElement();\n\t\t}\n\t}\n\n\tprivate _interpretCommandResult(cursorState: Selection[] | null): void {\n\t\tif (!cursorState || cursorState.length === 0) {\n\t\t\tcursorState = this._cursors.readSelectionFromMarkers();\n\t\t}\n\n\t\tthis._columnSelectData = null;\n\t\tthis._cursors.setSelections(cursorState);\n\t\tthis._cursors.normalize();\n\t}\n\n\t// -----------------------------------------------------------------------------------------------------------\n\t// ----- emitting events\n\n\tprivate _emitStateChangedIfNecessary(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, reason: CursorChangeReason, oldState: CursorModelState | null, reachedMaxCursorCount: boolean): boolean {\n\t\tconst newState = CursorModelState.from(this._model, this);\n\t\tif (newState.equals(oldState)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selections = this._cursors.getSelections();\n\t\tconst viewSelections = this._cursors.getViewSelections();\n\n\t\t// Let the view get the event first.\n\t\teventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n\n\t\t// Only after the view has been notified, let the rest of the world know...\n\t\tif (!oldState\n\t\t\t|| oldState.cursorState.length !== newState.cursorState.length\n\t\t\t|| newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))\n\t\t) {\n\t\t\tconst oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n\t\t\tconst oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n\t\t\teventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t// -----------------------------------------------------------------------------------------------------------\n\t// ----- handlers beyond this point\n\n\tprivate _findAutoClosingPairs(edits: IIdentifiedSingleEditOperation[]): [number, number][] | null {\n\t\tif (!edits.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst indices: [number, number][] = [];\n\t\tfor (let i = 0, len = edits.length; i < len; i++) {\n\t\t\tconst edit = edits[i];\n\t\t\tif (!edit.text || edit.text.indexOf('\\n') >= 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst closeChar = m[1];\n\n\t\t\tconst autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n\t\t\tif (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst openChar = autoClosingPairsCandidates[0].open;\n\t\t\tconst closeCharIndex = edit.text.length - m[2].length - 1;\n\t\t\tconst openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n\t\t\tif (openCharIndex === -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tindices.push([openCharIndex, closeCharIndex]);\n\t\t}\n\n\t\treturn indices;\n\t}\n\n\tpublic executeEdits(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, edits: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer, reason: TextModelEditSource): void {\n\t\tlet autoClosingIndices: [number, number][] | null = null;\n\t\tif (source === 'snippet') {\n\t\t\tautoClosingIndices = this._findAutoClosingPairs(edits);\n\t\t}\n\n\t\tif (autoClosingIndices) {\n\t\t\tedits[0]._isTracked = true;\n\t\t}\n\t\tconst autoClosedCharactersRanges: Range[] = [];\n\t\tconst autoClosedEnclosingRanges: Range[] = [];\n\t\tconst selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n\t\t\tif (autoClosingIndices) {\n\t\t\t\tfor (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n\t\t\t\t\tconst [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n\t\t\t\t\tconst undoEdit = undoEdits[i];\n\t\t\t\t\tconst lineNumber = undoEdit.range.startLineNumber;\n\t\t\t\t\tconst openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n\t\t\t\t\tconst closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n\n\t\t\t\t\tautoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n\t\t\t\t\tautoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst selections = cursorStateComputer(undoEdits);\n\t\t\tif (selections) {\n\t\t\t\t// Don't recover the selection from markers because\n\t\t\t\t// we know what it should be.\n\t\t\t\tthis._isHandling = true;\n\t\t\t}\n\n\t\t\treturn selections;\n\t\t}, undefined, reason);\n\t\tif (selections) {\n\t\t\tthis._isHandling = false;\n\t\t\tthis.setSelections(eventsCollector, source, selections, CursorChangeReason.NotSet);\n\t\t}\n\t\tif (autoClosedCharactersRanges.length > 0) {\n\t\t\tthis._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n\t\t}\n\t}\n\n\tprivate _executeEdit(callback: () => void, eventsCollector: ViewModelEventsCollector, source: string | null | undefined, cursorChangeReason: CursorChangeReason = CursorChangeReason.NotSet): void {\n\t\tif (this.context.cursorConfig.readOnly) {\n\t\t\t// we cannot edit when read only...\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldState = CursorModelState.from(this._model, this);\n\t\tthis._cursors.stopTrackingSelections();\n\t\tthis._isHandling = true;\n\n\t\ttry {\n\t\t\tthis._cursors.ensureValidState();\n\t\t\tcallback();\n\t\t} catch (err) {\n\t\t\tonUnexpectedError(err);\n\t\t}\n\n\t\tthis._isHandling = false;\n\t\tthis._cursors.startTrackingSelections();\n\t\tthis._validateAutoClosedActions();\n\t\tif (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n\t\t\tthis.revealAll(eventsCollector, source, false, VerticalRevealType.Simple, true, editorCommon.ScrollType.Smooth);\n\t\t}\n\t}\n\n\tpublic getAutoClosedCharacters(): Range[] {\n\t\treturn AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n\t}\n\n\tpublic startComposition(eventsCollector: ViewModelEventsCollector): void {\n\t\tthis._compositionState = new CompositionState(this._model, this.getSelections());\n\t}\n\n\tpublic endComposition(eventsCollector: ViewModelEventsCollector, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'compositionEnd', detailedSource: source });\n\n\t\tconst compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n\t\tthis._compositionState = null;\n\n\t\tthis._executeEdit(() => {\n\t\t\tif (source === 'keyboard') {\n\t\t\t\t// composition finishes, let's check if we need to auto complete if necessary.\n\t\t\t\tthis._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()), reason);\n\t\t\t}\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic type(eventsCollector: ViewModelEventsCollector, text: string, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'type', detailedSource: source });\n\n\t\tthis._executeEdit(() => {\n\t\t\tif (source === 'keyboard') {\n\t\t\t\t// If this event is coming straight from the keyboard, look for electric characters and enter\n\n\t\t\t\tconst len = text.length;\n\t\t\t\tlet offset = 0;\n\t\t\t\twhile (offset < len) {\n\t\t\t\t\tconst charLength = strings.nextCharLength(text, offset);\n\t\t\t\t\tconst chr = text.substr(offset, charLength);\n\n\t\t\t\t\t// Here we must interpret each typed character individually\n\t\t\t\t\tthis._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr), reason);\n\n\t\t\t\t\toffset += charLength;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tthis._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text), reason);\n\t\t\t}\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic compositionType(eventsCollector: ViewModelEventsCollector, text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'compositionType', detailedSource: source });\n\n\t\tif (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n\t\t\t// this edit is a no-op\n\t\t\tif (positionDelta !== 0) {\n\t\t\t\t// but it still wants to move the cursor\n\t\t\t\tconst newSelections = this.getSelections().map(selection => {\n\t\t\t\t\tconst position = selection.getPosition();\n\t\t\t\t\treturn new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n\t\t\t\t});\n\t\t\t\tthis.setSelections(eventsCollector, source, newSelections, CursorChangeReason.NotSet);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._executeEdit(() => {\n\t\t\tthis._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta), reason);\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic paste(eventsCollector: ViewModelEventsCollector, text: string, pasteOnNewLine: boolean, multicursorText?: string[] | null | undefined, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'paste', detailedSource: source });\n\n\t\tthis._executeEdit(() => {\n\t\t\tthis._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []), reason);\n\t\t}, eventsCollector, source, CursorChangeReason.Paste);\n\t}\n\n\tpublic cut(eventsCollector: ViewModelEventsCollector, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'cut', detailedSource: source });\n\t\tthis._executeEdit(() => {\n\t\t\tthis._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()), reason);\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic executeCommand(eventsCollector: ViewModelEventsCollector, command: editorCommon.ICommand, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'executeCommand', detailedSource: source });\n\n\t\tthis._executeEdit(() => {\n\t\t\tthis._cursors.killSecondaryCursors();\n\n\t\t\tthis._executeEditOperation(new EditOperationResult(EditOperationType.Other, [command], {\n\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\tshouldPushStackElementAfter: false\n\t\t\t}), reason);\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic executeCommands(eventsCollector: ViewModelEventsCollector, commands: editorCommon.ICommand[], source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'executeCommands', detailedSource: source });\n\n\t\tthis._executeEdit(() => {\n\t\t\tthis._executeEditOperation(new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\tshouldPushStackElementAfter: false\n\t\t\t}), reason);\n\t\t}, eventsCollector, source);\n\t}\n}\n\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n\tpublic static from(model: ITextModel, cursor: CursorsController): CursorModelState {\n\t\treturn new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n\t}\n\n\tconstructor(\n\t\tpublic readonly modelVersionId: number,\n\t\tpublic readonly cursorState: CursorState[],\n\t) {\n\t}\n\n\tpublic equals(other: CursorModelState | null): boolean {\n\t\tif (!other) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.modelVersionId !== other.modelVersionId) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.cursorState.length !== other.cursorState.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = this.cursorState.length; i < len; i++) {\n\t\t\tif (!this.cursorState[i].equals(other.cursorState[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nclass AutoClosedAction {\n\n\tpublic static getAllAutoClosedCharacters(autoClosedActions: AutoClosedAction[]): Range[] {\n\t\tlet autoClosedCharacters: Range[] = [];\n\t\tfor (const autoClosedAction of autoClosedActions) {\n\t\t\tautoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n\t\t}\n\t\treturn autoClosedCharacters;\n\t}\n\n\tprivate readonly _model: ITextModel;\n\n\tprivate _autoClosedCharactersDecorations: string[];\n\tprivate _autoClosedEnclosingDecorations: string[];\n\n\tconstructor(model: ITextModel, autoClosedCharactersDecorations: string[], autoClosedEnclosingDecorations: string[]) {\n\t\tthis._model = model;\n\t\tthis._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n\t\tthis._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n\t\tthis._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n\t}\n\n\tpublic getAutoClosedCharactersRanges(): Range[] {\n\t\tconst result: Range[] = [];\n\t\tfor (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n\t\t\tconst decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n\t\t\tif (decorationRange) {\n\t\t\t\tresult.push(decorationRange);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic isValid(selections: Range[]): boolean {\n\t\tconst enclosingRanges: Range[] = [];\n\t\tfor (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n\t\t\tconst decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n\t\t\tif (decorationRange) {\n\t\t\t\tenclosingRanges.push(decorationRange);\n\t\t\t\tif (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n\t\t\t\t\t// Stop tracking if the range becomes multiline...\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tenclosingRanges.sort(Range.compareRangesUsingStarts);\n\n\t\tselections.sort(Range.compareRangesUsingStarts);\n\n\t\tfor (let i = 0; i < selections.length; i++) {\n\t\t\tif (i >= enclosingRanges.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!enclosingRanges[i].strictContainsRange(selections[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\ninterface IExecContext {\n\treadonly model: ITextModel;\n\treadonly selectionsBefore: Selection[];\n\treadonly trackedRanges: string[];\n\treadonly trackedRangesDirection: SelectionDirection[];\n}\n\ninterface ICommandData {\n\toperations: IIdentifiedSingleEditOperation[];\n\thadTrackedEditOperation: boolean;\n}\n\ninterface ICommandsData {\n\toperations: IIdentifiedSingleEditOperation[];\n\thadTrackedEditOperation: boolean;\n}\n\nexport class CommandExecutor {\n\n\tpublic static executeCommands(model: ITextModel, selectionsBefore: Selection[], commands: (editorCommon.ICommand | null)[], editReason: TextModelEditSource = EditSources.unknown({ name: 'executeCommands' })): Selection[] | null {\n\n\t\tconst ctx: IExecContext = {\n\t\t\tmodel: model,\n\t\t\tselectionsBefore: selectionsBefore,\n\t\t\ttrackedRanges: [],\n\t\t\ttrackedRangesDirection: []\n\t\t};\n\n\t\tconst result = this._innerExecuteCommands(ctx, commands, editReason);\n\n\t\tfor (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n\t\t\tctx.model._setTrackedRange(ctx.trackedRanges[i], null, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _innerExecuteCommands(ctx: IExecContext, commands: (editorCommon.ICommand | null)[], editReason: TextModelEditSource): Selection[] | null {\n\n\t\tif (this._arrayIsEmpty(commands)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst commandsData = this._getEditOperations(ctx, commands);\n\t\tif (commandsData.operations.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst rawOperations = commandsData.operations;\n\n\t\tconst loserCursorsMap = this._getLoserCursorMap(rawOperations);\n\t\tif (loserCursorsMap.hasOwnProperty('0')) {\n\t\t\t// These commands are very messed up\n\t\t\tconsole.warn('Ignoring commands');\n\t\t\treturn null;\n\t\t}\n\n\t\t// Remove operations belonging to losing cursors\n\t\tconst filteredOperations: IIdentifiedSingleEditOperation[] = [];\n\t\tfor (let i = 0, len = rawOperations.length; i < len; i++) {\n\t\t\tif (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier!.major.toString())) {\n\t\t\t\tfilteredOperations.push(rawOperations[i]);\n\t\t\t}\n\t\t}\n\n\t\t// TODO@Alex: find a better way to do this.\n\t\t// give the hint that edit operations are tracked to the model\n\t\tif (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n\t\t\tfilteredOperations[0]._isTracked = true;\n\t\t}\n\t\tlet selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations: IValidEditOperation[]): Selection[] => {\n\t\t\tconst groupedInverseEditOperations: IValidEditOperation[][] = [];\n\t\t\tfor (let i = 0; i < ctx.selectionsBefore.length; i++) {\n\t\t\t\tgroupedInverseEditOperations[i] = [];\n\t\t\t}\n\t\t\tfor (const op of inverseEditOperations) {\n\t\t\t\tif (!op.identifier) {\n\t\t\t\t\t// perhaps auto whitespace trim edits\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgroupedInverseEditOperations[op.identifier.major].push(op);\n\t\t\t}\n\t\t\tconst minorBasedSorter = (a: IValidEditOperation, b: IValidEditOperation) => {\n\t\t\t\treturn a.identifier!.minor - b.identifier!.minor;\n\t\t\t};\n\t\t\tconst cursorSelections: Selection[] = [];\n\t\t\tfor (let i = 0; i < ctx.selectionsBefore.length; i++) {\n\t\t\t\tif (groupedInverseEditOperations[i].length > 0) {\n\t\t\t\t\tgroupedInverseEditOperations[i].sort(minorBasedSorter);\n\t\t\t\t\tcursorSelections[i] = commands[i]!.computeCursorState(ctx.model, {\n\t\t\t\t\t\tgetInverseEditOperations: () => {\n\t\t\t\t\t\t\treturn groupedInverseEditOperations[i];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetTrackedSelection: (id: string) => {\n\t\t\t\t\t\t\tconst idx = parseInt(id, 10);\n\t\t\t\t\t\t\tconst range = ctx.model._getTrackedRange(ctx.trackedRanges[idx])!;\n\t\t\t\t\t\t\tif (ctx.trackedRangesDirection[idx] === SelectionDirection.LTR) {\n\t\t\t\t\t\t\t\treturn new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcursorSelections[i] = ctx.selectionsBefore[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cursorSelections;\n\t\t}, undefined, editReason);\n\t\tif (!selectionsAfter) {\n\t\t\tselectionsAfter = ctx.selectionsBefore;\n\t\t}\n\n\t\t// Extract losing cursors\n\t\tconst losingCursors: number[] = [];\n\t\tfor (const losingCursorIndex in loserCursorsMap) {\n\t\t\tif (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n\t\t\t\tlosingCursors.push(parseInt(losingCursorIndex, 10));\n\t\t\t}\n\t\t}\n\n\t\t// Sort losing cursors descending\n\t\tlosingCursors.sort((a: number, b: number): number => {\n\t\t\treturn b - a;\n\t\t});\n\n\t\t// Remove losing cursors\n\t\tfor (const losingCursor of losingCursors) {\n\t\t\tselectionsAfter.splice(losingCursor, 1);\n\t\t}\n\n\t\treturn selectionsAfter;\n\t}\n\n\tprivate static _arrayIsEmpty(commands: (editorCommon.ICommand | null)[]): boolean {\n\t\tfor (let i = 0, len = commands.length; i < len; i++) {\n\t\t\tif (commands[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _getEditOperations(ctx: IExecContext, commands: (editorCommon.ICommand | null)[]): ICommandsData {\n\t\tlet operations: IIdentifiedSingleEditOperation[] = [];\n\t\tlet hadTrackedEditOperation: boolean = false;\n\n\t\tfor (let i = 0, len = commands.length; i < len; i++) {\n\t\t\tconst command = commands[i];\n\t\t\tif (command) {\n\t\t\t\tconst r = this._getEditOperationsFromCommand(ctx, i, command);\n\t\t\t\toperations = operations.concat(r.operations);\n\t\t\t\thadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\toperations: operations,\n\t\t\thadTrackedEditOperation: hadTrackedEditOperation\n\t\t};\n\t}\n\n\tprivate static _getEditOperationsFromCommand(ctx: IExecContext, majorIdentifier: number, command: editorCommon.ICommand): ICommandData {\n\t\t// This method acts as a transaction, if the command fails\n\t\t// everything it has done is ignored\n\t\tconst operations: IIdentifiedSingleEditOperation[] = [];\n\t\tlet operationMinor = 0;\n\n\t\tconst addEditOperation = (range: IRange, text: string | null, forceMoveMarkers: boolean = false) => {\n\t\t\tif (Range.isEmpty(range) && text === '') {\n\t\t\t\t// This command wants to add a no-op => no thank you\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toperations.push({\n\t\t\t\tidentifier: {\n\t\t\t\t\tmajor: majorIdentifier,\n\t\t\t\t\tminor: operationMinor++\n\t\t\t\t},\n\t\t\t\trange: range,\n\t\t\t\ttext: text,\n\t\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\t\tisAutoWhitespaceEdit: command.insertsAutoWhitespace\n\t\t\t});\n\t\t};\n\n\t\tlet hadTrackedEditOperation = false;\n\t\tconst addTrackedEditOperation = (selection: IRange, text: string | null, forceMoveMarkers?: boolean) => {\n\t\t\thadTrackedEditOperation = true;\n\t\t\taddEditOperation(selection, text, forceMoveMarkers);\n\t\t};\n\n\t\tconst trackSelection = (_selection: ISelection, trackPreviousOnEmpty?: boolean) => {\n\t\t\tconst selection = Selection.liftSelection(_selection);\n\t\t\tlet stickiness: TrackedRangeStickiness;\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\tif (typeof trackPreviousOnEmpty === 'boolean') {\n\t\t\t\t\tif (trackPreviousOnEmpty) {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Try to lock it with surrounding text\n\t\t\t\t\tconst maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n\t\t\t\t\tif (selection.startColumn === maxLineColumn) {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstickiness = TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;\n\t\t\t}\n\n\t\t\tconst l = ctx.trackedRanges.length;\n\t\t\tconst id = ctx.model._setTrackedRange(null, selection, stickiness);\n\t\t\tctx.trackedRanges[l] = id;\n\t\t\tctx.trackedRangesDirection[l] = selection.getDirection();\n\t\t\treturn l.toString();\n\t\t};\n\n\t\tconst editOperationBuilder: editorCommon.IEditOperationBuilder = {\n\t\t\taddEditOperation: addEditOperation,\n\t\t\taddTrackedEditOperation: addTrackedEditOperation,\n\t\t\ttrackSelection: trackSelection\n\t\t};\n\n\t\ttry {\n\t\t\tcommand.getEditOperations(ctx.model, editOperationBuilder);\n\t\t} catch (e) {\n\t\t\t// TODO@Alex use notification service if this should be user facing\n\t\t\t// e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n\t\t\tonUnexpectedError(e);\n\t\t\treturn {\n\t\t\t\toperations: [],\n\t\t\t\thadTrackedEditOperation: false\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\toperations: operations,\n\t\t\thadTrackedEditOperation: hadTrackedEditOperation\n\t\t};\n\t}\n\n\tprivate static _getLoserCursorMap(operations: IIdentifiedSingleEditOperation[]): { [index: string]: boolean } {\n\t\t// This is destructive on the array\n\t\toperations = operations.slice(0);\n\n\t\t// Sort operations with last one first\n\t\toperations.sort((a: IIdentifiedSingleEditOperation, b: IIdentifiedSingleEditOperation): number => {\n\t\t\t// Note the minus!\n\t\t\treturn -(Range.compareRangesUsingEnds(a.range, b.range));\n\t\t});\n\n\t\t// Operations can not overlap!\n\t\tconst loserCursorsMap: { [index: string]: boolean } = {};\n\n\t\tfor (let i = 1; i < operations.length; i++) {\n\t\t\tconst previousOp = operations[i - 1];\n\t\t\tconst currentOp = operations[i];\n\n\t\t\tif (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n\n\t\t\t\tlet loserMajor: number;\n\n\t\t\t\tif (previousOp.identifier!.major > currentOp.identifier!.major) {\n\t\t\t\t\t// previousOp loses the battle\n\t\t\t\t\tloserMajor = previousOp.identifier!.major;\n\t\t\t\t} else {\n\t\t\t\t\tloserMajor = currentOp.identifier!.major;\n\t\t\t\t}\n\n\t\t\t\tloserCursorsMap[loserMajor.toString()] = true;\n\n\t\t\t\tfor (let j = 0; j < operations.length; j++) {\n\t\t\t\t\tif (operations[j].identifier!.major === loserMajor) {\n\t\t\t\t\t\toperations.splice(j, 1);\n\t\t\t\t\t\tif (j < i) {\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn loserCursorsMap;\n\t}\n}\n\nclass CompositionLineState {\n\tconstructor(\n\t\tpublic readonly text: string,\n\t\tpublic readonly lineNumber: number,\n\t\tpublic readonly startSelectionOffset: number,\n\t\tpublic readonly endSelectionOffset: number\n\t) { }\n}\n\nclass CompositionState {\n\n\tprivate readonly _original: CompositionLineState[] | null;\n\n\tprivate static _capture(textModel: ITextModel, selections: Selection[]): CompositionLineState[] | null {\n\t\tconst result: CompositionLineState[] = [];\n\t\tfor (const selection of selections) {\n\t\t\tif (selection.startLineNumber !== selection.endLineNumber) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst lineNumber = selection.startLineNumber;\n\t\t\tresult.push(new CompositionLineState(\n\t\t\t\ttextModel.getLineContent(lineNumber),\n\t\t\t\tlineNumber,\n\t\t\t\tselection.startColumn - 1,\n\t\t\t\tselection.endColumn - 1\n\t\t\t));\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(textModel: ITextModel, selections: Selection[]) {\n\t\tthis._original = CompositionState._capture(textModel, selections);\n\t}\n\n\t/**\n\t * Returns the inserted text during this composition.\n\t * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n\t */\n\tdeduceOutcome(textModel: ITextModel, selections: Selection[]): CompositionOutcome[] | null {\n\t\tif (!this._original) {\n\t\t\treturn null;\n\t\t}\n\t\tconst current = CompositionState._capture(textModel, selections);\n\t\tif (!current) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._original.length !== current.length) {\n\t\t\treturn null;\n\t\t}\n\t\tconst result: CompositionOutcome[] = [];\n\t\tfor (let i = 0, len = this._original.length; i < len; i++) {\n\t\t\tresult.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _deduceOutcome(original: CompositionLineState, current: CompositionLineState): CompositionOutcome {\n\t\tconst commonPrefix = Math.min(\n\t\t\toriginal.startSelectionOffset,\n\t\t\tcurrent.startSelectionOffset,\n\t\t\tstrings.commonPrefixLength(original.text, current.text)\n\t\t);\n\t\tconst commonSuffix = Math.min(\n\t\t\toriginal.text.length - original.endSelectionOffset,\n\t\t\tcurrent.text.length - current.endSelectionOffset,\n\t\t\tstrings.commonSuffixLength(original.text, current.text)\n\t\t);\n\t\tconst deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n\t\tconst insertedTextStartOffset = commonPrefix;\n\t\tconst insertedTextEndOffset = current.text.length - commonSuffix;\n\t\tconst insertedText = current.text.substring(insertedTextStartOffset, insertedTextEndOffset);\n\t\tconst insertedTextRange = new Range(current.lineNumber, insertedTextStartOffset + 1, current.lineNumber, insertedTextEndOffset + 1);\n\t\treturn new CompositionOutcome(\n\t\t\tdeletedText,\n\t\t\toriginal.startSelectionOffset - commonPrefix,\n\t\t\toriginal.endSelectionOffset - commonPrefix,\n\t\t\tinsertedText,\n\t\t\tcurrent.startSelectionOffset - commonPrefix,\n\t\t\tcurrent.endSelectionOffset - commonPrefix,\n\t\t\tinsertedTextRange\n\t\t);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorConfiguration, CursorState, EditOperationResult, EditOperationType, IColumnSelectData, PartialCursorState, ICursorSimpleModel } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CursorChangeReason } from '../cursorEvents.js';\nimport { CompositionOutcome, TypeOperations } from './cursorTypeOperations.js';\nimport { BaseTypeWithAutoClosingCommand } from './cursorTypeEditOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range, IRange } from '../core/range.js';\nimport { ISelection, Selection, SelectionDirection } from '../core/selection.js';\nimport * as editorCommon from '../editorCommon.js';\nimport { ITextModel, TrackedRangeStickiness, IModelDeltaDecoration, ICursorStateComputer, IIdentifiedSingleEditOperation, IValidEditOperation } from '../model.js';\nimport { RawContentChangedType, ModelInjectedTextChangedEvent, InternalModelContentChangeEvent } from '../textModelEvents.js';\nimport { VerticalRevealType, ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent, ViewModelEventsCollector } from '../viewModelEventDispatcher.js';\nimport { TextModelEditSource, EditSources } from '../textModelEditSource.js';\nimport { ICoordinatesConverter } from '../coordinatesConverter.js';\n\nexport class CursorsController extends Disposable {\n\n\tprivate readonly _model: ITextModel;\n\tprivate _knownModelVersionId: number;\n\tprivate readonly _viewModel: ICursorSimpleModel;\n\tprivate readonly _coordinatesConverter: ICoordinatesConverter;\n\tpublic context: CursorContext;\n\tprivate _cursors: CursorCollection;\n\n\tprivate _hasFocus: boolean;\n\tprivate _isHandling: boolean;\n\tprivate _compositionState: CompositionState | null;\n\tprivate _columnSelectData: IColumnSelectData | null;\n\tprivate _autoClosedActions: AutoClosedAction[];\n\tprivate _prevEditOperationType: EditOperationType;\n\n\tconstructor(model: ITextModel, viewModel: ICursorSimpleModel, coordinatesConverter: ICoordinatesConverter, cursorConfig: CursorConfiguration) {\n\t\tsuper();\n\t\tthis._model = model;\n\t\tthis._knownModelVersionId = this._model.getVersionId();\n\t\tthis._viewModel = viewModel;\n\t\tthis._coordinatesConverter = coordinatesConverter;\n\t\tthis.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n\t\tthis._cursors = new CursorCollection(this.context);\n\n\t\tthis._hasFocus = false;\n\t\tthis._isHandling = false;\n\t\tthis._compositionState = null;\n\t\tthis._columnSelectData = null;\n\t\tthis._autoClosedActions = [];\n\t\tthis._prevEditOperationType = EditOperationType.Other;\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._cursors.dispose();\n\t\tthis._autoClosedActions = dispose(this._autoClosedActions);\n\t\tsuper.dispose();\n\t}\n\n\tpublic updateConfiguration(cursorConfig: CursorConfiguration): void {\n\t\tthis.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n\t\tthis._cursors.updateContext(this.context);\n\t}\n\n\tpublic onLineMappingChanged(eventsCollector: ViewModelEventsCollector): void {\n\t\tif (this._knownModelVersionId !== this._model.getVersionId()) {\n\t\t\t// There are model change events that I didn't yet receive.\n\t\t\t//\n\t\t\t// This can happen when editing the model, and the view model receives the change events first,\n\t\t\t// and the view model emits line mapping changed events, all before the cursor gets a chance to\n\t\t\t// recover from markers.\n\t\t\t//\n\t\t\t// The model change listener above will be called soon and we'll ensure a valid cursor state there.\n\t\t\treturn;\n\t\t}\n\t\t// Ensure valid state\n\t\tthis.setStates(eventsCollector, 'viewModel', CursorChangeReason.NotSet, this.getCursorStates());\n\t}\n\n\tpublic setHasFocus(hasFocus: boolean): void {\n\t\tthis._hasFocus = hasFocus;\n\t}\n\n\tprivate _validateAutoClosedActions(): void {\n\t\tif (this._autoClosedActions.length > 0) {\n\t\t\tconst selections: Range[] = this._cursors.getSelections();\n\t\t\tfor (let i = 0; i < this._autoClosedActions.length; i++) {\n\t\t\t\tconst autoClosedAction = this._autoClosedActions[i];\n\t\t\t\tif (!autoClosedAction.isValid(selections)) {\n\t\t\t\t\tautoClosedAction.dispose();\n\t\t\t\t\tthis._autoClosedActions.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ------ some getters/setters\n\n\tpublic getPrimaryCursorState(): CursorState {\n\t\treturn this._cursors.getPrimaryCursor();\n\t}\n\n\tpublic getLastAddedCursorIndex(): number {\n\t\treturn this._cursors.getLastAddedCursorIndex();\n\t}\n\n\tpublic getCursorStates(): CursorState[] {\n\t\treturn this._cursors.getAll();\n\t}\n\n\tpublic setStates(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, reason: CursorChangeReason, states: PartialCursorState[] | null): boolean {\n\t\tlet reachedMaxCursorCount = false;\n\t\tconst multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n\t\tif (states !== null && states.length > multiCursorLimit) {\n\t\t\tstates = states.slice(0, multiCursorLimit);\n\t\t\treachedMaxCursorCount = true;\n\t\t}\n\n\t\tconst oldState = CursorModelState.from(this._model, this);\n\n\t\tthis._cursors.setStates(states);\n\t\tthis._cursors.normalize();\n\t\tthis._columnSelectData = null;\n\n\t\tthis._validateAutoClosedActions();\n\n\t\treturn this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n\t}\n\n\tpublic setCursorColumnSelectData(columnSelectData: IColumnSelectData): void {\n\t\tthis._columnSelectData = columnSelectData;\n\t}\n\n\tpublic revealAll(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, minimalReveal: boolean, verticalType: VerticalRevealType, revealHorizontal: boolean, scrollType: editorCommon.ScrollType): void {\n\t\tconst viewPositions = this._cursors.getViewPositions();\n\n\t\tlet revealViewRange: Range | null = null;\n\t\tlet revealViewSelections: Selection[] | null = null;\n\t\tif (viewPositions.length > 1) {\n\t\t\trevealViewSelections = this._cursors.getViewSelections();\n\t\t} else {\n\t\t\trevealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n\t\t}\n\n\t\teventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n\t}\n\n\tpublic revealPrimary(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, minimalReveal: boolean, verticalType: VerticalRevealType, revealHorizontal: boolean, scrollType: editorCommon.ScrollType): void {\n\t\tconst primaryCursor = this._cursors.getPrimaryCursor();\n\t\tconst revealViewSelections = [primaryCursor.viewState.selection];\n\t\teventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n\t}\n\n\tpublic saveState(): editorCommon.ICursorState[] {\n\n\t\tconst result: editorCommon.ICursorState[] = [];\n\n\t\tconst selections = this._cursors.getSelections();\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tresult.push({\n\t\t\t\tinSelectionMode: !selection.isEmpty(),\n\t\t\t\tselectionStart: {\n\t\t\t\t\tlineNumber: selection.selectionStartLineNumber,\n\t\t\t\t\tcolumn: selection.selectionStartColumn,\n\t\t\t\t},\n\t\t\t\tposition: {\n\t\t\t\t\tlineNumber: selection.positionLineNumber,\n\t\t\t\t\tcolumn: selection.positionColumn,\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic restoreState(eventsCollector: ViewModelEventsCollector, states: editorCommon.ICursorState[]): void {\n\n\t\tconst desiredSelections: ISelection[] = [];\n\n\t\tfor (let i = 0, len = states.length; i < len; i++) {\n\t\t\tconst state = states[i];\n\n\t\t\tlet positionLineNumber = 1;\n\t\t\tlet positionColumn = 1;\n\n\t\t\t// Avoid missing properties on the literal\n\t\t\tif (state.position && state.position.lineNumber) {\n\t\t\t\tpositionLineNumber = state.position.lineNumber;\n\t\t\t}\n\t\t\tif (state.position && state.position.column) {\n\t\t\t\tpositionColumn = state.position.column;\n\t\t\t}\n\n\t\t\tlet selectionStartLineNumber = positionLineNumber;\n\t\t\tlet selectionStartColumn = positionColumn;\n\n\t\t\t// Avoid missing properties on the literal\n\t\t\tif (state.selectionStart && state.selectionStart.lineNumber) {\n\t\t\t\tselectionStartLineNumber = state.selectionStart.lineNumber;\n\t\t\t}\n\t\t\tif (state.selectionStart && state.selectionStart.column) {\n\t\t\t\tselectionStartColumn = state.selectionStart.column;\n\t\t\t}\n\n\t\t\tdesiredSelections.push({\n\t\t\t\tselectionStartLineNumber: selectionStartLineNumber,\n\t\t\t\tselectionStartColumn: selectionStartColumn,\n\t\t\t\tpositionLineNumber: positionLineNumber,\n\t\t\t\tpositionColumn: positionColumn\n\t\t\t});\n\t\t}\n\n\t\tthis.setStates(eventsCollector, 'restoreState', CursorChangeReason.NotSet, CursorState.fromModelSelections(desiredSelections));\n\t\tthis.revealAll(eventsCollector, 'restoreState', false, VerticalRevealType.Simple, true, editorCommon.ScrollType.Immediate);\n\t}\n\n\tpublic onModelContentChanged(eventsCollector: ViewModelEventsCollector, event: InternalModelContentChangeEvent | ModelInjectedTextChangedEvent): void {\n\t\tif (event instanceof ModelInjectedTextChangedEvent) {\n\t\t\t// If injected texts change, the view positions of all cursors need to be updated.\n\t\t\tif (this._isHandling) {\n\t\t\t\t// The view positions will be updated when handling finishes\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// setStates might remove markers, which could trigger a decoration change.\n\t\t\t// If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n\t\t\t// and an endless recursion happens.\n\t\t\t// _isHandling prevents that.\n\t\t\tthis._isHandling = true;\n\t\t\ttry {\n\t\t\t\tthis.setStates(eventsCollector, 'modelChange', CursorChangeReason.NotSet, this.getCursorStates());\n\t\t\t} finally {\n\t\t\t\tthis._isHandling = false;\n\t\t\t}\n\t\t} else {\n\t\t\tconst e = event.rawContentChangedEvent;\n\t\t\tthis._knownModelVersionId = e.versionId;\n\t\t\tif (this._isHandling) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst hadFlushEvent = e.containsEvent(RawContentChangedType.Flush);\n\t\t\tthis._prevEditOperationType = EditOperationType.Other;\n\n\t\t\tif (hadFlushEvent) {\n\t\t\t\t// a model.setValue() was called\n\t\t\t\tthis._cursors.dispose();\n\t\t\t\tthis._cursors = new CursorCollection(this.context);\n\t\t\t\tthis._validateAutoClosedActions();\n\t\t\t\tthis._emitStateChangedIfNecessary(eventsCollector, 'model', CursorChangeReason.ContentFlush, null, false);\n\t\t\t} else {\n\t\t\t\tif (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n\t\t\t\t\tconst cursorState = CursorState.fromModelSelections(e.resultingSelection);\n\t\t\t\t\tif (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? CursorChangeReason.Undo : e.isRedoing ? CursorChangeReason.Redo : CursorChangeReason.RecoverFromMarkers, cursorState)) {\n\t\t\t\t\t\tthis.revealAll(eventsCollector, 'modelChange', false, VerticalRevealType.Simple, true, editorCommon.ScrollType.Smooth);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n\t\t\t\t\tthis.setStates(eventsCollector, 'modelChange', CursorChangeReason.RecoverFromMarkers, CursorState.fromModelSelections(selectionsFromMarkers));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getSelection(): Selection {\n\t\treturn this._cursors.getPrimaryCursor().modelState.selection;\n\t}\n\n\tpublic getTopMostViewPosition(): Position {\n\t\treturn this._cursors.getTopMostViewPosition();\n\t}\n\n\tpublic getBottomMostViewPosition(): Position {\n\t\treturn this._cursors.getBottomMostViewPosition();\n\t}\n\n\tpublic getCursorColumnSelectData(): IColumnSelectData {\n\t\tif (this._columnSelectData) {\n\t\t\treturn this._columnSelectData;\n\t\t}\n\t\tconst primaryCursor = this._cursors.getPrimaryCursor();\n\t\tconst viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n\t\tconst viewPosition = primaryCursor.viewState.position;\n\t\treturn {\n\t\t\tisReal: false,\n\t\t\tfromViewLineNumber: viewSelectionStart.lineNumber,\n\t\t\tfromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n\t\t\ttoViewLineNumber: viewPosition.lineNumber,\n\t\t\ttoViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n\t\t};\n\t}\n\n\tpublic getSelections(): Selection[] {\n\t\treturn this._cursors.getSelections();\n\t}\n\n\tpublic setSelections(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, selections: readonly ISelection[], reason: CursorChangeReason): void {\n\t\tthis.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n\t}\n\n\tpublic getPrevEditOperationType(): EditOperationType {\n\t\treturn this._prevEditOperationType;\n\t}\n\n\tpublic setPrevEditOperationType(type: EditOperationType): void {\n\t\tthis._prevEditOperationType = type;\n\t}\n\n\t// ------ auxiliary handling logic\n\n\tprivate _pushAutoClosedAction(autoClosedCharactersRanges: Range[], autoClosedEnclosingRanges: Range[]): void {\n\t\tconst autoClosedCharactersDeltaDecorations: IModelDeltaDecoration[] = [];\n\t\tconst autoClosedEnclosingDeltaDecorations: IModelDeltaDecoration[] = [];\n\n\t\tfor (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n\t\t\tautoClosedCharactersDeltaDecorations.push({\n\t\t\t\trange: autoClosedCharactersRanges[i],\n\t\t\t\toptions: {\n\t\t\t\t\tdescription: 'auto-closed-character',\n\t\t\t\t\tinlineClassName: 'auto-closed-character',\n\t\t\t\t\tstickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n\t\t\t\t}\n\t\t\t});\n\t\t\tautoClosedEnclosingDeltaDecorations.push({\n\t\t\t\trange: autoClosedEnclosingRanges[i],\n\t\t\t\toptions: {\n\t\t\t\t\tdescription: 'auto-closed-enclosing',\n\t\t\t\t\tstickiness: TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tconst autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n\t\tconst autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n\t\tthis._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n\t}\n\n\tprivate _executeEditOperation(opResult: EditOperationResult | null, editReason: TextModelEditSource): void {\n\n\t\tif (!opResult) {\n\t\t\t// Nothing to execute\n\t\t\treturn;\n\t\t}\n\n\t\tif (opResult.shouldPushStackElementBefore) {\n\t\t\tthis._model.pushStackElement();\n\t\t}\n\n\t\tconst result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands, editReason);\n\t\tif (result) {\n\t\t\t// The commands were applied correctly\n\t\t\tthis._interpretCommandResult(result);\n\n\t\t\t// Check for auto-closing closed characters\n\t\t\tconst autoClosedCharactersRanges: Range[] = [];\n\t\t\tconst autoClosedEnclosingRanges: Range[] = [];\n\n\t\t\tfor (let i = 0; i < opResult.commands.length; i++) {\n\t\t\t\tconst command = opResult.commands[i];\n\t\t\t\tif (command instanceof BaseTypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n\t\t\t\t\tautoClosedCharactersRanges.push(command.closeCharacterRange);\n\t\t\t\t\tautoClosedEnclosingRanges.push(command.enclosingRange);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (autoClosedCharactersRanges.length > 0) {\n\t\t\t\tthis._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n\t\t\t}\n\n\t\t\tthis._prevEditOperationType = opResult.type;\n\t\t}\n\n\t\tif (opResult.shouldPushStackElementAfter) {\n\t\t\tthis._model.pushStackElement();\n\t\t}\n\t}\n\n\tprivate _interpretCommandResult(cursorState: Selection[] | null): void {\n\t\tif (!cursorState || cursorState.length === 0) {\n\t\t\tcursorState = this._cursors.readSelectionFromMarkers();\n\t\t}\n\n\t\tthis._columnSelectData = null;\n\t\tthis._cursors.setSelections(cursorState);\n\t\tthis._cursors.normalize();\n\t}\n\n\t// -----------------------------------------------------------------------------------------------------------\n\t// ----- emitting events\n\n\tprivate _emitStateChangedIfNecessary(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, reason: CursorChangeReason, oldState: CursorModelState | null, reachedMaxCursorCount: boolean): boolean {\n\t\tconst newState = CursorModelState.from(this._model, this);\n\t\tif (newState.equals(oldState)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selections = this._cursors.getSelections();\n\t\tconst viewSelections = this._cursors.getViewSelections();\n\n\t\t// Let the view get the event first.\n\t\teventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n\n\t\t// Only after the view has been notified, let the rest of the world know...\n\t\tif (!oldState\n\t\t\t|| oldState.cursorState.length !== newState.cursorState.length\n\t\t\t|| newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))\n\t\t) {\n\t\t\tconst oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n\t\t\tconst oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n\t\t\teventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t// -----------------------------------------------------------------------------------------------------------\n\t// ----- handlers beyond this point\n\n\tprivate _findAutoClosingPairs(edits: IIdentifiedSingleEditOperation[]): [number, number][] | null {\n\t\tif (!edits.length) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst indices: [number, number][] = [];\n\t\tfor (let i = 0, len = edits.length; i < len; i++) {\n\t\t\tconst edit = edits[i];\n\t\t\tif (!edit.text || edit.text.indexOf('\\n') >= 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst closeChar = m[1];\n\n\t\t\tconst autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n\t\t\tif (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst openChar = autoClosingPairsCandidates[0].open;\n\t\t\tconst closeCharIndex = edit.text.length - m[2].length - 1;\n\t\t\tconst openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n\t\t\tif (openCharIndex === -1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tindices.push([openCharIndex, closeCharIndex]);\n\t\t}\n\n\t\treturn indices;\n\t}\n\n\tpublic executeEdits(eventsCollector: ViewModelEventsCollector, source: string | null | undefined, edits: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer, reason: TextModelEditSource): void {\n\t\tlet autoClosingIndices: [number, number][] | null = null;\n\t\tif (source === 'snippet') {\n\t\t\tautoClosingIndices = this._findAutoClosingPairs(edits);\n\t\t}\n\n\t\tif (autoClosingIndices) {\n\t\t\tedits[0]._isTracked = true;\n\t\t}\n\t\tconst autoClosedCharactersRanges: Range[] = [];\n\t\tconst autoClosedEnclosingRanges: Range[] = [];\n\t\tconst selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n\t\t\tif (autoClosingIndices) {\n\t\t\t\tfor (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n\t\t\t\t\tconst [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n\t\t\t\t\tconst undoEdit = undoEdits[i];\n\t\t\t\t\tconst lineNumber = undoEdit.range.startLineNumber;\n\t\t\t\t\tconst openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n\t\t\t\t\tconst closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n\n\t\t\t\t\tautoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n\t\t\t\t\tautoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst selections = cursorStateComputer(undoEdits);\n\t\t\tif (selections) {\n\t\t\t\t// Don't recover the selection from markers because\n\t\t\t\t// we know what it should be.\n\t\t\t\tthis._isHandling = true;\n\t\t\t}\n\n\t\t\treturn selections;\n\t\t}, undefined, reason);\n\t\tif (selections) {\n\t\t\tthis._isHandling = false;\n\t\t\tthis.setSelections(eventsCollector, source, selections, CursorChangeReason.NotSet);\n\t\t}\n\t\tif (autoClosedCharactersRanges.length > 0) {\n\t\t\tthis._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n\t\t}\n\t}\n\n\tprivate _executeEdit(callback: () => void, eventsCollector: ViewModelEventsCollector, source: string | null | undefined, cursorChangeReason: CursorChangeReason = CursorChangeReason.NotSet): void {\n\t\tif (this.context.cursorConfig.readOnly) {\n\t\t\t// we cannot edit when read only...\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldState = CursorModelState.from(this._model, this);\n\t\tthis._cursors.stopTrackingSelections();\n\t\tthis._isHandling = true;\n\n\t\ttry {\n\t\t\tthis._cursors.ensureValidState();\n\t\t\tcallback();\n\t\t} catch (err) {\n\t\t\tonUnexpectedError(err);\n\t\t}\n\n\t\tthis._isHandling = false;\n\t\tthis._cursors.startTrackingSelections();\n\t\tthis._validateAutoClosedActions();\n\t\tif (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n\t\t\tthis.revealAll(eventsCollector, source, false, VerticalRevealType.Simple, true, editorCommon.ScrollType.Smooth);\n\t\t}\n\t}\n\n\tpublic getAutoClosedCharacters(): Range[] {\n\t\treturn AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n\t}\n\n\tpublic startComposition(eventsCollector: ViewModelEventsCollector): void {\n\t\tthis._compositionState = new CompositionState(this._model, this.getSelections());\n\t}\n\n\tpublic endComposition(eventsCollector: ViewModelEventsCollector, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'compositionEnd', detailedSource: source });\n\n\t\tconst compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n\t\tthis._compositionState = null;\n\n\t\tthis._executeEdit(() => {\n\t\t\tif (source === 'keyboard') {\n\t\t\t\t// composition finishes, let's check if we need to auto complete if necessary.\n\t\t\t\tthis._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()), reason);\n\t\t\t}\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic type(eventsCollector: ViewModelEventsCollector, text: string, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'type', detailedSource: source });\n\n\t\tthis._executeEdit(() => {\n\t\t\tif (source === 'keyboard') {\n\t\t\t\t// If this event is coming straight from the keyboard, look for electric characters and enter\n\n\t\t\t\tconst len = text.length;\n\t\t\t\tlet offset = 0;\n\t\t\t\twhile (offset < len) {\n\t\t\t\t\tconst charLength = strings.nextCharLength(text, offset);\n\t\t\t\t\tconst chr = text.substr(offset, charLength);\n\n\t\t\t\t\t// Here we must interpret each typed character individually\n\t\t\t\t\tthis._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr), reason);\n\n\t\t\t\t\toffset += charLength;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tthis._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text), reason);\n\t\t\t}\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic compositionType(eventsCollector: ViewModelEventsCollector, text: string, replacePrevCharCnt: number, replaceNextCharCnt: number, positionDelta: number, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'compositionType', detailedSource: source });\n\n\t\tif (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n\t\t\t// this edit is a no-op\n\t\t\tif (positionDelta !== 0) {\n\t\t\t\t// but it still wants to move the cursor\n\t\t\t\tconst newSelections = this.getSelections().map(selection => {\n\t\t\t\t\tconst position = selection.getPosition();\n\t\t\t\t\treturn new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n\t\t\t\t});\n\t\t\t\tthis.setSelections(eventsCollector, source, newSelections, CursorChangeReason.NotSet);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._executeEdit(() => {\n\t\t\tthis._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta), reason);\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic paste(eventsCollector: ViewModelEventsCollector, text: string, pasteOnNewLine: boolean, multicursorText?: string[] | null | undefined, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'paste', detailedSource: source });\n\n\t\tthis._executeEdit(() => {\n\t\t\tthis._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []), reason);\n\t\t}, eventsCollector, source, CursorChangeReason.Paste);\n\t}\n\n\tpublic cut(eventsCollector: ViewModelEventsCollector, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'cut', detailedSource: source });\n\t\tthis._executeEdit(() => {\n\t\t\tthis._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()), reason);\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic executeCommand(eventsCollector: ViewModelEventsCollector, command: editorCommon.ICommand, source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'executeCommand', detailedSource: source });\n\n\t\tthis._executeEdit(() => {\n\t\t\tthis._cursors.killSecondaryCursors();\n\n\t\t\tthis._executeEditOperation(new EditOperationResult(EditOperationType.Other, [command], {\n\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\tshouldPushStackElementAfter: false\n\t\t\t}), reason);\n\t\t}, eventsCollector, source);\n\t}\n\n\tpublic executeCommands(eventsCollector: ViewModelEventsCollector, commands: editorCommon.ICommand[], source?: string | null | undefined): void {\n\t\tconst reason = EditSources.cursor({ kind: 'executeCommands', detailedSource: source });\n\n\t\tthis._executeEdit(() => {\n\t\t\tthis._executeEditOperation(new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\tshouldPushStackElementAfter: false\n\t\t\t}), reason);\n\t\t}, eventsCollector, source);\n\t}\n}\n\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n\tpublic static from(model: ITextModel, cursor: CursorsController): CursorModelState {\n\t\treturn new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n\t}\n\n\tconstructor(\n\t\tpublic readonly modelVersionId: number,\n\t\tpublic readonly cursorState: CursorState[],\n\t) {\n\t}\n\n\tpublic equals(other: CursorModelState | null): boolean {\n\t\tif (!other) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.modelVersionId !== other.modelVersionId) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.cursorState.length !== other.cursorState.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0, len = this.cursorState.length; i < len; i++) {\n\t\t\tif (!this.cursorState[i].equals(other.cursorState[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nclass AutoClosedAction {\n\n\tpublic static getAllAutoClosedCharacters(autoClosedActions: AutoClosedAction[]): Range[] {\n\t\tlet autoClosedCharacters: Range[] = [];\n\t\tfor (const autoClosedAction of autoClosedActions) {\n\t\t\tautoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n\t\t}\n\t\treturn autoClosedCharacters;\n\t}\n\n\tprivate readonly _model: ITextModel;\n\n\tprivate _autoClosedCharactersDecorations: string[];\n\tprivate _autoClosedEnclosingDecorations: string[];\n\n\tconstructor(model: ITextModel, autoClosedCharactersDecorations: string[], autoClosedEnclosingDecorations: string[]) {\n\t\tthis._model = model;\n\t\tthis._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n\t\tthis._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n\t\tthis._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n\t}\n\n\tpublic getAutoClosedCharactersRanges(): Range[] {\n\t\tconst result: Range[] = [];\n\t\tfor (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n\t\t\tconst decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n\t\t\tif (decorationRange) {\n\t\t\t\tresult.push(decorationRange);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic isValid(selections: Range[]): boolean {\n\t\tconst enclosingRanges: Range[] = [];\n\t\tfor (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n\t\t\tconst decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n\t\t\tif (decorationRange) {\n\t\t\t\tenclosingRanges.push(decorationRange);\n\t\t\t\tif (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n\t\t\t\t\t// Stop tracking if the range becomes multiline...\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tenclosingRanges.sort(Range.compareRangesUsingStarts);\n\n\t\tselections.sort(Range.compareRangesUsingStarts);\n\n\t\tfor (let i = 0; i < selections.length; i++) {\n\t\t\tif (i >= enclosingRanges.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!enclosingRanges[i].strictContainsRange(selections[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\ninterface IExecContext {\n\treadonly model: ITextModel;\n\treadonly selectionsBefore: Selection[];\n\treadonly trackedRanges: string[];\n\treadonly trackedRangesDirection: SelectionDirection[];\n}\n\ninterface ICommandData {\n\toperations: IIdentifiedSingleEditOperation[];\n\thadTrackedEditOperation: boolean;\n}\n\ninterface ICommandsData {\n\toperations: IIdentifiedSingleEditOperation[];\n\thadTrackedEditOperation: boolean;\n}\n\nexport class CommandExecutor {\n\n\tpublic static executeCommands(model: ITextModel, selectionsBefore: Selection[], commands: (editorCommon.ICommand | null)[], editReason: TextModelEditSource = EditSources.unknown({ name: 'executeCommands' })): Selection[] | null {\n\n\t\tconst ctx: IExecContext = {\n\t\t\tmodel: model,\n\t\t\tselectionsBefore: selectionsBefore,\n\t\t\ttrackedRanges: [],\n\t\t\ttrackedRangesDirection: []\n\t\t};\n\n\t\tconst result = this._innerExecuteCommands(ctx, commands, editReason);\n\n\t\tfor (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n\t\t\tctx.model._setTrackedRange(ctx.trackedRanges[i], null, TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _innerExecuteCommands(ctx: IExecContext, commands: (editorCommon.ICommand | null)[], editReason: TextModelEditSource): Selection[] | null {\n\n\t\tif (this._arrayIsEmpty(commands)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst commandsData = this._getEditOperations(ctx, commands);\n\t\tif (commandsData.operations.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst rawOperations = commandsData.operations;\n\n\t\tconst loserCursorsMap = this._getLoserCursorMap(rawOperations);\n\t\tif (loserCursorsMap.hasOwnProperty('0')) {\n\t\t\t// These commands are very messed up\n\t\t\tconsole.warn('Ignoring commands');\n\t\t\treturn null;\n\t\t}\n\n\t\t// Remove operations belonging to losing cursors\n\t\tconst filteredOperations: IIdentifiedSingleEditOperation[] = [];\n\t\tfor (let i = 0, len = rawOperations.length; i < len; i++) {\n\t\t\tif (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier!.major.toString())) {\n\t\t\t\tfilteredOperations.push(rawOperations[i]);\n\t\t\t}\n\t\t}\n\n\t\t// TODO@Alex: find a better way to do this.\n\t\t// give the hint that edit operations are tracked to the model\n\t\tif (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n\t\t\tfilteredOperations[0]._isTracked = true;\n\t\t}\n\t\tlet selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations: IValidEditOperation[]): Selection[] => {\n\t\t\tconst groupedInverseEditOperations: IValidEditOperation[][] = [];\n\t\t\tfor (let i = 0; i < ctx.selectionsBefore.length; i++) {\n\t\t\t\tgroupedInverseEditOperations[i] = [];\n\t\t\t}\n\t\t\tfor (const op of inverseEditOperations) {\n\t\t\t\tif (!op.identifier) {\n\t\t\t\t\t// perhaps auto whitespace trim edits\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgroupedInverseEditOperations[op.identifier.major].push(op);\n\t\t\t}\n\t\t\tconst minorBasedSorter = (a: IValidEditOperation, b: IValidEditOperation) => {\n\t\t\t\treturn a.identifier!.minor - b.identifier!.minor;\n\t\t\t};\n\t\t\tconst cursorSelections: Selection[] = [];\n\t\t\tfor (let i = 0; i < ctx.selectionsBefore.length; i++) {\n\t\t\t\tif (groupedInverseEditOperations[i].length > 0) {\n\t\t\t\t\tgroupedInverseEditOperations[i].sort(minorBasedSorter);\n\t\t\t\t\tcursorSelections[i] = commands[i]!.computeCursorState(ctx.model, {\n\t\t\t\t\t\tgetInverseEditOperations: () => {\n\t\t\t\t\t\t\treturn groupedInverseEditOperations[i];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetTrackedSelection: (id: string) => {\n\t\t\t\t\t\t\tconst idx = parseInt(id, 10);\n\t\t\t\t\t\t\tconst range = ctx.model._getTrackedRange(ctx.trackedRanges[idx])!;\n\t\t\t\t\t\t\tif (ctx.trackedRangesDirection[idx] === SelectionDirection.LTR) {\n\t\t\t\t\t\t\t\treturn new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcursorSelections[i] = ctx.selectionsBefore[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cursorSelections;\n\t\t}, undefined, editReason);\n\t\tif (!selectionsAfter) {\n\t\t\tselectionsAfter = ctx.selectionsBefore;\n\t\t}\n\n\t\t// Extract losing cursors\n\t\tconst losingCursors: number[] = [];\n\t\tfor (const losingCursorIndex in loserCursorsMap) {\n\t\t\tif (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n\t\t\t\tlosingCursors.push(parseInt(losingCursorIndex, 10));\n\t\t\t}\n\t\t}\n\n\t\t// Sort losing cursors descending\n\t\tlosingCursors.sort((a: number, b: number): number => {\n\t\t\treturn b - a;\n\t\t});\n\n\t\t// Remove losing cursors\n\t\tfor (const losingCursor of losingCursors) {\n\t\t\tselectionsAfter.splice(losingCursor, 1);\n\t\t}\n\n\t\treturn selectionsAfter;\n\t}\n\n\tprivate static _arrayIsEmpty(commands: (editorCommon.ICommand | null)[]): boolean {\n\t\tfor (let i = 0, len = commands.length; i < len; i++) {\n\t\t\tif (commands[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate static _getEditOperations(ctx: IExecContext, commands: (editorCommon.ICommand | null)[]): ICommandsData {\n\t\tlet operations: IIdentifiedSingleEditOperation[] = [];\n\t\tlet hadTrackedEditOperation: boolean = false;\n\n\t\tfor (let i = 0, len = commands.length; i < len; i++) {\n\t\t\tconst command = commands[i];\n\t\t\tif (command) {\n\t\t\t\tconst r = this._getEditOperationsFromCommand(ctx, i, command);\n\t\t\t\toperations = operations.concat(r.operations);\n\t\t\t\thadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\toperations: operations,\n\t\t\thadTrackedEditOperation: hadTrackedEditOperation\n\t\t};\n\t}\n\n\tprivate static _getEditOperationsFromCommand(ctx: IExecContext, majorIdentifier: number, command: editorCommon.ICommand): ICommandData {\n\t\t// This method acts as a transaction, if the command fails\n\t\t// everything it has done is ignored\n\t\tconst operations: IIdentifiedSingleEditOperation[] = [];\n\t\tlet operationMinor = 0;\n\n\t\tconst addEditOperation = (range: IRange, text: string | null, forceMoveMarkers: boolean = false) => {\n\t\t\tif (Range.isEmpty(range) && text === '') {\n\t\t\t\t// This command wants to add a no-op => no thank you\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toperations.push({\n\t\t\t\tidentifier: {\n\t\t\t\t\tmajor: majorIdentifier,\n\t\t\t\t\tminor: operationMinor++\n\t\t\t\t},\n\t\t\t\trange: range,\n\t\t\t\ttext: text,\n\t\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\t\tisAutoWhitespaceEdit: command.insertsAutoWhitespace\n\t\t\t});\n\t\t};\n\n\t\tlet hadTrackedEditOperation = false;\n\t\tconst addTrackedEditOperation = (selection: IRange, text: string | null, forceMoveMarkers?: boolean) => {\n\t\t\thadTrackedEditOperation = true;\n\t\t\taddEditOperation(selection, text, forceMoveMarkers);\n\t\t};\n\n\t\tconst trackSelection = (_selection: ISelection, trackPreviousOnEmpty?: boolean) => {\n\t\t\tconst selection = Selection.liftSelection(_selection);\n\t\t\tlet stickiness: TrackedRangeStickiness;\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\tif (typeof trackPreviousOnEmpty === 'boolean') {\n\t\t\t\t\tif (trackPreviousOnEmpty) {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Try to lock it with surrounding text\n\t\t\t\t\tconst maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n\t\t\t\t\tif (selection.startColumn === maxLineColumn) {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstickiness = TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstickiness = TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;\n\t\t\t}\n\n\t\t\tconst l = ctx.trackedRanges.length;\n\t\t\tconst id = ctx.model._setTrackedRange(null, selection, stickiness);\n\t\t\tctx.trackedRanges[l] = id;\n\t\t\tctx.trackedRangesDirection[l] = selection.getDirection();\n\t\t\treturn l.toString();\n\t\t};\n\n\t\tconst editOperationBuilder: editorCommon.IEditOperationBuilder = {\n\t\t\taddEditOperation: addEditOperation,\n\t\t\taddTrackedEditOperation: addTrackedEditOperation,\n\t\t\ttrackSelection: trackSelection\n\t\t};\n\n\t\ttry {\n\t\t\tcommand.getEditOperations(ctx.model, editOperationBuilder);\n\t\t} catch (e) {\n\t\t\t// TODO@Alex use notification service if this should be user facing\n\t\t\t// e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n\t\t\tonUnexpectedError(e);\n\t\t\treturn {\n\t\t\t\toperations: [],\n\t\t\t\thadTrackedEditOperation: false\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\toperations: operations,\n\t\t\thadTrackedEditOperation: hadTrackedEditOperation\n\t\t};\n\t}\n\n\tprivate static _getLoserCursorMap(operations: IIdentifiedSingleEditOperation[]): { [index: string]: boolean } {\n\t\t// This is destructive on the array\n\t\toperations = operations.slice(0);\n\n\t\t// Sort operations with last one first\n\t\toperations.sort((a: IIdentifiedSingleEditOperation, b: IIdentifiedSingleEditOperation): number => {\n\t\t\t// Note the minus!\n\t\t\treturn -(Range.compareRangesUsingEnds(a.range, b.range));\n\t\t});\n\n\t\t// Operations can not overlap!\n\t\tconst loserCursorsMap: { [index: string]: boolean } = {};\n\n\t\tfor (let i = 1; i < operations.length; i++) {\n\t\t\tconst previousOp = operations[i - 1];\n\t\t\tconst currentOp = operations[i];\n\n\t\t\tif (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n\n\t\t\t\tlet loserMajor: number;\n\n\t\t\t\tif (previousOp.identifier!.major > currentOp.identifier!.major) {\n\t\t\t\t\t// previousOp loses the battle\n\t\t\t\t\tloserMajor = previousOp.identifier!.major;\n\t\t\t\t} else {\n\t\t\t\t\tloserMajor = currentOp.identifier!.major;\n\t\t\t\t}\n\n\t\t\t\tloserCursorsMap[loserMajor.toString()] = true;\n\n\t\t\t\tfor (let j = 0; j < operations.length; j++) {\n\t\t\t\t\tif (operations[j].identifier!.major === loserMajor) {\n\t\t\t\t\t\toperations.splice(j, 1);\n\t\t\t\t\t\tif (j < i) {\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn loserCursorsMap;\n\t}\n}\n\nclass CompositionLineState {\n\tconstructor(\n\t\tpublic readonly text: string,\n\t\tpublic readonly lineNumber: number,\n\t\tpublic readonly startSelectionOffset: number,\n\t\tpublic readonly endSelectionOffset: number\n\t) { }\n}\n\nclass CompositionState {\n\n\tprivate readonly _original: CompositionLineState[] | null;\n\n\tprivate static _capture(textModel: ITextModel, selections: Selection[]): CompositionLineState[] | null {\n\t\tconst result: CompositionLineState[] = [];\n\t\tfor (const selection of selections) {\n\t\t\tif (selection.startLineNumber !== selection.endLineNumber) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tconst lineNumber = selection.startLineNumber;\n\t\t\tresult.push(new CompositionLineState(\n\t\t\t\ttextModel.getLineContent(lineNumber),\n\t\t\t\tlineNumber,\n\t\t\t\tselection.startColumn - 1,\n\t\t\t\tselection.endColumn - 1\n\t\t\t));\n\t\t}\n\t\treturn result;\n\t}\n\n\tconstructor(textModel: ITextModel, selections: Selection[]) {\n\t\tthis._original = CompositionState._capture(textModel, selections);\n\t}\n\n\t/**\n\t * Returns the inserted text during this composition.\n\t * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n\t */\n\tdeduceOutcome(textModel: ITextModel, selections: Selection[]): CompositionOutcome[] | null {\n\t\tif (!this._original) {\n\t\t\treturn null;\n\t\t}\n\t\tconst current = CompositionState._capture(textModel, selections);\n\t\tif (!current) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this._original.length !== current.length) {\n\t\t\treturn null;\n\t\t}\n\t\tconst result: CompositionOutcome[] = [];\n\t\tfor (let i = 0, len = this._original.length; i < len; i++) {\n\t\t\tresult.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static _deduceOutcome(original: CompositionLineState, current: CompositionLineState): CompositionOutcome {\n\t\tconst commonPrefix = Math.min(\n\t\t\toriginal.startSelectionOffset,\n\t\t\tcurrent.startSelectionOffset,\n\t\t\tstrings.commonPrefixLength(original.text, current.text)\n\t\t);\n\t\tconst commonSuffix = Math.min(\n\t\t\toriginal.text.length - original.endSelectionOffset,\n\t\t\tcurrent.text.length - current.endSelectionOffset,\n\t\t\tstrings.commonSuffixLength(original.text, current.text)\n\t\t);\n\t\tconst deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n\t\tconst insertedTextStartOffset = commonPrefix;\n\t\tconst insertedTextEndOffset = current.text.length - commonSuffix;\n\t\tconst insertedText = current.text.substring(insertedTextStartOffset, insertedTextEndOffset);\n\t\tconst insertedTextRange = new Range(current.lineNumber, insertedTextStartOffset + 1, current.lineNumber, insertedTextEndOffset + 1);\n\t\treturn new CompositionOutcome(\n\t\t\tdeletedText,\n\t\t\toriginal.startSelectionOffset - commonPrefix,\n\t\t\toriginal.endSelectionOffset - commonPrefix,\n\t\t\tinsertedText,\n\t\t\tcurrent.startSelectionOffset - commonPrefix,\n\t\t\tcurrent.endSelectionOffset - commonPrefix,\n\t\t\tinsertedTextRange\n\t\t);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}