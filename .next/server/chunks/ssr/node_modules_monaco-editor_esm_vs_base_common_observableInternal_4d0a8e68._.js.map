{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/debugName.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/vs/base/common/observableInternal/debugName.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IDebugNameData {\n\t/**\n\t * The owner object of an observable.\n\t * Used for debugging only, such as computing a name for the observable by iterating over the fields of the owner.\n\t */\n\treadonly owner?: DebugOwner | undefined;\n\n\t/**\n\t * A string or function that returns a string that represents the name of the observable.\n\t * Used for debugging only.\n\t */\n\treadonly debugName?: DebugNameSource | undefined;\n\n\t/**\n\t * A function that points to the defining function of the object.\n\t * Used for debugging only.\n\t */\n\treadonly debugReferenceFn?: Function | undefined;\n}\n\nexport class DebugNameData {\n\tconstructor(\n\t\tpublic readonly owner: DebugOwner | undefined,\n\t\tpublic readonly debugNameSource: DebugNameSource | undefined,\n\t\tpublic readonly referenceFn: Function | undefined,\n\t) { }\n\n\tpublic getDebugName(target: object): string | undefined {\n\t\treturn getDebugName(target, this);\n\t}\n}\n\n/**\n * The owning object of an observable.\n * Is only used for debugging purposes, such as computing a name for the observable by iterating over the fields of the owner.\n */\nexport type DebugOwner = object | undefined;\nexport type DebugNameSource = string | (() => string | undefined);\n\nconst countPerName = new Map<string, number>();\nconst cachedDebugName = new WeakMap<object, string>();\n\nexport function getDebugName(target: object, data: DebugNameData): string | undefined {\n\tconst cached = cachedDebugName.get(target);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst dbgName = computeDebugName(target, data);\n\tif (dbgName) {\n\t\tlet count = countPerName.get(dbgName) ?? 0;\n\t\tcount++;\n\t\tcountPerName.set(dbgName, count);\n\t\tconst result = count === 1 ? dbgName : `${dbgName}#${count}`;\n\t\tcachedDebugName.set(target, result);\n\t\treturn result;\n\t}\n\treturn undefined;\n}\n\nfunction computeDebugName(self: object, data: DebugNameData): string | undefined {\n\tconst cached = cachedDebugName.get(self);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n\n\tlet result: string | undefined;\n\tconst debugNameSource = data.debugNameSource;\n\tif (debugNameSource !== undefined) {\n\t\tif (typeof debugNameSource === 'function') {\n\t\t\tresult = debugNameSource();\n\t\t\tif (result !== undefined) {\n\t\t\t\treturn ownerStr + result;\n\t\t\t}\n\t\t} else {\n\t\t\treturn ownerStr + debugNameSource;\n\t\t}\n\t}\n\n\tconst referenceFn = data.referenceFn;\n\tif (referenceFn !== undefined) {\n\t\tresult = getFunctionName(referenceFn);\n\t\tif (result !== undefined) {\n\t\t\treturn ownerStr + result;\n\t\t}\n\t}\n\n\tif (data.owner !== undefined) {\n\t\tconst key = findKey(data.owner, self);\n\t\tif (key !== undefined) {\n\t\t\treturn ownerStr + key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nfunction findKey(obj: object, value: object): string | undefined {\n\tfor (const key in obj) {\n\t\tif ((obj as any)[key] === value) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst countPerClassName = new Map<string, number>();\nconst ownerId = new WeakMap<object, string>();\n\nfunction formatOwner(owner: object): string {\n\tconst id = ownerId.get(owner);\n\tif (id) {\n\t\treturn id;\n\t}\n\tconst className = getClassName(owner) ?? 'Object';\n\tlet count = countPerClassName.get(className) ?? 0;\n\tcount++;\n\tcountPerClassName.set(className, count);\n\tconst result = count === 1 ? className : `${className}#${count}`;\n\townerId.set(owner, result);\n\treturn result;\n}\n\nexport function getClassName(obj: object): string | undefined {\n\tconst ctor = obj.constructor;\n\tif (ctor) {\n\t\tif (ctor.name === 'Object') {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn ctor.name;\n\t}\n\treturn undefined;\n}\n\nexport function getFunctionName(fn: Function): string | undefined {\n\tconst fnSrc = fn.toString();\n\t// Pattern: /** @description ... */\n\tconst regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n\tconst match = regexp.exec(fnSrc);\n\tconst result = match ? match[1] : undefined;\n\treturn result?.trim();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IDebugNameData {\n\t/**\n\t * The owner object of an observable.\n\t * Used for debugging only, such as computing a name for the observable by iterating over the fields of the owner.\n\t */\n\treadonly owner?: DebugOwner | undefined;\n\n\t/**\n\t * A string or function that returns a string that represents the name of the observable.\n\t * Used for debugging only.\n\t */\n\treadonly debugName?: DebugNameSource | undefined;\n\n\t/**\n\t * A function that points to the defining function of the object.\n\t * Used for debugging only.\n\t */\n\treadonly debugReferenceFn?: Function | undefined;\n}\n\nexport class DebugNameData {\n\tconstructor(\n\t\tpublic readonly owner: DebugOwner | undefined,\n\t\tpublic readonly debugNameSource: DebugNameSource | undefined,\n\t\tpublic readonly referenceFn: Function | undefined,\n\t) { }\n\n\tpublic getDebugName(target: object): string | undefined {\n\t\treturn getDebugName(target, this);\n\t}\n}\n\n/**\n * The owning object of an observable.\n * Is only used for debugging purposes, such as computing a name for the observable by iterating over the fields of the owner.\n */\nexport type DebugOwner = object | undefined;\nexport type DebugNameSource = string | (() => string | undefined);\n\nconst countPerName = new Map<string, number>();\nconst cachedDebugName = new WeakMap<object, string>();\n\nexport function getDebugName(target: object, data: DebugNameData): string | undefined {\n\tconst cached = cachedDebugName.get(target);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst dbgName = computeDebugName(target, data);\n\tif (dbgName) {\n\t\tlet count = countPerName.get(dbgName) ?? 0;\n\t\tcount++;\n\t\tcountPerName.set(dbgName, count);\n\t\tconst result = count === 1 ? dbgName : `${dbgName}#${count}`;\n\t\tcachedDebugName.set(target, result);\n\t\treturn result;\n\t}\n\treturn undefined;\n}\n\nfunction computeDebugName(self: object, data: DebugNameData): string | undefined {\n\tconst cached = cachedDebugName.get(self);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n\n\tlet result: string | undefined;\n\tconst debugNameSource = data.debugNameSource;\n\tif (debugNameSource !== undefined) {\n\t\tif (typeof debugNameSource === 'function') {\n\t\t\tresult = debugNameSource();\n\t\t\tif (result !== undefined) {\n\t\t\t\treturn ownerStr + result;\n\t\t\t}\n\t\t} else {\n\t\t\treturn ownerStr + debugNameSource;\n\t\t}\n\t}\n\n\tconst referenceFn = data.referenceFn;\n\tif (referenceFn !== undefined) {\n\t\tresult = getFunctionName(referenceFn);\n\t\tif (result !== undefined) {\n\t\t\treturn ownerStr + result;\n\t\t}\n\t}\n\n\tif (data.owner !== undefined) {\n\t\tconst key = findKey(data.owner, self);\n\t\tif (key !== undefined) {\n\t\t\treturn ownerStr + key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nfunction findKey(obj: object, value: object): string | undefined {\n\tfor (const key in obj) {\n\t\tif ((obj as any)[key] === value) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst countPerClassName = new Map<string, number>();\nconst ownerId = new WeakMap<object, string>();\n\nfunction formatOwner(owner: object): string {\n\tconst id = ownerId.get(owner);\n\tif (id) {\n\t\treturn id;\n\t}\n\tconst className = getClassName(owner) ?? 'Object';\n\tlet count = countPerClassName.get(className) ?? 0;\n\tcount++;\n\tcountPerClassName.set(className, count);\n\tconst result = count === 1 ? className : `${className}#${count}`;\n\townerId.set(owner, result);\n\treturn result;\n}\n\nexport function getClassName(obj: object): string | undefined {\n\tconst ctor = obj.constructor;\n\tif (ctor) {\n\t\tif (ctor.name === 'Object') {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn ctor.name;\n\t}\n\treturn undefined;\n}\n\nexport function getFunctionName(fn: Function): string | undefined {\n\tconst fnSrc = fn.toString();\n\t// Pattern: /** @description ... */\n\tconst regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n\tconst match = regexp.exec(fnSrc);\n\tconst result = match ? match[1] : undefined;\n\treturn result?.trim();\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/commonFacade/deps.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/commonFacade/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/commonFacade/deps.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/commonFacade/vs/base/common/observableInternal/commonFacade/deps.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport { assertFn } from '../../assert.js';\nexport { type EqualityComparer, strictEquals } from '../../equals.js';\nexport { BugIndicatingError, onBugIndicatingError, onUnexpectedError } from '../../errors.js';\nexport { Event, type IValueWithChangeEvent } from '../../event.js';\nexport { DisposableStore, type IDisposable, markAsDisposed, toDisposable, trackDisposable } from '../../lifecycle.js';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport { assertFn } from '../../assert.js';\nexport { type EqualityComparer, strictEquals } from '../../equals.js';\nexport { BugIndicatingError, onBugIndicatingError, onUnexpectedError } from '../../errors.js';\nexport { Event, type IValueWithChangeEvent } from '../../event.js';\nexport { DisposableStore, type IDisposable, markAsDisposed, toDisposable, trackDisposable } from '../../lifecycle.js';\n"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,QAAQ,EAAE,MAAM,iBAAiB,CAAC;AAC3C,OAAO,EAAyB,YAAY,EAAE,MAAM,iBAAiB,CAAC;AACtE,OAAO,EAAE,kBAAkB,EAAE,oBAAoB,EAAE,iBAAiB,EAAE,MAAM,iBAAiB,CAAC;AAC9F,OAAO,EAAE,KAAK,EAA8B,MAAM,gBAAgB,CAAC;AACnE,OAAO,EAAE,eAAe,EAAoB,cAAc,EAAE,YAAY,EAAE,eAAe,EAAE,MAAM,oBAAoB,CAAC","debugId":null}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/base.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/vs/base/common/observableInternal/base.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, onUnexpectedError } from './commonFacade/deps.js';\n\n/**\n * Represents an observable value.\n *\n * @template T The type of the values the observable can hold.\n */\n// This interface exists so that, for example for string observables,\n// typescript renders the type as `IObservable<string>` instead of `IObservable<string, unknown>`.\nexport interface IObservable<T> extends IObservableWithChange<T, unknown> { }\n\n/**\n * Represents an observable value.\n *\n * @template T The type of the values the observable can hold.\n * @template TChange The type used to describe value changes\n * (usually `void` and only used in advanced scenarios).\n * While observers can miss temporary values of an observable,\n * they will receive all change values (as long as they are subscribed)!\n */\nexport interface IObservableWithChange<T, TChange = unknown> {\n\t/**\n\t * Returns the current value.\n\t *\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\tget(): T;\n\n\t/**\n\t * Forces the observable to check for changes and report them.\n\t *\n\t * Has the same effect as calling {@link IObservable.get}, but does not force the observable\n\t * to actually construct the value, e.g. if change deltas are used.\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\treportChanges(): void;\n\n\t/**\n\t * Adds the observer to the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\taddObserver(observer: IObserver): void;\n\n\t/**\n\t * Removes the observer from the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\tremoveObserver(observer: IObserver): void;\n\n\t// #region These members have a standard implementation and are only part of the interface for convenience.\n\n\t/**\n\t * Reads the current value and subscribes the reader to this observable.\n\t *\n\t * Calls {@link IReader.readObservable} if a reader is given, otherwise {@link IObservable.get}\n\t * (see {@link ConvenientObservable.read} for the implementation).\n\t */\n\tread(reader: IReader | undefined): T;\n\n\t/**\n\t * Makes sure this value is computed eagerly.\n\t */\n\trecomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T>;\n\n\t/**\n\t * Creates a derived observable that depends on this observable.\n\t * Use the reader to read other observables\n\t * (see {@link ConvenientObservable.map} for the implementation).\n\t */\n\tmap<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tmap<TNew>(owner: object, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\n\tflatten<TNew>(this: IObservable<IObservable<TNew>>): IObservable<TNew>;\n\n\t/**\n\t * A human-readable name for debugging purposes.\n\t */\n\treadonly debugName: string;\n\n\t/**\n\t * This property captures the type of the change object. Do not use it at runtime!\n\t */\n\treadonly TChange: TChange;\n\n\t// #endregion\n}\n\n/**\n * Represents an observer that can be subscribed to an observable.\n *\n * If an observer is subscribed to an observable and that observable didn't signal\n * a change through one of the observer methods, the observer can assume that the\n * observable didn't change.\n * If an observable reported a possible change, {@link IObservable.reportChanges} forces\n * the observable to report an actual change if there was one.\n */\nexport interface IObserver {\n\t/**\n\t * Signals that the given observable might have changed and a transaction potentially modifying that observable started.\n\t * Before the given observable can call this method again, is must call {@link IObserver.endUpdate}.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t */\n\tbeginUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the transaction that potentially modified the given observable ended.\n\t * This is a good place to react to (potential) changes.\n\t */\n\tendUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable might have changed.\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandlePossibleChange<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given {@link observable} changed.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t *\n\t * @param change Indicates how or why the value changed.\n\t */\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void;\n}\n\nexport interface IReader {\n\t/**\n\t * Reads the value of an observable and subscribes to it.\n\t */\n\treadObservable<T>(observable: IObservableWithChange<T, any>): T;\n}\n\nexport interface ISettable<T, TChange = void> {\n\t/**\n\t * Sets the value of the observable.\n\t * Use a transaction to batch multiple changes (with a transaction, observers only react at the end of the transaction).\n\t *\n\t * @param transaction When given, value changes are handled on demand or when the transaction ends.\n\t * @param change Describes how or why the value changed.\n\t */\n\tset(value: T, transaction: ITransaction | undefined, change: TChange): void;\n}\n\nexport interface ITransaction {\n\t/**\n\t * Calls {@link Observer.beginUpdate} immediately\n\t * and {@link Observer.endUpdate} when the transaction ends.\n\t */\n\tupdateObserver(observer: IObserver, observable: IObservableWithChange<any, any>): void;\n}\n\n/**\n * This function is used to indicate that the caller recovered from an error that indicates a bug.\n*/\nexport function handleBugIndicatingErrorRecovery(message: string) {\n\tconst err = new Error('BugIndicatingErrorRecovery: ' + message);\n\tonUnexpectedError(err);\n\tconsole.error('recovered from an error that indicates a bug', err);\n}\n\n/**\n * A settable observable.\n */\nexport interface ISettableObservable<T, TChange = void> extends IObservableWithChange<T, TChange>, ISettable<T, TChange> {\n}\n\nexport interface IReaderWithStore extends IReader {\n\t/**\n\t * Items in this store get disposed just before the observable recomputes/reruns or when it becomes unobserved.\n\t*/\n\tget store(): DisposableStore;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, onUnexpectedError } from './commonFacade/deps.js';\n\n/**\n * Represents an observable value.\n *\n * @template T The type of the values the observable can hold.\n */\n// This interface exists so that, for example for string observables,\n// typescript renders the type as `IObservable<string>` instead of `IObservable<string, unknown>`.\nexport interface IObservable<T> extends IObservableWithChange<T, unknown> { }\n\n/**\n * Represents an observable value.\n *\n * @template T The type of the values the observable can hold.\n * @template TChange The type used to describe value changes\n * (usually `void` and only used in advanced scenarios).\n * While observers can miss temporary values of an observable,\n * they will receive all change values (as long as they are subscribed)!\n */\nexport interface IObservableWithChange<T, TChange = unknown> {\n\t/**\n\t * Returns the current value.\n\t *\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\tget(): T;\n\n\t/**\n\t * Forces the observable to check for changes and report them.\n\t *\n\t * Has the same effect as calling {@link IObservable.get}, but does not force the observable\n\t * to actually construct the value, e.g. if change deltas are used.\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\treportChanges(): void;\n\n\t/**\n\t * Adds the observer to the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\taddObserver(observer: IObserver): void;\n\n\t/**\n\t * Removes the observer from the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\tremoveObserver(observer: IObserver): void;\n\n\t// #region These members have a standard implementation and are only part of the interface for convenience.\n\n\t/**\n\t * Reads the current value and subscribes the reader to this observable.\n\t *\n\t * Calls {@link IReader.readObservable} if a reader is given, otherwise {@link IObservable.get}\n\t * (see {@link ConvenientObservable.read} for the implementation).\n\t */\n\tread(reader: IReader | undefined): T;\n\n\t/**\n\t * Makes sure this value is computed eagerly.\n\t */\n\trecomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T>;\n\n\t/**\n\t * Creates a derived observable that depends on this observable.\n\t * Use the reader to read other observables\n\t * (see {@link ConvenientObservable.map} for the implementation).\n\t */\n\tmap<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tmap<TNew>(owner: object, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\n\tflatten<TNew>(this: IObservable<IObservable<TNew>>): IObservable<TNew>;\n\n\t/**\n\t * A human-readable name for debugging purposes.\n\t */\n\treadonly debugName: string;\n\n\t/**\n\t * This property captures the type of the change object. Do not use it at runtime!\n\t */\n\treadonly TChange: TChange;\n\n\t// #endregion\n}\n\n/**\n * Represents an observer that can be subscribed to an observable.\n *\n * If an observer is subscribed to an observable and that observable didn't signal\n * a change through one of the observer methods, the observer can assume that the\n * observable didn't change.\n * If an observable reported a possible change, {@link IObservable.reportChanges} forces\n * the observable to report an actual change if there was one.\n */\nexport interface IObserver {\n\t/**\n\t * Signals that the given observable might have changed and a transaction potentially modifying that observable started.\n\t * Before the given observable can call this method again, is must call {@link IObserver.endUpdate}.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t */\n\tbeginUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the transaction that potentially modified the given observable ended.\n\t * This is a good place to react to (potential) changes.\n\t */\n\tendUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable might have changed.\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandlePossibleChange<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given {@link observable} changed.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t *\n\t * @param change Indicates how or why the value changed.\n\t */\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void;\n}\n\nexport interface IReader {\n\t/**\n\t * Reads the value of an observable and subscribes to it.\n\t */\n\treadObservable<T>(observable: IObservableWithChange<T, any>): T;\n}\n\nexport interface ISettable<T, TChange = void> {\n\t/**\n\t * Sets the value of the observable.\n\t * Use a transaction to batch multiple changes (with a transaction, observers only react at the end of the transaction).\n\t *\n\t * @param transaction When given, value changes are handled on demand or when the transaction ends.\n\t * @param change Describes how or why the value changed.\n\t */\n\tset(value: T, transaction: ITransaction | undefined, change: TChange): void;\n}\n\nexport interface ITransaction {\n\t/**\n\t * Calls {@link Observer.beginUpdate} immediately\n\t * and {@link Observer.endUpdate} when the transaction ends.\n\t */\n\tupdateObserver(observer: IObserver, observable: IObservableWithChange<any, any>): void;\n}\n\n/**\n * This function is used to indicate that the caller recovered from an error that indicates a bug.\n*/\nexport function handleBugIndicatingErrorRecovery(message: string) {\n\tconst err = new Error('BugIndicatingErrorRecovery: ' + message);\n\tonUnexpectedError(err);\n\tconsole.error('recovered from an error that indicates a bug', err);\n}\n\n/**\n * A settable observable.\n */\nexport interface ISettableObservable<T, TChange = void> extends IObservableWithChange<T, TChange>, ISettable<T, TChange> {\n}\n\nexport interface IReaderWithStore extends IReader {\n\t/**\n\t * Items in this store get disposed just before the observable recomputes/reruns or when it becomes unobserved.\n\t*/\n\tget store(): DisposableStore;\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;AAEhG,OAAO,EAAmB,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;;AAmKtE,SAAU,gCAAgC,CAAC,OAAe;IAC/D,MAAM,GAAG,GAAG,IAAI,KAAK,CAAC,8BAA8B,GAAG,OAAO,CAAC,CAAC;QAChE,8LAAiB,EAAC,GAAG,CAAC,CAAC;IACvB,OAAO,CAAC,KAAK,CAAC,8CAA8C,EAAE,GAAG,CAAC,CAAC;AACpE,CAAC","debugId":null}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/logging.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/logging/logging.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/vs/base/common/observableInternal/logging/logging.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AutorunObserver } from '../reactions/autorunImpl.js';\nimport { IObservable } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { Derived } from '../observables/derivedImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nlet globalObservableLogger: IObservableLogger | undefined;\n\nexport function addLogger(logger: IObservableLogger): void {\n\tif (!globalObservableLogger) {\n\t\tglobalObservableLogger = logger;\n\t} else if (globalObservableLogger instanceof ComposedLogger) {\n\t\tglobalObservableLogger.loggers.push(logger);\n\t} else {\n\t\tglobalObservableLogger = new ComposedLogger([globalObservableLogger, logger]);\n\t}\n}\n\nexport function getLogger(): IObservableLogger | undefined {\n\treturn globalObservableLogger;\n}\n\nlet globalObservableLoggerFn: ((obs: IObservable<any>) => void) | undefined = undefined;\nexport function setLogObservableFn(fn: (obs: IObservable<any>) => void): void {\n\tglobalObservableLoggerFn = fn;\n}\n\nexport interface IChangeInformation {\n\toldValue: unknown;\n\tnewValue: unknown;\n\tchange: unknown;\n\tdidChange: boolean;\n\thadValue: boolean;\n}\n\nexport interface IObservableLogger {\n\thandleObservableCreated(observable: IObservable<any>, location: DebugLocation): void;\n\thandleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void;\n\n\thandleObservableUpdated(observable: IObservable<any>, info: IChangeInformation): void;\n\n\thandleAutorunCreated(autorun: AutorunObserver, location: DebugLocation): void;\n\thandleAutorunDisposed(autorun: AutorunObserver): void;\n\thandleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void;\n\thandleAutorunStarted(autorun: AutorunObserver): void;\n\thandleAutorunFinished(autorun: AutorunObserver): void;\n\n\thandleDerivedDependencyChanged(derived: Derived<any, any, any>, observable: IObservable<any>, change: unknown): void;\n\thandleDerivedCleared(observable: Derived<any, any, any>): void;\n\n\thandleBeginTransaction(transaction: TransactionImpl): void;\n\thandleEndTransaction(transaction: TransactionImpl): void;\n}\n\nclass ComposedLogger implements IObservableLogger {\n\tconstructor(\n\t\tpublic readonly loggers: IObservableLogger[],\n\t) { }\n\n\thandleObservableCreated(observable: IObservable<any>, location: DebugLocation): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleObservableCreated(observable, location);\n\t\t}\n\t}\n\thandleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleOnListenerCountChanged(observable, newCount);\n\t\t}\n\t}\n\thandleObservableUpdated(observable: IObservable<any>, info: IChangeInformation): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleObservableUpdated(observable, info);\n\t\t}\n\t}\n\thandleAutorunCreated(autorun: AutorunObserver, location: DebugLocation): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunCreated(autorun, location);\n\t\t}\n\t}\n\thandleAutorunDisposed(autorun: AutorunObserver): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunDisposed(autorun);\n\t\t}\n\t}\n\thandleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunDependencyChanged(autorun, observable, change);\n\t\t}\n\t}\n\thandleAutorunStarted(autorun: AutorunObserver): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunStarted(autorun);\n\t\t}\n\t}\n\thandleAutorunFinished(autorun: AutorunObserver): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunFinished(autorun);\n\t\t}\n\t}\n\thandleDerivedDependencyChanged(derived: Derived<any>, observable: IObservable<any>, change: unknown): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleDerivedDependencyChanged(derived, observable, change);\n\t\t}\n\t}\n\thandleDerivedCleared(observable: Derived<any>): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleDerivedCleared(observable);\n\t\t}\n\t}\n\thandleBeginTransaction(transaction: TransactionImpl): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleBeginTransaction(transaction);\n\t\t}\n\t}\n\thandleEndTransaction(transaction: TransactionImpl): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleEndTransaction(transaction);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AutorunObserver } from '../reactions/autorunImpl.js';\nimport { IObservable } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { Derived } from '../observables/derivedImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nlet globalObservableLogger: IObservableLogger | undefined;\n\nexport function addLogger(logger: IObservableLogger): void {\n\tif (!globalObservableLogger) {\n\t\tglobalObservableLogger = logger;\n\t} else if (globalObservableLogger instanceof ComposedLogger) {\n\t\tglobalObservableLogger.loggers.push(logger);\n\t} else {\n\t\tglobalObservableLogger = new ComposedLogger([globalObservableLogger, logger]);\n\t}\n}\n\nexport function getLogger(): IObservableLogger | undefined {\n\treturn globalObservableLogger;\n}\n\nlet globalObservableLoggerFn: ((obs: IObservable<any>) => void) | undefined = undefined;\nexport function setLogObservableFn(fn: (obs: IObservable<any>) => void): void {\n\tglobalObservableLoggerFn = fn;\n}\n\nexport interface IChangeInformation {\n\toldValue: unknown;\n\tnewValue: unknown;\n\tchange: unknown;\n\tdidChange: boolean;\n\thadValue: boolean;\n}\n\nexport interface IObservableLogger {\n\thandleObservableCreated(observable: IObservable<any>, location: DebugLocation): void;\n\thandleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void;\n\n\thandleObservableUpdated(observable: IObservable<any>, info: IChangeInformation): void;\n\n\thandleAutorunCreated(autorun: AutorunObserver, location: DebugLocation): void;\n\thandleAutorunDisposed(autorun: AutorunObserver): void;\n\thandleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void;\n\thandleAutorunStarted(autorun: AutorunObserver): void;\n\thandleAutorunFinished(autorun: AutorunObserver): void;\n\n\thandleDerivedDependencyChanged(derived: Derived<any, any, any>, observable: IObservable<any>, change: unknown): void;\n\thandleDerivedCleared(observable: Derived<any, any, any>): void;\n\n\thandleBeginTransaction(transaction: TransactionImpl): void;\n\thandleEndTransaction(transaction: TransactionImpl): void;\n}\n\nclass ComposedLogger implements IObservableLogger {\n\tconstructor(\n\t\tpublic readonly loggers: IObservableLogger[],\n\t) { }\n\n\thandleObservableCreated(observable: IObservable<any>, location: DebugLocation): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleObservableCreated(observable, location);\n\t\t}\n\t}\n\thandleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleOnListenerCountChanged(observable, newCount);\n\t\t}\n\t}\n\thandleObservableUpdated(observable: IObservable<any>, info: IChangeInformation): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleObservableUpdated(observable, info);\n\t\t}\n\t}\n\thandleAutorunCreated(autorun: AutorunObserver, location: DebugLocation): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunCreated(autorun, location);\n\t\t}\n\t}\n\thandleAutorunDisposed(autorun: AutorunObserver): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunDisposed(autorun);\n\t\t}\n\t}\n\thandleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunDependencyChanged(autorun, observable, change);\n\t\t}\n\t}\n\thandleAutorunStarted(autorun: AutorunObserver): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunStarted(autorun);\n\t\t}\n\t}\n\thandleAutorunFinished(autorun: AutorunObserver): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleAutorunFinished(autorun);\n\t\t}\n\t}\n\thandleDerivedDependencyChanged(derived: Derived<any>, observable: IObservable<any>, change: unknown): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleDerivedDependencyChanged(derived, observable, change);\n\t\t}\n\t}\n\thandleDerivedCleared(observable: Derived<any>): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleDerivedCleared(observable);\n\t\t}\n\t}\n\thandleBeginTransaction(transaction: TransactionImpl): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleBeginTransaction(transaction);\n\t\t}\n\t}\n\thandleEndTransaction(transaction: TransactionImpl): void {\n\t\tfor (const logger of this.loggers) {\n\t\t\tlogger.handleEndTransaction(transaction);\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 260, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/transaction.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/transaction.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/vs/base/common/observableInternal/transaction.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { handleBugIndicatingErrorRecovery, IObservable, IObserver, ITransaction } from './base.js';\nimport { getFunctionName } from './debugName.js';\nimport { getLogger } from './logging/logging.js';\n\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\n\nexport function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\nlet _globalTransaction: ITransaction | undefined = undefined;\n\nexport function globalTransaction(fn: (tx: ITransaction) => void) {\n\tif (_globalTransaction) {\n\t\tfn(_globalTransaction);\n\t} else {\n\t\tconst tx = new TransactionImpl(fn, undefined);\n\t\t_globalTransaction = tx;\n\t\ttry {\n\t\t\tfn(tx);\n\t\t} finally {\n\t\t\ttx.finish(); // During finish, more actions might be added to the transaction.\n\n\t\t\t// Which is why we only clear the global transaction after finish.\n\t\t\t_globalTransaction = undefined;\n\t\t}\n\t}\n}\n/** @deprecated */\n\nexport async function asyncTransaction(fn: (tx: ITransaction) => Promise<void>, getDebugName?: () => string): Promise<void> {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tawait fn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n/**\n * Allows to chain transactions.\n */\n\nexport function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tif (!tx) {\n\t\ttransaction(fn, getDebugName);\n\t} else {\n\t\tfn(tx);\n\t}\n} export class TransactionImpl implements ITransaction {\n\tprivate _updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];\n\n\tconstructor(public readonly _fn: Function, private readonly _getDebugName?: () => string) {\n\t\tgetLogger()?.handleBeginTransaction(this);\n\t}\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this._fn);\n\t}\n\n\tpublic updateObserver(observer: IObserver, observable: IObservable<any>): void {\n\t\tif (!this._updatingObservers) {\n\t\t\t// This happens when a transaction is used in a callback or async function.\n\t\t\t// If an async transaction is used, make sure the promise awaits all users of the transaction (e.g. no race).\n\t\t\thandleBugIndicatingErrorRecovery('Transaction already finished!');\n\t\t\t// Error recovery\n\t\t\ttransaction(tx => {\n\t\t\t\ttx.updateObserver(observer, observable);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// When this gets called while finish is active, they will still get considered\n\t\tthis._updatingObservers.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this._updatingObservers;\n\t\tif (!updatingObservers) {\n\t\t\thandleBugIndicatingErrorRecovery('transaction.finish() has already been called!');\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < updatingObservers.length; i++) {\n\t\t\tconst { observer, observable } = updatingObservers[i];\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis._updatingObservers = null;\n\t\tgetLogger()?.handleEndTransaction(this);\n\t}\n\n\tpublic debugGetUpdatingObservers() {\n\t\treturn this._updatingObservers;\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { handleBugIndicatingErrorRecovery, IObservable, IObserver, ITransaction } from './base.js';\nimport { getFunctionName } from './debugName.js';\nimport { getLogger } from './logging/logging.js';\n\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\n\nexport function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\nlet _globalTransaction: ITransaction | undefined = undefined;\n\nexport function globalTransaction(fn: (tx: ITransaction) => void) {\n\tif (_globalTransaction) {\n\t\tfn(_globalTransaction);\n\t} else {\n\t\tconst tx = new TransactionImpl(fn, undefined);\n\t\t_globalTransaction = tx;\n\t\ttry {\n\t\t\tfn(tx);\n\t\t} finally {\n\t\t\ttx.finish(); // During finish, more actions might be added to the transaction.\n\n\t\t\t// Which is why we only clear the global transaction after finish.\n\t\t\t_globalTransaction = undefined;\n\t\t}\n\t}\n}\n/** @deprecated */\n\nexport async function asyncTransaction(fn: (tx: ITransaction) => Promise<void>, getDebugName?: () => string): Promise<void> {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tawait fn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n/**\n * Allows to chain transactions.\n */\n\nexport function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tif (!tx) {\n\t\ttransaction(fn, getDebugName);\n\t} else {\n\t\tfn(tx);\n\t}\n} export class TransactionImpl implements ITransaction {\n\tprivate _updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];\n\n\tconstructor(public readonly _fn: Function, private readonly _getDebugName?: () => string) {\n\t\tgetLogger()?.handleBeginTransaction(this);\n\t}\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this._fn);\n\t}\n\n\tpublic updateObserver(observer: IObserver, observable: IObservable<any>): void {\n\t\tif (!this._updatingObservers) {\n\t\t\t// This happens when a transaction is used in a callback or async function.\n\t\t\t// If an async transaction is used, make sure the promise awaits all users of the transaction (e.g. no race).\n\t\t\thandleBugIndicatingErrorRecovery('Transaction already finished!');\n\t\t\t// Error recovery\n\t\t\ttransaction(tx => {\n\t\t\t\ttx.updateObserver(observer, observable);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// When this gets called while finish is active, they will still get considered\n\t\tthis._updatingObservers.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this._updatingObservers;\n\t\tif (!updatingObservers) {\n\t\t\thandleBugIndicatingErrorRecovery('transaction.finish() has already been called!');\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < updatingObservers.length; i++) {\n\t\t\tconst { observer, observable } = updatingObservers[i];\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis._updatingObservers = null;\n\t\tgetLogger()?.handleEndTransaction(this);\n\t}\n\n\tpublic debugGetUpdatingObservers() {\n\t\treturn this._updatingObservers;\n\t}\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 373, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugLocation.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/debugLocation.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/vs/base/common/observableInternal/debugLocation.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type DebugLocation = DebugLocationImpl | undefined;\n\nexport namespace DebugLocation {\n\tlet enabled = false;\n\n\texport function enable(): void {\n\t\tenabled = true;\n\t}\n\n\texport function ofCaller(): DebugLocation {\n\t\tif (!enabled) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst Err = Error as any as { stackTraceLimit: number }; // For the monaco editor checks, which don't have the nodejs types.\n\n\t\tconst l = Err.stackTraceLimit;\n\t\tErr.stackTraceLimit = 3;\n\t\tconst stack = new Error().stack!;\n\t\tErr.stackTraceLimit = l;\n\n\t\treturn DebugLocationImpl.fromStack(stack, 2);\n\t}\n}\n\nclass DebugLocationImpl implements ILocation {\n\tpublic static fromStack(stack: string, parentIdx: number): DebugLocationImpl | undefined {\n\t\tconst lines = stack.split('\\n');\n\t\tconst location = parseLine(lines[parentIdx + 1]);\n\t\tif (location) {\n\t\t\treturn new DebugLocationImpl(\n\t\t\t\tlocation.fileName,\n\t\t\t\tlocation.line,\n\t\t\t\tlocation.column,\n\t\t\t\tlocation.id\n\t\t\t);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly fileName: string,\n\t\tpublic readonly line: number,\n\t\tpublic readonly column: number,\n\t\tpublic readonly id: string,\n\t) {\n\t}\n}\n\n\nexport interface ILocation {\n\tfileName: string;\n\tline: number;\n\tcolumn: number;\n\tid: string;\n}\n\nfunction parseLine(stackLine: string): ILocation | undefined {\n\tconst match = stackLine.match(/\\((.*):(\\d+):(\\d+)\\)/);\n\tif (match) {\n\t\treturn {\n\t\t\tfileName: match[1],\n\t\t\tline: parseInt(match[2]),\n\t\t\tcolumn: parseInt(match[3]),\n\t\t\tid: stackLine,\n\t\t};\n\t}\n\n\tconst match2 = stackLine.match(/at ([^\\(\\)]*):(\\d+):(\\d+)/);\n\n\tif (match2) {\n\t\treturn {\n\t\t\tfileName: match2[1],\n\t\t\tline: parseInt(match2[2]),\n\t\t\tcolumn: parseInt(match2[3]),\n\t\t\tid: stackLine,\n\t\t};\n\t}\n\n\treturn undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type DebugLocation = DebugLocationImpl | undefined;\n\nexport namespace DebugLocation {\n\tlet enabled = false;\n\n\texport function enable(): void {\n\t\tenabled = true;\n\t}\n\n\texport function ofCaller(): DebugLocation {\n\t\tif (!enabled) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst Err = Error as any as { stackTraceLimit: number }; // For the monaco editor checks, which don't have the nodejs types.\n\n\t\tconst l = Err.stackTraceLimit;\n\t\tErr.stackTraceLimit = 3;\n\t\tconst stack = new Error().stack!;\n\t\tErr.stackTraceLimit = l;\n\n\t\treturn DebugLocationImpl.fromStack(stack, 2);\n\t}\n}\n\nclass DebugLocationImpl implements ILocation {\n\tpublic static fromStack(stack: string, parentIdx: number): DebugLocationImpl | undefined {\n\t\tconst lines = stack.split('\\n');\n\t\tconst location = parseLine(lines[parentIdx + 1]);\n\t\tif (location) {\n\t\t\treturn new DebugLocationImpl(\n\t\t\t\tlocation.fileName,\n\t\t\t\tlocation.line,\n\t\t\t\tlocation.column,\n\t\t\t\tlocation.id\n\t\t\t);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly fileName: string,\n\t\tpublic readonly line: number,\n\t\tpublic readonly column: number,\n\t\tpublic readonly id: string,\n\t) {\n\t}\n}\n\n\nexport interface ILocation {\n\tfileName: string;\n\tline: number;\n\tcolumn: number;\n\tid: string;\n}\n\nfunction parseLine(stackLine: string): ILocation | undefined {\n\tconst match = stackLine.match(/\\((.*):(\\d+):(\\d+)\\)/);\n\tif (match) {\n\t\treturn {\n\t\t\tfileName: match[1],\n\t\t\tline: parseInt(match[2]),\n\t\t\tcolumn: parseInt(match[3]),\n\t\t\tid: stackLine,\n\t\t};\n\t}\n\n\tconst match2 = stackLine.match(/at ([^\\(\\)]*):(\\d+):(\\d+)/);\n\n\tif (match2) {\n\t\treturn {\n\t\t\tfileName: match2[1],\n\t\t\tline: parseInt(match2[2]),\n\t\t\tcolumn: parseInt(match2[3]),\n\t\t\tid: stackLine,\n\t\t};\n\t}\n\n\treturn undefined;\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAI1F,IAAW,aAAa,CAoB7B;AApBD,CAAA,SAAiB,aAAa;IAC7B,IAAI,OAAO,GAAG,KAAK,CAAC;IAEpB,SAAgB,MAAM;QACrB,OAAO,GAAG,IAAI,CAAC;IAChB,CAAC;IAFe,cAAA,MAAM,GAAA,MAErB,CAAA;IAED,SAAgB,QAAQ;QACvB,IAAI,CAAC,OAAO,EAAE,CAAC;YACd,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,MAAM,GAAG,GAAG,KAA2C,CAAC,CAAC,mEAAmE;QAE5H,MAAM,CAAC,GAAG,GAAG,CAAC,eAAe,CAAC;QAC9B,GAAG,CAAC,eAAe,GAAG,CAAC,CAAC;QACxB,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC,KAAM,CAAC;QACjC,GAAG,CAAC,eAAe,GAAG,CAAC,CAAC;QAExB,OAAO,iBAAiB,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IAC9C,CAAC;IAZe,cAAA,QAAQ,GAAA,QAYvB,CAAA;AACF,CAAC,EApBgB,aAAa,IAAA,CAAb,aAAa,GAAA,CAAA,CAAA,GAoB7B;AAED,MAAM,iBAAiB;IACf,MAAM,CAAC,SAAS,CAAC,KAAa,EAAE,SAAiB,EAAA;QACvD,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAChC,MAAM,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;QACjD,IAAI,QAAQ,EAAE,CAAC;YACd,OAAO,IAAI,iBAAiB,CAC3B,QAAQ,CAAC,QAAQ,EACjB,QAAQ,CAAC,IAAI,EACb,QAAQ,CAAC,MAAM,EACf,QAAQ,CAAC,EAAE,CACX,CAAC;QACH,CAAC,MAAM,CAAC;YACP,OAAO,SAAS,CAAC;QAClB,CAAC;IACF,CAAC;IAED,YACiB,QAAgB,EAChB,IAAY,EACZ,MAAc,EACd,EAAU,CAAA;QAHV,IAAA,CAAA,QAAQ,GAAR,QAAQ,CAAQ;QAChB,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAQ;QACZ,IAAA,CAAA,MAAM,GAAN,MAAM,CAAQ;QACd,IAAA,CAAA,EAAE,GAAF,EAAE,CAAQ;IAE3B,CAAC;CACD;AAUD,SAAS,SAAS,CAAC,SAAiB;IACnC,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,sBAAsB,CAAC,CAAC;IACtD,IAAI,KAAK,EAAE,CAAC;QACX,OAAO;YACN,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;YAClB,IAAI,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACxB,MAAM,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1B,EAAE,EAAE,SAAS;SACb,CAAC;IACH,CAAC;IAED,MAAM,MAAM,GAAG,SAAS,CAAC,KAAK,CAAC,2BAA2B,CAAC,CAAC;IAE5D,IAAI,MAAM,EAAE,CAAC;QACZ,OAAO;YACN,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC;YACnB,IAAI,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC3B,EAAE,EAAE,SAAS;SACb,CAAC;IACH,CAAC;IAED,OAAO,SAAS,CAAC;AAClB,CAAC","debugId":null}},
    {"offset": {"line": 442, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/baseObservable.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/baseObservable.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/baseObservable.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange, IObserver, IReader, IObservable } from '../base.js';\nimport { DisposableStore } from '../commonFacade/deps.js';\nimport { DebugLocation } from '../debugLocation.js';\nimport { DebugOwner, getFunctionName } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { keepObserved, recomputeInitiallyAndOnChange } from '../utils/utils.js';\nimport { derivedOpts } from './derived.js';\n\nlet _derived: typeof derivedOpts;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nlet _recomputeInitiallyAndOnChange: typeof recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange: typeof _recomputeInitiallyAndOnChange) {\n\t_recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\n\nlet _keepObserved: typeof keepObserved;\nexport function _setKeepObserved(keepObserved: typeof _keepObserved) {\n\t_keepObserved = keepObserved;\n}\n\nexport abstract class ConvenientObservable<T, TChange> implements IObservableWithChange<T, TChange> {\n\tget TChange(): TChange { return null!; }\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(owner: DebugOwner, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(fnOrOwner: DebugOwner | ((value: T, reader: IReader) => TNew), fnOrUndefined?: (value: T, reader: IReader) => TNew, debugLocation: DebugLocation = DebugLocation.ofCaller()): IObservable<TNew> {\n\t\tconst owner = fnOrUndefined === undefined ? undefined : fnOrOwner as DebugOwner;\n\t\tconst fn = fnOrUndefined === undefined ? fnOrOwner as (value: T, reader: IReader) => TNew : fnOrUndefined;\n\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner,\n\t\t\t\tdebugName: () => {\n\t\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\t\tif (name !== undefined) {\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n\t\t\t\t\tconst regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n\t\t\t\t\tconst match = regexp.exec(fn.toString());\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn `${this.debugName}.${match[2]}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!owner) {\n\t\t\t\t\t\treturn `${this.debugName} (mapped)`;\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tdebugReferenceFn: fn,\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader),\n\t\t\tdebugLocation,\n\t\t);\n\t}\n\n\t/**\n\t * @sealed\n\t * Converts an observable of an observable value into a direct observable of the value.\n\t*/\n\tpublic flatten<TNew>(this: IObservable<IObservableWithChange<TNew, any>>): IObservable<TNew> {\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner: undefined,\n\t\t\t\tdebugName: () => `${this.debugName} (flattened)`,\n\t\t\t},\n\t\t\t(reader) => this.read(reader).read(reader)\n\t\t);\n\t}\n\n\tpublic recomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T> {\n\t\tstore.add(_recomputeInitiallyAndOnChange!(this, handleValue));\n\t\treturn this;\n\t}\n\n\tpublic abstract get debugName(): string;\n}\n\nexport abstract class BaseObservable<T, TChange = void> extends ConvenientObservable<T, TChange> {\n\tprotected readonly _observers = new Set<IObserver>();\n\n\tconstructor(debugLocation: DebugLocation) {\n\t\tsuper();\n\t\tgetLogger()?.handleObservableCreated(this, debugLocation);\n\t}\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this._observers.size;\n\t\tthis._observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t\tif (len !== this._observers.size) {\n\t\t\tgetLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this._observers.delete(observer);\n\t\tif (deleted && this._observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t\tif (deleted) {\n\t\t\tgetLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void { }\n\tprotected onLastObserverRemoved(): void { }\n\n\tpublic debugGetObservers() {\n\t\treturn this._observers;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange, IObserver, IReader, IObservable } from '../base.js';\nimport { DisposableStore } from '../commonFacade/deps.js';\nimport { DebugLocation } from '../debugLocation.js';\nimport { DebugOwner, getFunctionName } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { keepObserved, recomputeInitiallyAndOnChange } from '../utils/utils.js';\nimport { derivedOpts } from './derived.js';\n\nlet _derived: typeof derivedOpts;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nlet _recomputeInitiallyAndOnChange: typeof recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange: typeof _recomputeInitiallyAndOnChange) {\n\t_recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\n\nlet _keepObserved: typeof keepObserved;\nexport function _setKeepObserved(keepObserved: typeof _keepObserved) {\n\t_keepObserved = keepObserved;\n}\n\nexport abstract class ConvenientObservable<T, TChange> implements IObservableWithChange<T, TChange> {\n\tget TChange(): TChange { return null!; }\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(owner: DebugOwner, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(fnOrOwner: DebugOwner | ((value: T, reader: IReader) => TNew), fnOrUndefined?: (value: T, reader: IReader) => TNew, debugLocation: DebugLocation = DebugLocation.ofCaller()): IObservable<TNew> {\n\t\tconst owner = fnOrUndefined === undefined ? undefined : fnOrOwner as DebugOwner;\n\t\tconst fn = fnOrUndefined === undefined ? fnOrOwner as (value: T, reader: IReader) => TNew : fnOrUndefined;\n\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner,\n\t\t\t\tdebugName: () => {\n\t\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\t\tif (name !== undefined) {\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n\t\t\t\t\tconst regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n\t\t\t\t\tconst match = regexp.exec(fn.toString());\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn `${this.debugName}.${match[2]}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!owner) {\n\t\t\t\t\t\treturn `${this.debugName} (mapped)`;\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tdebugReferenceFn: fn,\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader),\n\t\t\tdebugLocation,\n\t\t);\n\t}\n\n\t/**\n\t * @sealed\n\t * Converts an observable of an observable value into a direct observable of the value.\n\t*/\n\tpublic flatten<TNew>(this: IObservable<IObservableWithChange<TNew, any>>): IObservable<TNew> {\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner: undefined,\n\t\t\t\tdebugName: () => `${this.debugName} (flattened)`,\n\t\t\t},\n\t\t\t(reader) => this.read(reader).read(reader)\n\t\t);\n\t}\n\n\tpublic recomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T> {\n\t\tstore.add(_recomputeInitiallyAndOnChange!(this, handleValue));\n\t\treturn this;\n\t}\n\n\tpublic abstract get debugName(): string;\n}\n\nexport abstract class BaseObservable<T, TChange = void> extends ConvenientObservable<T, TChange> {\n\tprotected readonly _observers = new Set<IObserver>();\n\n\tconstructor(debugLocation: DebugLocation) {\n\t\tsuper();\n\t\tgetLogger()?.handleObservableCreated(this, debugLocation);\n\t}\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this._observers.size;\n\t\tthis._observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t\tif (len !== this._observers.size) {\n\t\t\tgetLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this._observers.delete(observer);\n\t\tif (deleted && this._observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t\tif (deleted) {\n\t\t\tgetLogger()?.handleOnListenerCountChanged(this, this._observers.size);\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void { }\n\tprotected onLastObserverRemoved(): void { }\n\n\tpublic debugGetObservers() {\n\t\treturn this._observers;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 562, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableValue.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/observableValue.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/observableValue.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ISettableObservable, ITransaction } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { EqualityComparer, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n * @template TChange An arbitrary type to describe how or why the value changed. Defaults to `void`.\n * Observers will receive every single change value.\n */\n\nexport function observableValue<T, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(owner: object, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(nameOrOwner: string | object, initialValue: T, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T, TChange> {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new ObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._value = initialValue;\n\n\t\tgetLogger()?.handleObservableUpdated(this, { hadValue: false, newValue: initialValue, change: undefined, didChange: true, oldValue: undefined });\n\t}\n\tpublic override get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (change === undefined && this._equalityComparator(this._value, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableUpdated(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tvalue: this._value,\n\t\t};\n\t}\n\n\tpublic debugSetValue(value: unknown) {\n\t\tthis._value = value as T;\n\t}\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\n\nexport function disposableObservableValue<T extends IDisposable | undefined, TChange = void>(nameOrOwner: string | object, initialValue: T, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T, TChange> & IDisposable {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new DisposableObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\n\nexport class DisposableObservableValue<T extends IDisposable | undefined, TChange = void> extends ObservableValue<T, TChange> implements IDisposable {\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ISettableObservable, ITransaction } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { EqualityComparer, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n * @template TChange An arbitrary type to describe how or why the value changed. Defaults to `void`.\n * Observers will receive every single change value.\n */\n\nexport function observableValue<T, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(owner: object, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(nameOrOwner: string | object, initialValue: T, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T, TChange> {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new ObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._value = initialValue;\n\n\t\tgetLogger()?.handleObservableUpdated(this, { hadValue: false, newValue: initialValue, change: undefined, didChange: true, oldValue: undefined });\n\t}\n\tpublic override get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (change === undefined && this._equalityComparator(this._value, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableUpdated(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tvalue: this._value,\n\t\t};\n\t}\n\n\tpublic debugSetValue(value: unknown) {\n\t\tthis._value = value as T;\n\t}\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\n\nexport function disposableObservableValue<T extends IDisposable | undefined, TChange = void>(nameOrOwner: string | object, initialValue: T, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T, TChange> & IDisposable {\n\tlet debugNameData: DebugNameData;\n\tif (typeof nameOrOwner === 'string') {\n\t\tdebugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n\t} else {\n\t\tdebugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n\t}\n\treturn new DisposableObservableValue(debugNameData, initialValue, strictEquals, debugLocation);\n}\n\nexport class DisposableObservableValue<T extends IDisposable | undefined, TChange = void> extends ObservableValue<T, TChange> implements IDisposable {\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 687, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/lazyObservableValue.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/lazyObservableValue.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/lazyObservableValue.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { EqualityComparer } from '../commonFacade/deps.js';\nimport { IObserver, ISettableObservable, ITransaction } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Holds off updating observers until the value is actually read.\n*/\nexport class LazyObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\tprivate _isUpToDate = true;\n\tprivate readonly _deltas: TChange[] = [];\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._value = initialValue;\n\t}\n\n\tpublic override get(): T {\n\t\tthis._update();\n\t\treturn this._value;\n\t}\n\n\tprivate _update(): void {\n\t\tif (this._isUpToDate) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isUpToDate = true;\n\n\t\tif (this._deltas.length > 0) {\n\t\t\tfor (const change of this._deltas) {\n\t\t\t\tgetLogger()?.handleObservableUpdated(this, { change, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n\t\t\t\tfor (const observer of this._observers) {\n\t\t\t\t\tobserver.handleChange(this, change);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._deltas.length = 0;\n\t\t} else {\n\t\t\tgetLogger()?.handleObservableUpdated(this, { change: undefined, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\tobserver.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _updateCounter = 0;\n\n\tprivate _beginUpdate(): void {\n\t\tthis._updateCounter++;\n\t\tif (this._updateCounter === 1) {\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _endUpdate(): void {\n\t\tthis._updateCounter--;\n\t\tif (this._updateCounter === 0) {\n\t\t\tthis._update();\n\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this._observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCounter > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate = this._observers.has(observer) && this._updateCounter > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (change === undefined && this._equalityComparator(this._value, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tthis._isUpToDate = false;\n\t\t\tthis._setValue(value);\n\t\t\tif (change !== undefined) {\n\t\t\t\tthis._deltas.push(change);\n\t\t\t}\n\n\t\t\ttx.updateObserver({\n\t\t\t\tbeginUpdate: () => this._beginUpdate(),\n\t\t\t\tendUpdate: () => this._endUpdate(),\n\t\t\t\thandleChange: (observable, change) => { },\n\t\t\t\thandlePossibleChange: (observable) => { },\n\t\t\t}, this);\n\n\t\t\tif (this._updateCounter > 1) {\n\t\t\t\t// We already started begin/end update, so we need to manually call handlePossibleChange\n\t\t\t\tfor (const observer of this._observers) {\n\t\t\t\t\tobserver.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { EqualityComparer } from '../commonFacade/deps.js';\nimport { IObserver, ISettableObservable, ITransaction } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Holds off updating observers until the value is actually read.\n*/\nexport class LazyObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\tprivate _isUpToDate = true;\n\tprivate readonly _deltas: TChange[] = [];\n\n\tget debugName() {\n\t\treturn this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tinitialValue: T,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._value = initialValue;\n\t}\n\n\tpublic override get(): T {\n\t\tthis._update();\n\t\treturn this._value;\n\t}\n\n\tprivate _update(): void {\n\t\tif (this._isUpToDate) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isUpToDate = true;\n\n\t\tif (this._deltas.length > 0) {\n\t\t\tfor (const change of this._deltas) {\n\t\t\t\tgetLogger()?.handleObservableUpdated(this, { change, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n\t\t\t\tfor (const observer of this._observers) {\n\t\t\t\t\tobserver.handleChange(this, change);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._deltas.length = 0;\n\t\t} else {\n\t\t\tgetLogger()?.handleObservableUpdated(this, { change: undefined, didChange: true, oldValue: '(unknown)', newValue: this._value, hadValue: true });\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\tobserver.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _updateCounter = 0;\n\n\tprivate _beginUpdate(): void {\n\t\tthis._updateCounter++;\n\t\tif (this._updateCounter === 1) {\n\t\t\tfor (const observer of this._observers) {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _endUpdate(): void {\n\t\tthis._updateCounter--;\n\t\tif (this._updateCounter === 0) {\n\t\t\tthis._update();\n\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this._observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCounter > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate = this._observers.has(observer) && this._updateCounter > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (change === undefined && this._equalityComparator(this._value, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tthis._isUpToDate = false;\n\t\t\tthis._setValue(value);\n\t\t\tif (change !== undefined) {\n\t\t\t\tthis._deltas.push(change);\n\t\t\t}\n\n\t\t\ttx.updateObserver({\n\t\t\t\tbeginUpdate: () => this._beginUpdate(),\n\t\t\t\tendUpdate: () => this._endUpdate(),\n\t\t\t\thandleChange: (observable, change) => { },\n\t\t\t\thandlePossibleChange: (observable) => { },\n\t\t\t}, this);\n\n\t\t\tif (this._updateCounter > 1) {\n\t\t\t\t// We already started begin/end update, so we need to manually call handlePossibleChange\n\t\t\t\tfor (const observer of this._observers) {\n\t\t\t\t\tobserver.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 828, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableValueOpts.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/observableValueOpts.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/observableValueOpts.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ISettableObservable } from '../base.js';\nimport { DebugNameData, IDebugNameData } from '../debugName.js';\nimport { EqualityComparer, strictEquals } from '../commonFacade/deps.js';\nimport { ObservableValue } from './observableValue.js';\nimport { LazyObservableValue } from './lazyObservableValue.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport function observableValueOpts<T, TChange = void>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tlazy?: boolean;\n\t},\n\tinitialValue: T,\n\tdebugLocation = DebugLocation.ofCaller(),\n): ISettableObservable<T, TChange> {\n\tif (options.lazy) {\n\t\treturn new LazyObservableValue(\n\t\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\t\tinitialValue,\n\t\t\toptions.equalsFn ?? strictEquals,\n\t\t\tdebugLocation\n\t\t);\n\t}\n\treturn new ObservableValue(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tinitialValue,\n\t\toptions.equalsFn ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ISettableObservable } from '../base.js';\nimport { DebugNameData, IDebugNameData } from '../debugName.js';\nimport { EqualityComparer, strictEquals } from '../commonFacade/deps.js';\nimport { ObservableValue } from './observableValue.js';\nimport { LazyObservableValue } from './lazyObservableValue.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport function observableValueOpts<T, TChange = void>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tlazy?: boolean;\n\t},\n\tinitialValue: T,\n\tdebugLocation = DebugLocation.ofCaller(),\n): ISettableObservable<T, TChange> {\n\tif (options.lazy) {\n\t\treturn new LazyObservableValue(\n\t\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\t\tinitialValue,\n\t\t\toptions.equalsFn ?? strictEquals,\n\t\t\tdebugLocation\n\t\t);\n\t}\n\treturn new ObservableValue(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tinitialValue,\n\t\toptions.equalsFn ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAGhG,OAAO,EAAE,aAAa,EAAkB,MAAM,iBAAiB,CAAC;;AAChE,OAAO,EAAoB,YAAY,EAAE,MAAM,yBAAyB,CAAC;AACzE,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAC;AACvD,OAAO,EAAE,mBAAmB,EAAE,MAAM,0BAA0B,CAAC;AAC/D,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;;;;;;AAE9C,SAAU,mBAAmB,CAClC,OAGC,EACD,YAAe,EACf,aAAa,GAAG,uNAAa,CAAC,QAAQ,EAAE;IAExC,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;QAClB,OAAO,IAAI,kPAAmB,CAC7B,IAAI,mNAAa,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,SAAS,EAAE,SAAS,CAAC,EAC9D,YAAY,EACZ,OAAO,CAAC,QAAQ,IAAI,yLAAY,EAChC,aAAa,CACb,CAAC;IACH,CAAC;IACD,OAAO,IAAI,0OAAe,CACzB,IAAI,mNAAa,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,SAAS,EAAE,SAAS,CAAC,EAC9D,YAAY,EACZ,OAAO,CAAC,QAAQ,IAAI,yLAAY,EAChC,aAAa,CACb,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 856, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/reactions/autorunImpl.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/reactions/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/reactions/autorunImpl.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/reactions/vs/base/common/observableInternal/reactions/autorunImpl.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IObservableWithChange, IObserver, IReaderWithStore } from '../base.js';\nimport { DebugNameData } from '../debugName.js';\nimport { assertFn, BugIndicatingError, DisposableStore, IDisposable, markAsDisposed, onBugIndicatingError, trackDisposable } from '../commonFacade/deps.js';\nimport { getLogger } from '../logging/logging.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport const enum AutorunState {\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t */\n\tstale = 2,\n\tupToDate = 3,\n}\n\nexport class AutorunObserver<TChangeSummary = any> implements IObserver, IReaderWithStore, IDisposable {\n\tprivate _state = AutorunState.stale;\n\tprivate _updateCount = 0;\n\tprivate _disposed = false;\n\tprivate _dependencies = new Set<IObservable<any>>();\n\tprivate _dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate _changeSummary: TChangeSummary | undefined;\n\tprivate _isRunning = false;\n\n\tpublic get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _runFn: (reader: IReaderWithStore, changeSummary: TChangeSummary) => void,\n\t\tprivate readonly _changeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(undefined);\n\t\tgetLogger()?.handleAutorunCreated(this, debugLocation);\n\t\tthis._run();\n\n\t\ttrackDisposable(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._disposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposed = true;\n\t\tfor (const o of this._dependencies) {\n\t\t\to.removeObserver(this); // Warning: external call!\n\t\t}\n\t\tthis._dependencies.clear();\n\n\t\tif (this._store !== undefined) {\n\t\t\tthis._store.dispose();\n\t\t}\n\t\tif (this._delayedStore !== undefined) {\n\t\t\tthis._delayedStore.dispose();\n\t\t}\n\n\t\tgetLogger()?.handleAutorunDisposed(this);\n\t\tmarkAsDisposed(this);\n\t}\n\n\tprivate _run() {\n\t\tconst emptySet = this._dependenciesToBeRemoved;\n\t\tthis._dependenciesToBeRemoved = this._dependencies;\n\t\tthis._dependencies = emptySet;\n\n\t\tthis._state = AutorunState.upToDate;\n\n\t\ttry {\n\t\t\tif (!this._disposed) {\n\t\t\t\tgetLogger()?.handleAutorunStarted(this);\n\t\t\t\tconst changeSummary = this._changeSummary!;\n\t\t\t\tconst delayedStore = this._delayedStore;\n\t\t\t\tif (delayedStore !== undefined) {\n\t\t\t\t\tthis._delayedStore = undefined;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tthis._isRunning = true;\n\t\t\t\t\tif (this._changeTracker) {\n\t\t\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\t\t\tthis._changeSummary = this._changeTracker.createChangeSummary(changeSummary); // Warning: external call!\n\t\t\t\t\t}\n\t\t\t\t\tif (this._store !== undefined) {\n\t\t\t\t\t\tthis._store.dispose();\n\t\t\t\t\t\tthis._store = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._runFn(this, changeSummary); // Warning: external call!\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonBugIndicatingError(e);\n\t\t\t\t} finally {\n\t\t\t\t\tthis._isRunning = false;\n\t\t\t\t\tif (delayedStore !== undefined) {\n\t\t\t\t\t\tdelayedStore.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!this._disposed) {\n\t\t\t\tgetLogger()?.handleAutorunFinished(this);\n\t\t\t}\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this._dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this); // Warning: external call!\n\t\t\t}\n\t\t\tthis._dependenciesToBeRemoved.clear();\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Autorun<${this.debugName}>`;\n\t}\n\n\t// IObserver implementation\n\tpublic beginUpdate(_observable: IObservable<any>): void {\n\t\tif (this._state === AutorunState.upToDate) {\n\t\t\tthis._state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t\tthis._updateCount++;\n\t}\n\n\tpublic endUpdate(_observable: IObservable<any>): void {\n\t\ttry {\n\t\t\tif (this._updateCount === 1) {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AutorunState.dependenciesMightHaveChanged) {\n\t\t\t\t\t\tthis._state = AutorunState.upToDate;\n\t\t\t\t\t\tfor (const d of this._dependencies) {\n\t\t\t\t\t\t\td.reportChanges(); // Warning: external call!\n\t\t\t\t\t\t\tif (this._state as AutorunState === AutorunState.stale) {\n\t\t\t\t\t\t\t\t// The other dependencies will refresh on demand\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._state !== AutorunState.upToDate) {\n\t\t\t\t\t\tthis._run(); // Warning: indirect external call!\n\t\t\t\t\t}\n\t\t\t\t} while (this._state !== AutorunState.upToDate);\n\t\t\t}\n\t\t} finally {\n\t\t\tthis._updateCount--;\n\t\t}\n\n\t\tassertFn(() => this._updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange(observable: IObservable<any>): void {\n\t\tif (this._state === AutorunState.upToDate && this._isDependency(observable)) {\n\t\t\tthis._state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tif (this._isDependency(observable)) {\n\t\t\tgetLogger()?.handleAutorunDependencyChanged(this, observable, change);\n\t\t\ttry {\n\t\t\t\t// Warning: external call!\n\t\t\t\tconst shouldReact = this._changeTracker ? this._changeTracker.handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this._changeSummary!) : true;\n\t\t\t\tif (shouldReact) {\n\t\t\t\t\tthis._state = AutorunState.stale;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _isDependency(observable: IObservableWithChange<any, any>): boolean {\n\t\treturn this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable);\n\t}\n\n\t// IReader implementation\n\n\tprivate _ensureNoRunning(): void {\n\t\tif (!this._isRunning) { throw new BugIndicatingError('The reader object cannot be used outside its compute function!'); }\n\t}\n\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\tthis._ensureNoRunning();\n\n\t\t// In case the run action disposes the autorun\n\t\tif (this._disposed) {\n\t\t\treturn observable.get(); // warning: external call!\n\t\t}\n\n\t\tobservable.addObserver(this); // warning: external call!\n\t\tconst value = observable.get(); // warning: external call!\n\t\tthis._dependencies.add(observable);\n\t\tthis._dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tprivate _store: DisposableStore | undefined = undefined;\n\tget store(): DisposableStore {\n\t\tthis._ensureNoRunning();\n\t\tif (this._disposed) {\n\t\t\tthrow new BugIndicatingError('Cannot access store after dispose');\n\t\t}\n\n\t\tif (this._store === undefined) {\n\t\t\tthis._store = new DisposableStore();\n\t\t}\n\t\treturn this._store;\n\t}\n\n\tprivate _delayedStore: DisposableStore | undefined = undefined;\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tisRunning: this._isRunning,\n\t\t\tupdateCount: this._updateCount,\n\t\t\tdependencies: this._dependencies,\n\t\t\tstate: this._state,\n\t\t};\n\t}\n\n\tpublic debugRerun(): void {\n\t\tif (!this._isRunning) {\n\t\t\tthis._run();\n\t\t} else {\n\t\t\tthis._state = AutorunState.stale;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IObservableWithChange, IObserver, IReaderWithStore } from '../base.js';\nimport { DebugNameData } from '../debugName.js';\nimport { assertFn, BugIndicatingError, DisposableStore, IDisposable, markAsDisposed, onBugIndicatingError, trackDisposable } from '../commonFacade/deps.js';\nimport { getLogger } from '../logging/logging.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport const enum AutorunState {\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t */\n\tstale = 2,\n\tupToDate = 3,\n}\n\nexport class AutorunObserver<TChangeSummary = any> implements IObserver, IReaderWithStore, IDisposable {\n\tprivate _state = AutorunState.stale;\n\tprivate _updateCount = 0;\n\tprivate _disposed = false;\n\tprivate _dependencies = new Set<IObservable<any>>();\n\tprivate _dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate _changeSummary: TChangeSummary | undefined;\n\tprivate _isRunning = false;\n\n\tpublic get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _runFn: (reader: IReaderWithStore, changeSummary: TChangeSummary) => void,\n\t\tprivate readonly _changeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(undefined);\n\t\tgetLogger()?.handleAutorunCreated(this, debugLocation);\n\t\tthis._run();\n\n\t\ttrackDisposable(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._disposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposed = true;\n\t\tfor (const o of this._dependencies) {\n\t\t\to.removeObserver(this); // Warning: external call!\n\t\t}\n\t\tthis._dependencies.clear();\n\n\t\tif (this._store !== undefined) {\n\t\t\tthis._store.dispose();\n\t\t}\n\t\tif (this._delayedStore !== undefined) {\n\t\t\tthis._delayedStore.dispose();\n\t\t}\n\n\t\tgetLogger()?.handleAutorunDisposed(this);\n\t\tmarkAsDisposed(this);\n\t}\n\n\tprivate _run() {\n\t\tconst emptySet = this._dependenciesToBeRemoved;\n\t\tthis._dependenciesToBeRemoved = this._dependencies;\n\t\tthis._dependencies = emptySet;\n\n\t\tthis._state = AutorunState.upToDate;\n\n\t\ttry {\n\t\t\tif (!this._disposed) {\n\t\t\t\tgetLogger()?.handleAutorunStarted(this);\n\t\t\t\tconst changeSummary = this._changeSummary!;\n\t\t\t\tconst delayedStore = this._delayedStore;\n\t\t\t\tif (delayedStore !== undefined) {\n\t\t\t\t\tthis._delayedStore = undefined;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tthis._isRunning = true;\n\t\t\t\t\tif (this._changeTracker) {\n\t\t\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\t\t\tthis._changeSummary = this._changeTracker.createChangeSummary(changeSummary); // Warning: external call!\n\t\t\t\t\t}\n\t\t\t\t\tif (this._store !== undefined) {\n\t\t\t\t\t\tthis._store.dispose();\n\t\t\t\t\t\tthis._store = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._runFn(this, changeSummary); // Warning: external call!\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonBugIndicatingError(e);\n\t\t\t\t} finally {\n\t\t\t\t\tthis._isRunning = false;\n\t\t\t\t\tif (delayedStore !== undefined) {\n\t\t\t\t\t\tdelayedStore.dispose();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!this._disposed) {\n\t\t\t\tgetLogger()?.handleAutorunFinished(this);\n\t\t\t}\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this._dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this); // Warning: external call!\n\t\t\t}\n\t\t\tthis._dependenciesToBeRemoved.clear();\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Autorun<${this.debugName}>`;\n\t}\n\n\t// IObserver implementation\n\tpublic beginUpdate(_observable: IObservable<any>): void {\n\t\tif (this._state === AutorunState.upToDate) {\n\t\t\tthis._state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t\tthis._updateCount++;\n\t}\n\n\tpublic endUpdate(_observable: IObservable<any>): void {\n\t\ttry {\n\t\t\tif (this._updateCount === 1) {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AutorunState.dependenciesMightHaveChanged) {\n\t\t\t\t\t\tthis._state = AutorunState.upToDate;\n\t\t\t\t\t\tfor (const d of this._dependencies) {\n\t\t\t\t\t\t\td.reportChanges(); // Warning: external call!\n\t\t\t\t\t\t\tif (this._state as AutorunState === AutorunState.stale) {\n\t\t\t\t\t\t\t\t// The other dependencies will refresh on demand\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._state !== AutorunState.upToDate) {\n\t\t\t\t\t\tthis._run(); // Warning: indirect external call!\n\t\t\t\t\t}\n\t\t\t\t} while (this._state !== AutorunState.upToDate);\n\t\t\t}\n\t\t} finally {\n\t\t\tthis._updateCount--;\n\t\t}\n\n\t\tassertFn(() => this._updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange(observable: IObservable<any>): void {\n\t\tif (this._state === AutorunState.upToDate && this._isDependency(observable)) {\n\t\t\tthis._state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tif (this._isDependency(observable)) {\n\t\t\tgetLogger()?.handleAutorunDependencyChanged(this, observable, change);\n\t\t\ttry {\n\t\t\t\t// Warning: external call!\n\t\t\t\tconst shouldReact = this._changeTracker ? this._changeTracker.handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this._changeSummary!) : true;\n\t\t\t\tif (shouldReact) {\n\t\t\t\t\tthis._state = AutorunState.stale;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _isDependency(observable: IObservableWithChange<any, any>): boolean {\n\t\treturn this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable);\n\t}\n\n\t// IReader implementation\n\n\tprivate _ensureNoRunning(): void {\n\t\tif (!this._isRunning) { throw new BugIndicatingError('The reader object cannot be used outside its compute function!'); }\n\t}\n\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\tthis._ensureNoRunning();\n\n\t\t// In case the run action disposes the autorun\n\t\tif (this._disposed) {\n\t\t\treturn observable.get(); // warning: external call!\n\t\t}\n\n\t\tobservable.addObserver(this); // warning: external call!\n\t\tconst value = observable.get(); // warning: external call!\n\t\tthis._dependencies.add(observable);\n\t\tthis._dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tprivate _store: DisposableStore | undefined = undefined;\n\tget store(): DisposableStore {\n\t\tthis._ensureNoRunning();\n\t\tif (this._disposed) {\n\t\t\tthrow new BugIndicatingError('Cannot access store after dispose');\n\t\t}\n\n\t\tif (this._store === undefined) {\n\t\t\tthis._store = new DisposableStore();\n\t\t}\n\t\treturn this._store;\n\t}\n\n\tprivate _delayedStore: DisposableStore | undefined = undefined;\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tisRunning: this._isRunning,\n\t\t\tupdateCount: this._updateCount,\n\t\t\tdependencies: this._dependencies,\n\t\t\tstate: this._state,\n\t\t};\n\t}\n\n\tpublic debugRerun(): void {\n\t\tif (!this._isRunning) {\n\t\t\tthis._run();\n\t\t} else {\n\t\t\tthis._state = AutorunState.stale;\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1061, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/reactions/autorun.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/reactions/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/reactions/autorun.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/reactions/vs/base/common/observableInternal/reactions/autorun.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IReaderWithStore, IReader, IObservable } from '../base.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DisposableStore, IDisposable, toDisposable } from '../commonFacade/deps.js';\nimport { DebugNameData, IDebugNameData } from '../debugName.js';\nimport { AutorunObserver } from './autorunImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn: (reader: IReaderWithStore) => void, debugLocation = DebugLocation.ofCaller()): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(undefined, undefined, fn),\n\t\tfn,\n\t\tundefined,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options: IDebugNameData & {}, fn: (reader: IReaderWithStore) => void, debugLocation = DebugLocation.ofCaller()): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\tundefined,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `changeTracker.createChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `changeTracker.handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void,\n\tdebugLocation = DebugLocation.ofCaller()\n): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\toptions.changeTracker,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\t{\n\t\t\towner: options.owner,\n\t\t\tdebugName: options.debugName,\n\t\t\tdebugReferenceFn: options.debugReferenceFn ?? fn,\n\t\t\tchangeTracker: options.changeTracker,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n *\n * @deprecated Use `autorun(reader => { reader.store.add(...) })` instead!\n */\nexport function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunOpts(\n\t\t{\n\t\t\towner: undefined,\n\t\t\tdebugName: undefined,\n\t\t\tdebugReferenceFn: fn,\n\t\t},\n\t\treader => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nexport function autorunDelta<T>(\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorunOpts({ debugReferenceFn: handler }, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IReaderWithStore, IReader, IObservable } from '../base.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DisposableStore, IDisposable, toDisposable } from '../commonFacade/deps.js';\nimport { DebugNameData, IDebugNameData } from '../debugName.js';\nimport { AutorunObserver } from './autorunImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn: (reader: IReaderWithStore) => void, debugLocation = DebugLocation.ofCaller()): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(undefined, undefined, fn),\n\t\tfn,\n\t\tundefined,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options: IDebugNameData & {}, fn: (reader: IReaderWithStore) => void, debugLocation = DebugLocation.ofCaller()): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\tundefined,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `changeTracker.createChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `changeTracker.handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void,\n\tdebugLocation = DebugLocation.ofCaller()\n): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\toptions.changeTracker,\n\t\tdebugLocation\n\t);\n}\n\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\t{\n\t\t\towner: options.owner,\n\t\t\tdebugName: options.debugName,\n\t\t\tdebugReferenceFn: options.debugReferenceFn ?? fn,\n\t\t\tchangeTracker: options.changeTracker,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n *\n * @deprecated Use `autorun(reader => { reader.store.add(...) })` instead!\n */\nexport function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunOpts(\n\t\t{\n\t\t\towner: undefined,\n\t\t\tdebugName: undefined,\n\t\t\tdebugReferenceFn: fn,\n\t\t},\n\t\treader => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nexport function autorunDelta<T>(\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorunOpts({ debugReferenceFn: handler }, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1145, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/derivedImpl.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/derivedImpl.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/derivedImpl.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IObservableWithChange, IObserver, IReaderWithStore, ISettableObservable, ITransaction } from '../base.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BugIndicatingError, DisposableStore, EqualityComparer, assertFn, onBugIndicatingError } from '../commonFacade/deps.js';\nimport { getLogger } from '../logging/logging.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport interface IDerivedReader<TChange = void> extends IReaderWithStore {\n}\n\nexport const enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any, TChange = void> extends BaseObservable<T, TChange> implements IDerivedReader<TChange>, IObserver {\n\tprivate _state = DerivedState.initial;\n\tprivate _value: T | undefined = undefined;\n\tprivate _updateCount = 0;\n\tprivate _dependencies = new Set<IObservable<any>>();\n\tprivate _dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate _changeSummary: TChangeSummary | undefined = undefined;\n\tprivate _isUpdating = false;\n\tprivate _isComputing = false;\n\tprivate _didReportChange = false;\n\tprivate _isInBeforeUpdate = false;\n\tprivate _isReaderValid = false;\n\tprivate _store: DisposableStore | undefined = undefined;\n\tprivate _delayedStore: DisposableStore | undefined = undefined;\n\tprivate _removedObserverToCallEndUpdateOn: Set<IObserver> | null = null;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (reader: IDerivedReader<TChange>, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly _changeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation,\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(undefined);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis._state = DerivedState.initial;\n\t\tthis._value = undefined;\n\t\tgetLogger()?.handleDerivedCleared(this);\n\t\tfor (const d of this._dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis._dependencies.clear();\n\n\t\tif (this._store !== undefined) {\n\t\t\tthis._store.dispose();\n\t\t\tthis._store = undefined;\n\t\t}\n\t\tif (this._delayedStore !== undefined) {\n\t\t\tthis._delayedStore.dispose();\n\t\t\tthis._delayedStore = undefined;\n\t\t}\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tconst checkEnabled = false; // TODO set to true\n\t\tif (this._isComputing && checkEnabled) {\n\t\t\t// investigate why this fails in the diff editor!\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tif (this._observers.size === 0) {\n\t\t\tlet result;\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\ttry {\n\t\t\t\tthis._isReaderValid = true;\n\t\t\t\tlet changeSummary = undefined;\n\t\t\t\tif (this._changeTracker) {\n\t\t\t\t\tchangeSummary = this._changeTracker.createChangeSummary(undefined);\n\t\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\t}\n\t\t\t\tresult = this._computeFn(this, changeSummary!);\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t}\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this._state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this._dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this._state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this._state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis._state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tif (this._state !== DerivedState.upToDate) {\n\t\t\t\t\tthis._recompute();\n\t\t\t\t}\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this._state !== DerivedState.upToDate);\n\t\t\treturn this._value!;\n\t\t}\n\t}\n\n\tprivate _recompute() {\n\t\tlet didChange = false;\n\t\tthis._isComputing = true;\n\t\tthis._didReportChange = false;\n\n\t\tconst emptySet = this._dependenciesToBeRemoved;\n\t\tthis._dependenciesToBeRemoved = this._dependencies;\n\t\tthis._dependencies = emptySet;\n\n\t\ttry {\n\t\t\tconst changeSummary = this._changeSummary!;\n\n\t\t\tthis._isReaderValid = true;\n\t\t\tif (this._changeTracker) {\n\t\t\t\tthis._isInBeforeUpdate = true;\n\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\tthis._isInBeforeUpdate = false;\n\t\t\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(changeSummary);\n\t\t\t}\n\n\t\t\tconst hadValue = this._state !== DerivedState.initial;\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._state = DerivedState.upToDate;\n\n\t\t\tconst delayedStore = this._delayedStore;\n\t\t\tif (delayedStore !== undefined) {\n\t\t\t\tthis._delayedStore = undefined;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (this._store !== undefined) {\n\t\t\t\t\tthis._store.dispose();\n\t\t\t\t\tthis._store = undefined;\n\t\t\t\t}\n\t\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\t\tthis._value = this._computeFn(this, changeSummary);\n\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\t\tfor (const o of this._dependenciesToBeRemoved) {\n\t\t\t\t\to.removeObserver(this);\n\t\t\t\t}\n\t\t\t\tthis._dependenciesToBeRemoved.clear();\n\n\t\t\t\tif (delayedStore !== undefined) {\n\t\t\t\t\tdelayedStore.dispose();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdidChange = this._didReportChange || (hadValue && !(this._equalityComparator(oldValue!, this._value)));\n\n\t\t\tgetLogger()?.handleObservableUpdated(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue: this._value,\n\t\t\t\tchange: undefined,\n\t\t\t\tdidChange,\n\t\t\t\thadValue,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonBugIndicatingError(e);\n\t\t}\n\n\t\tthis._isComputing = false;\n\n\t\tif (!this._didReportChange && didChange) {\n\t\t\tfor (const r of this._observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._didReportChange = false;\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tif (this._isUpdating) {\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tthis._updateCount++;\n\t\tthis._isUpdating = true;\n\t\ttry {\n\t\t\tconst propagateBeginUpdate = this._updateCount === 1;\n\t\t\tif (this._state === DerivedState.upToDate) {\n\t\t\t\tthis._state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propagateBeginUpdate) {\n\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis._isUpdating = false;\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis._updateCount--;\n\t\tif (this._updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this._observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t\tif (this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tconst observers = [...this._removedObserverToCallEndUpdateOn];\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = null;\n\t\t\t\tfor (const r of observers) {\n\t\t\t\t\tr.endUpdate(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this._updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this._state === DerivedState.upToDate && this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis._state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this._observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tif (this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable) || this._isInBeforeUpdate) {\n\t\t\tgetLogger()?.handleDerivedDependencyChanged(this, observable, change);\n\n\t\t\tlet shouldReact = false;\n\t\t\ttry {\n\t\t\t\tshouldReact = this._changeTracker ? this._changeTracker.handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this._changeSummary!) : true;\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\n\t\t\tconst wasUpToDate = this._state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this._state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis._state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\n\tprivate _ensureReaderValid(): void {\n\t\tif (!this._isReaderValid) { throw new BugIndicatingError('The reader object cannot be used outside its compute function!'); }\n\t}\n\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\tthis._ensureReaderValid();\n\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis._dependencies.add(observable);\n\t\tthis._dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tget store(): DisposableStore {\n\t\tthis._ensureReaderValid();\n\n\t\tif (this._store === undefined) {\n\t\t\tthis._store = new DisposableStore();\n\t\t}\n\t\treturn this._store;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tif (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(observer)) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn.delete(observer);\n\t\t\t} else {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tif (this._observers.has(observer) && this._updateCount > 0) {\n\t\t\tif (!this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = new Set();\n\t\t\t}\n\t\t\tthis._removedObserverToCallEndUpdateOn.add(observer);\n\t\t}\n\t\tsuper.removeObserver(observer);\n\t}\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tstate: this._state,\n\t\t\tupdateCount: this._updateCount,\n\t\t\tisComputing: this._isComputing,\n\t\t\tdependencies: this._dependencies,\n\t\t\tvalue: this._value,\n\t\t};\n\t}\n\n\tpublic debugSetValue(newValue: unknown) {\n\t\tthis._value = newValue as any;\n\t}\n\n\tpublic debugRecompute(): void {\n\t\tif (!this._isComputing) {\n\t\t\tthis._recompute();\n\t\t} else {\n\t\t\tthis._state = DerivedState.stale;\n\t\t}\n\t}\n\n\tpublic setValue(newValue: T, tx: ITransaction, change: TChange): void {\n\t\tthis._value = newValue;\n\t\tconst observers = this._observers;\n\t\ttx.updateObserver(this, this);\n\t\tfor (const d of observers) {\n\t\t\td.handleChange(this, change);\n\t\t}\n\t}\n}\n\n\nexport class DerivedWithSetter<T, TChangeSummary = any, TOutChanges = any> extends Derived<T, TChangeSummary, TOutChanges> implements ISettableObservable<T, TOutChanges> {\n\tconstructor(\n\t\tdebugNameData: DebugNameData,\n\t\tcomputeFn: (reader: IDerivedReader<TOutChanges>, changeSummary: TChangeSummary) => T,\n\t\tchangeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\thandleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tequalityComparator: EqualityComparer<T>,\n\t\tpublic readonly set: (value: T, tx: ITransaction | undefined, change: TOutChanges) => void,\n\t\tdebugLocation: DebugLocation,\n\t) {\n\t\tsuper(\n\t\t\tdebugNameData,\n\t\t\tcomputeFn,\n\t\t\tchangeTracker,\n\t\t\thandleLastObserverRemoved,\n\t\t\tequalityComparator,\n\t\t\tdebugLocation,\n\t\t);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IObservableWithChange, IObserver, IReaderWithStore, ISettableObservable, ITransaction } from '../base.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BugIndicatingError, DisposableStore, EqualityComparer, assertFn, onBugIndicatingError } from '../commonFacade/deps.js';\nimport { getLogger } from '../logging/logging.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport interface IDerivedReader<TChange = void> extends IReaderWithStore {\n}\n\nexport const enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any, TChange = void> extends BaseObservable<T, TChange> implements IDerivedReader<TChange>, IObserver {\n\tprivate _state = DerivedState.initial;\n\tprivate _value: T | undefined = undefined;\n\tprivate _updateCount = 0;\n\tprivate _dependencies = new Set<IObservable<any>>();\n\tprivate _dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate _changeSummary: TChangeSummary | undefined = undefined;\n\tprivate _isUpdating = false;\n\tprivate _isComputing = false;\n\tprivate _didReportChange = false;\n\tprivate _isInBeforeUpdate = false;\n\tprivate _isReaderValid = false;\n\tprivate _store: DisposableStore | undefined = undefined;\n\tprivate _delayedStore: DisposableStore | undefined = undefined;\n\tprivate _removedObserverToCallEndUpdateOn: Set<IObserver> | null = null;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tpublic readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (reader: IDerivedReader<TChange>, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly _changeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation,\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(undefined);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis._state = DerivedState.initial;\n\t\tthis._value = undefined;\n\t\tgetLogger()?.handleDerivedCleared(this);\n\t\tfor (const d of this._dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis._dependencies.clear();\n\n\t\tif (this._store !== undefined) {\n\t\t\tthis._store.dispose();\n\t\t\tthis._store = undefined;\n\t\t}\n\t\tif (this._delayedStore !== undefined) {\n\t\t\tthis._delayedStore.dispose();\n\t\t\tthis._delayedStore = undefined;\n\t\t}\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tconst checkEnabled = false; // TODO set to true\n\t\tif (this._isComputing && checkEnabled) {\n\t\t\t// investigate why this fails in the diff editor!\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tif (this._observers.size === 0) {\n\t\t\tlet result;\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\ttry {\n\t\t\t\tthis._isReaderValid = true;\n\t\t\t\tlet changeSummary = undefined;\n\t\t\t\tif (this._changeTracker) {\n\t\t\t\t\tchangeSummary = this._changeTracker.createChangeSummary(undefined);\n\t\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\t}\n\t\t\t\tresult = this._computeFn(this, changeSummary!);\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t}\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this._state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this._dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this._state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this._state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis._state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tif (this._state !== DerivedState.upToDate) {\n\t\t\t\t\tthis._recompute();\n\t\t\t\t}\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this._state !== DerivedState.upToDate);\n\t\t\treturn this._value!;\n\t\t}\n\t}\n\n\tprivate _recompute() {\n\t\tlet didChange = false;\n\t\tthis._isComputing = true;\n\t\tthis._didReportChange = false;\n\n\t\tconst emptySet = this._dependenciesToBeRemoved;\n\t\tthis._dependenciesToBeRemoved = this._dependencies;\n\t\tthis._dependencies = emptySet;\n\n\t\ttry {\n\t\t\tconst changeSummary = this._changeSummary!;\n\n\t\t\tthis._isReaderValid = true;\n\t\t\tif (this._changeTracker) {\n\t\t\t\tthis._isInBeforeUpdate = true;\n\t\t\t\tthis._changeTracker.beforeUpdate?.(this, changeSummary);\n\t\t\t\tthis._isInBeforeUpdate = false;\n\t\t\t\tthis._changeSummary = this._changeTracker?.createChangeSummary(changeSummary);\n\t\t\t}\n\n\t\t\tconst hadValue = this._state !== DerivedState.initial;\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._state = DerivedState.upToDate;\n\n\t\t\tconst delayedStore = this._delayedStore;\n\t\t\tif (delayedStore !== undefined) {\n\t\t\t\tthis._delayedStore = undefined;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (this._store !== undefined) {\n\t\t\t\t\tthis._store.dispose();\n\t\t\t\t\tthis._store = undefined;\n\t\t\t\t}\n\t\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\t\tthis._value = this._computeFn(this, changeSummary);\n\n\t\t\t} finally {\n\t\t\t\tthis._isReaderValid = false;\n\t\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\t\tfor (const o of this._dependenciesToBeRemoved) {\n\t\t\t\t\to.removeObserver(this);\n\t\t\t\t}\n\t\t\t\tthis._dependenciesToBeRemoved.clear();\n\n\t\t\t\tif (delayedStore !== undefined) {\n\t\t\t\t\tdelayedStore.dispose();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdidChange = this._didReportChange || (hadValue && !(this._equalityComparator(oldValue!, this._value)));\n\n\t\t\tgetLogger()?.handleObservableUpdated(this, {\n\t\t\t\toldValue,\n\t\t\t\tnewValue: this._value,\n\t\t\t\tchange: undefined,\n\t\t\t\tdidChange,\n\t\t\t\thadValue,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tonBugIndicatingError(e);\n\t\t}\n\n\t\tthis._isComputing = false;\n\n\t\tif (!this._didReportChange && didChange) {\n\t\t\tfor (const r of this._observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._didReportChange = false;\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tif (this._isUpdating) {\n\t\t\tthrow new BugIndicatingError('Cyclic deriveds are not supported yet!');\n\t\t}\n\n\t\tthis._updateCount++;\n\t\tthis._isUpdating = true;\n\t\ttry {\n\t\t\tconst propagateBeginUpdate = this._updateCount === 1;\n\t\t\tif (this._state === DerivedState.upToDate) {\n\t\t\t\tthis._state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (propagateBeginUpdate) {\n\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis._isUpdating = false;\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis._updateCount--;\n\t\tif (this._updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this._observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t\tif (this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tconst observers = [...this._removedObserverToCallEndUpdateOn];\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = null;\n\t\t\t\tfor (const r of observers) {\n\t\t\t\t\tr.endUpdate(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this._updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this._state === DerivedState.upToDate && this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis._state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this._observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\tif (this._dependencies.has(observable) && !this._dependenciesToBeRemoved.has(observable) || this._isInBeforeUpdate) {\n\t\t\tgetLogger()?.handleDerivedDependencyChanged(this, observable, change);\n\n\t\t\tlet shouldReact = false;\n\t\t\ttry {\n\t\t\t\tshouldReact = this._changeTracker ? this._changeTracker.handleChange({\n\t\t\t\t\tchangedObservable: observable,\n\t\t\t\t\tchange,\n\t\t\t\t\tdidChange: (o): this is any => o === observable as any,\n\t\t\t\t}, this._changeSummary!) : true;\n\t\t\t} catch (e) {\n\t\t\t\tonBugIndicatingError(e);\n\t\t\t}\n\n\t\t\tconst wasUpToDate = this._state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this._state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis._state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this._observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\n\tprivate _ensureReaderValid(): void {\n\t\tif (!this._isReaderValid) { throw new BugIndicatingError('The reader object cannot be used outside its compute function!'); }\n\t}\n\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\tthis._ensureReaderValid();\n\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis._dependencies.add(observable);\n\t\tthis._dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tget store(): DisposableStore {\n\t\tthis._ensureReaderValid();\n\n\t\tif (this._store === undefined) {\n\t\t\tthis._store = new DisposableStore();\n\t\t}\n\t\treturn this._store;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this._observers.has(observer) && this._updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tif (this._removedObserverToCallEndUpdateOn && this._removedObserverToCallEndUpdateOn.has(observer)) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn.delete(observer);\n\t\t\t} else {\n\t\t\t\tobserver.beginUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tif (this._observers.has(observer) && this._updateCount > 0) {\n\t\t\tif (!this._removedObserverToCallEndUpdateOn) {\n\t\t\t\tthis._removedObserverToCallEndUpdateOn = new Set();\n\t\t\t}\n\t\t\tthis._removedObserverToCallEndUpdateOn.add(observer);\n\t\t}\n\t\tsuper.removeObserver(observer);\n\t}\n\n\tpublic debugGetState() {\n\t\treturn {\n\t\t\tstate: this._state,\n\t\t\tupdateCount: this._updateCount,\n\t\t\tisComputing: this._isComputing,\n\t\t\tdependencies: this._dependencies,\n\t\t\tvalue: this._value,\n\t\t};\n\t}\n\n\tpublic debugSetValue(newValue: unknown) {\n\t\tthis._value = newValue as any;\n\t}\n\n\tpublic debugRecompute(): void {\n\t\tif (!this._isComputing) {\n\t\t\tthis._recompute();\n\t\t} else {\n\t\t\tthis._state = DerivedState.stale;\n\t\t}\n\t}\n\n\tpublic setValue(newValue: T, tx: ITransaction, change: TChange): void {\n\t\tthis._value = newValue;\n\t\tconst observers = this._observers;\n\t\ttx.updateObserver(this, this);\n\t\tfor (const d of observers) {\n\t\t\td.handleChange(this, change);\n\t\t}\n\t}\n}\n\n\nexport class DerivedWithSetter<T, TChangeSummary = any, TOutChanges = any> extends Derived<T, TChangeSummary, TOutChanges> implements ISettableObservable<T, TOutChanges> {\n\tconstructor(\n\t\tdebugNameData: DebugNameData,\n\t\tcomputeFn: (reader: IDerivedReader<TOutChanges>, changeSummary: TChangeSummary) => T,\n\t\tchangeTracker: IChangeTracker<TChangeSummary> | undefined,\n\t\thandleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tequalityComparator: EqualityComparer<T>,\n\t\tpublic readonly set: (value: T, tx: ITransaction | undefined, change: TOutChanges) => void,\n\t\tdebugLocation: DebugLocation,\n\t) {\n\t\tsuper(\n\t\t\tdebugNameData,\n\t\t\tcomputeFn,\n\t\t\tchangeTracker,\n\t\t\thandleLastObserverRemoved,\n\t\t\tequalityComparator,\n\t\t\tdebugLocation,\n\t\t);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1485, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/derived.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/derived.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/derived.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IReader, ITransaction, ISettableObservable, IObservableWithChange } from '../base.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DisposableStore, EqualityComparer, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugLocation } from '../debugLocation.js';\nimport { DebugOwner, DebugNameData, IDebugNameData } from '../debugName.js';\nimport { _setDerivedOpts } from './baseObservable.js';\nimport { IDerivedReader, Derived, DerivedWithSetter } from './derivedImpl.js';\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T, TChange = void>(computeFn: (reader: IDerivedReader<TChange>) => T): IObservableWithChange<T, TChange>;\nexport function derived<T, TChange = void>(owner: DebugOwner, computeFn: (reader: IDerivedReader<TChange>) => T): IObservableWithChange<T, TChange>;\nexport function derived<T, TChange = void>(\n\tcomputeFnOrOwner: ((reader: IDerivedReader<TChange>) => T) | DebugOwner,\n\tcomputeFn?: ((reader: IDerivedReader<TChange>) => T) | undefined,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tstrictEquals,\n\t\t\tdebugLocation,\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tdebugLocation,\n\t);\n}\n\nexport function derivedWithSetter<T>(owner: DebugOwner | undefined, computeFn: (reader: IReader) => T, setter: (value: T, transaction: ITransaction | undefined) => void, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T> {\n\treturn new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tsetter,\n\t\tdebugLocation\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: (() => void);\n\t},\n\tcomputeFn: (reader: IReader) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalsFn ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TDelta, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IDerivedReader<TDelta>, changeSummary: TChangeSummary) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservableWithChange<T, TDelta> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.changeTracker,\n\t\tundefined,\n\t\toptions.equalityComparer ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFnOrUndefined?: ((reader: IReader) => T), debugLocation = DebugLocation.ofCaller()): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet store: DisposableStore | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (!store) {\n\t\t\t\tstore = new DisposableStore();\n\t\t\t} else {\n\t\t\t\tstore.clear();\n\t\t\t}\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tundefined,\n\t\t() => {\n\t\t\tif (store) {\n\t\t\t\tstore.dispose();\n\t\t\t\tstore = undefined;\n\t\t\t}\n\t\t},\n\t\tstrictEquals,\n\t\tdebugLocation\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IReader, ITransaction, ISettableObservable, IObservableWithChange } from '../base.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DisposableStore, EqualityComparer, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugLocation } from '../debugLocation.js';\nimport { DebugOwner, DebugNameData, IDebugNameData } from '../debugName.js';\nimport { _setDerivedOpts } from './baseObservable.js';\nimport { IDerivedReader, Derived, DerivedWithSetter } from './derivedImpl.js';\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T, TChange = void>(computeFn: (reader: IDerivedReader<TChange>) => T): IObservableWithChange<T, TChange>;\nexport function derived<T, TChange = void>(owner: DebugOwner, computeFn: (reader: IDerivedReader<TChange>) => T): IObservableWithChange<T, TChange>;\nexport function derived<T, TChange = void>(\n\tcomputeFnOrOwner: ((reader: IDerivedReader<TChange>) => T) | DebugOwner,\n\tcomputeFn?: ((reader: IDerivedReader<TChange>) => T) | undefined,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tstrictEquals,\n\t\t\tdebugLocation,\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tdebugLocation,\n\t);\n}\n\nexport function derivedWithSetter<T>(owner: DebugOwner | undefined, computeFn: (reader: IReader) => T, setter: (value: T, transaction: ITransaction | undefined) => void, debugLocation = DebugLocation.ofCaller()): ISettableObservable<T> {\n\treturn new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\tstrictEquals,\n\t\tsetter,\n\t\tdebugLocation\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: (() => void);\n\t},\n\tcomputeFn: (reader: IReader) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalsFn ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TDelta, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tchangeTracker: IChangeTracker<TChangeSummary>;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IDerivedReader<TDelta>, changeSummary: TChangeSummary) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservableWithChange<T, TDelta> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.changeTracker,\n\t\tundefined,\n\t\toptions.equalityComparer ?? strictEquals,\n\t\tdebugLocation\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(owner: DebugOwner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFnOrOwner: ((reader: IReader) => T) | DebugOwner, computeFnOrUndefined?: ((reader: IReader) => T), debugLocation = DebugLocation.ofCaller()): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: DebugOwner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet store: DisposableStore | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (!store) {\n\t\t\t\tstore = new DisposableStore();\n\t\t\t} else {\n\t\t\t\tstore.clear();\n\t\t\t}\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tundefined,\n\t\t() => {\n\t\t\tif (store) {\n\t\t\t\tstore.dispose();\n\t\t\t\tstore = undefined;\n\t\t\t}\n\t\t},\n\t\tstrictEquals,\n\t\tdebugLocation\n\t);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1561, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/promise.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/utils/promise.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/vs/base/common/observableInternal/utils/promise.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IObservable } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { observableValue } from '../observables/observableValue.js';\n\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise<T> {\n\n\tprivate readonly _value = observableValue<PromiseResult<T> | undefined>(this, undefined);\n\n\t/**\n\t * The promise that this object wraps.\n\t */\n\tpublic readonly promise: Promise<T>;\n\n\t/**\n\t * The current state of the promise.\n\t * Is `undefined` if the promise didn't resolve yet.\n\t */\n\tpublic readonly promiseResult: IObservable<PromiseResult<T> | undefined> = this._value;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(value => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseResolved */\n\t\t\t\tthis._value.set(new PromiseResult(value, undefined), tx);\n\t\t\t});\n\t\t\treturn value;\n\t\t}, error => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseRejected */\n\t\t\t\tthis._value.set(new PromiseResult<T>(undefined, error), tx);\n\t\t\t});\n\t\t\tthrow error;\n\t\t});\n\t}\n}\n\nexport class PromiseResult<T> {\n\tconstructor(\n\t\t/**\n\t\t * The value of the resolved promise.\n\t\t * Undefined if the promise rejected.\n\t\t */\n\t\tpublic readonly data: T | undefined,\n\n\t\t/**\n\t\t * The error in case of a rejected promise.\n\t\t * Undefined if the promise resolved.\n\t\t */\n\t\tpublic readonly error: unknown | undefined,\n\t) {\n\t}\n\n\t/**\n\t * Returns the value if the promise resolved, otherwise throws the error.\n\t */\n\tpublic getDataOrThrow(): T {\n\t\tif (this.error) {\n\t\t\tthrow this.error;\n\t\t}\n\t\treturn this.data!;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IObservable } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { observableValue } from '../observables/observableValue.js';\n\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise<T> {\n\n\tprivate readonly _value = observableValue<PromiseResult<T> | undefined>(this, undefined);\n\n\t/**\n\t * The promise that this object wraps.\n\t */\n\tpublic readonly promise: Promise<T>;\n\n\t/**\n\t * The current state of the promise.\n\t * Is `undefined` if the promise didn't resolve yet.\n\t */\n\tpublic readonly promiseResult: IObservable<PromiseResult<T> | undefined> = this._value;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(value => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseResolved */\n\t\t\t\tthis._value.set(new PromiseResult(value, undefined), tx);\n\t\t\t});\n\t\t\treturn value;\n\t\t}, error => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseRejected */\n\t\t\t\tthis._value.set(new PromiseResult<T>(undefined, error), tx);\n\t\t\t});\n\t\t\tthrow error;\n\t\t});\n\t}\n}\n\nexport class PromiseResult<T> {\n\tconstructor(\n\t\t/**\n\t\t * The value of the resolved promise.\n\t\t * Undefined if the promise rejected.\n\t\t */\n\t\tpublic readonly data: T | undefined,\n\n\t\t/**\n\t\t * The error in case of a rejected promise.\n\t\t * Undefined if the promise resolved.\n\t\t */\n\t\tpublic readonly error: unknown | undefined,\n\t) {\n\t}\n\n\t/**\n\t * Returns the value if the promise resolved, otherwise throws the error.\n\t */\n\tpublic getDataOrThrow(): T {\n\t\tif (this.error) {\n\t\t\tthrow this.error;\n\t\t}\n\t\treturn this.data!;\n\t}\n}\n"],"names":[],"mappings":";;;;;;AAKA,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAChD,OAAO,EAAE,eAAe,EAAE,MAAM,mCAAmC,CAAC;;;AAK9D,MAAO,iBAAiB;IAe7B,YAAY,OAAmB,CAAA;QAbd,IAAA,CAAA,MAAM,OAAG,0OAAe,EAA+B,IAAI,EAAE,SAAS,CAAC,CAAC;QAOzF;;;WAGG,CACa,IAAA,CAAA,aAAa,GAA8C,IAAI,CAAC,MAAM,CAAC;QAGtF,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,IAAI,EAAC,KAAK,CAAC,EAAE;gBACnC,mNAAW,GAAC,EAAE,CAAC,EAAE;gBAChB,mCAAA,EAAqC,CACrC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,aAAa,CAAC,KAAK,EAAE,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC;YAC1D,CAAC,CAAC,CAAC;YACH,OAAO,KAAK,CAAC;QACd,CAAC,GAAE,KAAK,CAAC,EAAE;gBACV,mNAAW,GAAC,EAAE,CAAC,EAAE;gBAChB,mCAAA,EAAqC,CACrC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,aAAa,CAAI,SAAS,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;YAC7D,CAAC,CAAC,CAAC;YACH,MAAM,KAAK,CAAC;QACb,CAAC,CAAC,CAAC;IACJ,CAAC;CACD;AAEK,MAAO,aAAa;IACzB,YACC;;;OAGG,CACa,IAAmB,EAEnC;;;OAGG,CACa,KAA0B,CAAA;QAN1B,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAe;QAMnB,IAAA,CAAA,KAAK,GAAL,KAAK,CAAqB;IAE3C,CAAC;IAED;;OAEG,CACI,cAAc,GAAA;QACpB,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;YAChB,MAAM,IAAI,CAAC,KAAK,CAAC;QAClB,CAAC;QACD,OAAO,IAAI,CAAC,IAAK,CAAC;IACnB,CAAC;CACD","debugId":null}},
    {"offset": {"line": 1615, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/commonFacade/cancellation.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/commonFacade/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/commonFacade/cancellation.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/commonFacade/vs/base/common/observableInternal/commonFacade/cancellation.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport { CancellationError } from '../../errors.js';\nexport { CancellationToken, CancellationTokenSource, cancelOnDispose } from '../../cancellation.js';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport { CancellationError } from '../../errors.js';\nexport { CancellationToken, CancellationTokenSource, cancelOnDispose } from '../../cancellation.js';\n"],"names":[],"mappings":"AAAA;;;gGAGgG;AAEhG,OAAO,EAAE,iBAAiB,EAAE,MAAM,iBAAiB,CAAC;AACpD,OAAO,EAAE,iBAAiB,EAAE,uBAAuB,EAAE,eAAe,EAAE,MAAM,uBAAuB,CAAC","debugId":null}},
    {"offset": {"line": 1627, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/utilsCancellation.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/utils/utilsCancellation.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/vs/base/common/observableInternal/utils/utilsCancellation.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable } from '../base.js';\nimport { CancellationError, CancellationToken } from '../commonFacade/cancellation.js';\nimport { autorun } from '../reactions/autorun.js';\n\n/**\n * Resolves the promise when the observables state matches the predicate.\n */\nexport function waitForState<T>(observable: IObservable<T | null | undefined>): Promise<T>;\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate?: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T> {\n\tif (!predicate) {\n\t\tpredicate = state => state !== null && state !== undefined;\n\t}\n\treturn new Promise((resolve, reject) => {\n\t\tlet isImmediateRun = true;\n\t\tlet shouldDispose = false;\n\t\tconst stateObs = observable.map(state => {\n\t\t\t/** @description waitForState.state */\n\t\t\treturn {\n\t\t\t\tisFinished: predicate(state),\n\t\t\t\terror: isError ? isError(state) : false,\n\t\t\t\tstate\n\t\t\t};\n\t\t});\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description waitForState */\n\t\t\tconst { isFinished, error, state } = stateObs.read(reader);\n\t\t\tif (isFinished || error) {\n\t\t\t\tif (isImmediateRun) {\n\t\t\t\t\t// The variable `d` is not initialized yet\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error === true ? state : error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(state);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (cancellationToken) {\n\t\t\tconst dc = cancellationToken.onCancellationRequested(() => {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t});\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tisImmediateRun = false;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable } from '../base.js';\nimport { CancellationError, CancellationToken } from '../commonFacade/cancellation.js';\nimport { autorun } from '../reactions/autorun.js';\n\n/**\n * Resolves the promise when the observables state matches the predicate.\n */\nexport function waitForState<T>(observable: IObservable<T | null | undefined>): Promise<T>;\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate?: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined, cancellationToken?: CancellationToken): Promise<T> {\n\tif (!predicate) {\n\t\tpredicate = state => state !== null && state !== undefined;\n\t}\n\treturn new Promise((resolve, reject) => {\n\t\tlet isImmediateRun = true;\n\t\tlet shouldDispose = false;\n\t\tconst stateObs = observable.map(state => {\n\t\t\t/** @description waitForState.state */\n\t\t\treturn {\n\t\t\t\tisFinished: predicate(state),\n\t\t\t\terror: isError ? isError(state) : false,\n\t\t\t\tstate\n\t\t\t};\n\t\t});\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description waitForState */\n\t\t\tconst { isFinished, error, state } = stateObs.read(reader);\n\t\t\tif (isFinished || error) {\n\t\t\t\tif (isImmediateRun) {\n\t\t\t\t\t// The variable `d` is not initialized yet\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error === true ? state : error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(state);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (cancellationToken) {\n\t\t\tconst dc = cancellationToken.onCancellationRequested(() => {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t});\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\td.dispose();\n\t\t\t\tdc.dispose();\n\t\t\t\treject(new CancellationError());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tisImmediateRun = false;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;AAGhG,OAAO,EAAE,iBAAiB,EAAqB,MAAM,iCAAiC,CAAC;AACvF,OAAO,EAAE,OAAO,EAAE,MAAM,yBAAyB,CAAC;;;AAQ5C,SAAU,YAAY,CAAI,UAA0B,EAAE,SAAiC,EAAE,OAAqD,EAAE,iBAAqC;IAC1L,IAAI,CAAC,SAAS,EAAE,CAAC;QAChB,SAAS,IAAG,KAAK,CAAC,EAAE,AAAC,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,CAAC;IAC5D,CAAC;IACD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACtC,IAAI,cAAc,GAAG,IAAI,CAAC;QAC1B,IAAI,aAAa,GAAG,KAAK,CAAC;QAC1B,MAAM,QAAQ,GAAG,UAAU,CAAC,GAAG,EAAC,KAAK,CAAC,EAAE;YACvC,oCAAA,EAAsC,CACtC,OAAO;gBACN,UAAU,EAAE,SAAS,CAAC,KAAK,CAAC;gBAC5B,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK;gBACvC,KAAK;aACL,CAAC;QACH,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,OAAG,wNAAO,GAAC,MAAM,CAAC,EAAE;YAC1B,8BAAA,EAAgC,CAChC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC3D,IAAI,UAAU,IAAI,KAAK,EAAE,CAAC;gBACzB,IAAI,cAAc,EAAE,CAAC;oBACpB,0CAA0C;oBAC1C,aAAa,GAAG,IAAI,CAAC;gBACtB,CAAC,MAAM,CAAC;oBACP,CAAC,CAAC,OAAO,EAAE,CAAC;gBACb,CAAC;gBACD,IAAI,KAAK,EAAE,CAAC;oBACX,MAAM,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBACxC,CAAC,MAAM,CAAC;oBACP,OAAO,CAAC,KAAK,CAAC,CAAC;gBAChB,CAAC;YACF,CAAC;QACF,CAAC,CAAC,CAAC;QACH,IAAI,iBAAiB,EAAE,CAAC;YACvB,MAAM,EAAE,GAAG,iBAAiB,CAAC,uBAAuB,CAAC,GAAG,EAAE;gBACzD,CAAC,CAAC,OAAO,EAAE,CAAC;gBACZ,EAAE,CAAC,OAAO,EAAE,CAAC;gBACb,MAAM,CAAC,IAAI,8LAAiB,EAAE,CAAC,CAAC;YACjC,CAAC,CAAC,CAAC;YACH,IAAI,iBAAiB,CAAC,uBAAuB,EAAE,CAAC;gBAC/C,CAAC,CAAC,OAAO,EAAE,CAAC;gBACZ,EAAE,CAAC,OAAO,EAAE,CAAC;gBACb,MAAM,CAAC,IAAI,8LAAiB,EAAE,CAAC,CAAC;gBAChC,OAAO;YACR,CAAC;QACF,CAAC;QACD,cAAc,GAAG,KAAK,CAAC;QACvB,IAAI,aAAa,EAAE,CAAC;YACnB,CAAC,CAAC,OAAO,EAAE,CAAC;QACb,CAAC;IACF,CAAC,CAAC,CAAC;AACJ,CAAC","debugId":null}},
    {"offset": {"line": 1692, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableFromEvent.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/observableFromEvent.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/observableFromEvent.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, ITransaction } from '../base.js';\nimport { subtransaction } from '../transaction.js';\nimport { EqualityComparer, Event, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugOwner, DebugNameData, IDebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\towner: DebugOwner,\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n\tdebugLocation?: DebugLocation,\n): IObservable<T>;\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent(...args:\n\t[owner: DebugOwner, event: Event<any>, getValue: (args: any | undefined) => any, debugLocation?: DebugLocation] |\n\t[event: Event<any>, getValue: (args: any | undefined) => any]\n): IObservable<any> {\n\tlet owner;\n\tlet event;\n\tlet getValue;\n\tlet debugLocation;\n\tif (args.length === 2) {\n\t\t[event, getValue] = args;\n\t} else {\n\t\t[owner, event, getValue, debugLocation] = args;\n\t}\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(owner, undefined, getValue),\n\t\tevent,\n\t\tgetValue,\n\t\t() => FromEventObservable.globalTransaction,\n\t\tstrictEquals,\n\t\tdebugLocation ?? DebugLocation.ofCaller()\n\t);\n}\n\nexport function observableFromEventOpts<T, TArgs = unknown>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t},\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue),\n\t\tevent,\n\t\tgetValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals, debugLocation\n\t);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate _value: T | undefined;\n\tprivate _hasValue = false;\n\tprivate _subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T,\n\t\tprivate readonly _getTransaction: () => ITransaction | undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn this._debugNameData.getDebugName(this);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis._subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this._value;\n\n\t\tconst didChange = !this._hasValue || !(this._equalityComparator(oldValue!, newValue));\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis._value = newValue;\n\n\t\t\tif (this._hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tthis._getTransaction(),\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: undefined, didChange, hadValue: this._hasValue });\n\n\t\t\t\t\t\tfor (const o of this._observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis._hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: undefined, didChange, hadValue: this._hasValue });\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis._subscription!.dispose();\n\t\tthis._subscription = undefined;\n\t\tthis._hasValue = false;\n\t\tthis._value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this._subscription) {\n\t\t\tif (!this._hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this._value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\tconst value = this._getValue(undefined);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tpublic debugSetValue(value: unknown) {\n\t\tthis._value = value as any;\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(tx: ITransaction, fn: () => void): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, ITransaction } from '../base.js';\nimport { subtransaction } from '../transaction.js';\nimport { EqualityComparer, Event, IDisposable, strictEquals } from '../commonFacade/deps.js';\nimport { DebugOwner, DebugNameData, IDebugNameData } from '../debugName.js';\nimport { getLogger } from '../logging/logging.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\towner: DebugOwner,\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n\tdebugLocation?: DebugLocation,\n): IObservable<T>;\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n): IObservable<T>;\nexport function observableFromEvent(...args:\n\t[owner: DebugOwner, event: Event<any>, getValue: (args: any | undefined) => any, debugLocation?: DebugLocation] |\n\t[event: Event<any>, getValue: (args: any | undefined) => any]\n): IObservable<any> {\n\tlet owner;\n\tlet event;\n\tlet getValue;\n\tlet debugLocation;\n\tif (args.length === 2) {\n\t\t[event, getValue] = args;\n\t} else {\n\t\t[owner, event, getValue, debugLocation] = args;\n\t}\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(owner, undefined, getValue),\n\t\tevent,\n\t\tgetValue,\n\t\t() => FromEventObservable.globalTransaction,\n\t\tstrictEquals,\n\t\tdebugLocation ?? DebugLocation.ofCaller()\n\t);\n}\n\nexport function observableFromEventOpts<T, TArgs = unknown>(\n\toptions: IDebugNameData & {\n\t\tequalsFn?: EqualityComparer<T>;\n\t},\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<T> {\n\treturn new FromEventObservable(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue),\n\t\tevent,\n\t\tgetValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals, debugLocation\n\t);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate _value: T | undefined;\n\tprivate _hasValue = false;\n\tprivate _subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T,\n\t\tprivate readonly _getTransaction: () => ITransaction | undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn this._debugNameData.getDebugName(this);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis._subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this._value;\n\n\t\tconst didChange = !this._hasValue || !(this._equalityComparator(oldValue!, newValue));\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis._value = newValue;\n\n\t\t\tif (this._hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tthis._getTransaction(),\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: undefined, didChange, hadValue: this._hasValue });\n\n\t\t\t\t\t\tfor (const o of this._observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis._hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleObservableUpdated(this, { oldValue, newValue, change: undefined, didChange, hadValue: this._hasValue });\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis._subscription!.dispose();\n\t\tthis._subscription = undefined;\n\t\tthis._hasValue = false;\n\t\tthis._value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this._subscription) {\n\t\t\tif (!this._hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this._value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\tconst value = this._getValue(undefined);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tpublic debugSetValue(value: unknown) {\n\t\tthis._value = value as any;\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(tx: ITransaction, fn: () => void): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1833, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableSignal.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/observableSignal.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/observableSignal.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange, ITransaction } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object, debugLocation = DebugLocation.ofCaller()): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner, undefined, debugLocation);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner, debugLocation);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservableWithChange<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tpublic override toString(): string {\n\t\treturn this.debugName;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner: object | undefined,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this._observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange, ITransaction } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { DebugNameData } from '../debugName.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object, debugLocation = DebugLocation.ofCaller()): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner, undefined, debugLocation);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner, debugLocation);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservableWithChange<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tpublic override toString(): string {\n\t\treturn this.debugName;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner: object | undefined,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this._observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAGhG,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAChD,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAChD,OAAO,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAC;AACrD,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;;;;;AAS9C,SAAU,gBAAgB,CAAgB,gBAAiC,EAAE,aAAa,GAAG,uNAAa,CAAC,QAAQ,EAAE;IAC1H,IAAI,OAAO,gBAAgB,KAAK,QAAQ,EAAE,CAAC;QAC1C,OAAO,IAAI,gBAAgB,CAAS,gBAAgB,EAAE,SAAS,EAAE,aAAa,CAAC,CAAC;IACjF,CAAC,MAAM,CAAC;QACP,OAAO,IAAI,gBAAgB,CAAS,SAAS,EAAE,gBAAgB,EAAE,aAAa,CAAC,CAAC;IACjF,CAAC;AACF,CAAC;AAMD,MAAM,gBAA0B,SAAQ,wOAA6B;IACpE,IAAW,SAAS,GAAA;QACnB,OAAO,IAAI,mNAAa,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,mBAAmB,CAAC;IAC7G,CAAC;IAEe,QAAQ,GAAA;QACvB,OAAO,IAAI,CAAC,SAAS,CAAC;IACvB,CAAC;IAED,YACkB,UAA8B,EAC9B,MAA0B,EAC3C,aAA4B,CAAA;QAE5B,KAAK,CAAC,aAAa,CAAC,CAAC;QAJJ,IAAA,CAAA,UAAU,GAAV,UAAU,CAAoB;QAC9B,IAAA,CAAA,MAAM,GAAN,MAAM,CAAoB;IAI5C,CAAC;IAEM,OAAO,CAAC,EAA4B,EAAE,MAAe,EAAA;QAC3D,IAAI,CAAC,EAAE,EAAE,CAAC;gBACT,mNAAW,GAAC,EAAE,CAAC,EAAE;gBAChB,IAAI,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;YAC1B,CAAC,EAAE,GAAG,CAAG,CAAD,AAAC,eAAA,EAAkB,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;YAC7C,OAAO;QACR,CAAC;QAED,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,UAAU,CAAE,CAAC;YACjC,EAAE,CAAC,cAAc,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YAC3B,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC9B,CAAC;IACF,CAAC;IAEe,GAAG,GAAA;IAClB,QAAQ;IACT,CAAC;CACD","debugId":null}},
    {"offset": {"line": 1887, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/utils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/utils/utils.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/vs/base/common/observableInternal/utils/utils.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { autorun } from '../reactions/autorun.js';\nimport { IObservable, IObservableWithChange, IObserver, IReader, ITransaction } from '../base.js';\nimport { DebugOwner } from '../debugName.js';\nimport { DisposableStore, IDisposable, toDisposable } from '../commonFacade/deps.js';\nimport { derived, derivedOpts } from '../observables/derived.js';\nimport { observableFromEvent } from '../observables/observableFromEvent.js';\nimport { observableSignal } from '../observables/observableSignal.js';\nimport { _setKeepObserved, _setRecomputeInitiallyAndOnChange } from '../observables/baseObservable.js';\n\n/**\n * Creates an observable that debounces the input observable.\n */\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number): IObservable<T> {\n\tlet hasValue = false;\n\tlet lastValue: T | undefined;\n\n\tlet timeout: Timeout | undefined = undefined;\n\n\treturn observableFromEvent<T, void>(cb => {\n\t\tconst d = autorun(reader => {\n\t\t\tconst value = observable.read(reader);\n\n\t\t\tif (!hasValue) {\n\t\t\t\thasValue = true;\n\t\t\t\tlastValue = value;\n\t\t\t} else {\n\t\t\t\tif (timeout) {\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t}\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tcb();\n\t\t\t\t}, debounceMs);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tdispose() {\n\t\t\t\td.dispose();\n\t\t\t\thasValue = false;\n\t\t\t\tlastValue = undefined;\n\t\t\t},\n\t\t};\n\t}, () => {\n\t\tif (hasValue) {\n\t\t\treturn lastValue!;\n\t\t} else {\n\t\t\treturn observable.get();\n\t\t}\n\t});\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\ttry {\n\t\to.beginUpdate(observable);\n\t} finally {\n\t\to.endUpdate(observable);\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T>): void {\n\t\tif (this._counter === 1 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t\tthis._counter--;\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(owner: DebugOwner, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T>\n\t& { clearCache(transaction: ITransaction): void; setCache(newValue: T | undefined, tx: ITransaction | undefined): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst onChange = observableSignal('derivedObservableWithWritableCache');\n\tconst observable = derived(owner, reader => {\n\t\tonChange.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (tx: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tonChange.trigger(tx);\n\t\t},\n\t\tsetCache: (newValue: T | undefined, tx: ITransaction | undefined) => {\n\t\t\tlastValue = newValue;\n\t\t\tonChange.trigger(tx);\n\t\t}\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: DebugOwner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { autorun } from '../reactions/autorun.js';\nimport { IObservable, IObservableWithChange, IObserver, IReader, ITransaction } from '../base.js';\nimport { DebugOwner } from '../debugName.js';\nimport { DisposableStore, IDisposable, toDisposable } from '../commonFacade/deps.js';\nimport { derived, derivedOpts } from '../observables/derived.js';\nimport { observableFromEvent } from '../observables/observableFromEvent.js';\nimport { observableSignal } from '../observables/observableSignal.js';\nimport { _setKeepObserved, _setRecomputeInitiallyAndOnChange } from '../observables/baseObservable.js';\n\n/**\n * Creates an observable that debounces the input observable.\n */\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number): IObservable<T> {\n\tlet hasValue = false;\n\tlet lastValue: T | undefined;\n\n\tlet timeout: Timeout | undefined = undefined;\n\n\treturn observableFromEvent<T, void>(cb => {\n\t\tconst d = autorun(reader => {\n\t\t\tconst value = observable.read(reader);\n\n\t\t\tif (!hasValue) {\n\t\t\t\thasValue = true;\n\t\t\t\tlastValue = value;\n\t\t\t} else {\n\t\t\t\tif (timeout) {\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t}\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tcb();\n\t\t\t\t}, debounceMs);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tdispose() {\n\t\t\t\td.dispose();\n\t\t\t\thasValue = false;\n\t\t\t\tlastValue = undefined;\n\t\t\t},\n\t\t};\n\t}, () => {\n\t\tif (hasValue) {\n\t\t\treturn lastValue!;\n\t\t} else {\n\t\t\treturn observable.get();\n\t\t}\n\t});\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\ttry {\n\t\to.beginUpdate(observable);\n\t} finally {\n\t\to.endUpdate(observable);\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T>): void {\n\t\tif (this._counter === 1 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t\tthis._counter--;\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(owner: DebugOwner, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T>\n\t& { clearCache(transaction: ITransaction): void; setCache(newValue: T | undefined, tx: ITransaction | undefined): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst onChange = observableSignal('derivedObservableWithWritableCache');\n\tconst observable = derived(owner, reader => {\n\t\tonChange.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (tx: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tonChange.trigger(tx);\n\t\t},\n\t\tsetCache: (newValue: T | undefined, tx: ITransaction | undefined) => {\n\t\t\tlastValue = newValue;\n\t\t\tonChange.trigger(tx);\n\t\t}\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: DebugOwner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2091, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/changeTracker.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/changeTracker.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/vs/base/common/observableInternal/changeTracker.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from './commonFacade/deps.js';\nimport { IObservableWithChange, IReader } from './base.js';\n\nexport interface IChangeTracker<TChangeSummary> {\n\tcreateChangeSummary(previousChangeSummary: TChangeSummary | undefined): TChangeSummary;\n\thandleChange(ctx: IChangeContext, change: TChangeSummary): boolean;\n\tbeforeUpdate?(reader: IReader, change: TChangeSummary): void;\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservableWithChange<any, any>;\n\treadonly change: unknown;\n\n\t/**\n\t * Returns if the given observable caused the change.\n\t */\n\tdidChange<T, TChange>(observable: IObservableWithChange<T, TChange>): this is { change: TChange };\n}\n\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nexport function recordChanges<TObs extends Record<any, IObservableWithChange<any, any>>>(obs: TObs):\n\tIChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }\n\t\t& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {\n\treturn {\n\t\tcreateChangeSummary: (_previousChangeSummary) => {\n\t\t\treturn {\n\t\t\t\tchanges: [],\n\t\t\t} as any;\n\t\t},\n\t\thandleChange(ctx, changeSummary) {\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (ctx.didChange(obs[key])) {\n\t\t\t\t\t(changeSummary.changes as any).push({ key, change: ctx.change });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tbeforeUpdate(reader, changeSummary) {\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (key === 'changes') {\n\t\t\t\t\tthrow new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n\t\t\t\t}\n\t\t\t\tchangeSummary[key] = obs[key].read(reader);\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nexport function recordChangesLazy<TObs extends Record<any, IObservableWithChange<any, any>>>(getObs: () => TObs):\n\tIChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }\n\t\t& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {\n\tlet obs: TObs | undefined = undefined;\n\treturn {\n\t\tcreateChangeSummary: (_previousChangeSummary) => {\n\t\t\treturn {\n\t\t\t\tchanges: [],\n\t\t\t} as any;\n\t\t},\n\t\thandleChange(ctx, changeSummary) {\n\t\t\tif (!obs) {\n\t\t\t\tobs = getObs();\n\t\t\t}\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (ctx.didChange(obs[key])) {\n\t\t\t\t\t(changeSummary.changes as any).push({ key, change: ctx.change });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tbeforeUpdate(reader, changeSummary) {\n\t\t\tif (!obs) {\n\t\t\t\tobs = getObs();\n\t\t\t}\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (key === 'changes') {\n\t\t\t\t\tthrow new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n\t\t\t\t}\n\t\t\t\tchangeSummary[key] = obs[key].read(reader);\n\t\t\t}\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from './commonFacade/deps.js';\nimport { IObservableWithChange, IReader } from './base.js';\n\nexport interface IChangeTracker<TChangeSummary> {\n\tcreateChangeSummary(previousChangeSummary: TChangeSummary | undefined): TChangeSummary;\n\thandleChange(ctx: IChangeContext, change: TChangeSummary): boolean;\n\tbeforeUpdate?(reader: IReader, change: TChangeSummary): void;\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservableWithChange<any, any>;\n\treadonly change: unknown;\n\n\t/**\n\t * Returns if the given observable caused the change.\n\t */\n\tdidChange<T, TChange>(observable: IObservableWithChange<T, TChange>): this is { change: TChange };\n}\n\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nexport function recordChanges<TObs extends Record<any, IObservableWithChange<any, any>>>(obs: TObs):\n\tIChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }\n\t\t& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {\n\treturn {\n\t\tcreateChangeSummary: (_previousChangeSummary) => {\n\t\t\treturn {\n\t\t\t\tchanges: [],\n\t\t\t} as any;\n\t\t},\n\t\thandleChange(ctx, changeSummary) {\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (ctx.didChange(obs[key])) {\n\t\t\t\t\t(changeSummary.changes as any).push({ key, change: ctx.change });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tbeforeUpdate(reader, changeSummary) {\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (key === 'changes') {\n\t\t\t\t\tthrow new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n\t\t\t\t}\n\t\t\t\tchangeSummary[key] = obs[key].read(reader);\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Subscribes to and records changes and the last value of the given observables.\n * Don't use the key \"changes\", as it is reserved for the changes array!\n*/\nexport function recordChangesLazy<TObs extends Record<any, IObservableWithChange<any, any>>>(getObs: () => TObs):\n\tIChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }\n\t\t& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {\n\tlet obs: TObs | undefined = undefined;\n\treturn {\n\t\tcreateChangeSummary: (_previousChangeSummary) => {\n\t\t\treturn {\n\t\t\t\tchanges: [],\n\t\t\t} as any;\n\t\t},\n\t\thandleChange(ctx, changeSummary) {\n\t\t\tif (!obs) {\n\t\t\t\tobs = getObs();\n\t\t\t}\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (ctx.didChange(obs[key])) {\n\t\t\t\t\t(changeSummary.changes as any).push({ key, change: ctx.change });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tbeforeUpdate(reader, changeSummary) {\n\t\t\tif (!obs) {\n\t\t\t\tobs = getObs();\n\t\t\t}\n\t\t\tfor (const key in obs) {\n\t\t\t\tif (key === 'changes') {\n\t\t\t\t\tthrow new BugIndicatingError('property name \"changes\" is reserved for change tracking');\n\t\t\t\t}\n\t\t\t\tchangeSummary[key] = obs[key].read(reader);\n\t\t\t}\n\t\t}\n\t};\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;AAEhG,OAAO,EAAE,kBAAkB,EAAE,MAAM,wBAAwB,CAAC;;AAuBtD,SAAU,aAAa,CAA4D,GAAS;IAGjG,OAAO;QACN,mBAAmB,EAAE,CAAC,sBAAsB,EAAE,EAAE;YAC/C,OAAO;gBACN,OAAO,EAAE,EAAE;aACJ,CAAC;QACV,CAAC;QACD,YAAY,EAAC,GAAG,EAAE,aAAa;YAC9B,IAAK,MAAM,GAAG,IAAI,GAAG,CAAE,CAAC;gBACvB,IAAI,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;oBAC5B,aAAa,CAAC,OAAe,CAAC,IAAI,CAAC;wBAAE,GAAG;wBAAE,MAAM,EAAE,GAAG,CAAC,MAAM;oBAAA,CAAE,CAAC,CAAC;gBAClE,CAAC;YACF,CAAC;YACD,OAAO,IAAI,CAAC;QACb,CAAC;QACD,YAAY,EAAC,MAAM,EAAE,aAAa;YACjC,IAAK,MAAM,GAAG,IAAI,GAAG,CAAE,CAAC;gBACvB,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;oBACvB,MAAM,IAAI,+LAAkB,CAAC,yDAAyD,CAAC,CAAC;gBACzF,CAAC;gBACD,aAAa,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC5C,CAAC;QACF,CAAC;KACD,CAAC;AACH,CAAC;AAMK,SAAU,iBAAiB,CAA4D,MAAkB;IAG9G,IAAI,GAAG,GAAqB,SAAS,CAAC;IACtC,OAAO;QACN,mBAAmB,EAAE,CAAC,sBAAsB,EAAE,EAAE;YAC/C,OAAO;gBACN,OAAO,EAAE,EAAE;aACJ,CAAC;QACV,CAAC;QACD,YAAY,EAAC,GAAG,EAAE,aAAa;YAC9B,IAAI,CAAC,GAAG,EAAE,CAAC;gBACV,GAAG,GAAG,MAAM,EAAE,CAAC;YAChB,CAAC;YACD,IAAK,MAAM,GAAG,IAAI,GAAG,CAAE,CAAC;gBACvB,IAAI,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;oBAC5B,aAAa,CAAC,OAAe,CAAC,IAAI,CAAC;wBAAE,GAAG;wBAAE,MAAM,EAAE,GAAG,CAAC,MAAM;oBAAA,CAAE,CAAC,CAAC;gBAClE,CAAC;YACF,CAAC;YACD,OAAO,IAAI,CAAC;QACb,CAAC;QACD,YAAY,EAAC,MAAM,EAAE,aAAa;YACjC,IAAI,CAAC,GAAG,EAAE,CAAC;gBACV,GAAG,GAAG,MAAM,EAAE,CAAC;YAChB,CAAC;YACD,IAAK,MAAM,GAAG,IAAI,GAAG,CAAE,CAAC;gBACvB,IAAI,GAAG,KAAK,SAAS,EAAE,CAAC;oBACvB,MAAM,IAAI,+LAAkB,CAAC,yDAAyD,CAAC,CAAC;gBACzF,CAAC;gBACD,aAAa,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC5C,CAAC;QACF,CAAC;KACD,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 2170, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/constObservable.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/constObservable.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/constObservable.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IObserver } from '../base.js';\nimport { ConvenientObservable } from './baseObservable.js';\n\n/**\n * Represents an efficient observable whose value never changes.\n */\n\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IObserver } from '../base.js';\nimport { ConvenientObservable } from './baseObservable.js';\n\n/**\n * Represents an efficient observable whose value never changes.\n */\n\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAGhG,OAAO,EAAE,oBAAoB,EAAE,MAAM,qBAAqB,CAAC;;AAMrD,SAAU,eAAe,CAAI,KAAQ;IAC1C,OAAO,IAAI,eAAe,CAAC,KAAK,CAAC,CAAC;AACnC,CAAC;AACD,MAAM,eAAmB,SAAQ,8OAA6B;IAC7D,YAA6B,KAAQ,CAAA;QACpC,KAAK,EAAE,CAAC;QADoB,IAAA,CAAA,KAAK,GAAL,KAAK,CAAG;IAErC,CAAC;IAED,IAAoB,SAAS,GAAA;QAC5B,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC;IACxB,CAAC;IAEM,GAAG,GAAA;QACT,OAAO,IAAI,CAAC,KAAK,CAAC;IACnB,CAAC;IACM,WAAW,CAAC,QAAmB,EAAA;IACrC,QAAQ;IACT,CAAC;IACM,cAAc,CAAC,QAAmB,EAAA;IACxC,QAAQ;IACT,CAAC;IAEQ,QAAQ,GAAA;QAChB,OAAO,CAAA,OAAA,EAAU,IAAI,CAAC,KAAK,EAAE,CAAC;IAC/B,CAAC;CACD","debugId":null}},
    {"offset": {"line": 2207, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/observableSignalFromEvent.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/observables/observableSignalFromEvent.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/observables/vs/base/common/observableInternal/observables/observableSignalFromEvent.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { Event, IDisposable } from '../commonFacade/deps.js';\nimport { DebugOwner, DebugNameData } from '../debugName.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport function observableSignalFromEvent(\n\towner: DebugOwner | string,\n\tevent: Event<any>,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<void> {\n\treturn new FromEventObservableSignal(typeof owner === 'string' ? owner : new DebugNameData(owner, undefined, undefined), event, debugLocation);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tpublic readonly debugName: string;\n\tconstructor(\n\t\tdebugNameDataOrName: DebugNameData | string,\n\t\tprivate readonly event: Event<any>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis.debugName = typeof debugNameDataOrName === 'string'\n\t\t\t? debugNameDataOrName\n\t\t\t: debugNameDataOrName.getDebugName(this) ?? 'Observable Signal From Event';\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this._observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable } from '../base.js';\nimport { transaction } from '../transaction.js';\nimport { Event, IDisposable } from '../commonFacade/deps.js';\nimport { DebugOwner, DebugNameData } from '../debugName.js';\nimport { BaseObservable } from './baseObservable.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport function observableSignalFromEvent(\n\towner: DebugOwner | string,\n\tevent: Event<any>,\n\tdebugLocation = DebugLocation.ofCaller()\n): IObservable<void> {\n\treturn new FromEventObservableSignal(typeof owner === 'string' ? owner : new DebugNameData(owner, undefined, undefined), event, debugLocation);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tpublic readonly debugName: string;\n\tconstructor(\n\t\tdebugNameDataOrName: DebugNameData | string,\n\t\tprivate readonly event: Event<any>,\n\t\tdebugLocation: DebugLocation\n\t) {\n\t\tsuper(debugLocation);\n\t\tthis.debugName = typeof debugNameDataOrName === 'string'\n\t\t\t? debugNameDataOrName\n\t\t\t: debugNameDataOrName.getDebugName(this) ?? 'Observable Signal From Event';\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this._observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAGhG,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAEhD,OAAO,EAAc,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAC5D,OAAO,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAC;AACrD,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;;;;;AAE9C,SAAU,yBAAyB,CACxC,KAA0B,EAC1B,KAAiB,EACjB,aAAa,GAAG,uNAAa,CAAC,QAAQ,EAAE;IAExC,OAAO,IAAI,yBAAyB,CAAC,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,mNAAa,CAAC,KAAK,EAAE,SAAS,EAAE,SAAS,CAAC,EAAE,KAAK,EAAE,aAAa,CAAC,CAAC;AAChJ,CAAC;AAED,MAAM,yBAA0B,SAAQ,wOAAoB;IAI3D,YACC,mBAA2C,EAC1B,KAAiB,EAClC,aAA4B,CAAA;QAE5B,KAAK,CAAC,aAAa,CAAC,CAAC;QAHJ,IAAA,CAAA,KAAK,GAAL,KAAK,CAAY;QAalB,IAAA,CAAA,WAAW,GAAG,GAAG,EAAE;gBACnC,mNAAW,EACV,CAAC,EAAE,EAAE,EAAE;gBACN,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,UAAU,CAAE,CAAC;oBACjC,EAAE,CAAC,cAAc,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;oBAC3B,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;gBACjC,CAAC;YACF,CAAC,EACD,GAAG,CAAG,CAAD,GAAK,CAAC,SAAS,CACpB,CAAC;QACH,CAAC,CAAC;QAnBD,IAAI,CAAC,SAAS,GAAG,OAAO,mBAAmB,KAAK,QAAQ,GACrD,mBAAmB,GACnB,mBAAmB,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,8BAA8B,CAAC;IAC7E,CAAC;IAEkB,oBAAoB,GAAA;QACtC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAClD,CAAC;IAckB,qBAAqB,GAAA;QACvC,IAAI,CAAC,YAAa,CAAC,OAAO,EAAE,CAAC;QAC7B,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;IAC/B,CAAC;IAEe,GAAG,GAAA;IAClB,QAAQ;IACT,CAAC;CACD","debugId":null}},
    {"offset": {"line": 2254, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/valueWithChangeEvent.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/utils/valueWithChangeEvent.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/vs/base/common/observableInternal/utils/valueWithChangeEvent.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable } from '../base.js';\nimport { Event, IValueWithChangeEvent } from '../commonFacade/deps.js';\nimport { DebugOwner } from '../debugName.js';\nimport { observableFromEvent } from '../observables/observableFromEvent.js';\n\nexport class ValueWithChangeEventFromObservable<T> implements IValueWithChangeEvent<T> {\n\tconstructor(public readonly observable: IObservable<T>) {\n\t}\n\n\tget onDidChange(): Event<void> {\n\t\treturn Event.fromObservableLight(this.observable);\n\t}\n\n\tget value(): T {\n\t\treturn this.observable.get();\n\t}\n}\n\nexport function observableFromValueWithChangeEvent<T>(owner: DebugOwner, value: IValueWithChangeEvent<T>): IObservable<T> {\n\tif (value instanceof ValueWithChangeEventFromObservable) {\n\t\treturn value.observable;\n\t}\n\treturn observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable } from '../base.js';\nimport { Event, IValueWithChangeEvent } from '../commonFacade/deps.js';\nimport { DebugOwner } from '../debugName.js';\nimport { observableFromEvent } from '../observables/observableFromEvent.js';\n\nexport class ValueWithChangeEventFromObservable<T> implements IValueWithChangeEvent<T> {\n\tconstructor(public readonly observable: IObservable<T>) {\n\t}\n\n\tget onDidChange(): Event<void> {\n\t\treturn Event.fromObservableLight(this.observable);\n\t}\n\n\tget value(): T {\n\t\treturn this.observable.get();\n\t}\n}\n\nexport function observableFromValueWithChangeEvent<T>(owner: DebugOwner, value: IValueWithChangeEvent<T>): IObservable<T> {\n\tif (value instanceof ValueWithChangeEventFromObservable) {\n\t\treturn value.observable;\n\t}\n\treturn observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;AAGhG,OAAO,EAAE,KAAK,EAAyB,MAAM,yBAAyB,CAAC;AAEvE,OAAO,EAAE,mBAAmB,EAAE,MAAM,uCAAuC,CAAC;;;AAEtE,MAAO,kCAAkC;IAC9C,YAA4B,UAA0B,CAAA;QAA1B,IAAA,CAAA,UAAU,GAAV,UAAU,CAAgB;IACtD,CAAC;IAED,IAAI,WAAW,GAAA;QACd,OAAO,iLAAK,CAAC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACnD,CAAC;IAED,IAAI,KAAK,GAAA;QACR,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;IAC9B,CAAC;CACD;AAEK,SAAU,kCAAkC,CAAI,KAAiB,EAAE,KAA+B;IACvG,IAAI,KAAK,YAAY,kCAAkC,EAAE,CAAC;QACzD,OAAO,KAAK,CAAC,UAAU,CAAC;IACzB,CAAC;IACD,WAAO,kPAAmB,EAAC,KAAK,EAAE,KAAK,CAAC,WAAW,EAAE,GAAG,CAAG,CAAD,IAAM,CAAC,KAAK,CAAC,CAAC;AACzE,CAAC","debugId":null}},
    {"offset": {"line": 2289, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/runOnChange.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/utils/runOnChange.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils/vs/base/common/observableInternal/utils/runOnChange.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange } from '../base.js';\nimport { CancellationToken, cancelOnDispose } from '../commonFacade/cancellation.js';\nimport { DisposableStore, IDisposable } from '../commonFacade/deps.js';\nimport { autorunWithStoreHandleChanges } from '../reactions/autorun.js';\n\nexport type RemoveUndefined<T> = T extends undefined ? never : T;\n\nexport function runOnChange<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[]) => void): IDisposable {\n\tlet _previousValue: T | undefined;\n\tlet _firstRun = true;\n\treturn autorunWithStoreHandleChanges({\n\t\tchangeTracker: {\n\t\t\tcreateChangeSummary: () => ({ deltas: [] as RemoveUndefined<TChange>[], didChange: false }),\n\t\t\thandleChange: (context, changeSummary) => {\n\t\t\t\tif (context.didChange(observable)) {\n\t\t\t\t\tconst e = context.change;\n\t\t\t\t\tif (e !== undefined) {\n\t\t\t\t\t\tchangeSummary.deltas.push(e as RemoveUndefined<TChange>);\n\t\t\t\t\t}\n\t\t\t\t\tchangeSummary.didChange = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\t}\n\t}, (reader, changeSummary) => {\n\t\tconst value = observable.read(reader);\n\t\tconst previousValue = _previousValue;\n\t\tif (changeSummary.didChange) {\n\t\t\t_previousValue = value;\n\t\t\t// didChange can never be true on the first autorun, so we know previousValue is defined\n\t\t\tcb(value, previousValue!, changeSummary.deltas);\n\t\t}\n\t\tif (_firstRun) {\n\t\t\t_firstRun = false;\n\t\t\t_previousValue = value;\n\t\t}\n\t});\n}\n\nexport function runOnChangeWithStore<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[], store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = runOnChange(observable, (value, previousValue: T, deltas) => {\n\t\tstore.clear();\n\t\tcb(value, previousValue, deltas, store);\n\t});\n\treturn {\n\t\tdispose() {\n\t\t\tdisposable.dispose();\n\t\t\tstore.dispose();\n\t\t}\n\t};\n}\n\nexport function runOnChangeWithCancellationToken<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[], token: CancellationToken) => Promise<void>): IDisposable {\n\treturn runOnChangeWithStore(observable, (value, previousValue, deltas, store) => {\n\t\tcb(value, previousValue, deltas, cancelOnDispose(store));\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservableWithChange } from '../base.js';\nimport { CancellationToken, cancelOnDispose } from '../commonFacade/cancellation.js';\nimport { DisposableStore, IDisposable } from '../commonFacade/deps.js';\nimport { autorunWithStoreHandleChanges } from '../reactions/autorun.js';\n\nexport type RemoveUndefined<T> = T extends undefined ? never : T;\n\nexport function runOnChange<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[]) => void): IDisposable {\n\tlet _previousValue: T | undefined;\n\tlet _firstRun = true;\n\treturn autorunWithStoreHandleChanges({\n\t\tchangeTracker: {\n\t\t\tcreateChangeSummary: () => ({ deltas: [] as RemoveUndefined<TChange>[], didChange: false }),\n\t\t\thandleChange: (context, changeSummary) => {\n\t\t\t\tif (context.didChange(observable)) {\n\t\t\t\t\tconst e = context.change;\n\t\t\t\t\tif (e !== undefined) {\n\t\t\t\t\t\tchangeSummary.deltas.push(e as RemoveUndefined<TChange>);\n\t\t\t\t\t}\n\t\t\t\t\tchangeSummary.didChange = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\t}\n\t}, (reader, changeSummary) => {\n\t\tconst value = observable.read(reader);\n\t\tconst previousValue = _previousValue;\n\t\tif (changeSummary.didChange) {\n\t\t\t_previousValue = value;\n\t\t\t// didChange can never be true on the first autorun, so we know previousValue is defined\n\t\t\tcb(value, previousValue!, changeSummary.deltas);\n\t\t}\n\t\tif (_firstRun) {\n\t\t\t_firstRun = false;\n\t\t\t_previousValue = value;\n\t\t}\n\t});\n}\n\nexport function runOnChangeWithStore<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[], store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = runOnChange(observable, (value, previousValue: T, deltas) => {\n\t\tstore.clear();\n\t\tcb(value, previousValue, deltas, store);\n\t});\n\treturn {\n\t\tdispose() {\n\t\t\tdisposable.dispose();\n\t\t\tstore.dispose();\n\t\t}\n\t};\n}\n\nexport function runOnChangeWithCancellationToken<T, TChange>(observable: IObservableWithChange<T, TChange>, cb: (value: T, previousValue: T, deltas: RemoveUndefined<TChange>[], token: CancellationToken) => Promise<void>): IDisposable {\n\treturn runOnChangeWithStore(observable, (value, previousValue, deltas, store) => {\n\t\tcb(value, previousValue, deltas, cancelOnDispose(store));\n\t});\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;AAGhG,OAAO,EAAqB,eAAe,EAAE,MAAM,iCAAiC,CAAC;;AACrF,OAAO,EAAE,eAAe,EAAe,MAAM,yBAAyB,CAAC;AACvE,OAAO,EAAE,6BAA6B,EAAE,MAAM,yBAAyB,CAAC;;;;AAIlE,SAAU,WAAW,CAAa,UAA6C,EAAE,EAA4E;IAClK,IAAI,cAA6B,CAAC;IAClC,IAAI,SAAS,GAAG,IAAI,CAAC;IACrB,WAAO,8OAA6B,EAAC;QACpC,aAAa,EAAE;YACd,mBAAmB,EAAE,GAAG,CAAG,CAAD,AAAE;oBAAE,MAAM,EAAE,EAAgC;oBAAE,SAAS,EAAE,KAAK;gBAAA,CAAE,CAAC;YAC3F,YAAY,EAAE,CAAC,OAAO,EAAE,aAAa,EAAE,EAAE;gBACxC,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC;oBACnC,MAAM,CAAC,GAAG,OAAO,CAAC,MAAM,CAAC;oBACzB,IAAI,CAAC,KAAK,SAAS,EAAE,CAAC;wBACrB,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC,CAA6B,CAAC,CAAC;oBAC1D,CAAC;oBACD,aAAa,CAAC,SAAS,GAAG,IAAI,CAAC;gBAChC,CAAC;gBACD,OAAO,IAAI,CAAC;YACb,CAAC;SACD;KACD,EAAE,CAAC,MAAM,EAAE,aAAa,EAAE,EAAE;QAC5B,MAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACtC,MAAM,aAAa,GAAG,cAAc,CAAC;QACrC,IAAI,aAAa,CAAC,SAAS,EAAE,CAAC;YAC7B,cAAc,GAAG,KAAK,CAAC;YACvB,wFAAwF;YACxF,EAAE,CAAC,KAAK,EAAE,aAAc,EAAE,aAAa,CAAC,MAAM,CAAC,CAAC;QACjD,CAAC;QACD,IAAI,SAAS,EAAE,CAAC;YACf,SAAS,GAAG,KAAK,CAAC;YAClB,cAAc,GAAG,KAAK,CAAC;QACxB,CAAC;IACF,CAAC,CAAC,CAAC;AACJ,CAAC;AAEK,SAAU,oBAAoB,CAAa,UAA6C,EAAE,EAAoG;IACnM,MAAM,KAAK,GAAG,IAAI,+LAAe,EAAE,CAAC;IACpC,MAAM,UAAU,GAAG,WAAW,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,aAAgB,EAAE,MAAM,EAAE,EAAE;QAC9E,KAAK,CAAC,KAAK,EAAE,CAAC;QACd,EAAE,CAAC,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;IACzC,CAAC,CAAC,CAAC;IACH,OAAO;QACN,OAAO;YACN,UAAU,CAAC,OAAO,EAAE,CAAC;YACrB,KAAK,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;KACD,CAAC;AACH,CAAC;AAEK,SAAU,gCAAgC,CAAa,UAA6C,EAAE,EAA+G;IAC1N,OAAO,oBAAoB,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,aAAa,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE;QAC/E,EAAE,CAAC,KAAK,EAAE,aAAa,EAAE,MAAM,MAAE,kMAAe,EAAC,KAAK,CAAC,CAAC,CAAC;IAC1D,CAAC,CAAC,CAAC;AACJ,CAAC","debugId":null}},
    {"offset": {"line": 2364, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/experimental/utils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/experimental/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/experimental/utils.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/experimental/vs/base/common/observableInternal/experimental/utils.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IReader } from '../base.js';\nimport { DebugOwner } from '../debugName.js';\nimport { derivedObservableWithCache } from '../utils/utils.js';\n\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined<T>(owner: DebugOwner, fn: (reader: IReader) => T): IObservable<T | undefined> {\n\treturn derivedObservableWithCache<T | undefined>(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable, IReader } from '../base.js';\nimport { DebugOwner } from '../debugName.js';\nimport { derivedObservableWithCache } from '../utils/utils.js';\n\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined<T>(owner: DebugOwner, fn: (reader: IReader) => T): IObservable<T | undefined> {\n\treturn derivedObservableWithCache<T | undefined>(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAIhG,OAAO,EAAE,0BAA0B,EAAE,MAAM,mBAAmB,CAAC;;AAOzD,SAAU,uBAAuB,CAAI,KAAiB,EAAE,EAA0B;IACvF,WAAO,qOAA0B,EAAgB,KAAK,EAAE,CAAC,MAAM,EAAE,SAAS,EAAE,CAAG,CAAD,QAAU,IAAI,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;AACzG,CAAC","debugId":null}},
    {"offset": {"line": 2380, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/consoleObservableLogger.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/logging/consoleObservableLogger.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/vs/base/common/observableInternal/logging/consoleObservableLogger.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { IObservableLogger, IChangeInformation, addLogger } from './logging.js';\nimport { getClassName } from '../debugName.js';\nimport { Derived } from '../observables/derivedImpl.js';\nimport { AutorunObserver } from '../reactions/autorunImpl.js';\n\nlet consoleObservableLogger: ConsoleObservableLogger | undefined;\n\nexport function logObservableToConsole(obs: IObservable<any>): void {\n\tif (!consoleObservableLogger) {\n\t\tconsoleObservableLogger = new ConsoleObservableLogger();\n\t\taddLogger(consoleObservableLogger);\n\t}\n\tconsoleObservableLogger.addFilteredObj(obs);\n}\n\nexport class ConsoleObservableLogger implements IObservableLogger {\n\tprivate indentation = 0;\n\n\tprivate _filteredObjects: Set<unknown> | undefined;\n\n\tpublic addFilteredObj(obj: unknown): void {\n\t\tif (!this._filteredObjects) {\n\t\t\tthis._filteredObjects = new Set();\n\t\t}\n\t\tthis._filteredObjects.add(obj);\n\t}\n\n\tprivate _isIncluded(obj: unknown): boolean {\n\t\treturn this._filteredObjects?.has(obj) ?? true;\n\t}\n\n\tprivate textToConsoleArgs(text: ConsoleText): unknown[] {\n\t\treturn consoleTextToArgs([\n\t\t\tnormalText(repeat('|  ', this.indentation)),\n\t\t\ttext,\n\t\t]);\n\t}\n\n\tprivate formatInfo(info: IChangeInformation): ConsoleText[] {\n\t\tif (!info.hadValue) {\n\t\t\treturn [\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.newValue, 60), {\n\t\t\t\t\tcolor: 'green',\n\t\t\t\t}),\n\t\t\t\tnormalText(` (initial)`),\n\t\t\t];\n\t\t}\n\t\treturn info.didChange\n\t\t\t? [\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.oldValue, 70), {\n\t\t\t\t\tcolor: 'red',\n\t\t\t\t\tstrikeThrough: true,\n\t\t\t\t}),\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.newValue, 60), {\n\t\t\t\t\tcolor: 'green',\n\t\t\t\t}),\n\t\t\t]\n\t\t\t: [normalText(` (unchanged)`)];\n\t}\n\n\thandleObservableCreated(observable: IObservable<any>): void {\n\t\tif (observable instanceof Derived) {\n\t\t\tconst derived = observable;\n\t\t\tthis.changedObservablesSets.set(derived, new Set());\n\n\t\t\tconst debugTrackUpdating = false;\n\t\t\tif (debugTrackUpdating) {\n\t\t\t\tconst updating: IObservable<any>[] = [];\n\t\t\t\t(derived as any).__debugUpdating = updating;\n\n\t\t\t\tconst existingBeginUpdate = derived.beginUpdate;\n\t\t\t\tderived.beginUpdate = (obs) => {\n\t\t\t\t\tupdating.push(obs);\n\t\t\t\t\treturn existingBeginUpdate.apply(derived, [obs]);\n\t\t\t\t};\n\n\t\t\t\tconst existingEndUpdate = derived.endUpdate;\n\t\t\t\tderived.endUpdate = (obs) => {\n\t\t\t\t\tconst idx = updating.indexOf(obs);\n\t\t\t\t\tif (idx === -1) {\n\t\t\t\t\t\tconsole.error('endUpdate called without beginUpdate', derived.debugName, obs.debugName);\n\t\t\t\t\t}\n\t\t\t\t\tupdating.splice(idx, 1);\n\t\t\t\t\treturn existingEndUpdate.apply(derived, [obs]);\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\thandleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void {\n\t}\n\n\thandleObservableUpdated(observable: IObservable<unknown>, info: IChangeInformation): void {\n\t\tif (!this._isIncluded(observable)) { return; }\n\t\tif (observable instanceof Derived) {\n\t\t\tthis._handleDerivedRecomputed(observable, info);\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('observable value changed'),\n\t\t\tstyled(observable.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t]));\n\t}\n\n\tprivate readonly changedObservablesSets = new WeakMap<object, Set<IObservable<any>>>();\n\n\tformatChanges(changes: Set<IObservable<any>>): ConsoleText | undefined {\n\t\tif (changes.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn styled(\n\t\t\t' (changed deps: ' +\n\t\t\t[...changes].map((o) => o.debugName).join(', ') +\n\t\t\t')',\n\t\t\t{ color: 'gray' }\n\t\t);\n\t}\n\n\thandleDerivedDependencyChanged(derived: Derived<any>, observable: IObservable<any>, change: unknown): void {\n\t\tif (!this._isIncluded(derived)) { return; }\n\n\t\tthis.changedObservablesSets.get(derived)?.add(observable);\n\t}\n\n\t_handleDerivedRecomputed(derived: Derived<unknown>, info: IChangeInformation): void {\n\t\tif (!this._isIncluded(derived)) { return; }\n\n\t\tconst changedObservables = this.changedObservablesSets.get(derived);\n\t\tif (!changedObservables) { return; }\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('derived recomputed'),\n\t\t\tstyled(derived.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t\tthis.formatChanges(changedObservables),\n\t\t\t{ data: [{ fn: derived._debugNameData.referenceFn ?? derived._computeFn }] }\n\t\t]));\n\t\tchangedObservables.clear();\n\t}\n\n\thandleDerivedCleared(derived: Derived<unknown>): void {\n\t\tif (!this._isIncluded(derived)) { return; }\n\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('derived cleared'),\n\t\t\tstyled(derived.debugName, { color: 'BlueViolet' }),\n\t\t]));\n\t}\n\n\thandleAutorunCreated(autorun: AutorunObserver): void {\n\t\tif (!this._isIncluded(autorun)) { return; }\n\n\t\tthis.changedObservablesSets.set(autorun, new Set());\n\t}\n\n\thandleAutorunDisposed(autorun: AutorunObserver): void {\n\t}\n\n\thandleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void {\n\t\tif (!this._isIncluded(autorun)) { return; }\n\n\t\tthis.changedObservablesSets.get(autorun)!.add(observable);\n\t}\n\n\thandleAutorunStarted(autorun: AutorunObserver): void {\n\t\tconst changedObservables = this.changedObservablesSets.get(autorun);\n\t\tif (!changedObservables) { return; }\n\n\t\tif (this._isIncluded(autorun)) {\n\t\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\t\tformatKind('autorun'),\n\t\t\t\tstyled(autorun.debugName, { color: 'BlueViolet' }),\n\t\t\t\tthis.formatChanges(changedObservables),\n\t\t\t\t{ data: [{ fn: autorun._debugNameData.referenceFn ?? autorun._runFn }] }\n\t\t\t]));\n\t\t}\n\t\tchangedObservables.clear();\n\t\tthis.indentation++;\n\t}\n\n\thandleAutorunFinished(autorun: AutorunObserver): void {\n\t\tthis.indentation--;\n\t}\n\n\thandleBeginTransaction(transaction: TransactionImpl): void {\n\t\tlet transactionName = transaction.getDebugName();\n\t\tif (transactionName === undefined) {\n\t\t\ttransactionName = '';\n\t\t}\n\t\tif (this._isIncluded(transaction)) {\n\t\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\t\tformatKind('transaction'),\n\t\t\t\tstyled(transactionName, { color: 'BlueViolet' }),\n\t\t\t\t{ data: [{ fn: transaction._fn }] }\n\t\t\t]));\n\t\t}\n\t\tthis.indentation++;\n\t}\n\n\thandleEndTransaction(): void {\n\t\tthis.indentation--;\n\t}\n}\ntype ConsoleText = (ConsoleText | undefined)[] |\n{ text: string; style: string; data?: unknown[] } |\n{ data: unknown[] };\nfunction consoleTextToArgs(text: ConsoleText): unknown[] {\n\tconst styles = new Array<any>();\n\tconst data: unknown[] = [];\n\tlet firstArg = '';\n\n\tfunction process(t: ConsoleText): void {\n\t\tif ('length' in t) {\n\t\t\tfor (const item of t) {\n\t\t\t\tif (item) {\n\t\t\t\t\tprocess(item);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('text' in t) {\n\t\t\tfirstArg += `%c${t.text}`;\n\t\t\tstyles.push(t.style);\n\t\t\tif (t.data) {\n\t\t\t\tdata.push(...t.data);\n\t\t\t}\n\t\t} else if ('data' in t) {\n\t\t\tdata.push(...t.data);\n\t\t}\n\t}\n\n\tprocess(text);\n\n\tconst result = [firstArg, ...styles];\n\tresult.push(...data);\n\treturn result;\n}\nfunction normalText(text: string): ConsoleText {\n\treturn styled(text, { color: 'black' });\n}\nfunction formatKind(kind: string): ConsoleText {\n\treturn styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });\n}\nfunction styled(\n\ttext: string,\n\toptions: { color: string; strikeThrough?: boolean; bold?: boolean } = {\n\t\tcolor: 'black',\n\t}\n): ConsoleText {\n\tfunction objToCss(styleObj: Record<string, string>): string {\n\t\treturn Object.entries(styleObj).reduce(\n\t\t\t(styleString, [propName, propValue]) => {\n\t\t\t\treturn `${styleString}${propName}:${propValue};`;\n\t\t\t},\n\t\t\t''\n\t\t);\n\t}\n\n\tconst style: Record<string, string> = {\n\t\tcolor: options.color,\n\t};\n\tif (options.strikeThrough) {\n\t\tstyle['text-decoration'] = 'line-through';\n\t}\n\tif (options.bold) {\n\t\tstyle['font-weight'] = 'bold';\n\t}\n\n\treturn {\n\t\ttext,\n\t\tstyle: objToCss(style),\n\t};\n}\n\nexport function formatValue(value: unknown, availableLen: number): string {\n\tswitch (typeof value) {\n\t\tcase 'number':\n\t\t\treturn '' + value;\n\t\tcase 'string':\n\t\t\tif (value.length + 2 <= availableLen) {\n\t\t\t\treturn `\"${value}\"`;\n\t\t\t}\n\t\t\treturn `\"${value.substr(0, availableLen - 7)}\"+...`;\n\n\t\tcase 'boolean':\n\t\t\treturn value ? 'true' : 'false';\n\t\tcase 'undefined':\n\t\t\treturn 'undefined';\n\t\tcase 'object':\n\t\t\tif (value === null) {\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn formatArray(value, availableLen);\n\t\t\t}\n\t\t\treturn formatObject(value, availableLen);\n\t\tcase 'symbol':\n\t\t\treturn value.toString();\n\t\tcase 'function':\n\t\t\treturn `[[Function${value.name ? ' ' + value.name : ''}]]`;\n\t\tdefault:\n\t\t\treturn '' + value;\n\t}\n}\n\nfunction formatArray(value: unknown[], availableLen: number): string {\n\tlet result = '[ ';\n\tlet first = true;\n\tfor (const val of value) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += ' ]';\n\treturn result;\n}\n\nfunction formatObject(value: object, availableLen: number): string {\n\tif (typeof value.toString === 'function' && value.toString !== Object.prototype.toString) {\n\t\tconst val = value.toString();\n\t\tif (val.length <= availableLen) {\n\t\t\treturn val;\n\t\t}\n\t\treturn val.substring(0, availableLen - 3) + '...';\n\t}\n\n\tconst className = getClassName(value);\n\n\tlet result = className ? className + '(' : '{ ';\n\tlet first = true;\n\tfor (const [key, val] of Object.entries(value)) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${key}: ${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += className ? ')' : ' }';\n\treturn result;\n}\n\nfunction repeat(str: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 1; i <= count; i++) {\n\t\tresult += str;\n\t}\n\treturn result;\n}\n\nfunction padStr(str: string, length: number): string {\n\twhile (str.length < length) {\n\t\tstr += ' ';\n\t}\n\treturn str;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IObservable } from '../base.js';\nimport { TransactionImpl } from '../transaction.js';\nimport { IObservableLogger, IChangeInformation, addLogger } from './logging.js';\nimport { getClassName } from '../debugName.js';\nimport { Derived } from '../observables/derivedImpl.js';\nimport { AutorunObserver } from '../reactions/autorunImpl.js';\n\nlet consoleObservableLogger: ConsoleObservableLogger | undefined;\n\nexport function logObservableToConsole(obs: IObservable<any>): void {\n\tif (!consoleObservableLogger) {\n\t\tconsoleObservableLogger = new ConsoleObservableLogger();\n\t\taddLogger(consoleObservableLogger);\n\t}\n\tconsoleObservableLogger.addFilteredObj(obs);\n}\n\nexport class ConsoleObservableLogger implements IObservableLogger {\n\tprivate indentation = 0;\n\n\tprivate _filteredObjects: Set<unknown> | undefined;\n\n\tpublic addFilteredObj(obj: unknown): void {\n\t\tif (!this._filteredObjects) {\n\t\t\tthis._filteredObjects = new Set();\n\t\t}\n\t\tthis._filteredObjects.add(obj);\n\t}\n\n\tprivate _isIncluded(obj: unknown): boolean {\n\t\treturn this._filteredObjects?.has(obj) ?? true;\n\t}\n\n\tprivate textToConsoleArgs(text: ConsoleText): unknown[] {\n\t\treturn consoleTextToArgs([\n\t\t\tnormalText(repeat('|  ', this.indentation)),\n\t\t\ttext,\n\t\t]);\n\t}\n\n\tprivate formatInfo(info: IChangeInformation): ConsoleText[] {\n\t\tif (!info.hadValue) {\n\t\t\treturn [\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.newValue, 60), {\n\t\t\t\t\tcolor: 'green',\n\t\t\t\t}),\n\t\t\t\tnormalText(` (initial)`),\n\t\t\t];\n\t\t}\n\t\treturn info.didChange\n\t\t\t? [\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.oldValue, 70), {\n\t\t\t\t\tcolor: 'red',\n\t\t\t\t\tstrikeThrough: true,\n\t\t\t\t}),\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.newValue, 60), {\n\t\t\t\t\tcolor: 'green',\n\t\t\t\t}),\n\t\t\t]\n\t\t\t: [normalText(` (unchanged)`)];\n\t}\n\n\thandleObservableCreated(observable: IObservable<any>): void {\n\t\tif (observable instanceof Derived) {\n\t\t\tconst derived = observable;\n\t\t\tthis.changedObservablesSets.set(derived, new Set());\n\n\t\t\tconst debugTrackUpdating = false;\n\t\t\tif (debugTrackUpdating) {\n\t\t\t\tconst updating: IObservable<any>[] = [];\n\t\t\t\t(derived as any).__debugUpdating = updating;\n\n\t\t\t\tconst existingBeginUpdate = derived.beginUpdate;\n\t\t\t\tderived.beginUpdate = (obs) => {\n\t\t\t\t\tupdating.push(obs);\n\t\t\t\t\treturn existingBeginUpdate.apply(derived, [obs]);\n\t\t\t\t};\n\n\t\t\t\tconst existingEndUpdate = derived.endUpdate;\n\t\t\t\tderived.endUpdate = (obs) => {\n\t\t\t\t\tconst idx = updating.indexOf(obs);\n\t\t\t\t\tif (idx === -1) {\n\t\t\t\t\t\tconsole.error('endUpdate called without beginUpdate', derived.debugName, obs.debugName);\n\t\t\t\t\t}\n\t\t\t\t\tupdating.splice(idx, 1);\n\t\t\t\t\treturn existingEndUpdate.apply(derived, [obs]);\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\thandleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void {\n\t}\n\n\thandleObservableUpdated(observable: IObservable<unknown>, info: IChangeInformation): void {\n\t\tif (!this._isIncluded(observable)) { return; }\n\t\tif (observable instanceof Derived) {\n\t\t\tthis._handleDerivedRecomputed(observable, info);\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('observable value changed'),\n\t\t\tstyled(observable.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t]));\n\t}\n\n\tprivate readonly changedObservablesSets = new WeakMap<object, Set<IObservable<any>>>();\n\n\tformatChanges(changes: Set<IObservable<any>>): ConsoleText | undefined {\n\t\tif (changes.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn styled(\n\t\t\t' (changed deps: ' +\n\t\t\t[...changes].map((o) => o.debugName).join(', ') +\n\t\t\t')',\n\t\t\t{ color: 'gray' }\n\t\t);\n\t}\n\n\thandleDerivedDependencyChanged(derived: Derived<any>, observable: IObservable<any>, change: unknown): void {\n\t\tif (!this._isIncluded(derived)) { return; }\n\n\t\tthis.changedObservablesSets.get(derived)?.add(observable);\n\t}\n\n\t_handleDerivedRecomputed(derived: Derived<unknown>, info: IChangeInformation): void {\n\t\tif (!this._isIncluded(derived)) { return; }\n\n\t\tconst changedObservables = this.changedObservablesSets.get(derived);\n\t\tif (!changedObservables) { return; }\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('derived recomputed'),\n\t\t\tstyled(derived.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t\tthis.formatChanges(changedObservables),\n\t\t\t{ data: [{ fn: derived._debugNameData.referenceFn ?? derived._computeFn }] }\n\t\t]));\n\t\tchangedObservables.clear();\n\t}\n\n\thandleDerivedCleared(derived: Derived<unknown>): void {\n\t\tif (!this._isIncluded(derived)) { return; }\n\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('derived cleared'),\n\t\t\tstyled(derived.debugName, { color: 'BlueViolet' }),\n\t\t]));\n\t}\n\n\thandleAutorunCreated(autorun: AutorunObserver): void {\n\t\tif (!this._isIncluded(autorun)) { return; }\n\n\t\tthis.changedObservablesSets.set(autorun, new Set());\n\t}\n\n\thandleAutorunDisposed(autorun: AutorunObserver): void {\n\t}\n\n\thandleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void {\n\t\tif (!this._isIncluded(autorun)) { return; }\n\n\t\tthis.changedObservablesSets.get(autorun)!.add(observable);\n\t}\n\n\thandleAutorunStarted(autorun: AutorunObserver): void {\n\t\tconst changedObservables = this.changedObservablesSets.get(autorun);\n\t\tif (!changedObservables) { return; }\n\n\t\tif (this._isIncluded(autorun)) {\n\t\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\t\tformatKind('autorun'),\n\t\t\t\tstyled(autorun.debugName, { color: 'BlueViolet' }),\n\t\t\t\tthis.formatChanges(changedObservables),\n\t\t\t\t{ data: [{ fn: autorun._debugNameData.referenceFn ?? autorun._runFn }] }\n\t\t\t]));\n\t\t}\n\t\tchangedObservables.clear();\n\t\tthis.indentation++;\n\t}\n\n\thandleAutorunFinished(autorun: AutorunObserver): void {\n\t\tthis.indentation--;\n\t}\n\n\thandleBeginTransaction(transaction: TransactionImpl): void {\n\t\tlet transactionName = transaction.getDebugName();\n\t\tif (transactionName === undefined) {\n\t\t\ttransactionName = '';\n\t\t}\n\t\tif (this._isIncluded(transaction)) {\n\t\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\t\tformatKind('transaction'),\n\t\t\t\tstyled(transactionName, { color: 'BlueViolet' }),\n\t\t\t\t{ data: [{ fn: transaction._fn }] }\n\t\t\t]));\n\t\t}\n\t\tthis.indentation++;\n\t}\n\n\thandleEndTransaction(): void {\n\t\tthis.indentation--;\n\t}\n}\ntype ConsoleText = (ConsoleText | undefined)[] |\n{ text: string; style: string; data?: unknown[] } |\n{ data: unknown[] };\nfunction consoleTextToArgs(text: ConsoleText): unknown[] {\n\tconst styles = new Array<any>();\n\tconst data: unknown[] = [];\n\tlet firstArg = '';\n\n\tfunction process(t: ConsoleText): void {\n\t\tif ('length' in t) {\n\t\t\tfor (const item of t) {\n\t\t\t\tif (item) {\n\t\t\t\t\tprocess(item);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('text' in t) {\n\t\t\tfirstArg += `%c${t.text}`;\n\t\t\tstyles.push(t.style);\n\t\t\tif (t.data) {\n\t\t\t\tdata.push(...t.data);\n\t\t\t}\n\t\t} else if ('data' in t) {\n\t\t\tdata.push(...t.data);\n\t\t}\n\t}\n\n\tprocess(text);\n\n\tconst result = [firstArg, ...styles];\n\tresult.push(...data);\n\treturn result;\n}\nfunction normalText(text: string): ConsoleText {\n\treturn styled(text, { color: 'black' });\n}\nfunction formatKind(kind: string): ConsoleText {\n\treturn styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });\n}\nfunction styled(\n\ttext: string,\n\toptions: { color: string; strikeThrough?: boolean; bold?: boolean } = {\n\t\tcolor: 'black',\n\t}\n): ConsoleText {\n\tfunction objToCss(styleObj: Record<string, string>): string {\n\t\treturn Object.entries(styleObj).reduce(\n\t\t\t(styleString, [propName, propValue]) => {\n\t\t\t\treturn `${styleString}${propName}:${propValue};`;\n\t\t\t},\n\t\t\t''\n\t\t);\n\t}\n\n\tconst style: Record<string, string> = {\n\t\tcolor: options.color,\n\t};\n\tif (options.strikeThrough) {\n\t\tstyle['text-decoration'] = 'line-through';\n\t}\n\tif (options.bold) {\n\t\tstyle['font-weight'] = 'bold';\n\t}\n\n\treturn {\n\t\ttext,\n\t\tstyle: objToCss(style),\n\t};\n}\n\nexport function formatValue(value: unknown, availableLen: number): string {\n\tswitch (typeof value) {\n\t\tcase 'number':\n\t\t\treturn '' + value;\n\t\tcase 'string':\n\t\t\tif (value.length + 2 <= availableLen) {\n\t\t\t\treturn `\"${value}\"`;\n\t\t\t}\n\t\t\treturn `\"${value.substr(0, availableLen - 7)}\"+...`;\n\n\t\tcase 'boolean':\n\t\t\treturn value ? 'true' : 'false';\n\t\tcase 'undefined':\n\t\t\treturn 'undefined';\n\t\tcase 'object':\n\t\t\tif (value === null) {\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn formatArray(value, availableLen);\n\t\t\t}\n\t\t\treturn formatObject(value, availableLen);\n\t\tcase 'symbol':\n\t\t\treturn value.toString();\n\t\tcase 'function':\n\t\t\treturn `[[Function${value.name ? ' ' + value.name : ''}]]`;\n\t\tdefault:\n\t\t\treturn '' + value;\n\t}\n}\n\nfunction formatArray(value: unknown[], availableLen: number): string {\n\tlet result = '[ ';\n\tlet first = true;\n\tfor (const val of value) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += ' ]';\n\treturn result;\n}\n\nfunction formatObject(value: object, availableLen: number): string {\n\tif (typeof value.toString === 'function' && value.toString !== Object.prototype.toString) {\n\t\tconst val = value.toString();\n\t\tif (val.length <= availableLen) {\n\t\t\treturn val;\n\t\t}\n\t\treturn val.substring(0, availableLen - 3) + '...';\n\t}\n\n\tconst className = getClassName(value);\n\n\tlet result = className ? className + '(' : '{ ';\n\tlet first = true;\n\tfor (const [key, val] of Object.entries(value)) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${key}: ${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += className ? ')' : ' }';\n\treturn result;\n}\n\nfunction repeat(str: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 1; i <= count; i++) {\n\t\tresult += str;\n\t}\n\treturn result;\n}\n\nfunction padStr(str: string, length: number): string {\n\twhile (str.length < length) {\n\t\tstr += ' ';\n\t}\n\treturn str;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2743, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/rpc.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/logging/debugger/rpc.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/vs/base/common/observableInternal/logging/debugger/rpc.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type ChannelFactory = (handler: IChannelHandler) => IChannel;\n\nexport interface IChannel {\n\tsendNotification(data: unknown): void;\n\tsendRequest(data: unknown): Promise<RpcRequestResult>;\n}\n\nexport interface IChannelHandler {\n\thandleNotification(notificationData: unknown): void;\n\thandleRequest(requestData: unknown): Promise<RpcRequestResult> | RpcRequestResult;\n}\n\nexport type RpcRequestResult = { type: 'result'; value: unknown } | { type: 'error'; value: unknown };\n\nexport type API = {\n\thost: Side;\n\tclient: Side;\n};\n\nexport type Side = {\n\tnotifications: Record<string, (...args: any[]) => void>;\n\trequests: Record<string, (...args: any[]) => Promise<unknown> | unknown>;\n};\n\ntype MakeAsyncIfNot<TFn> = TFn extends (...args: infer TArgs) => infer TResult ? TResult extends Promise<unknown> ? TFn : (...args: TArgs) => Promise<TResult> : never;\n\nexport type MakeSideAsync<T extends Side> = {\n\tnotifications: T['notifications'];\n\trequests: { [K in keyof T['requests']]: MakeAsyncIfNot<T['requests'][K]> };\n};\n\nexport class SimpleTypedRpcConnection<T extends Side> {\n\n\tpublic static createClient<T extends API>(channelFactory: ChannelFactory, getHandler: () => T['client']): SimpleTypedRpcConnection<MakeSideAsync<T['host']>> {\n\t\treturn new SimpleTypedRpcConnection(channelFactory, getHandler);\n\t}\n\n\tpublic readonly api: T;\n\tprivate readonly _channel: IChannel;\n\n\tprivate constructor(\n\t\tprivate readonly _channelFactory: ChannelFactory,\n\t\tprivate readonly _getHandler: () => Side,\n\t) {\n\t\tthis._channel = this._channelFactory({\n\t\t\thandleNotification: (notificationData) => {\n\t\t\t\tconst m = notificationData as OutgoingMessage;\n\t\t\t\tconst fn = this._getHandler().notifications[m[0]];\n\t\t\t\tif (!fn) {\n\t\t\t\t\tthrow new Error(`Unknown notification \"${m[0]}\"!`);\n\t\t\t\t}\n\t\t\t\tfn(...m[1]);\n\t\t\t},\n\t\t\thandleRequest: (requestData) => {\n\t\t\t\tconst m = requestData as OutgoingMessage;\n\t\t\t\ttry {\n\t\t\t\t\tconst result = this._getHandler().requests[m[0]](...m[1]);\n\t\t\t\t\treturn { type: 'result', value: result };\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn { type: 'error', value: e };\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\n\t\tconst requests = new Proxy({}, {\n\t\t\tget: (target, key: string) => {\n\t\t\t\treturn async (...args: any[]) => {\n\t\t\t\t\tconst result = await this._channel.sendRequest([key, args] satisfies OutgoingMessage);\n\t\t\t\t\tif (result.type === 'error') {\n\t\t\t\t\t\tthrow result.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn result.value;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tconst notifications = new Proxy({}, {\n\t\t\tget: (target, key: string) => {\n\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\tthis._channel.sendNotification([key, args] satisfies OutgoingMessage);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tthis.api = { notifications: notifications, requests: requests } as any;\n\t}\n}\n\ntype OutgoingMessage = [\n\tmethod: string,\n\targs: unknown[],\n];\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type ChannelFactory = (handler: IChannelHandler) => IChannel;\n\nexport interface IChannel {\n\tsendNotification(data: unknown): void;\n\tsendRequest(data: unknown): Promise<RpcRequestResult>;\n}\n\nexport interface IChannelHandler {\n\thandleNotification(notificationData: unknown): void;\n\thandleRequest(requestData: unknown): Promise<RpcRequestResult> | RpcRequestResult;\n}\n\nexport type RpcRequestResult = { type: 'result'; value: unknown } | { type: 'error'; value: unknown };\n\nexport type API = {\n\thost: Side;\n\tclient: Side;\n};\n\nexport type Side = {\n\tnotifications: Record<string, (...args: any[]) => void>;\n\trequests: Record<string, (...args: any[]) => Promise<unknown> | unknown>;\n};\n\ntype MakeAsyncIfNot<TFn> = TFn extends (...args: infer TArgs) => infer TResult ? TResult extends Promise<unknown> ? TFn : (...args: TArgs) => Promise<TResult> : never;\n\nexport type MakeSideAsync<T extends Side> = {\n\tnotifications: T['notifications'];\n\trequests: { [K in keyof T['requests']]: MakeAsyncIfNot<T['requests'][K]> };\n};\n\nexport class SimpleTypedRpcConnection<T extends Side> {\n\n\tpublic static createClient<T extends API>(channelFactory: ChannelFactory, getHandler: () => T['client']): SimpleTypedRpcConnection<MakeSideAsync<T['host']>> {\n\t\treturn new SimpleTypedRpcConnection(channelFactory, getHandler);\n\t}\n\n\tpublic readonly api: T;\n\tprivate readonly _channel: IChannel;\n\n\tprivate constructor(\n\t\tprivate readonly _channelFactory: ChannelFactory,\n\t\tprivate readonly _getHandler: () => Side,\n\t) {\n\t\tthis._channel = this._channelFactory({\n\t\t\thandleNotification: (notificationData) => {\n\t\t\t\tconst m = notificationData as OutgoingMessage;\n\t\t\t\tconst fn = this._getHandler().notifications[m[0]];\n\t\t\t\tif (!fn) {\n\t\t\t\t\tthrow new Error(`Unknown notification \"${m[0]}\"!`);\n\t\t\t\t}\n\t\t\t\tfn(...m[1]);\n\t\t\t},\n\t\t\thandleRequest: (requestData) => {\n\t\t\t\tconst m = requestData as OutgoingMessage;\n\t\t\t\ttry {\n\t\t\t\t\tconst result = this._getHandler().requests[m[0]](...m[1]);\n\t\t\t\t\treturn { type: 'result', value: result };\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn { type: 'error', value: e };\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\n\t\tconst requests = new Proxy({}, {\n\t\t\tget: (target, key: string) => {\n\t\t\t\treturn async (...args: any[]) => {\n\t\t\t\t\tconst result = await this._channel.sendRequest([key, args] satisfies OutgoingMessage);\n\t\t\t\t\tif (result.type === 'error') {\n\t\t\t\t\t\tthrow result.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn result.value;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tconst notifications = new Proxy({}, {\n\t\t\tget: (target, key: string) => {\n\t\t\t\treturn (...args: any[]) => {\n\t\t\t\t\tthis._channel.sendNotification([key, args] satisfies OutgoingMessage);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tthis.api = { notifications: notifications, requests: requests } as any;\n\t}\n}\n\ntype OutgoingMessage = [\n\tmethod: string,\n\targs: unknown[],\n];\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAiC1F,MAAO,wBAAwB;IAE7B,MAAM,CAAC,YAAY,CAAgB,cAA8B,EAAE,UAA6B,EAAA;QACtG,OAAO,IAAI,wBAAwB,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;IACjE,CAAC;IAKD,YACkB,eAA+B,EAC/B,WAAuB,CAAA;QADvB,IAAA,CAAA,eAAe,GAAf,eAAe,CAAgB;QAC/B,IAAA,CAAA,WAAW,GAAX,WAAW,CAAY;QAExC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC;YACpC,kBAAkB,EAAE,CAAC,gBAAgB,EAAE,EAAE;gBACxC,MAAM,CAAC,GAAG,gBAAmC,CAAC;gBAC9C,MAAM,EAAE,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAClD,IAAI,CAAC,EAAE,EAAE,CAAC;oBACT,MAAM,IAAI,KAAK,CAAC,CAAA,sBAAA,EAAyB,CAAC,CAAC,CAAC,CAAC,CAAA,EAAA,CAAI,CAAC,CAAC;gBACpD,CAAC;gBACD,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACb,CAAC;YACD,aAAa,EAAE,CAAC,WAAW,EAAE,EAAE;gBAC9B,MAAM,CAAC,GAAG,WAA8B,CAAC;gBACzC,IAAI,CAAC;oBACJ,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC1D,OAAO;wBAAE,IAAI,EAAE,QAAQ;wBAAE,KAAK,EAAE,MAAM;oBAAA,CAAE,CAAC;gBAC1C,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;oBACZ,OAAO;wBAAE,IAAI,EAAE,OAAO;wBAAE,KAAK,EAAE,CAAC;oBAAA,CAAE,CAAC;gBACpC,CAAC;YACF,CAAC;SACD,CAAC,CAAC;QAEH,MAAM,QAAQ,GAAG,IAAI,KAAK,CAAC,CAAA,CAAE,EAAE;YAC9B,GAAG,EAAE,CAAC,MAAM,EAAE,GAAW,EAAE,EAAE;gBAC5B,OAAO,KAAK,EAAE,GAAG,IAAW,EAAE,EAAE;oBAC/B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC;wBAAC,GAAG;wBAAE,IAAI;qBAA2B,CAAC,CAAC;oBACtF,IAAI,MAAM,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;wBAC7B,MAAM,MAAM,CAAC,KAAK,CAAC;oBACpB,CAAC,MAAM,CAAC;wBACP,OAAO,MAAM,CAAC,KAAK,CAAC;oBACrB,CAAC;gBACF,CAAC,CAAC;YACH,CAAC;SACD,CAAC,CAAC;QAEH,MAAM,aAAa,GAAG,IAAI,KAAK,CAAC,CAAA,CAAE,EAAE;YACnC,GAAG,EAAE,CAAC,MAAM,EAAE,GAAW,EAAE,EAAE;gBAC5B,OAAO,CAAC,GAAG,IAAW,EAAE,EAAE;oBACzB,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC;wBAAC,GAAG;wBAAE,IAAI;qBAA2B,CAAC,CAAC;gBACvE,CAAC,CAAC;YACH,CAAC;SACD,CAAC,CAAC;QAEH,IAAI,CAAC,GAAG,GAAG;YAAE,aAAa,EAAE,aAAa;YAAE,QAAQ,EAAE,QAAQ;QAAA,CAAS,CAAC;IACxE,CAAC;CACD","debugId":null}},
    {"offset": {"line": 2817, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/debuggerRpc.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/logging/debugger/debuggerRpc.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/vs/base/common/observableInternal/logging/debugger/debuggerRpc.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChannelFactory, IChannelHandler, API, SimpleTypedRpcConnection, MakeSideAsync } from './rpc.js';\n\nexport function registerDebugChannel<T extends { channelId: string } & API>(\n\tchannelId: T['channelId'],\n\tcreateClient: () => T['client'],\n): SimpleTypedRpcConnection<MakeSideAsync<T['host']>> {\n\tconst g = globalThis as any as GlobalObj;\n\n\tlet queuedNotifications: unknown[] = [];\n\tlet curHost: IHost | undefined = undefined;\n\n\tconst { channel, handler } = createChannelFactoryFromDebugChannel({\n\t\tsendNotification: (data) => {\n\t\t\tif (curHost) {\n\t\t\t\tcurHost.sendNotification(data);\n\t\t\t} else {\n\t\t\t\tqueuedNotifications.push(data);\n\t\t\t}\n\t\t},\n\t});\n\n\tlet curClient: T['client'] | undefined = undefined;\n\n\t(g.$$debugValueEditor_debugChannels ?? (g.$$debugValueEditor_debugChannels = {}))[channelId] = (host) => {\n\t\tcurClient = createClient();\n\t\tcurHost = host;\n\t\tfor (const n of queuedNotifications) {\n\t\t\thost.sendNotification(n);\n\t\t}\n\t\tqueuedNotifications = [];\n\t\treturn handler;\n\t};\n\n\treturn SimpleTypedRpcConnection.createClient<T>(channel, () => {\n\t\tif (!curClient) { throw new Error('Not supported'); }\n\t\treturn curClient;\n\t});\n}\n\ninterface GlobalObj {\n\t$$debugValueEditor_debugChannels: Record<string, (host: IHost) => { handleRequest: (data: unknown) => unknown }>;\n}\n\ninterface IHost {\n\tsendNotification: (data: unknown) => void;\n}\n\nfunction createChannelFactoryFromDebugChannel(host: IHost): { channel: ChannelFactory; handler: { handleRequest: (data: unknown) => unknown } } {\n\tlet h: IChannelHandler | undefined;\n\tconst channel: ChannelFactory = (handler) => {\n\t\th = handler;\n\t\treturn {\n\t\t\tsendNotification: data => {\n\t\t\t\thost.sendNotification(data);\n\t\t\t},\n\t\t\tsendRequest: data => {\n\t\t\t\tthrow new Error('not supported');\n\t\t\t},\n\t\t};\n\t};\n\treturn {\n\t\tchannel: channel,\n\t\thandler: {\n\t\t\thandleRequest: (data: any) => {\n\t\t\t\tif (data.type === 'notification') {\n\t\t\t\t\treturn h?.handleNotification(data.data);\n\t\t\t\t} else {\n\t\t\t\t\treturn h?.handleRequest(data.data);\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ChannelFactory, IChannelHandler, API, SimpleTypedRpcConnection, MakeSideAsync } from './rpc.js';\n\nexport function registerDebugChannel<T extends { channelId: string } & API>(\n\tchannelId: T['channelId'],\n\tcreateClient: () => T['client'],\n): SimpleTypedRpcConnection<MakeSideAsync<T['host']>> {\n\tconst g = globalThis as any as GlobalObj;\n\n\tlet queuedNotifications: unknown[] = [];\n\tlet curHost: IHost | undefined = undefined;\n\n\tconst { channel, handler } = createChannelFactoryFromDebugChannel({\n\t\tsendNotification: (data) => {\n\t\t\tif (curHost) {\n\t\t\t\tcurHost.sendNotification(data);\n\t\t\t} else {\n\t\t\t\tqueuedNotifications.push(data);\n\t\t\t}\n\t\t},\n\t});\n\n\tlet curClient: T['client'] | undefined = undefined;\n\n\t(g.$$debugValueEditor_debugChannels ?? (g.$$debugValueEditor_debugChannels = {}))[channelId] = (host) => {\n\t\tcurClient = createClient();\n\t\tcurHost = host;\n\t\tfor (const n of queuedNotifications) {\n\t\t\thost.sendNotification(n);\n\t\t}\n\t\tqueuedNotifications = [];\n\t\treturn handler;\n\t};\n\n\treturn SimpleTypedRpcConnection.createClient<T>(channel, () => {\n\t\tif (!curClient) { throw new Error('Not supported'); }\n\t\treturn curClient;\n\t});\n}\n\ninterface GlobalObj {\n\t$$debugValueEditor_debugChannels: Record<string, (host: IHost) => { handleRequest: (data: unknown) => unknown }>;\n}\n\ninterface IHost {\n\tsendNotification: (data: unknown) => void;\n}\n\nfunction createChannelFactoryFromDebugChannel(host: IHost): { channel: ChannelFactory; handler: { handleRequest: (data: unknown) => unknown } } {\n\tlet h: IChannelHandler | undefined;\n\tconst channel: ChannelFactory = (handler) => {\n\t\th = handler;\n\t\treturn {\n\t\t\tsendNotification: data => {\n\t\t\t\thost.sendNotification(data);\n\t\t\t},\n\t\t\tsendRequest: data => {\n\t\t\t\tthrow new Error('not supported');\n\t\t\t},\n\t\t};\n\t};\n\treturn {\n\t\tchannel: channel,\n\t\thandler: {\n\t\t\thandleRequest: (data: any) => {\n\t\t\t\tif (data.type === 'notification') {\n\t\t\t\t\treturn h?.handleNotification(data.data);\n\t\t\t\t} else {\n\t\t\t\t\treturn h?.handleRequest(data.data);\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t};\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAwC,wBAAwB,EAAiB,MAAM,UAAU,CAAC;;AAEnG,SAAU,oBAAoB,CACnC,SAAyB,EACzB,YAA+B;IAE/B,MAAM,CAAC,GAAG,UAA8B,CAAC;IAEzC,IAAI,mBAAmB,GAAc,EAAE,CAAC;IACxC,IAAI,OAAO,GAAsB,SAAS,CAAC;IAE3C,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,oCAAoC,CAAC;QACjE,gBAAgB,EAAE,CAAC,IAAI,EAAE,EAAE;YAC1B,IAAI,OAAO,EAAE,CAAC;gBACb,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;YAChC,CAAC,MAAM,CAAC;gBACP,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAChC,CAAC;QACF,CAAC;KACD,CAAC,CAAC;IAEH,IAAI,SAAS,GAA4B,SAAS,CAAC;IAEnD,CAAC,CAAC,CAAC,gCAAgC,IAAI,CAAC,CAAC,CAAC,gCAAgC,GAAG,CAAA,CAAE,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE;QACvG,SAAS,GAAG,YAAY,EAAE,CAAC;QAC3B,OAAO,GAAG,IAAI,CAAC;QACf,KAAK,MAAM,CAAC,IAAI,mBAAmB,CAAE,CAAC;YACrC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;QAC1B,CAAC;QACD,mBAAmB,GAAG,EAAE,CAAC;QACzB,OAAO,OAAO,CAAC;IAChB,CAAC,CAAC;IAEF,OAAO,+OAAwB,CAAC,YAAY,CAAI,OAAO,EAAE,GAAG,EAAE;QAC7D,IAAI,CAAC,SAAS,EAAE,CAAC;YAAC,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;QAAC,CAAC;QACrD,OAAO,SAAS,CAAC;IAClB,CAAC,CAAC,CAAC;AACJ,CAAC;AAUD,SAAS,oCAAoC,CAAC,IAAW;IACxD,IAAI,CAA8B,CAAC;IACnC,MAAM,OAAO,GAAmB,CAAC,OAAO,EAAE,EAAE;QAC3C,CAAC,GAAG,OAAO,CAAC;QACZ,OAAO;YACN,gBAAgB,GAAE,IAAI,CAAC,EAAE;gBACxB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;YAC7B,CAAC;YACD,WAAW,GAAE,IAAI,CAAC,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;YAClC,CAAC;SACD,CAAC;IACH,CAAC,CAAC;IACF,OAAO;QACN,OAAO,EAAE,OAAO;QAChB,OAAO,EAAE;YACR,aAAa,EAAE,CAAC,IAAS,EAAE,EAAE;gBAC5B,IAAI,IAAI,CAAC,IAAI,KAAK,cAAc,EAAE,CAAC;oBAClC,OAAO,CAAC,EAAE,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACzC,CAAC,MAAM,CAAC;oBACP,OAAO,CAAC,EAAE,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACpC,CAAC;YACF,CAAC;SACD;KACD,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 2886, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/utils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/logging/debugger/utils.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/vs/base/common/observableInternal/logging/debugger/utils.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from '../../../lifecycle.js';\n\nexport class Throttler implements IDisposable {\n\tprivate _timeout: Timeout | undefined = undefined;\n\n\tpublic throttle(fn: () => void, timeoutMs: number): void {\n\t\tif (this._timeout === undefined) {\n\t\t\tthis._timeout = setTimeout(() => {\n\t\t\t\tthis._timeout = undefined;\n\t\t\t\tfn();\n\t\t\t}, timeoutMs);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this._timeout !== undefined) {\n\t\t\tclearTimeout(this._timeout);\n\t\t}\n\t}\n}\n\nexport function deepAssign<T>(target: T, source: T): void {\n\tfor (const key in source) {\n\t\tif (!!target[key] && typeof target[key] === 'object' && !!source[key] && typeof source[key] === 'object') {\n\t\t\tdeepAssign(target[key], source[key]);\n\t\t} else {\n\t\t\ttarget[key] = source[key];\n\t\t}\n\t}\n}\n\nexport function deepAssignDeleteNulls<T>(target: T, source: T): void {\n\tfor (const key in source) {\n\t\tif (source[key] === null) {\n\t\t\tdelete target[key];\n\t\t} else if (!!target[key] && typeof target[key] === 'object' && !!source[key] && typeof source[key] === 'object') {\n\t\t\tdeepAssignDeleteNulls(target[key], source[key]);\n\t\t} else {\n\t\t\ttarget[key] = source[key];\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from '../../../lifecycle.js';\n\nexport class Throttler implements IDisposable {\n\tprivate _timeout: Timeout | undefined = undefined;\n\n\tpublic throttle(fn: () => void, timeoutMs: number): void {\n\t\tif (this._timeout === undefined) {\n\t\t\tthis._timeout = setTimeout(() => {\n\t\t\t\tthis._timeout = undefined;\n\t\t\t\tfn();\n\t\t\t}, timeoutMs);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this._timeout !== undefined) {\n\t\t\tclearTimeout(this._timeout);\n\t\t}\n\t}\n}\n\nexport function deepAssign<T>(target: T, source: T): void {\n\tfor (const key in source) {\n\t\tif (!!target[key] && typeof target[key] === 'object' && !!source[key] && typeof source[key] === 'object') {\n\t\t\tdeepAssign(target[key], source[key]);\n\t\t} else {\n\t\t\ttarget[key] = source[key];\n\t\t}\n\t}\n}\n\nexport function deepAssignDeleteNulls<T>(target: T, source: T): void {\n\tfor (const key in source) {\n\t\tif (source[key] === null) {\n\t\t\tdelete target[key];\n\t\t} else if (!!target[key] && typeof target[key] === 'object' && !!source[key] && typeof source[key] === 'object') {\n\t\t\tdeepAssignDeleteNulls(target[key], source[key]);\n\t\t} else {\n\t\t\ttarget[key] = source[key];\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;AAI1F,MAAO,SAAS;IAAtB,aAAA;QACS,IAAA,CAAA,QAAQ,GAAwB,SAAS,CAAC;IAgBnD,CAAC;IAdO,QAAQ,CAAC,EAAc,EAAE,SAAiB,EAAA;QAChD,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;YACjC,IAAI,CAAC,QAAQ,GAAG,UAAU,CAAC,GAAG,EAAE;gBAC/B,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;gBAC1B,EAAE,EAAE,CAAC;YACN,CAAC,EAAE,SAAS,CAAC,CAAC;QACf,CAAC;IACF,CAAC;IAED,OAAO,GAAA;QACN,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;YACjC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC7B,CAAC;IACF,CAAC;CACD;AAEK,SAAU,UAAU,CAAI,MAAS,EAAE,MAAS;IACjD,IAAK,MAAM,GAAG,IAAI,MAAM,CAAE,CAAC;QAC1B,IAAI,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,IAAI,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE,CAAC;YAC1G,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;QACtC,CAAC,MAAM,CAAC;YACP,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;QAC3B,CAAC;IACF,CAAC;AACF,CAAC;AAEK,SAAU,qBAAqB,CAAI,MAAS,EAAE,MAAS;IAC5D,IAAK,MAAM,GAAG,IAAI,MAAM,CAAE,CAAC;QAC1B,IAAI,MAAM,CAAC,GAAG,CAAC,KAAK,IAAI,EAAE,CAAC;YAC1B,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;QACpB,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,IAAI,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE,CAAC;YACjH,qBAAqB,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;QACjD,CAAC,MAAM,CAAC;YACP,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;QAC3B,CAAC;IACF,CAAC;AACF,CAAC","debugId":null}},
    {"offset": {"line": 2939, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/devToolsLogger.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/logging/debugger/devToolsLogger.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging/debugger/vs/base/common/observableInternal/logging/debugger/devToolsLogger.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AutorunObserver, AutorunState } from '../../reactions/autorunImpl.js';\nimport { TransactionImpl } from '../../transaction.js';\nimport { IChangeInformation, IObservableLogger } from '../logging.js';\nimport { formatValue } from '../consoleObservableLogger.js';\nimport { ObsDebuggerApi, IObsDeclaration, ObsInstanceId, ObsStateUpdate, ITransactionState, ObserverInstanceState } from './debuggerApi.js';\nimport { registerDebugChannel } from './debuggerRpc.js';\nimport { deepAssign, deepAssignDeleteNulls, Throttler } from './utils.js';\nimport { isDefined } from '../../../types.js';\nimport { FromEventObservable } from '../../observables/observableFromEvent.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../errors.js';\nimport { IObservable, IObserver } from '../../base.js';\nimport { BaseObservable } from '../../observables/baseObservable.js';\nimport { Derived, DerivedState } from '../../observables/derivedImpl.js';\nimport { ObservableValue } from '../../observables/observableValue.js';\nimport { DebugLocation } from '../../debugLocation.js';\n\ninterface IInstanceInfo {\n\tdeclarationId: number;\n\tinstanceId: number;\n}\n\ninterface IObservableInfo extends IInstanceInfo {\n\tlistenerCount: number;\n\tlastValue: string | undefined;\n\tupdateCount: number;\n\tchangedObservables: Set<IObservable<any>>;\n}\n\ninterface IAutorunInfo extends IInstanceInfo {\n\tupdateCount: number;\n\tchangedObservables: Set<IObservable<any>>;\n}\n\nexport class DevToolsLogger implements IObservableLogger {\n\tprivate static _instance: DevToolsLogger | undefined = undefined;\n\tpublic static getInstance(): DevToolsLogger {\n\t\tif (DevToolsLogger._instance === undefined) {\n\t\t\tDevToolsLogger._instance = new DevToolsLogger();\n\t\t}\n\t\treturn DevToolsLogger._instance;\n\t}\n\n\tprivate _declarationId = 0;\n\tprivate _instanceId = 0;\n\n\tprivate readonly _declarations = new Map</* declarationId + type */string, IObsDeclaration>();\n\tprivate readonly _instanceInfos = new WeakMap<object, IObservableInfo | IAutorunInfo>();\n\tprivate readonly _aliveInstances = new Map<ObsInstanceId, IObservable<any> | AutorunObserver>();\n\tprivate readonly _activeTransactions = new Set<TransactionImpl>();\n\n\tprivate readonly _channel = registerDebugChannel<ObsDebuggerApi>('observableDevTools', () => {\n\t\treturn {\n\t\t\tnotifications: {\n\t\t\t\tsetDeclarationIdFilter: declarationIds => {\n\n\t\t\t\t},\n\t\t\t\tlogObservableValue: (observableId) => {\n\t\t\t\t\tconsole.log('logObservableValue', observableId);\n\t\t\t\t},\n\t\t\t\tflushUpdates: () => {\n\t\t\t\t\tthis._flushUpdates();\n\t\t\t\t},\n\t\t\t\tresetUpdates: () => {\n\t\t\t\t\tthis._pendingChanges = null;\n\t\t\t\t\tthis._channel.api.notifications.handleChange(this._fullState, true);\n\t\t\t\t},\n\t\t\t},\n\t\t\trequests: {\n\t\t\t\tgetDeclarations: () => {\n\t\t\t\t\tconst result: Record<string, IObsDeclaration> = {};\n\t\t\t\t\tfor (const decl of this._declarations.values()) {\n\t\t\t\t\t\tresult[decl.id] = decl;\n\t\t\t\t\t}\n\t\t\t\t\treturn { decls: result };\n\t\t\t\t},\n\t\t\t\tgetSummarizedInstances: () => {\n\t\t\t\t\treturn null!;\n\t\t\t\t},\n\t\t\t\tgetObservableValueInfo: instanceId => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId) as BaseObservable<any>;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tobservers: [...obs.debugGetObservers()].map(d => this._formatObserver(d)).filter(isDefined),\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tgetDerivedInfo: instanceId => {\n\t\t\t\t\tconst d = this._aliveInstances.get(instanceId) as Derived<any>;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdependencies: [...d.debugGetState().dependencies].map(d => this._formatObservable(d)).filter(isDefined),\n\t\t\t\t\t\tobservers: [...d.debugGetObservers()].map(d => this._formatObserver(d)).filter(isDefined),\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tgetAutorunInfo: instanceId => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId) as AutorunObserver;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdependencies: [...obs.debugGetState().dependencies].map(d => this._formatObservable(d)).filter(isDefined),\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tgetTransactionState: () => {\n\t\t\t\t\treturn this.getTransactionState();\n\t\t\t\t},\n\t\t\t\tsetValue: (instanceId, jsonValue) => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId) as BaseObservable<any>;\n\n\t\t\t\t\tif (obs instanceof Derived) {\n\t\t\t\t\t\tobs.debugSetValue(jsonValue);\n\t\t\t\t\t} else if (obs instanceof ObservableValue) {\n\t\t\t\t\t\tobs.debugSetValue(jsonValue);\n\t\t\t\t\t} else if (obs instanceof FromEventObservable) {\n\t\t\t\t\t\tobs.debugSetValue(jsonValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new BugIndicatingError('Observable is not supported');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst observers = [...obs.debugGetObservers()];\n\t\t\t\t\tfor (const d of observers) {\n\t\t\t\t\t\td.beginUpdate(obs);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const d of observers) {\n\t\t\t\t\t\td.handleChange(obs, undefined);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const d of observers) {\n\t\t\t\t\t\td.endUpdate(obs);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetValue: instanceId => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId) as BaseObservable<any>;\n\t\t\t\t\tif (obs instanceof Derived) {\n\t\t\t\t\t\treturn formatValue(obs.debugGetState().value, 200);\n\t\t\t\t\t} else if (obs instanceof ObservableValue) {\n\t\t\t\t\t\treturn formatValue(obs.debugGetState().value, 200);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tlogValue: (instanceId) => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId);\n\t\t\t\t\tif (obs && 'get' in obs) {\n\t\t\t\t\t\tconsole.log('Logged Value:', obs.get());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new BugIndicatingError('Observable is not supported');\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trerun: (instanceId) => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId);\n\t\t\t\t\tif (obs instanceof Derived) {\n\t\t\t\t\t\tobs.debugRecompute();\n\t\t\t\t\t} else if (obs instanceof AutorunObserver) {\n\t\t\t\t\t\tobs.debugRerun();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new BugIndicatingError('Observable is not supported');\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\t});\n\n\tprivate getTransactionState(): ITransactionState | undefined {\n\t\tconst affected: ObserverInstanceState[] = [];\n\t\tconst txs = [...this._activeTransactions];\n\t\tif (txs.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst observerQueue = txs.flatMap(t => t.debugGetUpdatingObservers() ?? []).map(o => o.observer);\n\t\tconst processedObservers = new Set<IObserver>();\n\t\twhile (observerQueue.length > 0) {\n\t\t\tconst observer = observerQueue.shift()!;\n\t\t\tif (processedObservers.has(observer)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprocessedObservers.add(observer);\n\n\t\t\tconst state = this._getInfo(observer, d => {\n\t\t\t\tif (!processedObservers.has(d)) {\n\t\t\t\t\tobserverQueue.push(d);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (state) {\n\t\t\t\taffected.push(state);\n\t\t\t}\n\t\t}\n\n\t\treturn { names: txs.map(t => t.getDebugName() ?? 'tx'), affected };\n\t}\n\n\tprivate _getObservableInfo(observable: IObservable<any>): IObservableInfo | undefined {\n\t\tconst info = this._instanceInfos.get(observable);\n\t\tif (!info) {\n\t\t\tonUnexpectedError(new BugIndicatingError('No info found'));\n\t\t\treturn undefined;\n\t\t}\n\t\treturn info as IObservableInfo;\n\t}\n\n\tprivate _getAutorunInfo(autorun: AutorunObserver): IAutorunInfo | undefined {\n\t\tconst info = this._instanceInfos.get(autorun);\n\t\tif (!info) {\n\t\t\tonUnexpectedError(new BugIndicatingError('No info found'));\n\t\t\treturn undefined;\n\t\t}\n\t\treturn info as IAutorunInfo;\n\t}\n\n\tprivate _getInfo(observer: IObserver, queue: (observer: IObserver) => void): ObserverInstanceState | undefined {\n\t\tif (observer instanceof Derived) {\n\t\t\tconst observersToUpdate = [...observer.debugGetObservers()];\n\t\t\tfor (const o of observersToUpdate) {\n\t\t\t\tqueue(o);\n\t\t\t}\n\n\t\t\tconst info = this._getObservableInfo(observer);\n\t\t\tif (!info) { return; }\n\n\t\t\tconst observerState = observer.debugGetState();\n\n\t\t\tconst base = { name: observer.debugName, instanceId: info.instanceId, updateCount: observerState.updateCount };\n\t\t\tconst changedDependencies = [...info.changedObservables].map(o => this._instanceInfos.get(o)?.instanceId).filter(isDefined);\n\t\t\tif (observerState.isComputing) {\n\t\t\t\treturn { ...base, type: 'observable/derived', state: 'updating', changedDependencies, initialComputation: false };\n\t\t\t}\n\t\t\tswitch (observerState.state) {\n\t\t\t\tcase DerivedState.initial:\n\t\t\t\t\treturn { ...base, type: 'observable/derived', state: 'noValue' };\n\t\t\t\tcase DerivedState.upToDate:\n\t\t\t\t\treturn { ...base, type: 'observable/derived', state: 'upToDate' };\n\t\t\t\tcase DerivedState.stale:\n\t\t\t\t\treturn { ...base, type: 'observable/derived', state: 'stale', changedDependencies };\n\t\t\t\tcase DerivedState.dependenciesMightHaveChanged:\n\t\t\t\t\treturn { ...base, type: 'observable/derived', state: 'possiblyStale' };\n\t\t\t}\n\t\t} else if (observer instanceof AutorunObserver) {\n\t\t\tconst info = this._getAutorunInfo(observer);\n\t\t\tif (!info) { return undefined; }\n\n\t\t\tconst base = { name: observer.debugName, instanceId: info.instanceId, updateCount: info.updateCount };\n\t\t\tconst changedDependencies = [...info.changedObservables].map(o => this._instanceInfos.get(o)!.instanceId);\n\t\t\tif (observer.debugGetState().isRunning) {\n\t\t\t\treturn { ...base, type: 'autorun', state: 'updating', changedDependencies };\n\t\t\t}\n\t\t\tswitch (observer.debugGetState().state) {\n\t\t\t\tcase AutorunState.upToDate:\n\t\t\t\t\treturn { ...base, type: 'autorun', state: 'upToDate' };\n\t\t\t\tcase AutorunState.stale:\n\t\t\t\t\treturn { ...base, type: 'autorun', state: 'stale', changedDependencies };\n\t\t\t\tcase AutorunState.dependenciesMightHaveChanged:\n\t\t\t\t\treturn { ...base, type: 'autorun', state: 'possiblyStale' };\n\t\t\t}\n\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _formatObservable(obs: IObservable<any>): { name: string; instanceId: ObsInstanceId } | undefined {\n\t\tconst info = this._getObservableInfo(obs);\n\t\tif (!info) { return undefined; }\n\t\treturn { name: obs.debugName, instanceId: info.instanceId };\n\t}\n\n\tprivate _formatObserver(obs: IObserver): { name: string; instanceId: ObsInstanceId } | undefined {\n\t\tif (obs instanceof Derived) {\n\t\t\treturn { name: obs.toString(), instanceId: this._getObservableInfo(obs)?.instanceId! };\n\t\t}\n\t\tconst autorunInfo = this._getAutorunInfo(obs as AutorunObserver);\n\t\tif (autorunInfo) {\n\t\t\treturn { name: obs.toString(), instanceId: autorunInfo.instanceId };\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate constructor() {\n\t\tDebugLocation.enable();\n\t}\n\n\tprivate _pendingChanges: ObsStateUpdate | null = null;\n\tprivate readonly _changeThrottler = new Throttler();\n\n\tprivate readonly _fullState = {};\n\n\tprivate _handleChange(update: ObsStateUpdate): void {\n\t\tdeepAssignDeleteNulls(this._fullState, update);\n\n\t\tif (this._pendingChanges === null) {\n\t\t\tthis._pendingChanges = update;\n\t\t} else {\n\t\t\tdeepAssign(this._pendingChanges, update);\n\t\t}\n\n\t\tthis._changeThrottler.throttle(this._flushUpdates, 10);\n\t}\n\n\tprivate readonly _flushUpdates = () => {\n\t\tif (this._pendingChanges !== null) {\n\t\t\tthis._channel.api.notifications.handleChange(this._pendingChanges, false);\n\t\t\tthis._pendingChanges = null;\n\t\t}\n\t};\n\n\tprivate _getDeclarationId(type: IObsDeclaration['type'], location: DebugLocation): number {\n\t\tif (!location) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlet decInfo = this._declarations.get(location.id);\n\t\tif (decInfo === undefined) {\n\t\t\tdecInfo = {\n\t\t\t\tid: this._declarationId++,\n\t\t\t\ttype,\n\t\t\t\turl: location.fileName,\n\t\t\t\tline: location.line,\n\t\t\t\tcolumn: location.column,\n\t\t\t};\n\t\t\tthis._declarations.set(location.id, decInfo);\n\n\t\t\tthis._handleChange({ decls: { [decInfo.id]: decInfo } });\n\t\t}\n\t\treturn decInfo.id;\n\t}\n\n\thandleObservableCreated(observable: IObservable<any>, location: DebugLocation): void {\n\t\tconst declarationId = this._getDeclarationId('observable/value', location);\n\n\t\tconst info: IObservableInfo = {\n\t\t\tdeclarationId,\n\t\t\tinstanceId: this._instanceId++,\n\t\t\tlistenerCount: 0,\n\t\t\tlastValue: undefined,\n\t\t\tupdateCount: 0,\n\t\t\tchangedObservables: new Set(),\n\t\t};\n\t\tthis._instanceInfos.set(observable, info);\n\t}\n\n\thandleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void {\n\t\tconst info = this._getObservableInfo(observable);\n\t\tif (!info) { return; }\n\n\t\tif (info.listenerCount === 0 && newCount > 0) {\n\t\t\tconst type: IObsDeclaration['type'] =\n\t\t\t\tobservable instanceof Derived ? 'observable/derived' : 'observable/value';\n\t\t\tthis._aliveInstances.set(info.instanceId, observable);\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: {\n\t\t\t\t\t[info.instanceId]: {\n\t\t\t\t\t\tinstanceId: info.instanceId,\n\t\t\t\t\t\tdeclarationId: info.declarationId,\n\t\t\t\t\t\tformattedValue: info.lastValue,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tname: observable.debugName,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (info.listenerCount > 0 && newCount === 0) {\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: { [info.instanceId]: null }\n\t\t\t});\n\t\t\tthis._aliveInstances.delete(info.instanceId);\n\t\t}\n\t\tinfo.listenerCount = newCount;\n\t}\n\n\thandleObservableUpdated(observable: IObservable<any>, changeInfo: IChangeInformation): void {\n\t\tif (observable instanceof Derived) {\n\t\t\tthis._handleDerivedRecomputed(observable, changeInfo);\n\t\t\treturn;\n\t\t}\n\n\t\tconst info = this._getObservableInfo(observable);\n\t\tif (info) {\n\t\t\tif (changeInfo.didChange) {\n\t\t\t\tinfo.lastValue = formatValue(changeInfo.newValue, 30);\n\t\t\t\tif (info.listenerCount > 0) {\n\t\t\t\t\tthis._handleChange({\n\t\t\t\t\t\tinstances: { [info.instanceId]: { formattedValue: info.lastValue } }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thandleAutorunCreated(autorun: AutorunObserver, location: DebugLocation): void {\n\t\tconst declarationId = this._getDeclarationId('autorun', location);\n\t\tconst info: IAutorunInfo = {\n\t\t\tdeclarationId,\n\t\t\tinstanceId: this._instanceId++,\n\t\t\tupdateCount: 0,\n\t\t\tchangedObservables: new Set(),\n\t\t};\n\t\tthis._instanceInfos.set(autorun, info);\n\t\tthis._aliveInstances.set(info.instanceId, autorun);\n\t\tif (info) {\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: {\n\t\t\t\t\t[info.instanceId]: {\n\t\t\t\t\t\tinstanceId: info.instanceId,\n\t\t\t\t\t\tdeclarationId: info.declarationId,\n\t\t\t\t\t\trunCount: 0,\n\t\t\t\t\t\ttype: 'autorun',\n\t\t\t\t\t\tname: autorun.debugName,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\thandleAutorunDisposed(autorun: AutorunObserver): void {\n\t\tconst info = this._getAutorunInfo(autorun);\n\t\tif (!info) { return; }\n\n\t\tthis._handleChange({\n\t\t\tinstances: { [info.instanceId]: null }\n\t\t});\n\t\tthis._instanceInfos.delete(autorun);\n\t\tthis._aliveInstances.delete(info.instanceId);\n\t}\n\thandleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void {\n\t\tconst info = this._getAutorunInfo(autorun);\n\t\tif (!info) { return; }\n\n\t\tinfo.changedObservables.add(observable);\n\t}\n\thandleAutorunStarted(autorun: AutorunObserver): void {\n\n\t}\n\thandleAutorunFinished(autorun: AutorunObserver): void {\n\t\tconst info = this._getAutorunInfo(autorun);\n\t\tif (!info) { return; }\n\n\t\tinfo.changedObservables.clear();\n\t\tinfo.updateCount++;\n\t\tthis._handleChange({\n\t\t\tinstances: { [info.instanceId]: { runCount: info.updateCount } }\n\t\t});\n\t}\n\n\thandleDerivedDependencyChanged(derived: Derived<any>, observable: IObservable<any>, change: unknown): void {\n\t\tconst info = this._getObservableInfo(derived);\n\t\tif (info) {\n\t\t\tinfo.changedObservables.add(observable);\n\t\t}\n\t}\n\t_handleDerivedRecomputed(observable: Derived<any>, changeInfo: IChangeInformation): void {\n\t\tconst info = this._getObservableInfo(observable);\n\t\tif (!info) { return; }\n\n\t\tconst formattedValue = formatValue(changeInfo.newValue, 30);\n\t\tinfo.updateCount++;\n\t\tinfo.changedObservables.clear();\n\n\t\tinfo.lastValue = formattedValue;\n\t\tif (info.listenerCount > 0) {\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: { [info.instanceId]: { formattedValue: formattedValue, recomputationCount: info.updateCount } }\n\t\t\t});\n\t\t}\n\t}\n\thandleDerivedCleared(observable: Derived<any>): void {\n\t\tconst info = this._getObservableInfo(observable);\n\t\tif (!info) { return; }\n\n\t\tinfo.lastValue = undefined;\n\t\tinfo.changedObservables.clear();\n\t\tif (info.listenerCount > 0) {\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: {\n\t\t\t\t\t[info.instanceId]: {\n\t\t\t\t\t\tformattedValue: undefined,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\thandleBeginTransaction(transaction: TransactionImpl): void {\n\t\tthis._activeTransactions.add(transaction);\n\t}\n\thandleEndTransaction(transaction: TransactionImpl): void {\n\t\tthis._activeTransactions.delete(transaction);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AutorunObserver, AutorunState } from '../../reactions/autorunImpl.js';\nimport { TransactionImpl } from '../../transaction.js';\nimport { IChangeInformation, IObservableLogger } from '../logging.js';\nimport { formatValue } from '../consoleObservableLogger.js';\nimport { ObsDebuggerApi, IObsDeclaration, ObsInstanceId, ObsStateUpdate, ITransactionState, ObserverInstanceState } from './debuggerApi.js';\nimport { registerDebugChannel } from './debuggerRpc.js';\nimport { deepAssign, deepAssignDeleteNulls, Throttler } from './utils.js';\nimport { isDefined } from '../../../types.js';\nimport { FromEventObservable } from '../../observables/observableFromEvent.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../errors.js';\nimport { IObservable, IObserver } from '../../base.js';\nimport { BaseObservable } from '../../observables/baseObservable.js';\nimport { Derived, DerivedState } from '../../observables/derivedImpl.js';\nimport { ObservableValue } from '../../observables/observableValue.js';\nimport { DebugLocation } from '../../debugLocation.js';\n\ninterface IInstanceInfo {\n\tdeclarationId: number;\n\tinstanceId: number;\n}\n\ninterface IObservableInfo extends IInstanceInfo {\n\tlistenerCount: number;\n\tlastValue: string | undefined;\n\tupdateCount: number;\n\tchangedObservables: Set<IObservable<any>>;\n}\n\ninterface IAutorunInfo extends IInstanceInfo {\n\tupdateCount: number;\n\tchangedObservables: Set<IObservable<any>>;\n}\n\nexport class DevToolsLogger implements IObservableLogger {\n\tprivate static _instance: DevToolsLogger | undefined = undefined;\n\tpublic static getInstance(): DevToolsLogger {\n\t\tif (DevToolsLogger._instance === undefined) {\n\t\t\tDevToolsLogger._instance = new DevToolsLogger();\n\t\t}\n\t\treturn DevToolsLogger._instance;\n\t}\n\n\tprivate _declarationId = 0;\n\tprivate _instanceId = 0;\n\n\tprivate readonly _declarations = new Map</* declarationId + type */string, IObsDeclaration>();\n\tprivate readonly _instanceInfos = new WeakMap<object, IObservableInfo | IAutorunInfo>();\n\tprivate readonly _aliveInstances = new Map<ObsInstanceId, IObservable<any> | AutorunObserver>();\n\tprivate readonly _activeTransactions = new Set<TransactionImpl>();\n\n\tprivate readonly _channel = registerDebugChannel<ObsDebuggerApi>('observableDevTools', () => {\n\t\treturn {\n\t\t\tnotifications: {\n\t\t\t\tsetDeclarationIdFilter: declarationIds => {\n\n\t\t\t\t},\n\t\t\t\tlogObservableValue: (observableId) => {\n\t\t\t\t\tconsole.log('logObservableValue', observableId);\n\t\t\t\t},\n\t\t\t\tflushUpdates: () => {\n\t\t\t\t\tthis._flushUpdates();\n\t\t\t\t},\n\t\t\t\tresetUpdates: () => {\n\t\t\t\t\tthis._pendingChanges = null;\n\t\t\t\t\tthis._channel.api.notifications.handleChange(this._fullState, true);\n\t\t\t\t},\n\t\t\t},\n\t\t\trequests: {\n\t\t\t\tgetDeclarations: () => {\n\t\t\t\t\tconst result: Record<string, IObsDeclaration> = {};\n\t\t\t\t\tfor (const decl of this._declarations.values()) {\n\t\t\t\t\t\tresult[decl.id] = decl;\n\t\t\t\t\t}\n\t\t\t\t\treturn { decls: result };\n\t\t\t\t},\n\t\t\t\tgetSummarizedInstances: () => {\n\t\t\t\t\treturn null!;\n\t\t\t\t},\n\t\t\t\tgetObservableValueInfo: instanceId => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId) as BaseObservable<any>;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tobservers: [...obs.debugGetObservers()].map(d => this._formatObserver(d)).filter(isDefined),\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tgetDerivedInfo: instanceId => {\n\t\t\t\t\tconst d = this._aliveInstances.get(instanceId) as Derived<any>;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdependencies: [...d.debugGetState().dependencies].map(d => this._formatObservable(d)).filter(isDefined),\n\t\t\t\t\t\tobservers: [...d.debugGetObservers()].map(d => this._formatObserver(d)).filter(isDefined),\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tgetAutorunInfo: instanceId => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId) as AutorunObserver;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdependencies: [...obs.debugGetState().dependencies].map(d => this._formatObservable(d)).filter(isDefined),\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tgetTransactionState: () => {\n\t\t\t\t\treturn this.getTransactionState();\n\t\t\t\t},\n\t\t\t\tsetValue: (instanceId, jsonValue) => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId) as BaseObservable<any>;\n\n\t\t\t\t\tif (obs instanceof Derived) {\n\t\t\t\t\t\tobs.debugSetValue(jsonValue);\n\t\t\t\t\t} else if (obs instanceof ObservableValue) {\n\t\t\t\t\t\tobs.debugSetValue(jsonValue);\n\t\t\t\t\t} else if (obs instanceof FromEventObservable) {\n\t\t\t\t\t\tobs.debugSetValue(jsonValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new BugIndicatingError('Observable is not supported');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst observers = [...obs.debugGetObservers()];\n\t\t\t\t\tfor (const d of observers) {\n\t\t\t\t\t\td.beginUpdate(obs);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const d of observers) {\n\t\t\t\t\t\td.handleChange(obs, undefined);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const d of observers) {\n\t\t\t\t\t\td.endUpdate(obs);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetValue: instanceId => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId) as BaseObservable<any>;\n\t\t\t\t\tif (obs instanceof Derived) {\n\t\t\t\t\t\treturn formatValue(obs.debugGetState().value, 200);\n\t\t\t\t\t} else if (obs instanceof ObservableValue) {\n\t\t\t\t\t\treturn formatValue(obs.debugGetState().value, 200);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tlogValue: (instanceId) => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId);\n\t\t\t\t\tif (obs && 'get' in obs) {\n\t\t\t\t\t\tconsole.log('Logged Value:', obs.get());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new BugIndicatingError('Observable is not supported');\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trerun: (instanceId) => {\n\t\t\t\t\tconst obs = this._aliveInstances.get(instanceId);\n\t\t\t\t\tif (obs instanceof Derived) {\n\t\t\t\t\t\tobs.debugRecompute();\n\t\t\t\t\t} else if (obs instanceof AutorunObserver) {\n\t\t\t\t\t\tobs.debugRerun();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new BugIndicatingError('Observable is not supported');\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\t});\n\n\tprivate getTransactionState(): ITransactionState | undefined {\n\t\tconst affected: ObserverInstanceState[] = [];\n\t\tconst txs = [...this._activeTransactions];\n\t\tif (txs.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst observerQueue = txs.flatMap(t => t.debugGetUpdatingObservers() ?? []).map(o => o.observer);\n\t\tconst processedObservers = new Set<IObserver>();\n\t\twhile (observerQueue.length > 0) {\n\t\t\tconst observer = observerQueue.shift()!;\n\t\t\tif (processedObservers.has(observer)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprocessedObservers.add(observer);\n\n\t\t\tconst state = this._getInfo(observer, d => {\n\t\t\t\tif (!processedObservers.has(d)) {\n\t\t\t\t\tobserverQueue.push(d);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (state) {\n\t\t\t\taffected.push(state);\n\t\t\t}\n\t\t}\n\n\t\treturn { names: txs.map(t => t.getDebugName() ?? 'tx'), affected };\n\t}\n\n\tprivate _getObservableInfo(observable: IObservable<any>): IObservableInfo | undefined {\n\t\tconst info = this._instanceInfos.get(observable);\n\t\tif (!info) {\n\t\t\tonUnexpectedError(new BugIndicatingError('No info found'));\n\t\t\treturn undefined;\n\t\t}\n\t\treturn info as IObservableInfo;\n\t}\n\n\tprivate _getAutorunInfo(autorun: AutorunObserver): IAutorunInfo | undefined {\n\t\tconst info = this._instanceInfos.get(autorun);\n\t\tif (!info) {\n\t\t\tonUnexpectedError(new BugIndicatingError('No info found'));\n\t\t\treturn undefined;\n\t\t}\n\t\treturn info as IAutorunInfo;\n\t}\n\n\tprivate _getInfo(observer: IObserver, queue: (observer: IObserver) => void): ObserverInstanceState | undefined {\n\t\tif (observer instanceof Derived) {\n\t\t\tconst observersToUpdate = [...observer.debugGetObservers()];\n\t\t\tfor (const o of observersToUpdate) {\n\t\t\t\tqueue(o);\n\t\t\t}\n\n\t\t\tconst info = this._getObservableInfo(observer);\n\t\t\tif (!info) { return; }\n\n\t\t\tconst observerState = observer.debugGetState();\n\n\t\t\tconst base = { name: observer.debugName, instanceId: info.instanceId, updateCount: observerState.updateCount };\n\t\t\tconst changedDependencies = [...info.changedObservables].map(o => this._instanceInfos.get(o)?.instanceId).filter(isDefined);\n\t\t\tif (observerState.isComputing) {\n\t\t\t\treturn { ...base, type: 'observable/derived', state: 'updating', changedDependencies, initialComputation: false };\n\t\t\t}\n\t\t\tswitch (observerState.state) {\n\t\t\t\tcase DerivedState.initial:\n\t\t\t\t\treturn { ...base, type: 'observable/derived', state: 'noValue' };\n\t\t\t\tcase DerivedState.upToDate:\n\t\t\t\t\treturn { ...base, type: 'observable/derived', state: 'upToDate' };\n\t\t\t\tcase DerivedState.stale:\n\t\t\t\t\treturn { ...base, type: 'observable/derived', state: 'stale', changedDependencies };\n\t\t\t\tcase DerivedState.dependenciesMightHaveChanged:\n\t\t\t\t\treturn { ...base, type: 'observable/derived', state: 'possiblyStale' };\n\t\t\t}\n\t\t} else if (observer instanceof AutorunObserver) {\n\t\t\tconst info = this._getAutorunInfo(observer);\n\t\t\tif (!info) { return undefined; }\n\n\t\t\tconst base = { name: observer.debugName, instanceId: info.instanceId, updateCount: info.updateCount };\n\t\t\tconst changedDependencies = [...info.changedObservables].map(o => this._instanceInfos.get(o)!.instanceId);\n\t\t\tif (observer.debugGetState().isRunning) {\n\t\t\t\treturn { ...base, type: 'autorun', state: 'updating', changedDependencies };\n\t\t\t}\n\t\t\tswitch (observer.debugGetState().state) {\n\t\t\t\tcase AutorunState.upToDate:\n\t\t\t\t\treturn { ...base, type: 'autorun', state: 'upToDate' };\n\t\t\t\tcase AutorunState.stale:\n\t\t\t\t\treturn { ...base, type: 'autorun', state: 'stale', changedDependencies };\n\t\t\t\tcase AutorunState.dependenciesMightHaveChanged:\n\t\t\t\t\treturn { ...base, type: 'autorun', state: 'possiblyStale' };\n\t\t\t}\n\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _formatObservable(obs: IObservable<any>): { name: string; instanceId: ObsInstanceId } | undefined {\n\t\tconst info = this._getObservableInfo(obs);\n\t\tif (!info) { return undefined; }\n\t\treturn { name: obs.debugName, instanceId: info.instanceId };\n\t}\n\n\tprivate _formatObserver(obs: IObserver): { name: string; instanceId: ObsInstanceId } | undefined {\n\t\tif (obs instanceof Derived) {\n\t\t\treturn { name: obs.toString(), instanceId: this._getObservableInfo(obs)?.instanceId! };\n\t\t}\n\t\tconst autorunInfo = this._getAutorunInfo(obs as AutorunObserver);\n\t\tif (autorunInfo) {\n\t\t\treturn { name: obs.toString(), instanceId: autorunInfo.instanceId };\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tprivate constructor() {\n\t\tDebugLocation.enable();\n\t}\n\n\tprivate _pendingChanges: ObsStateUpdate | null = null;\n\tprivate readonly _changeThrottler = new Throttler();\n\n\tprivate readonly _fullState = {};\n\n\tprivate _handleChange(update: ObsStateUpdate): void {\n\t\tdeepAssignDeleteNulls(this._fullState, update);\n\n\t\tif (this._pendingChanges === null) {\n\t\t\tthis._pendingChanges = update;\n\t\t} else {\n\t\t\tdeepAssign(this._pendingChanges, update);\n\t\t}\n\n\t\tthis._changeThrottler.throttle(this._flushUpdates, 10);\n\t}\n\n\tprivate readonly _flushUpdates = () => {\n\t\tif (this._pendingChanges !== null) {\n\t\t\tthis._channel.api.notifications.handleChange(this._pendingChanges, false);\n\t\t\tthis._pendingChanges = null;\n\t\t}\n\t};\n\n\tprivate _getDeclarationId(type: IObsDeclaration['type'], location: DebugLocation): number {\n\t\tif (!location) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlet decInfo = this._declarations.get(location.id);\n\t\tif (decInfo === undefined) {\n\t\t\tdecInfo = {\n\t\t\t\tid: this._declarationId++,\n\t\t\t\ttype,\n\t\t\t\turl: location.fileName,\n\t\t\t\tline: location.line,\n\t\t\t\tcolumn: location.column,\n\t\t\t};\n\t\t\tthis._declarations.set(location.id, decInfo);\n\n\t\t\tthis._handleChange({ decls: { [decInfo.id]: decInfo } });\n\t\t}\n\t\treturn decInfo.id;\n\t}\n\n\thandleObservableCreated(observable: IObservable<any>, location: DebugLocation): void {\n\t\tconst declarationId = this._getDeclarationId('observable/value', location);\n\n\t\tconst info: IObservableInfo = {\n\t\t\tdeclarationId,\n\t\t\tinstanceId: this._instanceId++,\n\t\t\tlistenerCount: 0,\n\t\t\tlastValue: undefined,\n\t\t\tupdateCount: 0,\n\t\t\tchangedObservables: new Set(),\n\t\t};\n\t\tthis._instanceInfos.set(observable, info);\n\t}\n\n\thandleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void {\n\t\tconst info = this._getObservableInfo(observable);\n\t\tif (!info) { return; }\n\n\t\tif (info.listenerCount === 0 && newCount > 0) {\n\t\t\tconst type: IObsDeclaration['type'] =\n\t\t\t\tobservable instanceof Derived ? 'observable/derived' : 'observable/value';\n\t\t\tthis._aliveInstances.set(info.instanceId, observable);\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: {\n\t\t\t\t\t[info.instanceId]: {\n\t\t\t\t\t\tinstanceId: info.instanceId,\n\t\t\t\t\t\tdeclarationId: info.declarationId,\n\t\t\t\t\t\tformattedValue: info.lastValue,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tname: observable.debugName,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (info.listenerCount > 0 && newCount === 0) {\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: { [info.instanceId]: null }\n\t\t\t});\n\t\t\tthis._aliveInstances.delete(info.instanceId);\n\t\t}\n\t\tinfo.listenerCount = newCount;\n\t}\n\n\thandleObservableUpdated(observable: IObservable<any>, changeInfo: IChangeInformation): void {\n\t\tif (observable instanceof Derived) {\n\t\t\tthis._handleDerivedRecomputed(observable, changeInfo);\n\t\t\treturn;\n\t\t}\n\n\t\tconst info = this._getObservableInfo(observable);\n\t\tif (info) {\n\t\t\tif (changeInfo.didChange) {\n\t\t\t\tinfo.lastValue = formatValue(changeInfo.newValue, 30);\n\t\t\t\tif (info.listenerCount > 0) {\n\t\t\t\t\tthis._handleChange({\n\t\t\t\t\t\tinstances: { [info.instanceId]: { formattedValue: info.lastValue } }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thandleAutorunCreated(autorun: AutorunObserver, location: DebugLocation): void {\n\t\tconst declarationId = this._getDeclarationId('autorun', location);\n\t\tconst info: IAutorunInfo = {\n\t\t\tdeclarationId,\n\t\t\tinstanceId: this._instanceId++,\n\t\t\tupdateCount: 0,\n\t\t\tchangedObservables: new Set(),\n\t\t};\n\t\tthis._instanceInfos.set(autorun, info);\n\t\tthis._aliveInstances.set(info.instanceId, autorun);\n\t\tif (info) {\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: {\n\t\t\t\t\t[info.instanceId]: {\n\t\t\t\t\t\tinstanceId: info.instanceId,\n\t\t\t\t\t\tdeclarationId: info.declarationId,\n\t\t\t\t\t\trunCount: 0,\n\t\t\t\t\t\ttype: 'autorun',\n\t\t\t\t\t\tname: autorun.debugName,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\thandleAutorunDisposed(autorun: AutorunObserver): void {\n\t\tconst info = this._getAutorunInfo(autorun);\n\t\tif (!info) { return; }\n\n\t\tthis._handleChange({\n\t\t\tinstances: { [info.instanceId]: null }\n\t\t});\n\t\tthis._instanceInfos.delete(autorun);\n\t\tthis._aliveInstances.delete(info.instanceId);\n\t}\n\thandleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void {\n\t\tconst info = this._getAutorunInfo(autorun);\n\t\tif (!info) { return; }\n\n\t\tinfo.changedObservables.add(observable);\n\t}\n\thandleAutorunStarted(autorun: AutorunObserver): void {\n\n\t}\n\thandleAutorunFinished(autorun: AutorunObserver): void {\n\t\tconst info = this._getAutorunInfo(autorun);\n\t\tif (!info) { return; }\n\n\t\tinfo.changedObservables.clear();\n\t\tinfo.updateCount++;\n\t\tthis._handleChange({\n\t\t\tinstances: { [info.instanceId]: { runCount: info.updateCount } }\n\t\t});\n\t}\n\n\thandleDerivedDependencyChanged(derived: Derived<any>, observable: IObservable<any>, change: unknown): void {\n\t\tconst info = this._getObservableInfo(derived);\n\t\tif (info) {\n\t\t\tinfo.changedObservables.add(observable);\n\t\t}\n\t}\n\t_handleDerivedRecomputed(observable: Derived<any>, changeInfo: IChangeInformation): void {\n\t\tconst info = this._getObservableInfo(observable);\n\t\tif (!info) { return; }\n\n\t\tconst formattedValue = formatValue(changeInfo.newValue, 30);\n\t\tinfo.updateCount++;\n\t\tinfo.changedObservables.clear();\n\n\t\tinfo.lastValue = formattedValue;\n\t\tif (info.listenerCount > 0) {\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: { [info.instanceId]: { formattedValue: formattedValue, recomputationCount: info.updateCount } }\n\t\t\t});\n\t\t}\n\t}\n\thandleDerivedCleared(observable: Derived<any>): void {\n\t\tconst info = this._getObservableInfo(observable);\n\t\tif (!info) { return; }\n\n\t\tinfo.lastValue = undefined;\n\t\tinfo.changedObservables.clear();\n\t\tif (info.listenerCount > 0) {\n\t\t\tthis._handleChange({\n\t\t\t\tinstances: {\n\t\t\t\t\t[info.instanceId]: {\n\t\t\t\t\t\tformattedValue: undefined,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\thandleBeginTransaction(transaction: TransactionImpl): void {\n\t\tthis._activeTransactions.add(transaction);\n\t}\n\thandleEndTransaction(transaction: TransactionImpl): void {\n\t\tthis._activeTransactions.delete(transaction);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3487, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/index.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/index.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/vs/base/common/observableInternal/index.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// This is a facade for the observable implementation. Only import from here!\n\nexport { observableValueOpts } from './observables/observableValueOpts.js';\nexport { autorun, autorunDelta, autorunHandleChanges, autorunOpts, autorunWithStore, autorunWithStoreHandleChanges } from './reactions/autorun.js';\nexport { type IObservable, type IObservableWithChange, type IObserver, type IReader, type ISettable, type ISettableObservable, type ITransaction } from './base.js';\nexport { disposableObservableValue } from './observables/observableValue.js';\nexport { derived, derivedDisposable, derivedHandleChanges, derivedOpts, derivedWithSetter } from './observables/derived.js';\nexport { type IDerivedReader } from './observables/derivedImpl.js';\nexport { ObservablePromise, PromiseResult } from './utils/promise.js';\nexport { waitForState } from './utils/utilsCancellation.js';\nexport { debouncedObservable, derivedObservableWithCache,\n\tderivedObservableWithWritableCache, keepObserved, mapObservableArrayCached,\n\trecomputeInitiallyAndOnChange } from './utils/utils.js';\nexport { type DebugOwner } from './debugName.js';\nexport { type IChangeContext, type IChangeTracker, recordChanges, recordChangesLazy } from './changeTracker.js';\nexport { constObservable } from './observables/constObservable.js';\nexport { type IObservableSignal, observableSignal } from './observables/observableSignal.js';\nexport { observableFromEventOpts } from './observables/observableFromEvent.js';\nexport { observableSignalFromEvent } from './observables/observableSignalFromEvent.js';\nexport { asyncTransaction, globalTransaction, subtransaction, transaction, TransactionImpl } from './transaction.js';\nexport { observableFromValueWithChangeEvent, ValueWithChangeEventFromObservable } from './utils/valueWithChangeEvent.js';\nexport { runOnChange, runOnChangeWithCancellationToken, runOnChangeWithStore, type RemoveUndefined } from './utils/runOnChange.js';\nexport { derivedConstOnceDefined } from './experimental/utils.js';\nexport { observableFromEvent } from './observables/observableFromEvent.js';\nexport { observableValue } from './observables/observableValue.js';\nexport { DebugLocation } from './debugLocation.js';\n\nimport { addLogger, setLogObservableFn } from './logging/logging.js';\nimport { ConsoleObservableLogger, logObservableToConsole } from './logging/consoleObservableLogger.js';\nimport { DevToolsLogger } from './logging/debugger/devToolsLogger.js';\nimport { env } from '../process.js';\n\n\nsetLogObservableFn(logObservableToConsole);\n\n// Remove \"//\" in the next line to enable logging\nconst enableLogging = false\n\t// || Boolean(\"true\") // done \"weirdly\" so that a lint warning prevents you from pushing this\n\t;\n\nif (enableLogging) {\n\taddLogger(new ConsoleObservableLogger());\n}\n\nif (env && env['VSCODE_DEV_DEBUG_OBSERVABLES']) {\n\t// To debug observables you also need the extension \"ms-vscode.debug-value-editor\"\n\taddLogger(DevToolsLogger.getInstance());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// This is a facade for the observable implementation. Only import from here!\n\nexport { observableValueOpts } from './observables/observableValueOpts.js';\nexport { autorun, autorunDelta, autorunHandleChanges, autorunOpts, autorunWithStore, autorunWithStoreHandleChanges } from './reactions/autorun.js';\nexport { type IObservable, type IObservableWithChange, type IObserver, type IReader, type ISettable, type ISettableObservable, type ITransaction } from './base.js';\nexport { disposableObservableValue } from './observables/observableValue.js';\nexport { derived, derivedDisposable, derivedHandleChanges, derivedOpts, derivedWithSetter } from './observables/derived.js';\nexport { type IDerivedReader } from './observables/derivedImpl.js';\nexport { ObservablePromise, PromiseResult } from './utils/promise.js';\nexport { waitForState } from './utils/utilsCancellation.js';\nexport { debouncedObservable, derivedObservableWithCache,\n\tderivedObservableWithWritableCache, keepObserved, mapObservableArrayCached,\n\trecomputeInitiallyAndOnChange } from './utils/utils.js';\nexport { type DebugOwner } from './debugName.js';\nexport { type IChangeContext, type IChangeTracker, recordChanges, recordChangesLazy } from './changeTracker.js';\nexport { constObservable } from './observables/constObservable.js';\nexport { type IObservableSignal, observableSignal } from './observables/observableSignal.js';\nexport { observableFromEventOpts } from './observables/observableFromEvent.js';\nexport { observableSignalFromEvent } from './observables/observableSignalFromEvent.js';\nexport { asyncTransaction, globalTransaction, subtransaction, transaction, TransactionImpl } from './transaction.js';\nexport { observableFromValueWithChangeEvent, ValueWithChangeEventFromObservable } from './utils/valueWithChangeEvent.js';\nexport { runOnChange, runOnChangeWithCancellationToken, runOnChangeWithStore, type RemoveUndefined } from './utils/runOnChange.js';\nexport { derivedConstOnceDefined } from './experimental/utils.js';\nexport { observableFromEvent } from './observables/observableFromEvent.js';\nexport { observableValue } from './observables/observableValue.js';\nexport { DebugLocation } from './debugLocation.js';\n\nimport { addLogger, setLogObservableFn } from './logging/logging.js';\nimport { ConsoleObservableLogger, logObservableToConsole } from './logging/consoleObservableLogger.js';\nimport { DevToolsLogger } from './logging/debugger/devToolsLogger.js';\nimport { env } from '../process.js';\n\n\nsetLogObservableFn(logObservableToConsole);\n\n// Remove \"//\" in the next line to enable logging\nconst enableLogging = false\n\t// || Boolean(\"true\") // done \"weirdly\" so that a lint warning prevents you from pushing this\n\t;\n\nif (enableLogging) {\n\taddLogger(new ConsoleObservableLogger());\n}\n\nif (env && env['VSCODE_DEV_DEBUG_OBSERVABLES']) {\n\t// To debug observables you also need the extension \"ms-vscode.debug-value-editor\"\n\taddLogger(DevToolsLogger.getInstance());\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG,CAEhG,6EAA6E;;AAE7E,OAAO,EAAE,mBAAmB,EAAE,MAAM,sCAAsC,CAAC;AAC3E,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAE,WAAW,EAAE,gBAAgB,EAAE,6BAA6B,EAAE,MAAM,wBAAwB,CAAC;AAEnJ,OAAO,EAAE,yBAAyB,EAAE,MAAM,kCAAkC,CAAC;AAC7E,OAAO,EAAE,OAAO,EAAE,iBAAiB,EAAE,oBAAoB,EAAE,WAAW,EAAE,iBAAiB,EAAE,MAAM,0BAA0B,CAAC;AAE5H,OAAO,EAAE,iBAAiB,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAC;AACtE,OAAO,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAC5D,OAAO,EAAE,mBAAmB,EAAE,0BAA0B,EACvD,kCAAkC,EAAE,YAAY,EAAE,wBAAwB,EAC1E,6BAA6B,EAAE,MAAM,kBAAkB,CAAC;AAEzD,OAAO,EAA4C,aAAa,EAAE,iBAAiB,EAAE,MAAM,oBAAoB,CAAC;AAChH,OAAO,EAAE,eAAe,EAAE,MAAM,kCAAkC,CAAC;AACnE,OAAO,EAA0B,gBAAgB,EAAE,MAAM,mCAAmC,CAAC;AAC7F,OAAO,EAAE,uBAAuB,EAAE,MAAM,sCAAsC,CAAC;AAC/E,OAAO,EAAE,yBAAyB,EAAE,MAAM,4CAA4C,CAAC;AACvF,OAAO,EAAE,gBAAgB,EAAE,iBAAiB,EAAE,cAAc,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,kBAAkB,CAAC;AACrH,OAAO,EAAE,kCAAkC,EAAE,kCAAkC,EAAE,MAAM,iCAAiC,CAAC;AACzH,OAAO,EAAE,WAAW,EAAE,gCAAgC,EAAE,oBAAoB,EAAwB,MAAM,wBAAwB,CAAC;AACnI,OAAO,EAAE,uBAAuB,EAAE,MAAM,yBAAyB,CAAC;AAGlE,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAC;AAEnD,OAAO,EAAE,SAAS,EAAE,kBAAkB,EAAE,MAAM,sBAAsB,CAAC;AACrE,OAAO,EAAE,uBAAuB,EAAE,sBAAsB,EAAE,MAAM,sCAAsC,CAAC;AACvG,OAAO,EAAE,cAAc,EAAE,MAAM,sCAAsC,CAAC;AACtE,OAAO,EAAE,GAAG,EAAE,MAAM,eAAe,CAAC;;;;;;;;;;;;;;;;;;;;;;;;IAGpC,iOAAkB,EAAC,qPAAsB,CAAC,CAAC;AAE3C,iDAAiD;AACjD,MAAM,aAAa,GAAG,KAAK,CAEzB;AAEF,IAAI,aAAa,EAAE,CAAC;;AAIpB,IAAI,iLAAG,IAAI,iLAAG,CAAC,8BAA8B,CAAC,EAAE,CAAC;IAChD,kFAAkF;QAClF,wNAAS,EAAC,gPAAc,CAAC,WAAW,EAAE,CAAC,CAAC;AACzC,CAAC","debugId":null}},
    {"offset": {"line": 3657, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/base/common/observableInternal/experimental/reducer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/experimental/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/base/common/observableInternal/experimental/reducer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/base/common/observableInternal/experimental/vs/base/common/observableInternal/experimental/reducer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { EqualityComparer, strictEquals, BugIndicatingError } from '../commonFacade/deps.js';\nimport { ISettableObservable } from '../base.js';\nimport { subtransaction } from '../transaction.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DebugNameData, DebugOwner } from '../debugName.js';\nimport { DerivedWithSetter, IDerivedReader } from '../observables/derivedImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport interface IReducerOptions<T, TChangeSummary = void, TOutChange = void> {\n\t/**\n\t * Is called to create the initial value of the observable when it becomes observed.\n\t*/\n\tinitial: T | (() => T);\n\n\t/**\n\t * Is called to dispose the observable value when it is no longer observed.\n\t*/\n\tdisposeFinal?(value: T): void;\n\tchangeTracker?: IChangeTracker<TChangeSummary>;\n\tequalityComparer?: EqualityComparer<T>;\n\n\t/**\n\t * Applies the changes to the value.\n\t * Use `reader.reportChange` to report change details or to report a change if the same value is returned.\n\t*/\n\tupdate(reader: IDerivedReader<TOutChange>, previousValue: T, changes: TChangeSummary): T;\n}\n\n/**\n * Creates an observable value that is based on values and changes from other observables.\n * Additionally, a reducer can report how that state changed.\n*/\nexport function observableReducerSettable<T, TInChanges, TOutChange = void>(owner: DebugOwner, options: IReducerOptions<T, TInChanges, TOutChange>): ISettableObservable<T, TOutChange> {\n\tlet prevValue: T | undefined = undefined;\n\tlet hasValue = false;\n\n\tconst d = new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, options.update),\n\t\t(reader: IDerivedReader<TOutChange>, changeSummary) => {\n\t\t\tif (!hasValue) {\n\t\t\t\tprevValue = options.initial instanceof Function ? options.initial() : options.initial;\n\t\t\t\thasValue = true;\n\t\t\t}\n\t\t\tconst newValue = options.update(reader, prevValue!, changeSummary);\n\t\t\tprevValue = newValue;\n\t\t\treturn newValue;\n\t\t},\n\t\toptions.changeTracker,\n\t\t() => {\n\t\t\tif (hasValue) {\n\t\t\t\toptions.disposeFinal?.(prevValue!);\n\t\t\t\thasValue = false;\n\t\t\t}\n\t\t},\n\t\toptions.equalityComparer ?? strictEquals,\n\t\t(value, tx, change) => {\n\t\t\tif (!hasValue) {\n\t\t\t\tthrow new BugIndicatingError('Can only set when there is a listener! This is to prevent leaks.');\n\t\t\t}\n\t\t\tsubtransaction(tx, tx => {\n\t\t\t\tprevValue = value;\n\t\t\t\td.setValue(value, tx, change);\n\t\t\t});\n\t\t},\n\t\tDebugLocation.ofCaller()\n\t);\n\n\treturn d;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { EqualityComparer, strictEquals, BugIndicatingError } from '../commonFacade/deps.js';\nimport { ISettableObservable } from '../base.js';\nimport { subtransaction } from '../transaction.js';\nimport { IChangeTracker } from '../changeTracker.js';\nimport { DebugNameData, DebugOwner } from '../debugName.js';\nimport { DerivedWithSetter, IDerivedReader } from '../observables/derivedImpl.js';\nimport { DebugLocation } from '../debugLocation.js';\n\nexport interface IReducerOptions<T, TChangeSummary = void, TOutChange = void> {\n\t/**\n\t * Is called to create the initial value of the observable when it becomes observed.\n\t*/\n\tinitial: T | (() => T);\n\n\t/**\n\t * Is called to dispose the observable value when it is no longer observed.\n\t*/\n\tdisposeFinal?(value: T): void;\n\tchangeTracker?: IChangeTracker<TChangeSummary>;\n\tequalityComparer?: EqualityComparer<T>;\n\n\t/**\n\t * Applies the changes to the value.\n\t * Use `reader.reportChange` to report change details or to report a change if the same value is returned.\n\t*/\n\tupdate(reader: IDerivedReader<TOutChange>, previousValue: T, changes: TChangeSummary): T;\n}\n\n/**\n * Creates an observable value that is based on values and changes from other observables.\n * Additionally, a reducer can report how that state changed.\n*/\nexport function observableReducerSettable<T, TInChanges, TOutChange = void>(owner: DebugOwner, options: IReducerOptions<T, TInChanges, TOutChange>): ISettableObservable<T, TOutChange> {\n\tlet prevValue: T | undefined = undefined;\n\tlet hasValue = false;\n\n\tconst d = new DerivedWithSetter(\n\t\tnew DebugNameData(owner, undefined, options.update),\n\t\t(reader: IDerivedReader<TOutChange>, changeSummary) => {\n\t\t\tif (!hasValue) {\n\t\t\t\tprevValue = options.initial instanceof Function ? options.initial() : options.initial;\n\t\t\t\thasValue = true;\n\t\t\t}\n\t\t\tconst newValue = options.update(reader, prevValue!, changeSummary);\n\t\t\tprevValue = newValue;\n\t\t\treturn newValue;\n\t\t},\n\t\toptions.changeTracker,\n\t\t() => {\n\t\t\tif (hasValue) {\n\t\t\t\toptions.disposeFinal?.(prevValue!);\n\t\t\t\thasValue = false;\n\t\t\t}\n\t\t},\n\t\toptions.equalityComparer ?? strictEquals,\n\t\t(value, tx, change) => {\n\t\t\tif (!hasValue) {\n\t\t\t\tthrow new BugIndicatingError('Can only set when there is a listener! This is to prevent leaks.');\n\t\t\t}\n\t\t\tsubtransaction(tx, tx => {\n\t\t\t\tprevValue = value;\n\t\t\t\td.setValue(value, tx, change);\n\t\t\t});\n\t\t},\n\t\tDebugLocation.ofCaller()\n\t);\n\n\treturn d;\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;AAEhG,OAAO,EAAoB,YAAY,EAAE,kBAAkB,EAAE,MAAM,yBAAyB,CAAC;AAE7F,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAEnD,OAAO,EAAE,aAAa,EAAc,MAAM,iBAAiB,CAAC;AAC5D,OAAO,EAAE,iBAAiB,EAAkB,MAAM,+BAA+B,CAAC;AAClF,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;;;;;;AA0B9C,SAAU,yBAAyB,CAAmC,KAAiB,EAAE,OAAmD;IACjJ,IAAI,SAAS,GAAkB,SAAS,CAAC;IACzC,IAAI,QAAQ,GAAG,KAAK,CAAC;IAErB,MAAM,CAAC,GAAG,IAAI,wOAAiB,CAC9B,IAAI,mNAAa,CAAC,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,MAAM,CAAC,EACnD,CAAC,MAAkC,EAAE,aAAa,EAAE,EAAE;QACrD,IAAI,CAAC,QAAQ,EAAE,CAAC;YACf,SAAS,GAAG,OAAO,CAAC,OAAO,YAAY,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC;YACtF,QAAQ,GAAG,IAAI,CAAC;QACjB,CAAC;QACD,MAAM,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,SAAU,EAAE,aAAa,CAAC,CAAC;QACnE,SAAS,GAAG,QAAQ,CAAC;QACrB,OAAO,QAAQ,CAAC;IACjB,CAAC,EACD,OAAO,CAAC,aAAa,EACrB,GAAG,EAAE;QACJ,IAAI,QAAQ,EAAE,CAAC;YACd,OAAO,CAAC,YAAY,EAAE,CAAC,SAAU,CAAC,CAAC;YACnC,QAAQ,GAAG,KAAK,CAAC;QAClB,CAAC;IACF,CAAC,EACD,OAAO,CAAC,gBAAgB,IAAI,yLAAY,EACxC,CAAC,KAAK,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE;QACrB,IAAI,CAAC,QAAQ,EAAE,CAAC;YACf,MAAM,IAAI,+LAAkB,CAAC,kEAAkE,CAAC,CAAC;QAClG,CAAC;YACD,sNAAc,EAAC,EAAE,GAAE,EAAE,CAAC,EAAE;YACvB,SAAS,GAAG,KAAK,CAAC;YAClB,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACJ,CAAC,EACD,uNAAa,CAAC,QAAQ,EAAE,CACxB,CAAC;IAEF,OAAO,CAAC,CAAC;AACV,CAAC","debugId":null}}]
}