{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/gpuUtils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/gpuUtils.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/vs/editor/browser/gpu/gpuUtils.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\n\nexport const quadVertices = new Float32Array([\n\t1, 0,\n\t1, 1,\n\t0, 1,\n\t0, 0,\n\t0, 1,\n\t1, 0,\n]);\n\nexport function ensureNonNullable<T>(value: T | null): T {\n\tif (!value) {\n\t\tthrow new Error(`Value \"${value}\" cannot be null`);\n\t}\n\treturn value;\n}\n\n// TODO: Move capabilities into ElementSizeObserver?\nexport function observeDevicePixelDimensions(element: HTMLElement, parentWindow: Window & typeof globalThis, callback: (deviceWidth: number, deviceHeight: number) => void): IDisposable {\n\t// Observe any resizes to the element and extract the actual pixel size of the element if the\n\t// devicePixelContentBoxSize API is supported. This allows correcting rounding errors when\n\t// converting between CSS pixels and device pixels which causes blurry rendering when device\n\t// pixel ratio is not a round number.\n\tlet observer: ResizeObserver | undefined = new parentWindow.ResizeObserver((entries) => {\n\t\tconst entry = entries.find((entry) => entry.target === element);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Disconnect if devicePixelContentBoxSize isn't supported by the browser\n\t\tif (!('devicePixelContentBoxSize' in entry)) {\n\t\t\tobserver?.disconnect();\n\t\t\tobserver = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\t// Fire the callback, ignore events where the dimensions are 0x0 as the canvas is likely hidden\n\t\tconst width = entry.devicePixelContentBoxSize[0].inlineSize;\n\t\tconst height = entry.devicePixelContentBoxSize[0].blockSize;\n\t\tif (width > 0 && height > 0) {\n\t\t\tcallback(width, height);\n\t\t}\n\t});\n\ttry {\n\t\tobserver.observe(element, { box: ['device-pixel-content-box'] } as any);\n\t} catch {\n\t\tobserver.disconnect();\n\t\tobserver = undefined;\n\t\tthrow new BugIndicatingError('Could not observe device pixel dimensions');\n\t}\n\treturn toDisposable(() => observer?.disconnect());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\n\nexport const quadVertices = new Float32Array([\n\t1, 0,\n\t1, 1,\n\t0, 1,\n\t0, 0,\n\t0, 1,\n\t1, 0,\n]);\n\nexport function ensureNonNullable<T>(value: T | null): T {\n\tif (!value) {\n\t\tthrow new Error(`Value \"${value}\" cannot be null`);\n\t}\n\treturn value;\n}\n\n// TODO: Move capabilities into ElementSizeObserver?\nexport function observeDevicePixelDimensions(element: HTMLElement, parentWindow: Window & typeof globalThis, callback: (deviceWidth: number, deviceHeight: number) => void): IDisposable {\n\t// Observe any resizes to the element and extract the actual pixel size of the element if the\n\t// devicePixelContentBoxSize API is supported. This allows correcting rounding errors when\n\t// converting between CSS pixels and device pixels which causes blurry rendering when device\n\t// pixel ratio is not a round number.\n\tlet observer: ResizeObserver | undefined = new parentWindow.ResizeObserver((entries) => {\n\t\tconst entry = entries.find((entry) => entry.target === element);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Disconnect if devicePixelContentBoxSize isn't supported by the browser\n\t\tif (!('devicePixelContentBoxSize' in entry)) {\n\t\t\tobserver?.disconnect();\n\t\t\tobserver = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\t// Fire the callback, ignore events where the dimensions are 0x0 as the canvas is likely hidden\n\t\tconst width = entry.devicePixelContentBoxSize[0].inlineSize;\n\t\tconst height = entry.devicePixelContentBoxSize[0].blockSize;\n\t\tif (width > 0 && height > 0) {\n\t\t\tcallback(width, height);\n\t\t}\n\t});\n\ttry {\n\t\tobserver.observe(element, { box: ['device-pixel-content-box'] } as any);\n\t} catch {\n\t\tobserver.disconnect();\n\t\tobserver = undefined;\n\t\tthrow new BugIndicatingError('Could not observe device pixel dimensions');\n\t}\n\treturn toDisposable(() => observer?.disconnect());\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;AAEhG,OAAO,EAAE,kBAAkB,EAAE,MAAM,gCAAgC,CAAC;AACpE,OAAO,EAAE,YAAY,EAAoB,MAAM,mCAAmC,CAAC;;;AAE5E,MAAM,YAAY,GAAG,IAAI,YAAY,CAAC;IAC5C,CAAC;IAAE,CAAC;IACJ,CAAC;IAAE,CAAC;IACJ,CAAC;IAAE,CAAC;IACJ,CAAC;IAAE,CAAC;IACJ,CAAC;IAAE,CAAC;IACJ,CAAC;IAAE,CAAC;CACJ,CAAC,CAAC;AAEG,SAAU,iBAAiB,CAAI,KAAe;IACnD,IAAI,CAAC,KAAK,EAAE,CAAC;QACZ,MAAM,IAAI,KAAK,CAAC,CAAA,OAAA,EAAU,KAAK,CAAA,gBAAA,CAAkB,CAAC,CAAC;IACpD,CAAC;IACD,OAAO,KAAK,CAAC;AACd,CAAC;AAGK,SAAU,4BAA4B,CAAC,OAAoB,EAAE,YAAwC,EAAE,QAA6D;IACzK,6FAA6F;IAC7F,0FAA0F;IAC1F,4FAA4F;IAC5F,qCAAqC;IACrC,IAAI,QAAQ,GAA+B,IAAI,YAAY,CAAC,cAAc,CAAC,CAAC,OAAO,EAAE,EAAE;QACtF,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAG,CAAD,IAAM,CAAC,MAAM,KAAK,OAAO,CAAC,CAAC;QAChE,IAAI,CAAC,KAAK,EAAE,CAAC;YACZ,OAAO;QACR,CAAC;QAED,yEAAyE;QACzE,IAAI,CAAC,CAAC,2BAA2B,IAAI,KAAK,CAAC,EAAE,CAAC;YAC7C,QAAQ,EAAE,UAAU,EAAE,CAAC;YACvB,QAAQ,GAAG,SAAS,CAAC;YACrB,OAAO;QACR,CAAC;QAED,+FAA+F;QAC/F,MAAM,KAAK,GAAG,KAAK,CAAC,yBAAyB,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;QAC5D,MAAM,MAAM,GAAG,KAAK,CAAC,yBAAyB,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAC5D,IAAI,KAAK,GAAG,CAAC,IAAI,MAAM,GAAG,CAAC,EAAE,CAAC;YAC7B,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QACzB,CAAC;IACF,CAAC,CAAC,CAAC;IACH,IAAI,CAAC;QACJ,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE;YAAE,GAAG,EAAE;gBAAC,0BAA0B;aAAC;QAAA,CAAS,CAAC,CAAC;IACzE,CAAC,CAAC,OAAM,CAAC;QACR,QAAQ,CAAC,UAAU,EAAE,CAAC;QACtB,QAAQ,GAAG,SAAS,CAAC;QACrB,MAAM,IAAI,+LAAkB,CAAC,2CAA2C,CAAC,CAAC;IAC3E,CAAC;IACD,WAAO,4LAAY,EAAC,GAAG,CAAG,CAAD,OAAS,EAAE,UAAU,EAAE,CAAC,CAAC;AACnD,CAAC","debugId":null}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/raster/glyphRasterizer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/raster/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/raster/glyphRasterizer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/raster/vs/editor/browser/gpu/raster/glyphRasterizer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { memoize } from '../../../../base/common/decorators.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isMacintosh } from '../../../../base/common/platform.js';\nimport { StringBuilder } from '../../../common/core/stringBuilder.js';\nimport { FontStyle, TokenMetadata } from '../../../common/encodedTokenAttributes.js';\nimport { DecorationStyleCache } from '../css/decorationStyleCache.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { type IBoundingBox, type IGlyphRasterizer, type IRasterizedGlyph } from './raster.js';\n\nlet nextId = 0;\n\nexport class GlyphRasterizer extends Disposable implements IGlyphRasterizer {\n\tpublic readonly id = nextId++;\n\n\t@memoize\n\tpublic get cacheKey(): string {\n\t\treturn `${this.fontFamily}_${this.fontSize}px`;\n\t}\n\n\tprivate _canvas: OffscreenCanvas;\n\tprivate _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate readonly _textMetrics: TextMetrics;\n\n\tprivate _workGlyph: IRasterizedGlyph = {\n\t\tsource: null!,\n\t\tboundingBox: {\n\t\t\tleft: 0,\n\t\t\tbottom: 0,\n\t\t\tright: 0,\n\t\t\ttop: 0,\n\t\t},\n\t\toriginOffset: {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t},\n\t\tfontBoundingBoxAscent: 0,\n\t\tfontBoundingBoxDescent: 0,\n\t};\n\tprivate _workGlyphConfig: { chars: string | undefined; tokenMetadata: number; decorationStyleSetId: number } = { chars: undefined, tokenMetadata: 0, decorationStyleSetId: 0 };\n\n\t// TODO: Support workbench.fontAliasing correctly\n\tprivate _antiAliasing: 'subpixel' | 'greyscale' = isMacintosh ? 'greyscale' : 'subpixel';\n\n\tconstructor(\n\t\treadonly fontSize: number,\n\t\treadonly fontFamily: string,\n\t\treadonly devicePixelRatio: number,\n\t\tprivate readonly _decorationStyleCache: DecorationStyleCache,\n\t) {\n\t\tsuper();\n\n\t\tconst devicePixelFontSize = Math.ceil(this.fontSize * devicePixelRatio);\n\t\tthis._canvas = new OffscreenCanvas(devicePixelFontSize * 3, devicePixelFontSize * 3);\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true,\n\t\t\talpha: this._antiAliasing === 'greyscale',\n\t\t}));\n\t\tthis._ctx.textBaseline = 'top';\n\t\tthis._ctx.fillStyle = '#FFFFFF';\n\t\tthis._ctx.font = `${devicePixelFontSize}px ${this.fontFamily}`;\n\t\tthis._textMetrics = this._ctx.measureText('A');\n\t}\n\n\t/**\n\t * Rasterizes a glyph. Note that the returned object is reused across different glyphs and\n\t * therefore is only safe for synchronous access.\n\t */\n\tpublic rasterizeGlyph(\n\t\tchars: string,\n\t\ttokenMetadata: number,\n\t\tdecorationStyleSetId: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\tif (chars === '') {\n\t\t\treturn {\n\t\t\t\tsource: this._canvas,\n\t\t\t\tboundingBox: { top: 0, left: 0, bottom: -1, right: -1 },\n\t\t\t\toriginOffset: { x: 0, y: 0 },\n\t\t\t\tfontBoundingBoxAscent: 0,\n\t\t\t\tfontBoundingBoxDescent: 0,\n\t\t\t};\n\t\t}\n\t\t// Check if the last glyph matches the config, reuse if so. This helps avoid unnecessary\n\t\t// work when the rasterizer is called multiple times like when the glyph doesn't fit into a\n\t\t// page.\n\t\tif (this._workGlyphConfig.chars === chars && this._workGlyphConfig.tokenMetadata === tokenMetadata && this._workGlyphConfig.decorationStyleSetId === decorationStyleSetId) {\n\t\t\treturn this._workGlyph;\n\t\t}\n\t\tthis._workGlyphConfig.chars = chars;\n\t\tthis._workGlyphConfig.tokenMetadata = tokenMetadata;\n\t\tthis._workGlyphConfig.decorationStyleSetId = decorationStyleSetId;\n\t\treturn this._rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, colorMap);\n\t}\n\n\tpublic _rasterizeGlyph(\n\t\tchars: string,\n\t\ttokenMetadata: number,\n\t\tdecorationStyleSetId: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\tconst devicePixelFontSize = Math.ceil(this.fontSize * this.devicePixelRatio);\n\t\tconst canvasDim = devicePixelFontSize * 3;\n\t\tif (this._canvas.width !== canvasDim) {\n\t\t\tthis._canvas.width = canvasDim;\n\t\t\tthis._canvas.height = canvasDim;\n\t\t}\n\n\t\tthis._ctx.save();\n\n\t\t// The sub-pixel x offset is the fractional part of the x pixel coordinate of the cell, this\n\t\t// is used to improve the spacing between rendered characters.\n\t\tconst xSubPixelXOffset = (tokenMetadata & 0b1111) / 10;\n\n\t\tconst bgId = TokenMetadata.getBackground(tokenMetadata);\n\t\tconst bg = colorMap[bgId];\n\n\t\tconst decorationStyleSet = this._decorationStyleCache.getStyleSet(decorationStyleSetId);\n\n\t\t// When SPAA is used, the background color must be present to get the right glyph\n\t\tif (this._antiAliasing === 'subpixel') {\n\t\t\tthis._ctx.fillStyle = bg;\n\t\t\tthis._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n\t\t} else {\n\t\t\tthis._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n\t\t}\n\n\t\tconst fontSb = new StringBuilder(200);\n\t\tconst fontStyle = TokenMetadata.getFontStyle(tokenMetadata);\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tfontSb.appendString('italic ');\n\t\t}\n\t\tif (decorationStyleSet?.bold !== undefined) {\n\t\t\tif (decorationStyleSet.bold) {\n\t\t\t\tfontSb.appendString('bold ');\n\t\t\t}\n\t\t} else if (fontStyle & FontStyle.Bold) {\n\t\t\tfontSb.appendString('bold ');\n\t\t}\n\t\tfontSb.appendString(`${devicePixelFontSize}px ${this.fontFamily}`);\n\t\tthis._ctx.font = fontSb.build();\n\n\t\t// TODO: Support FontStyle.Strikethrough and FontStyle.Underline text decorations, these\n\t\t//       need to be drawn manually to the canvas. See xterm.js for \"dodging\" the text for\n\t\t//       underlines.\n\n\t\tconst originX = devicePixelFontSize;\n\t\tconst originY = devicePixelFontSize;\n\t\tif (decorationStyleSet?.color !== undefined) {\n\t\t\tthis._ctx.fillStyle = `#${decorationStyleSet.color.toString(16).padStart(8, '0')}`;\n\t\t} else {\n\t\t\tthis._ctx.fillStyle = colorMap[TokenMetadata.getForeground(tokenMetadata)];\n\t\t}\n\t\tthis._ctx.textBaseline = 'top';\n\n\t\tif (decorationStyleSet?.opacity !== undefined) {\n\t\t\tthis._ctx.globalAlpha = decorationStyleSet.opacity;\n\t\t}\n\n\t\tthis._ctx.fillText(chars, originX + xSubPixelXOffset, originY);\n\t\tthis._ctx.restore();\n\n\t\tconst imageData = this._ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);\n\t\tif (this._antiAliasing === 'subpixel') {\n\t\t\tconst bgR = parseInt(bg.substring(1, 3), 16);\n\t\t\tconst bgG = parseInt(bg.substring(3, 5), 16);\n\t\t\tconst bgB = parseInt(bg.substring(5, 7), 16);\n\t\t\tthis._clearColor(imageData, bgR, bgG, bgB);\n\t\t\tthis._ctx.putImageData(imageData, 0, 0);\n\t\t}\n\t\tthis._findGlyphBoundingBox(imageData, this._workGlyph.boundingBox);\n\t\t// const offset = {\n\t\t// \tx: textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxAscent\n\t\t// };\n\t\t// const size = {\n\t\t// \tw: textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent,\n\t\t// \twInt: Math.ceil(textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft),\n\t\t// \tyInt: Math.ceil(textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent),\n\t\t// };\n\t\t// console.log(`${chars}_${fg}`, textMetrics, boundingBox, originX, originY, { width: boundingBox.right - boundingBox.left, height: boundingBox.bottom - boundingBox.top });\n\t\tthis._workGlyph.source = this._canvas;\n\t\tthis._workGlyph.originOffset.x = this._workGlyph.boundingBox.left - originX;\n\t\tthis._workGlyph.originOffset.y = this._workGlyph.boundingBox.top - originY;\n\t\tthis._workGlyph.fontBoundingBoxAscent = this._textMetrics.fontBoundingBoxAscent;\n\t\tthis._workGlyph.fontBoundingBoxDescent = this._textMetrics.fontBoundingBoxDescent;\n\n\t\t// const result2: IRasterizedGlyph = {\n\t\t// \tsource: this._canvas,\n\t\t// \tboundingBox: {\n\t\t// \t\tleft: Math.floor(originX - textMetrics.actualBoundingBoxLeft),\n\t\t// \t\tright: Math.ceil(originX + textMetrics.actualBoundingBoxRight),\n\t\t// \t\ttop: Math.floor(originY - textMetrics.actualBoundingBoxAscent),\n\t\t// \t\tbottom: Math.ceil(originY + textMetrics.actualBoundingBoxDescent),\n\t\t// \t},\n\t\t// \toriginOffset: {\n\t\t// \t\tx: Math.floor(boundingBox.left - originX),\n\t\t// \t\ty: Math.floor(boundingBox.top - originY)\n\t\t// \t}\n\t\t// };\n\n\t\t// TODO: Verify result 1 and 2 are the same\n\n\t\t// if (result2.boundingBox.left > result.boundingBox.left) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.top > result.boundingBox.top) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.right < result.boundingBox.right) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.bottom < result.boundingBox.bottom) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (JSON.stringify(result2.originOffset) !== JSON.stringify(result.originOffset)) {\n\t\t// \tdebugger;\n\t\t// }\n\n\n\n\t\treturn this._workGlyph;\n\t}\n\n\tprivate _clearColor(imageData: ImageData, r: number, g: number, b: number) {\n\t\tfor (let offset = 0; offset < imageData.data.length; offset += 4) {\n\t\t\t// Check exact match\n\t\t\tif (imageData.data[offset] === r &&\n\t\t\t\timageData.data[offset + 1] === g &&\n\t\t\t\timageData.data[offset + 2] === b) {\n\t\t\t\timageData.data[offset + 3] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: Does this even need to happen when measure text is used?\n\tprivate _findGlyphBoundingBox(imageData: ImageData, outBoundingBox: IBoundingBox) {\n\t\tconst height = this._canvas.height;\n\t\tconst width = this._canvas.width;\n\t\tlet found = false;\n\t\tfor (let y = 0; y < height; y++) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.top = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.left = 0;\n\t\tfound = false;\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.left = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.right = width;\n\t\tfound = false;\n\t\tfor (let x = width - 1; x >= outBoundingBox.left; x--) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.right = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.bottom = outBoundingBox.top;\n\t\tfound = false;\n\t\tfor (let y = height - 1; y >= 0; y--) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.bottom = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getTextMetrics(text: string): TextMetrics {\n\t\treturn this._ctx.measureText(text);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { memoize } from '../../../../base/common/decorators.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { isMacintosh } from '../../../../base/common/platform.js';\nimport { StringBuilder } from '../../../common/core/stringBuilder.js';\nimport { FontStyle, TokenMetadata } from '../../../common/encodedTokenAttributes.js';\nimport { DecorationStyleCache } from '../css/decorationStyleCache.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { type IBoundingBox, type IGlyphRasterizer, type IRasterizedGlyph } from './raster.js';\n\nlet nextId = 0;\n\nexport class GlyphRasterizer extends Disposable implements IGlyphRasterizer {\n\tpublic readonly id = nextId++;\n\n\t@memoize\n\tpublic get cacheKey(): string {\n\t\treturn `${this.fontFamily}_${this.fontSize}px`;\n\t}\n\n\tprivate _canvas: OffscreenCanvas;\n\tprivate _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate readonly _textMetrics: TextMetrics;\n\n\tprivate _workGlyph: IRasterizedGlyph = {\n\t\tsource: null!,\n\t\tboundingBox: {\n\t\t\tleft: 0,\n\t\t\tbottom: 0,\n\t\t\tright: 0,\n\t\t\ttop: 0,\n\t\t},\n\t\toriginOffset: {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t},\n\t\tfontBoundingBoxAscent: 0,\n\t\tfontBoundingBoxDescent: 0,\n\t};\n\tprivate _workGlyphConfig: { chars: string | undefined; tokenMetadata: number; decorationStyleSetId: number } = { chars: undefined, tokenMetadata: 0, decorationStyleSetId: 0 };\n\n\t// TODO: Support workbench.fontAliasing correctly\n\tprivate _antiAliasing: 'subpixel' | 'greyscale' = isMacintosh ? 'greyscale' : 'subpixel';\n\n\tconstructor(\n\t\treadonly fontSize: number,\n\t\treadonly fontFamily: string,\n\t\treadonly devicePixelRatio: number,\n\t\tprivate readonly _decorationStyleCache: DecorationStyleCache,\n\t) {\n\t\tsuper();\n\n\t\tconst devicePixelFontSize = Math.ceil(this.fontSize * devicePixelRatio);\n\t\tthis._canvas = new OffscreenCanvas(devicePixelFontSize * 3, devicePixelFontSize * 3);\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true,\n\t\t\talpha: this._antiAliasing === 'greyscale',\n\t\t}));\n\t\tthis._ctx.textBaseline = 'top';\n\t\tthis._ctx.fillStyle = '#FFFFFF';\n\t\tthis._ctx.font = `${devicePixelFontSize}px ${this.fontFamily}`;\n\t\tthis._textMetrics = this._ctx.measureText('A');\n\t}\n\n\t/**\n\t * Rasterizes a glyph. Note that the returned object is reused across different glyphs and\n\t * therefore is only safe for synchronous access.\n\t */\n\tpublic rasterizeGlyph(\n\t\tchars: string,\n\t\ttokenMetadata: number,\n\t\tdecorationStyleSetId: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\tif (chars === '') {\n\t\t\treturn {\n\t\t\t\tsource: this._canvas,\n\t\t\t\tboundingBox: { top: 0, left: 0, bottom: -1, right: -1 },\n\t\t\t\toriginOffset: { x: 0, y: 0 },\n\t\t\t\tfontBoundingBoxAscent: 0,\n\t\t\t\tfontBoundingBoxDescent: 0,\n\t\t\t};\n\t\t}\n\t\t// Check if the last glyph matches the config, reuse if so. This helps avoid unnecessary\n\t\t// work when the rasterizer is called multiple times like when the glyph doesn't fit into a\n\t\t// page.\n\t\tif (this._workGlyphConfig.chars === chars && this._workGlyphConfig.tokenMetadata === tokenMetadata && this._workGlyphConfig.decorationStyleSetId === decorationStyleSetId) {\n\t\t\treturn this._workGlyph;\n\t\t}\n\t\tthis._workGlyphConfig.chars = chars;\n\t\tthis._workGlyphConfig.tokenMetadata = tokenMetadata;\n\t\tthis._workGlyphConfig.decorationStyleSetId = decorationStyleSetId;\n\t\treturn this._rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, colorMap);\n\t}\n\n\tpublic _rasterizeGlyph(\n\t\tchars: string,\n\t\ttokenMetadata: number,\n\t\tdecorationStyleSetId: number,\n\t\tcolorMap: string[],\n\t): Readonly<IRasterizedGlyph> {\n\t\tconst devicePixelFontSize = Math.ceil(this.fontSize * this.devicePixelRatio);\n\t\tconst canvasDim = devicePixelFontSize * 3;\n\t\tif (this._canvas.width !== canvasDim) {\n\t\t\tthis._canvas.width = canvasDim;\n\t\t\tthis._canvas.height = canvasDim;\n\t\t}\n\n\t\tthis._ctx.save();\n\n\t\t// The sub-pixel x offset is the fractional part of the x pixel coordinate of the cell, this\n\t\t// is used to improve the spacing between rendered characters.\n\t\tconst xSubPixelXOffset = (tokenMetadata & 0b1111) / 10;\n\n\t\tconst bgId = TokenMetadata.getBackground(tokenMetadata);\n\t\tconst bg = colorMap[bgId];\n\n\t\tconst decorationStyleSet = this._decorationStyleCache.getStyleSet(decorationStyleSetId);\n\n\t\t// When SPAA is used, the background color must be present to get the right glyph\n\t\tif (this._antiAliasing === 'subpixel') {\n\t\t\tthis._ctx.fillStyle = bg;\n\t\t\tthis._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n\t\t} else {\n\t\t\tthis._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n\t\t}\n\n\t\tconst fontSb = new StringBuilder(200);\n\t\tconst fontStyle = TokenMetadata.getFontStyle(tokenMetadata);\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tfontSb.appendString('italic ');\n\t\t}\n\t\tif (decorationStyleSet?.bold !== undefined) {\n\t\t\tif (decorationStyleSet.bold) {\n\t\t\t\tfontSb.appendString('bold ');\n\t\t\t}\n\t\t} else if (fontStyle & FontStyle.Bold) {\n\t\t\tfontSb.appendString('bold ');\n\t\t}\n\t\tfontSb.appendString(`${devicePixelFontSize}px ${this.fontFamily}`);\n\t\tthis._ctx.font = fontSb.build();\n\n\t\t// TODO: Support FontStyle.Strikethrough and FontStyle.Underline text decorations, these\n\t\t//       need to be drawn manually to the canvas. See xterm.js for \"dodging\" the text for\n\t\t//       underlines.\n\n\t\tconst originX = devicePixelFontSize;\n\t\tconst originY = devicePixelFontSize;\n\t\tif (decorationStyleSet?.color !== undefined) {\n\t\t\tthis._ctx.fillStyle = `#${decorationStyleSet.color.toString(16).padStart(8, '0')}`;\n\t\t} else {\n\t\t\tthis._ctx.fillStyle = colorMap[TokenMetadata.getForeground(tokenMetadata)];\n\t\t}\n\t\tthis._ctx.textBaseline = 'top';\n\n\t\tif (decorationStyleSet?.opacity !== undefined) {\n\t\t\tthis._ctx.globalAlpha = decorationStyleSet.opacity;\n\t\t}\n\n\t\tthis._ctx.fillText(chars, originX + xSubPixelXOffset, originY);\n\t\tthis._ctx.restore();\n\n\t\tconst imageData = this._ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);\n\t\tif (this._antiAliasing === 'subpixel') {\n\t\t\tconst bgR = parseInt(bg.substring(1, 3), 16);\n\t\t\tconst bgG = parseInt(bg.substring(3, 5), 16);\n\t\t\tconst bgB = parseInt(bg.substring(5, 7), 16);\n\t\t\tthis._clearColor(imageData, bgR, bgG, bgB);\n\t\t\tthis._ctx.putImageData(imageData, 0, 0);\n\t\t}\n\t\tthis._findGlyphBoundingBox(imageData, this._workGlyph.boundingBox);\n\t\t// const offset = {\n\t\t// \tx: textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxAscent\n\t\t// };\n\t\t// const size = {\n\t\t// \tw: textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft,\n\t\t// \ty: textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent,\n\t\t// \twInt: Math.ceil(textMetrics.actualBoundingBoxRight + textMetrics.actualBoundingBoxLeft),\n\t\t// \tyInt: Math.ceil(textMetrics.actualBoundingBoxDescent + textMetrics.actualBoundingBoxAscent),\n\t\t// };\n\t\t// console.log(`${chars}_${fg}`, textMetrics, boundingBox, originX, originY, { width: boundingBox.right - boundingBox.left, height: boundingBox.bottom - boundingBox.top });\n\t\tthis._workGlyph.source = this._canvas;\n\t\tthis._workGlyph.originOffset.x = this._workGlyph.boundingBox.left - originX;\n\t\tthis._workGlyph.originOffset.y = this._workGlyph.boundingBox.top - originY;\n\t\tthis._workGlyph.fontBoundingBoxAscent = this._textMetrics.fontBoundingBoxAscent;\n\t\tthis._workGlyph.fontBoundingBoxDescent = this._textMetrics.fontBoundingBoxDescent;\n\n\t\t// const result2: IRasterizedGlyph = {\n\t\t// \tsource: this._canvas,\n\t\t// \tboundingBox: {\n\t\t// \t\tleft: Math.floor(originX - textMetrics.actualBoundingBoxLeft),\n\t\t// \t\tright: Math.ceil(originX + textMetrics.actualBoundingBoxRight),\n\t\t// \t\ttop: Math.floor(originY - textMetrics.actualBoundingBoxAscent),\n\t\t// \t\tbottom: Math.ceil(originY + textMetrics.actualBoundingBoxDescent),\n\t\t// \t},\n\t\t// \toriginOffset: {\n\t\t// \t\tx: Math.floor(boundingBox.left - originX),\n\t\t// \t\ty: Math.floor(boundingBox.top - originY)\n\t\t// \t}\n\t\t// };\n\n\t\t// TODO: Verify result 1 and 2 are the same\n\n\t\t// if (result2.boundingBox.left > result.boundingBox.left) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.top > result.boundingBox.top) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.right < result.boundingBox.right) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (result2.boundingBox.bottom < result.boundingBox.bottom) {\n\t\t// \tdebugger;\n\t\t// }\n\t\t// if (JSON.stringify(result2.originOffset) !== JSON.stringify(result.originOffset)) {\n\t\t// \tdebugger;\n\t\t// }\n\n\n\n\t\treturn this._workGlyph;\n\t}\n\n\tprivate _clearColor(imageData: ImageData, r: number, g: number, b: number) {\n\t\tfor (let offset = 0; offset < imageData.data.length; offset += 4) {\n\t\t\t// Check exact match\n\t\t\tif (imageData.data[offset] === r &&\n\t\t\t\timageData.data[offset + 1] === g &&\n\t\t\t\timageData.data[offset + 2] === b) {\n\t\t\t\timageData.data[offset + 3] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: Does this even need to happen when measure text is used?\n\tprivate _findGlyphBoundingBox(imageData: ImageData, outBoundingBox: IBoundingBox) {\n\t\tconst height = this._canvas.height;\n\t\tconst width = this._canvas.width;\n\t\tlet found = false;\n\t\tfor (let y = 0; y < height; y++) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.top = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.left = 0;\n\t\tfound = false;\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.left = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.right = width;\n\t\tfound = false;\n\t\tfor (let x = width - 1; x >= outBoundingBox.left; x--) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.right = x;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\toutBoundingBox.bottom = outBoundingBox.top;\n\t\tfound = false;\n\t\tfor (let y = height - 1; y >= 0; y--) {\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tconst alphaOffset = y * width * 4 + x * 4 + 3;\n\t\t\t\tif (imageData.data[alphaOffset] !== 0) {\n\t\t\t\t\toutBoundingBox.bottom = y;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getTextMetrics(text: string): TextMetrics {\n\t\treturn this._ctx.measureText(text);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/taskQueue.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/taskQueue.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/vs/editor/browser/gpu/taskQueue.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../base/browser/dom.js';\nimport { Disposable, toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\n\n/**\n * Copyright (c) 2022 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport interface ITaskQueue extends IDisposable {\n\n\t/**\n\t * Clears any remaining tasks from the queue, these will not be run.\n\t */\n\tclear(): void;\n}\n\ninterface ITaskDeadline {\n\ttimeRemaining(): number;\n}\ntype CallbackWithDeadline = (deadline: ITaskDeadline) => void;\n\nabstract class TaskQueue extends Disposable implements ITaskQueue {\n\tprivate _tasks: (() => boolean | void)[] = [];\n\tprivate _idleCallback?: number;\n\tprivate _i = 0;\n\n\tconstructor(\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => this.clear()));\n\t}\n\n\tprotected abstract _requestCallback(callback: CallbackWithDeadline): number;\n\tprotected abstract _cancelCallback(identifier: number): void;\n\n\tpublic enqueue(task: () => boolean | void): void {\n\t\tthis._tasks.push(task);\n\t\tthis._start();\n\t}\n\n\tpublic clear(): void {\n\t\tif (this._idleCallback) {\n\t\t\tthis._cancelCallback(this._idleCallback);\n\t\t\tthis._idleCallback = undefined;\n\t\t}\n\t\tthis._i = 0;\n\t\tthis._tasks.length = 0;\n\t}\n\n\tprivate _start(): void {\n\t\tif (!this._idleCallback) {\n\t\t\tthis._idleCallback = this._requestCallback(this._process.bind(this));\n\t\t}\n\t}\n\n\tprivate _process(deadline: ITaskDeadline): void {\n\t\tthis._idleCallback = undefined;\n\t\tlet taskDuration = 0;\n\t\tlet longestTask = 0;\n\t\tlet lastDeadlineRemaining = deadline.timeRemaining();\n\t\tlet deadlineRemaining = 0;\n\t\twhile (this._i < this._tasks.length) {\n\t\t\ttaskDuration = Date.now();\n\t\t\tif (!this._tasks[this._i]()) {\n\t\t\t\tthis._i++;\n\t\t\t}\n\t\t\t// other than performance.now, Date.now might not be stable (changes on wall clock changes),\n\t\t\t// this is not an issue here as a clock change during a short running task is very unlikely\n\t\t\t// in case it still happened and leads to negative duration, simply assume 1 msec\n\t\t\ttaskDuration = Math.max(1, Date.now() - taskDuration);\n\t\t\tlongestTask = Math.max(taskDuration, longestTask);\n\t\t\t// Guess the following task will take a similar time to the longest task in this batch, allow\n\t\t\t// additional room to try avoid exceeding the deadline\n\t\t\tdeadlineRemaining = deadline.timeRemaining();\n\t\t\tif (longestTask * 1.5 > deadlineRemaining) {\n\t\t\t\t// Warn when the time exceeding the deadline is over 20ms, if this happens in practice the\n\t\t\t\t// task should be split into sub-tasks to ensure the UI remains responsive.\n\t\t\t\tif (lastDeadlineRemaining - taskDuration < -20) {\n\t\t\t\t\tthis._logService.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(lastDeadlineRemaining - taskDuration))}ms`);\n\t\t\t\t}\n\t\t\t\tthis._start();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastDeadlineRemaining = deadlineRemaining;\n\t\t}\n\t\tthis.clear();\n\t}\n}\n\n/**\n * A queue of that runs tasks over several tasks via setTimeout, trying to maintain above 60 frames\n * per second. The tasks will run in the order they are enqueued, but they will run some time later,\n * and care should be taken to ensure they're non-urgent and will not introduce race conditions.\n */\nexport class PriorityTaskQueue extends TaskQueue {\n\tprotected _requestCallback(callback: CallbackWithDeadline): number {\n\t\treturn getActiveWindow().setTimeout(() => callback(this._createDeadline(16)));\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().clearTimeout(identifier);\n\t}\n\n\tprivate _createDeadline(duration: number): ITaskDeadline {\n\t\tconst end = Date.now() + duration;\n\t\treturn {\n\t\t\ttimeRemaining: () => Math.max(0, end - Date.now())\n\t\t};\n\t}\n}\n\nclass IdleTaskQueueInternal extends TaskQueue {\n\tprotected _requestCallback(callback: IdleRequestCallback): number {\n\t\treturn getActiveWindow().requestIdleCallback(callback);\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().cancelIdleCallback(identifier);\n\t}\n}\n\n/**\n * A queue of that runs tasks over several idle callbacks, trying to respect the idle callback's\n * deadline given by the environment. The tasks will run in the order they are enqueued, but they\n * will run some time later, and care should be taken to ensure they're non-urgent and will not\n * introduce race conditions.\n *\n * This reverts to a {@link PriorityTaskQueue} if the environment does not support idle callbacks.\n */\nexport const IdleTaskQueue = ('requestIdleCallback' in getActiveWindow()) ? IdleTaskQueueInternal : PriorityTaskQueue;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../base/browser/dom.js';\nimport { Disposable, toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\n\n/**\n * Copyright (c) 2022 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport interface ITaskQueue extends IDisposable {\n\n\t/**\n\t * Clears any remaining tasks from the queue, these will not be run.\n\t */\n\tclear(): void;\n}\n\ninterface ITaskDeadline {\n\ttimeRemaining(): number;\n}\ntype CallbackWithDeadline = (deadline: ITaskDeadline) => void;\n\nabstract class TaskQueue extends Disposable implements ITaskQueue {\n\tprivate _tasks: (() => boolean | void)[] = [];\n\tprivate _idleCallback?: number;\n\tprivate _i = 0;\n\n\tconstructor(\n\t\t@ILogService private readonly _logService: ILogService\n\t) {\n\t\tsuper();\n\t\tthis._register(toDisposable(() => this.clear()));\n\t}\n\n\tprotected abstract _requestCallback(callback: CallbackWithDeadline): number;\n\tprotected abstract _cancelCallback(identifier: number): void;\n\n\tpublic enqueue(task: () => boolean | void): void {\n\t\tthis._tasks.push(task);\n\t\tthis._start();\n\t}\n\n\tpublic clear(): void {\n\t\tif (this._idleCallback) {\n\t\t\tthis._cancelCallback(this._idleCallback);\n\t\t\tthis._idleCallback = undefined;\n\t\t}\n\t\tthis._i = 0;\n\t\tthis._tasks.length = 0;\n\t}\n\n\tprivate _start(): void {\n\t\tif (!this._idleCallback) {\n\t\t\tthis._idleCallback = this._requestCallback(this._process.bind(this));\n\t\t}\n\t}\n\n\tprivate _process(deadline: ITaskDeadline): void {\n\t\tthis._idleCallback = undefined;\n\t\tlet taskDuration = 0;\n\t\tlet longestTask = 0;\n\t\tlet lastDeadlineRemaining = deadline.timeRemaining();\n\t\tlet deadlineRemaining = 0;\n\t\twhile (this._i < this._tasks.length) {\n\t\t\ttaskDuration = Date.now();\n\t\t\tif (!this._tasks[this._i]()) {\n\t\t\t\tthis._i++;\n\t\t\t}\n\t\t\t// other than performance.now, Date.now might not be stable (changes on wall clock changes),\n\t\t\t// this is not an issue here as a clock change during a short running task is very unlikely\n\t\t\t// in case it still happened and leads to negative duration, simply assume 1 msec\n\t\t\ttaskDuration = Math.max(1, Date.now() - taskDuration);\n\t\t\tlongestTask = Math.max(taskDuration, longestTask);\n\t\t\t// Guess the following task will take a similar time to the longest task in this batch, allow\n\t\t\t// additional room to try avoid exceeding the deadline\n\t\t\tdeadlineRemaining = deadline.timeRemaining();\n\t\t\tif (longestTask * 1.5 > deadlineRemaining) {\n\t\t\t\t// Warn when the time exceeding the deadline is over 20ms, if this happens in practice the\n\t\t\t\t// task should be split into sub-tasks to ensure the UI remains responsive.\n\t\t\t\tif (lastDeadlineRemaining - taskDuration < -20) {\n\t\t\t\t\tthis._logService.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(lastDeadlineRemaining - taskDuration))}ms`);\n\t\t\t\t}\n\t\t\t\tthis._start();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastDeadlineRemaining = deadlineRemaining;\n\t\t}\n\t\tthis.clear();\n\t}\n}\n\n/**\n * A queue of that runs tasks over several tasks via setTimeout, trying to maintain above 60 frames\n * per second. The tasks will run in the order they are enqueued, but they will run some time later,\n * and care should be taken to ensure they're non-urgent and will not introduce race conditions.\n */\nexport class PriorityTaskQueue extends TaskQueue {\n\tprotected _requestCallback(callback: CallbackWithDeadline): number {\n\t\treturn getActiveWindow().setTimeout(() => callback(this._createDeadline(16)));\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().clearTimeout(identifier);\n\t}\n\n\tprivate _createDeadline(duration: number): ITaskDeadline {\n\t\tconst end = Date.now() + duration;\n\t\treturn {\n\t\t\ttimeRemaining: () => Math.max(0, end - Date.now())\n\t\t};\n\t}\n}\n\nclass IdleTaskQueueInternal extends TaskQueue {\n\tprotected _requestCallback(callback: IdleRequestCallback): number {\n\t\treturn getActiveWindow().requestIdleCallback(callback);\n\t}\n\n\tprotected _cancelCallback(identifier: number): void {\n\t\tgetActiveWindow().cancelIdleCallback(identifier);\n\t}\n}\n\n/**\n * A queue of that runs tasks over several idle callbacks, trying to respect the idle callback's\n * deadline given by the environment. The tasks will run in the order they are enqueued, but they\n * will run some time later, and care should be taken to ensure they're non-urgent and will not\n * introduce race conditions.\n *\n * This reverts to a {@link PriorityTaskQueue} if the environment does not support idle callbacks.\n */\nexport const IdleTaskQueue = ('requestIdleCallback' in getActiveWindow()) ? IdleTaskQueueInternal : PriorityTaskQueue;\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;AAEhG,OAAO,EAAE,eAAe,EAAE,MAAM,8BAA8B,CAAC;AAC/D,OAAO,EAAE,UAAU,EAAE,YAAY,EAAoB,MAAM,mCAAmC,CAAC;AAC/F,OAAO,EAAE,WAAW,EAAE,MAAM,qCAAqC,CAAC;;;;;;;;;;;;;;;AAoBlE,IAAe,SAAS,GAAxB,MAAe,SAAU,SAAQ,0LAAU;IAK1C,YACc,WAAyC,CAAA;QAEtD,KAAK,EAAE,CAAC;QAFsB,IAAA,CAAA,WAAW,GAAX,WAAW,CAAa;QAL/C,IAAA,CAAA,MAAM,GAA6B,EAAE,CAAC;QAEtC,IAAA,CAAA,EAAE,GAAG,CAAC,CAAC;QAMd,IAAI,CAAC,SAAS,KAAC,4LAAY,EAAC,GAAG,CAAG,CAAD,GAAK,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IAClD,CAAC;IAKM,OAAO,CAAC,IAA0B,EAAA;QACxC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACvB,IAAI,CAAC,MAAM,EAAE,CAAC;IACf,CAAC;IAEM,KAAK,GAAA;QACX,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACxB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YACzC,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;QAChC,CAAC;QACD,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;IACxB,CAAC;IAEO,MAAM,GAAA;QACb,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC;YACzB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACtE,CAAC;IACF,CAAC;IAEO,QAAQ,CAAC,QAAuB,EAAA;QACvC,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;QAC/B,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,IAAI,qBAAqB,GAAG,QAAQ,CAAC,aAAa,EAAE,CAAC;QACrD,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAC1B,MAAO,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAE,CAAC;YACrC,YAAY,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAC1B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC7B,IAAI,CAAC,EAAE,EAAE,CAAC;YACX,CAAC;YACD,4FAA4F;YAC5F,2FAA2F;YAC3F,iFAAiF;YACjF,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,YAAY,CAAC,CAAC;YACtD,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;YAClD,6FAA6F;YAC7F,sDAAsD;YACtD,iBAAiB,GAAG,QAAQ,CAAC,aAAa,EAAE,CAAC;YAC7C,IAAI,WAAW,GAAG,GAAG,GAAG,iBAAiB,EAAE,CAAC;gBAC3C,0FAA0F;gBAC1F,2EAA2E;gBAC3E,IAAI,qBAAqB,GAAG,YAAY,GAAG,CAAC,EAAE,EAAE,CAAC;oBAChD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAA,yCAAA,EAA4C,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,qBAAqB,GAAG,YAAY,CAAC,CAAC,CAAA,EAAA,CAAI,CAAC,CAAC;gBACnI,CAAC;gBACD,IAAI,CAAC,MAAM,EAAE,CAAC;gBACd,OAAO;YACR,CAAC;YACD,qBAAqB,GAAG,iBAAiB,CAAC;QAC3C,CAAC;QACD,IAAI,CAAC,KAAK,EAAE,CAAC;IACd,CAAC;CACD,CAAA;AAnEc,SAAS,GAAA,WAAA;IAMrB,QAAA,GAAA,gMAAW,CAAA;GANC,SAAS,CAmEvB;AAOK,MAAO,iBAAkB,SAAQ,SAAS;IACrC,gBAAgB,CAAC,QAA8B,EAAA;QACxD,WAAO,0LAAe,EAAE,EAAC,UAAU,CAAC,GAAG,CAAG,CAAD,OAAS,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAC/E,CAAC;IAES,eAAe,CAAC,UAAkB,EAAA;YAC3C,0LAAe,EAAE,EAAC,YAAY,CAAC,UAAU,CAAC,CAAC;IAC5C,CAAC;IAEO,eAAe,CAAC,QAAgB,EAAA;QACvC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,QAAQ,CAAC;QAClC,OAAO;YACN,aAAa,EAAE,GAAG,CAAG,CAAD,GAAK,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;SAClD,CAAC;IACH,CAAC;CACD;AAED,MAAM,qBAAsB,SAAQ,SAAS;IAClC,gBAAgB,CAAC,QAA6B,EAAA;QACvD,WAAO,0LAAe,EAAE,EAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;IACxD,CAAC;IAES,eAAe,CAAC,UAAkB,EAAA;YAC3C,0LAAe,EAAE,EAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;IAClD,CAAC;CACD;AAUM,MAAM,aAAa,GAAG,AAAC,qBAAqB,QAAI,0LAAe,EAAE,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC,iBAAiB,CAAC","debugId":null}},
    {"offset": {"line": 485, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/textureAtlasShelfAllocator.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/atlas/textureAtlasShelfAllocator.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/vs/editor/browser/gpu/atlas/textureAtlasShelfAllocator.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { IRasterizedGlyph } from '../raster/raster.js';\nimport { UsagePreviewColors, type ITextureAtlasAllocator, type ITextureAtlasPageGlyph } from './atlas.js';\n\n/**\n * The shelf allocator is a simple allocator that places glyphs in rows, starting a new row when the\n * current row is full. Due to its simplicity, it can waste space but it is very fast.\n */\nexport class TextureAtlasShelfAllocator implements ITextureAtlasAllocator {\n\n\tprivate readonly _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate _currentRow: ITextureAtlasShelf = {\n\t\tx: 0,\n\t\ty: 0,\n\t\th: 0\n\t};\n\n\t/** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n\tprivate readonly _allocatedGlyphs: Set<Readonly<ITextureAtlasPageGlyph>> = new Set();\n\n\tprivate _nextIndex = 0;\n\n\tconstructor(\n\t\tprivate readonly _canvas: OffscreenCanvas,\n\t\tprivate readonly _textureIndex: number,\n\t) {\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true\n\t\t}));\n\t}\n\n\tpublic allocate(rasterizedGlyph: IRasterizedGlyph): ITextureAtlasPageGlyph | undefined {\n\t\t// The glyph does not fit into the atlas page\n\t\tconst glyphWidth = rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1;\n\t\tconst glyphHeight = rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1;\n\t\tif (glyphWidth > this._canvas.width || glyphHeight > this._canvas.height) {\n\t\t\tthrow new BugIndicatingError('Glyph is too large for the atlas page');\n\t\t}\n\n\t\t// Finalize and increment row if it doesn't fix horizontally\n\t\tif (rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1 > this._canvas.width - this._currentRow.x) {\n\t\t\tthis._currentRow.x = 0;\n\t\t\tthis._currentRow.y += this._currentRow.h;\n\t\t\tthis._currentRow.h = 1;\n\t\t}\n\n\t\t// Return undefined if there isn't any room left\n\t\tif (this._currentRow.y + rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1 > this._canvas.height) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Draw glyph\n\t\tthis._ctx.drawImage(\n\t\t\trasterizedGlyph.source,\n\t\t\t// source\n\t\t\trasterizedGlyph.boundingBox.left,\n\t\t\trasterizedGlyph.boundingBox.top,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t\t// destination\n\t\t\tthis._currentRow.x,\n\t\t\tthis._currentRow.y,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight\n\t\t);\n\n\t\t// Create glyph object\n\t\tconst glyph: ITextureAtlasPageGlyph = {\n\t\t\tpageIndex: this._textureIndex,\n\t\t\tglyphIndex: this._nextIndex++,\n\t\t\tx: this._currentRow.x,\n\t\t\ty: this._currentRow.y,\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t\toriginOffsetX: rasterizedGlyph.originOffset.x,\n\t\t\toriginOffsetY: rasterizedGlyph.originOffset.y,\n\t\t\tfontBoundingBoxAscent: rasterizedGlyph.fontBoundingBoxAscent,\n\t\t\tfontBoundingBoxDescent: rasterizedGlyph.fontBoundingBoxDescent,\n\t\t};\n\n\t\t// Shift current row\n\t\tthis._currentRow.x += glyphWidth;\n\t\tthis._currentRow.h = Math.max(this._currentRow.h, glyphHeight);\n\n\t\t// Set the glyph\n\t\tthis._allocatedGlyphs.add(glyph);\n\n\t\treturn glyph;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob> {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext('2d'));\n\t\tctx.fillStyle = UsagePreviewColors.Unused;\n\t\tctx.fillRect(0, 0, w, h);\n\n\t\tconst rowHeight: Map<number, number> = new Map(); // y -> h\n\t\tconst rowWidth: Map<number, number> = new Map(); // y -> w\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\trowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n\t\t\trowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n\t\t}\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tctx.fillStyle = UsagePreviewColors.Used;\n\t\t\tctx.fillRect(g.x, g.y, g.w, g.h);\n\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\tctx.fillRect(g.x, g.y + g.h, g.w, rowHeight.get(g.y)! - g.h);\n\t\t}\n\t\tfor (const [rowY, rowW] of rowWidth.entries()) {\n\t\t\tif (rowY !== this._currentRow.y) {\n\t\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\t\tctx.fillRect(rowW, rowY, w - rowW, rowHeight.get(rowY)!);\n\t\t\t}\n\t\t}\n\t\treturn canvas.convertToBlob();\n\t}\n\n\tgetStats(): string {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\n\t\tlet usedPixels = 0;\n\t\tlet wastedPixels = 0;\n\t\tconst totalPixels = w * h;\n\n\t\tconst rowHeight: Map<number, number> = new Map(); // y -> h\n\t\tconst rowWidth: Map<number, number> = new Map(); // y -> w\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\trowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n\t\t\trowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n\t\t}\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t\twastedPixels += g.w * (rowHeight.get(g.y)! - g.h);\n\t\t}\n\t\tfor (const [rowY, rowW] of rowWidth.entries()) {\n\t\t\tif (rowY !== this._currentRow.y) {\n\t\t\t\twastedPixels += (w - rowW) * rowHeight.get(rowY)!;\n\t\t\t}\n\t\t}\n\t\treturn [\n\t\t\t`page${this._textureIndex}:`,\n\t\t\t`     Total: ${totalPixels} (${w}x${h})`,\n\t\t\t`      Used: ${usedPixels} (${((usedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n\t\t\t`    Wasted: ${wastedPixels} (${((wastedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n\t\t\t`Efficiency: ${((usedPixels / (usedPixels + wastedPixels)) * 100).toPrecision(2)}%`,\n\t\t].join('\\n');\n\t}\n}\n\ninterface ITextureAtlasShelf {\n\tx: number;\n\ty: number;\n\th: number;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { IRasterizedGlyph } from '../raster/raster.js';\nimport { UsagePreviewColors, type ITextureAtlasAllocator, type ITextureAtlasPageGlyph } from './atlas.js';\n\n/**\n * The shelf allocator is a simple allocator that places glyphs in rows, starting a new row when the\n * current row is full. Due to its simplicity, it can waste space but it is very fast.\n */\nexport class TextureAtlasShelfAllocator implements ITextureAtlasAllocator {\n\n\tprivate readonly _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate _currentRow: ITextureAtlasShelf = {\n\t\tx: 0,\n\t\ty: 0,\n\t\th: 0\n\t};\n\n\t/** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n\tprivate readonly _allocatedGlyphs: Set<Readonly<ITextureAtlasPageGlyph>> = new Set();\n\n\tprivate _nextIndex = 0;\n\n\tconstructor(\n\t\tprivate readonly _canvas: OffscreenCanvas,\n\t\tprivate readonly _textureIndex: number,\n\t) {\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true\n\t\t}));\n\t}\n\n\tpublic allocate(rasterizedGlyph: IRasterizedGlyph): ITextureAtlasPageGlyph | undefined {\n\t\t// The glyph does not fit into the atlas page\n\t\tconst glyphWidth = rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1;\n\t\tconst glyphHeight = rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1;\n\t\tif (glyphWidth > this._canvas.width || glyphHeight > this._canvas.height) {\n\t\t\tthrow new BugIndicatingError('Glyph is too large for the atlas page');\n\t\t}\n\n\t\t// Finalize and increment row if it doesn't fix horizontally\n\t\tif (rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1 > this._canvas.width - this._currentRow.x) {\n\t\t\tthis._currentRow.x = 0;\n\t\t\tthis._currentRow.y += this._currentRow.h;\n\t\t\tthis._currentRow.h = 1;\n\t\t}\n\n\t\t// Return undefined if there isn't any room left\n\t\tif (this._currentRow.y + rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1 > this._canvas.height) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Draw glyph\n\t\tthis._ctx.drawImage(\n\t\t\trasterizedGlyph.source,\n\t\t\t// source\n\t\t\trasterizedGlyph.boundingBox.left,\n\t\t\trasterizedGlyph.boundingBox.top,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t\t// destination\n\t\t\tthis._currentRow.x,\n\t\t\tthis._currentRow.y,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight\n\t\t);\n\n\t\t// Create glyph object\n\t\tconst glyph: ITextureAtlasPageGlyph = {\n\t\t\tpageIndex: this._textureIndex,\n\t\t\tglyphIndex: this._nextIndex++,\n\t\t\tx: this._currentRow.x,\n\t\t\ty: this._currentRow.y,\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t\toriginOffsetX: rasterizedGlyph.originOffset.x,\n\t\t\toriginOffsetY: rasterizedGlyph.originOffset.y,\n\t\t\tfontBoundingBoxAscent: rasterizedGlyph.fontBoundingBoxAscent,\n\t\t\tfontBoundingBoxDescent: rasterizedGlyph.fontBoundingBoxDescent,\n\t\t};\n\n\t\t// Shift current row\n\t\tthis._currentRow.x += glyphWidth;\n\t\tthis._currentRow.h = Math.max(this._currentRow.h, glyphHeight);\n\n\t\t// Set the glyph\n\t\tthis._allocatedGlyphs.add(glyph);\n\n\t\treturn glyph;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob> {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext('2d'));\n\t\tctx.fillStyle = UsagePreviewColors.Unused;\n\t\tctx.fillRect(0, 0, w, h);\n\n\t\tconst rowHeight: Map<number, number> = new Map(); // y -> h\n\t\tconst rowWidth: Map<number, number> = new Map(); // y -> w\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\trowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n\t\t\trowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n\t\t}\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tctx.fillStyle = UsagePreviewColors.Used;\n\t\t\tctx.fillRect(g.x, g.y, g.w, g.h);\n\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\tctx.fillRect(g.x, g.y + g.h, g.w, rowHeight.get(g.y)! - g.h);\n\t\t}\n\t\tfor (const [rowY, rowW] of rowWidth.entries()) {\n\t\t\tif (rowY !== this._currentRow.y) {\n\t\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\t\tctx.fillRect(rowW, rowY, w - rowW, rowHeight.get(rowY)!);\n\t\t\t}\n\t\t}\n\t\treturn canvas.convertToBlob();\n\t}\n\n\tgetStats(): string {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\n\t\tlet usedPixels = 0;\n\t\tlet wastedPixels = 0;\n\t\tconst totalPixels = w * h;\n\n\t\tconst rowHeight: Map<number, number> = new Map(); // y -> h\n\t\tconst rowWidth: Map<number, number> = new Map(); // y -> w\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\trowHeight.set(g.y, Math.max(rowHeight.get(g.y) ?? 0, g.h));\n\t\t\trowWidth.set(g.y, Math.max(rowWidth.get(g.y) ?? 0, g.x + g.w));\n\t\t}\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t\twastedPixels += g.w * (rowHeight.get(g.y)! - g.h);\n\t\t}\n\t\tfor (const [rowY, rowW] of rowWidth.entries()) {\n\t\t\tif (rowY !== this._currentRow.y) {\n\t\t\t\twastedPixels += (w - rowW) * rowHeight.get(rowY)!;\n\t\t\t}\n\t\t}\n\t\treturn [\n\t\t\t`page${this._textureIndex}:`,\n\t\t\t`     Total: ${totalPixels} (${w}x${h})`,\n\t\t\t`      Used: ${usedPixels} (${((usedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n\t\t\t`    Wasted: ${wastedPixels} (${((wastedPixels / totalPixels) * 100).toPrecision(2)}%)`,\n\t\t\t`Efficiency: ${((usedPixels / (usedPixels + wastedPixels)) * 100).toPrecision(2)}%`,\n\t\t].join('\\n');\n\t}\n}\n\ninterface ITextureAtlasShelf {\n\tx: number;\n\ty: number;\n\th: number;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/textureAtlasSlabAllocator.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/atlas/textureAtlasSlabAllocator.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/vs/editor/browser/gpu/atlas/textureAtlasSlabAllocator.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { IRasterizedGlyph } from '../raster/raster.js';\nimport { UsagePreviewColors, type ITextureAtlasAllocator, type ITextureAtlasPageGlyph } from './atlas.js';\n\nexport interface TextureAtlasSlabAllocatorOptions {\n\tslabW?: number;\n\tslabH?: number;\n}\n\n/**\n * The slab allocator is a more complex allocator that places glyphs in square slabs of a fixed\n * size. Slabs are defined by a small range of glyphs sizes they can house, this places like-sized\n * glyphs in the same slab which reduces wasted space.\n *\n * Slabs also may contain \"unused\" regions on the left and bottom depending on the size of the\n * glyphs they include. This space is used to place very thin or short glyphs, which would otherwise\n * waste a lot of space in their own slab.\n */\nexport class TextureAtlasSlabAllocator implements ITextureAtlasAllocator {\n\n\tprivate readonly _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate readonly _slabs: ITextureAtlasSlab[] = [];\n\tprivate readonly _activeSlabsByDims: NKeyMap<ITextureAtlasSlab, [number, number]> = new NKeyMap();\n\n\tprivate readonly _unusedRects: ITextureAtlasSlabUnusedRect[] = [];\n\n\tprivate readonly _openRegionsByHeight: Map<number, ITextureAtlasSlabUnusedRect[]> = new Map();\n\tprivate readonly _openRegionsByWidth: Map<number, ITextureAtlasSlabUnusedRect[]> = new Map();\n\n\t/** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n\tprivate readonly _allocatedGlyphs: Set<Readonly<ITextureAtlasPageGlyph>> = new Set();\n\n\tprivate _slabW: number;\n\tprivate _slabH: number;\n\tprivate _slabsPerRow: number;\n\tprivate _slabsPerColumn: number;\n\tprivate _nextIndex = 0;\n\n\tconstructor(\n\t\tprivate readonly _canvas: OffscreenCanvas,\n\t\tprivate readonly _textureIndex: number,\n\t\toptions?: TextureAtlasSlabAllocatorOptions\n\t) {\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true\n\t\t}));\n\n\t\tthis._slabW = Math.min(\n\t\t\toptions?.slabW ?? (64 << Math.max(Math.floor(getActiveWindow().devicePixelRatio) - 1, 0)),\n\t\t\tthis._canvas.width\n\t\t);\n\t\tthis._slabH = Math.min(\n\t\t\toptions?.slabH ?? this._slabW,\n\t\t\tthis._canvas.height\n\t\t);\n\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\tthis._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n\t}\n\n\tpublic allocate(rasterizedGlyph: IRasterizedGlyph): ITextureAtlasPageGlyph | undefined {\n\t\t// Find ideal slab, creating it if there is none suitable\n\t\tconst glyphWidth = rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1;\n\t\tconst glyphHeight = rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1;\n\n\t\t// The glyph does not fit into the atlas page, glyphs should never be this large in practice\n\t\tif (glyphWidth > this._canvas.width || glyphHeight > this._canvas.height) {\n\t\t\tthrow new BugIndicatingError('Glyph is too large for the atlas page');\n\t\t}\n\n\t\t// The glyph does not fit into a slab\n\t\tif (glyphWidth > this._slabW || glyphHeight > this._slabH) {\n\t\t\t// Only if this is the allocator's first glyph, resize the slab size to fit the glyph.\n\t\t\tif (this._allocatedGlyphs.size > 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Find the largest power of 2 devisor that the glyph fits into, this ensure there is no\n\t\t\t// wasted space outside the allocated slabs.\n\t\t\tlet sizeCandidate = this._canvas.width;\n\t\t\twhile (glyphWidth < sizeCandidate / 2 && glyphHeight < sizeCandidate / 2) {\n\t\t\t\tsizeCandidate /= 2;\n\t\t\t}\n\t\t\tthis._slabW = sizeCandidate;\n\t\t\tthis._slabH = sizeCandidate;\n\t\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\t\tthis._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n\t\t}\n\n\t\t// const dpr = getActiveWindow().devicePixelRatio;\n\n\t\t// TODO: Include font size as well as DPR in nearestXPixels calculation\n\n\t\t// Round slab glyph dimensions to the nearest x pixels, where x scaled with device pixel ratio\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr / 0.5));\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr));\n\t\tconst desiredSlabSize = {\n\t\t\t// Nearest square number\n\t\t\t// TODO: This can probably be optimized\n\t\t\t// w: 1 << Math.ceil(Math.sqrt(glyphWidth)),\n\t\t\t// h: 1 << Math.ceil(Math.sqrt(glyphHeight)),\n\n\t\t\t// Nearest x px\n\t\t\t// w: Math.ceil(glyphWidth / nearestXPixels) * nearestXPixels,\n\t\t\t// h: Math.ceil(glyphHeight / nearestXPixels) * nearestXPixels,\n\n\t\t\t// Round odd numbers up\n\t\t\t// w: glyphWidth % 0 === 1 ? glyphWidth + 1 : glyphWidth,\n\t\t\t// h: glyphHeight % 0 === 1 ? glyphHeight + 1 : glyphHeight,\n\n\t\t\t// Exact number only\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t};\n\n\t\t// Get any existing slab\n\t\tlet slab = this._activeSlabsByDims.get(desiredSlabSize.w, desiredSlabSize.h);\n\n\t\t// Check if the slab is full\n\t\tif (slab) {\n\t\t\tconst glyphsPerSlab = Math.floor(this._slabW / slab.entryW) * Math.floor(this._slabH / slab.entryH);\n\t\t\tif (slab.count >= glyphsPerSlab) {\n\t\t\t\tslab = undefined;\n\t\t\t}\n\t\t}\n\n\t\tlet dx: number | undefined;\n\t\tlet dy: number | undefined;\n\n\t\t// Search for suitable space in unused rectangles\n\t\tif (!slab) {\n\t\t\t// Only check availability for the smallest side\n\t\t\tif (glyphWidth < glyphHeight) {\n\t\t\t\tconst openRegions = this._openRegionsByWidth.get(glyphWidth);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphWidth < r.w) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x + glyphWidth,\n\t\t\t\t\t\t\t\t\ty: r.y,\n\t\t\t\t\t\t\t\t\tw: r.w - glyphWidth,\n\t\t\t\t\t\t\t\t\th: glyphHeight\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.y += glyphHeight;\n\t\t\t\t\t\t\tr.h -= glyphHeight;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst openRegions = this._openRegionsByHeight.get(glyphHeight);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphHeight < r.h) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x,\n\t\t\t\t\t\t\t\t\ty: r.y + glyphHeight,\n\t\t\t\t\t\t\t\t\tw: glyphWidth,\n\t\t\t\t\t\t\t\t\th: r.h - glyphHeight\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.x += glyphWidth;\n\t\t\t\t\t\t\tr.w -= glyphWidth;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create a new slab\n\t\tif (dx === undefined || dy === undefined) {\n\t\t\tif (!slab) {\n\t\t\t\tif (this._slabs.length >= this._slabsPerRow * this._slabsPerColumn) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tslab = {\n\t\t\t\t\tx: Math.floor(this._slabs.length % this._slabsPerRow) * this._slabW,\n\t\t\t\t\ty: Math.floor(this._slabs.length / this._slabsPerRow) * this._slabH,\n\t\t\t\t\tentryW: desiredSlabSize.w,\n\t\t\t\t\tentryH: desiredSlabSize.h,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\t\t\t\t// Track unused regions to use for small glyphs\n\t\t\t\t// +-------------+----+\n\t\t\t\t// |             |    |\n\t\t\t\t// |             |    | <- Unused W region\n\t\t\t\t// |             |    |\n\t\t\t\t// |-------------+----+\n\t\t\t\t// |                  | <- Unused H region\n\t\t\t\t// +------------------+\n\t\t\t\tconst unusedW = this._slabW % slab.entryW;\n\t\t\t\tconst unusedH = this._slabH % slab.entryH;\n\t\t\t\tif (unusedW) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByWidth, unusedW, {\n\t\t\t\t\t\tx: slab.x + this._slabW - unusedW,\n\t\t\t\t\t\tw: unusedW,\n\t\t\t\t\t\ty: slab.y,\n\t\t\t\t\t\th: this._slabH - (unusedH ?? 0)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (unusedH) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByHeight, unusedH, {\n\t\t\t\t\t\tx: slab.x,\n\t\t\t\t\t\tw: this._slabW,\n\t\t\t\t\t\ty: slab.y + this._slabH - unusedH,\n\t\t\t\t\t\th: unusedH\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis._slabs.push(slab);\n\t\t\t\tthis._activeSlabsByDims.set(slab, desiredSlabSize.w, desiredSlabSize.h);\n\t\t\t}\n\n\t\t\tconst glyphsPerRow = Math.floor(this._slabW / slab.entryW);\n\t\t\tdx = slab.x + Math.floor(slab.count % glyphsPerRow) * slab.entryW;\n\t\t\tdy = slab.y + Math.floor(slab.count / glyphsPerRow) * slab.entryH;\n\n\t\t\t// Shift current row\n\t\t\tslab.count++;\n\t\t}\n\n\t\t// Draw glyph\n\t\tthis._ctx.drawImage(\n\t\t\trasterizedGlyph.source,\n\t\t\t// source\n\t\t\trasterizedGlyph.boundingBox.left,\n\t\t\trasterizedGlyph.boundingBox.top,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t\t// destination\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight\n\t\t);\n\n\t\t// Create glyph object\n\t\tconst glyph: ITextureAtlasPageGlyph = {\n\t\t\tpageIndex: this._textureIndex,\n\t\t\tglyphIndex: this._nextIndex++,\n\t\t\tx: dx,\n\t\t\ty: dy,\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t\toriginOffsetX: rasterizedGlyph.originOffset.x,\n\t\t\toriginOffsetY: rasterizedGlyph.originOffset.y,\n\t\t\tfontBoundingBoxAscent: rasterizedGlyph.fontBoundingBoxAscent,\n\t\t\tfontBoundingBoxDescent: rasterizedGlyph.fontBoundingBoxDescent,\n\t\t};\n\n\t\t// Set the glyph\n\t\tthis._allocatedGlyphs.add(glyph);\n\n\t\treturn glyph;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob> {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext('2d'));\n\n\t\tctx.fillStyle = UsagePreviewColors.Unused;\n\t\tctx.fillRect(0, 0, w, h);\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\t\tctx.fillRect(slab.x + x, slab.y + y, slab.entryW, slab.entryH);\n\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels = slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += (slabW * slabH) - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t\tctx.fillStyle = UsagePreviewColors.Used;\n\t\t\tctx.fillRect(g.x, g.y, g.w, g.h);\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\tctx.fillStyle = UsagePreviewColors.Restricted;\n\t\t\tctx.fillRect(r.x, r.y, r.w, r.h);\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\n\t\t// Overlay actual glyphs on top\n\t\tctx.globalAlpha = 0.5;\n\t\tctx.drawImage(this._canvas, 0, 0);\n\t\tctx.globalAlpha = 1;\n\n\t\treturn canvas.convertToBlob();\n\t}\n\n\tpublic getStats(): string {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet wastedPixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst totalPixels = w * h;\n\t\tconst slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels = slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += (slabW * slabH) - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\t\tconst edgeUsedPixels = slabEdgePixels - restrictedPixels;\n\t\twastedPixels = slabEntryPixels - (usedPixels - edgeUsedPixels);\n\n\t\t// usedPixels += slabEdgePixels - restrictedPixels;\n\t\tconst efficiency = usedPixels / (usedPixels + wastedPixels + restrictedPixels);\n\n\t\treturn [\n\t\t\t`page[${this._textureIndex}]:`,\n\t\t\t`     Total: ${totalPixels}px (${w}x${h})`,\n\t\t\t`      Used: ${usedPixels}px (${((usedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`    Wasted: ${wastedPixels}px (${((wastedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`Restricted: ${restrictedPixels}px (${((restrictedPixels / totalPixels) * 100).toFixed(2)}%) (hard to allocate)`,\n\t\t\t`Efficiency: ${efficiency === 1 ? '100' : (efficiency * 100).toFixed(2)}%`,\n\t\t\t`     Slabs: ${this._slabs.length} of ${Math.floor(this._canvas.width / slabW) * Math.floor(this._canvas.height / slabH)}`\n\t\t].join('\\n');\n\t}\n}\n\ninterface ITextureAtlasSlab {\n\tx: number;\n\ty: number;\n\tentryH: number;\n\tentryW: number;\n\tcount: number;\n}\n\ninterface ITextureAtlasSlabUnusedRect {\n\tx: number;\n\ty: number;\n\tw: number;\n\th: number;\n}\n\nfunction addEntryToMapArray<K, V>(map: Map<K, V[]>, key: K, entry: V) {\n\tlet list = map.get(key);\n\tif (!list) {\n\t\tlist = [];\n\t\tmap.set(key, list);\n\t}\n\tlist.push(entry);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { ensureNonNullable } from '../gpuUtils.js';\nimport { IRasterizedGlyph } from '../raster/raster.js';\nimport { UsagePreviewColors, type ITextureAtlasAllocator, type ITextureAtlasPageGlyph } from './atlas.js';\n\nexport interface TextureAtlasSlabAllocatorOptions {\n\tslabW?: number;\n\tslabH?: number;\n}\n\n/**\n * The slab allocator is a more complex allocator that places glyphs in square slabs of a fixed\n * size. Slabs are defined by a small range of glyphs sizes they can house, this places like-sized\n * glyphs in the same slab which reduces wasted space.\n *\n * Slabs also may contain \"unused\" regions on the left and bottom depending on the size of the\n * glyphs they include. This space is used to place very thin or short glyphs, which would otherwise\n * waste a lot of space in their own slab.\n */\nexport class TextureAtlasSlabAllocator implements ITextureAtlasAllocator {\n\n\tprivate readonly _ctx: OffscreenCanvasRenderingContext2D;\n\n\tprivate readonly _slabs: ITextureAtlasSlab[] = [];\n\tprivate readonly _activeSlabsByDims: NKeyMap<ITextureAtlasSlab, [number, number]> = new NKeyMap();\n\n\tprivate readonly _unusedRects: ITextureAtlasSlabUnusedRect[] = [];\n\n\tprivate readonly _openRegionsByHeight: Map<number, ITextureAtlasSlabUnusedRect[]> = new Map();\n\tprivate readonly _openRegionsByWidth: Map<number, ITextureAtlasSlabUnusedRect[]> = new Map();\n\n\t/** A set of all glyphs allocated, this is only tracked to enable debug related functionality */\n\tprivate readonly _allocatedGlyphs: Set<Readonly<ITextureAtlasPageGlyph>> = new Set();\n\n\tprivate _slabW: number;\n\tprivate _slabH: number;\n\tprivate _slabsPerRow: number;\n\tprivate _slabsPerColumn: number;\n\tprivate _nextIndex = 0;\n\n\tconstructor(\n\t\tprivate readonly _canvas: OffscreenCanvas,\n\t\tprivate readonly _textureIndex: number,\n\t\toptions?: TextureAtlasSlabAllocatorOptions\n\t) {\n\t\tthis._ctx = ensureNonNullable(this._canvas.getContext('2d', {\n\t\t\twillReadFrequently: true\n\t\t}));\n\n\t\tthis._slabW = Math.min(\n\t\t\toptions?.slabW ?? (64 << Math.max(Math.floor(getActiveWindow().devicePixelRatio) - 1, 0)),\n\t\t\tthis._canvas.width\n\t\t);\n\t\tthis._slabH = Math.min(\n\t\t\toptions?.slabH ?? this._slabW,\n\t\t\tthis._canvas.height\n\t\t);\n\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\tthis._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n\t}\n\n\tpublic allocate(rasterizedGlyph: IRasterizedGlyph): ITextureAtlasPageGlyph | undefined {\n\t\t// Find ideal slab, creating it if there is none suitable\n\t\tconst glyphWidth = rasterizedGlyph.boundingBox.right - rasterizedGlyph.boundingBox.left + 1;\n\t\tconst glyphHeight = rasterizedGlyph.boundingBox.bottom - rasterizedGlyph.boundingBox.top + 1;\n\n\t\t// The glyph does not fit into the atlas page, glyphs should never be this large in practice\n\t\tif (glyphWidth > this._canvas.width || glyphHeight > this._canvas.height) {\n\t\t\tthrow new BugIndicatingError('Glyph is too large for the atlas page');\n\t\t}\n\n\t\t// The glyph does not fit into a slab\n\t\tif (glyphWidth > this._slabW || glyphHeight > this._slabH) {\n\t\t\t// Only if this is the allocator's first glyph, resize the slab size to fit the glyph.\n\t\t\tif (this._allocatedGlyphs.size > 0) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Find the largest power of 2 devisor that the glyph fits into, this ensure there is no\n\t\t\t// wasted space outside the allocated slabs.\n\t\t\tlet sizeCandidate = this._canvas.width;\n\t\t\twhile (glyphWidth < sizeCandidate / 2 && glyphHeight < sizeCandidate / 2) {\n\t\t\t\tsizeCandidate /= 2;\n\t\t\t}\n\t\t\tthis._slabW = sizeCandidate;\n\t\t\tthis._slabH = sizeCandidate;\n\t\t\tthis._slabsPerRow = Math.floor(this._canvas.width / this._slabW);\n\t\t\tthis._slabsPerColumn = Math.floor(this._canvas.height / this._slabH);\n\t\t}\n\n\t\t// const dpr = getActiveWindow().devicePixelRatio;\n\n\t\t// TODO: Include font size as well as DPR in nearestXPixels calculation\n\n\t\t// Round slab glyph dimensions to the nearest x pixels, where x scaled with device pixel ratio\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr / 0.5));\n\t\t// const nearestXPixels = Math.max(1, Math.floor(dpr));\n\t\tconst desiredSlabSize = {\n\t\t\t// Nearest square number\n\t\t\t// TODO: This can probably be optimized\n\t\t\t// w: 1 << Math.ceil(Math.sqrt(glyphWidth)),\n\t\t\t// h: 1 << Math.ceil(Math.sqrt(glyphHeight)),\n\n\t\t\t// Nearest x px\n\t\t\t// w: Math.ceil(glyphWidth / nearestXPixels) * nearestXPixels,\n\t\t\t// h: Math.ceil(glyphHeight / nearestXPixels) * nearestXPixels,\n\n\t\t\t// Round odd numbers up\n\t\t\t// w: glyphWidth % 0 === 1 ? glyphWidth + 1 : glyphWidth,\n\t\t\t// h: glyphHeight % 0 === 1 ? glyphHeight + 1 : glyphHeight,\n\n\t\t\t// Exact number only\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t};\n\n\t\t// Get any existing slab\n\t\tlet slab = this._activeSlabsByDims.get(desiredSlabSize.w, desiredSlabSize.h);\n\n\t\t// Check if the slab is full\n\t\tif (slab) {\n\t\t\tconst glyphsPerSlab = Math.floor(this._slabW / slab.entryW) * Math.floor(this._slabH / slab.entryH);\n\t\t\tif (slab.count >= glyphsPerSlab) {\n\t\t\t\tslab = undefined;\n\t\t\t}\n\t\t}\n\n\t\tlet dx: number | undefined;\n\t\tlet dy: number | undefined;\n\n\t\t// Search for suitable space in unused rectangles\n\t\tif (!slab) {\n\t\t\t// Only check availability for the smallest side\n\t\t\tif (glyphWidth < glyphHeight) {\n\t\t\t\tconst openRegions = this._openRegionsByWidth.get(glyphWidth);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphWidth < r.w) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x + glyphWidth,\n\t\t\t\t\t\t\t\t\ty: r.y,\n\t\t\t\t\t\t\t\t\tw: r.w - glyphWidth,\n\t\t\t\t\t\t\t\t\th: glyphHeight\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.y += glyphHeight;\n\t\t\t\t\t\t\tr.h -= glyphHeight;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst openRegions = this._openRegionsByHeight.get(glyphHeight);\n\t\t\t\tif (openRegions?.length) {\n\t\t\t\t\t// TODO: Don't search everything?\n\t\t\t\t\t// Search from the end so we can typically pop it off the stack\n\t\t\t\t\tfor (let i = openRegions.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst r = openRegions[i];\n\t\t\t\t\t\tif (r.w >= glyphWidth && r.h >= glyphHeight) {\n\t\t\t\t\t\t\tdx = r.x;\n\t\t\t\t\t\t\tdy = r.y;\n\t\t\t\t\t\t\tif (glyphHeight < r.h) {\n\t\t\t\t\t\t\t\tthis._unusedRects.push({\n\t\t\t\t\t\t\t\t\tx: r.x,\n\t\t\t\t\t\t\t\t\ty: r.y + glyphHeight,\n\t\t\t\t\t\t\t\t\tw: glyphWidth,\n\t\t\t\t\t\t\t\t\th: r.h - glyphHeight\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr.x += glyphWidth;\n\t\t\t\t\t\t\tr.w -= glyphWidth;\n\t\t\t\t\t\t\tif (r.h === 0) {\n\t\t\t\t\t\t\t\tif (i === openRegions.length - 1) {\n\t\t\t\t\t\t\t\t\topenRegions.pop();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._unusedRects.splice(i, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create a new slab\n\t\tif (dx === undefined || dy === undefined) {\n\t\t\tif (!slab) {\n\t\t\t\tif (this._slabs.length >= this._slabsPerRow * this._slabsPerColumn) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tslab = {\n\t\t\t\t\tx: Math.floor(this._slabs.length % this._slabsPerRow) * this._slabW,\n\t\t\t\t\ty: Math.floor(this._slabs.length / this._slabsPerRow) * this._slabH,\n\t\t\t\t\tentryW: desiredSlabSize.w,\n\t\t\t\t\tentryH: desiredSlabSize.h,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\t\t\t\t// Track unused regions to use for small glyphs\n\t\t\t\t// +-------------+----+\n\t\t\t\t// |             |    |\n\t\t\t\t// |             |    | <- Unused W region\n\t\t\t\t// |             |    |\n\t\t\t\t// |-------------+----+\n\t\t\t\t// |                  | <- Unused H region\n\t\t\t\t// +------------------+\n\t\t\t\tconst unusedW = this._slabW % slab.entryW;\n\t\t\t\tconst unusedH = this._slabH % slab.entryH;\n\t\t\t\tif (unusedW) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByWidth, unusedW, {\n\t\t\t\t\t\tx: slab.x + this._slabW - unusedW,\n\t\t\t\t\t\tw: unusedW,\n\t\t\t\t\t\ty: slab.y,\n\t\t\t\t\t\th: this._slabH - (unusedH ?? 0)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (unusedH) {\n\t\t\t\t\taddEntryToMapArray(this._openRegionsByHeight, unusedH, {\n\t\t\t\t\t\tx: slab.x,\n\t\t\t\t\t\tw: this._slabW,\n\t\t\t\t\t\ty: slab.y + this._slabH - unusedH,\n\t\t\t\t\t\th: unusedH\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis._slabs.push(slab);\n\t\t\t\tthis._activeSlabsByDims.set(slab, desiredSlabSize.w, desiredSlabSize.h);\n\t\t\t}\n\n\t\t\tconst glyphsPerRow = Math.floor(this._slabW / slab.entryW);\n\t\t\tdx = slab.x + Math.floor(slab.count % glyphsPerRow) * slab.entryW;\n\t\t\tdy = slab.y + Math.floor(slab.count / glyphsPerRow) * slab.entryH;\n\n\t\t\t// Shift current row\n\t\t\tslab.count++;\n\t\t}\n\n\t\t// Draw glyph\n\t\tthis._ctx.drawImage(\n\t\t\trasterizedGlyph.source,\n\t\t\t// source\n\t\t\trasterizedGlyph.boundingBox.left,\n\t\t\trasterizedGlyph.boundingBox.top,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight,\n\t\t\t// destination\n\t\t\tdx,\n\t\t\tdy,\n\t\t\tglyphWidth,\n\t\t\tglyphHeight\n\t\t);\n\n\t\t// Create glyph object\n\t\tconst glyph: ITextureAtlasPageGlyph = {\n\t\t\tpageIndex: this._textureIndex,\n\t\t\tglyphIndex: this._nextIndex++,\n\t\t\tx: dx,\n\t\t\ty: dy,\n\t\t\tw: glyphWidth,\n\t\t\th: glyphHeight,\n\t\t\toriginOffsetX: rasterizedGlyph.originOffset.x,\n\t\t\toriginOffsetY: rasterizedGlyph.originOffset.y,\n\t\t\tfontBoundingBoxAscent: rasterizedGlyph.fontBoundingBoxAscent,\n\t\t\tfontBoundingBoxDescent: rasterizedGlyph.fontBoundingBoxDescent,\n\t\t};\n\n\t\t// Set the glyph\n\t\tthis._allocatedGlyphs.add(glyph);\n\n\t\treturn glyph;\n\t}\n\n\tpublic getUsagePreview(): Promise<Blob> {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\t\tconst canvas = new OffscreenCanvas(w, h);\n\t\tconst ctx = ensureNonNullable(canvas.getContext('2d'));\n\n\t\tctx.fillStyle = UsagePreviewColors.Unused;\n\t\tctx.fillRect(0, 0, w, h);\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tctx.fillStyle = UsagePreviewColors.Wasted;\n\t\t\t\tctx.fillRect(slab.x + x, slab.y + y, slab.entryW, slab.entryH);\n\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels = slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += (slabW * slabH) - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t\tctx.fillStyle = UsagePreviewColors.Used;\n\t\t\tctx.fillRect(g.x, g.y, g.w, g.h);\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\tctx.fillStyle = UsagePreviewColors.Restricted;\n\t\t\tctx.fillRect(r.x, r.y, r.w, r.h);\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\n\t\t// Overlay actual glyphs on top\n\t\tctx.globalAlpha = 0.5;\n\t\tctx.drawImage(this._canvas, 0, 0);\n\t\tctx.globalAlpha = 1;\n\n\t\treturn canvas.convertToBlob();\n\t}\n\n\tpublic getStats(): string {\n\t\tconst w = this._canvas.width;\n\t\tconst h = this._canvas.height;\n\n\t\tlet slabEntryPixels = 0;\n\t\tlet usedPixels = 0;\n\t\tlet slabEdgePixels = 0;\n\t\tlet wastedPixels = 0;\n\t\tlet restrictedPixels = 0;\n\t\tconst totalPixels = w * h;\n\t\tconst slabW = 64 << (Math.floor(getActiveWindow().devicePixelRatio) - 1);\n\t\tconst slabH = slabW;\n\n\t\t// Draw wasted underneath glyphs first\n\t\tfor (const slab of this._slabs) {\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tfor (let i = 0; i < slab.count; i++) {\n\t\t\t\tif (x + slab.entryW > slabW) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += slab.entryH;\n\t\t\t\t}\n\t\t\t\tslabEntryPixels += slab.entryW * slab.entryH;\n\t\t\t\tx += slab.entryW;\n\t\t\t}\n\t\t\tconst entriesPerRow = Math.floor(slabW / slab.entryW);\n\t\t\tconst entriesPerCol = Math.floor(slabH / slab.entryH);\n\t\t\tconst thisSlabPixels = slab.entryW * entriesPerRow * slab.entryH * entriesPerCol;\n\t\t\tslabEdgePixels += (slabW * slabH) - thisSlabPixels;\n\t\t}\n\n\t\t// Draw glyphs\n\t\tfor (const g of this._allocatedGlyphs) {\n\t\t\tusedPixels += g.w * g.h;\n\t\t}\n\n\t\t// Draw unused space on side\n\t\tconst unusedRegions = Array.from(this._openRegionsByWidth.values()).flat().concat(Array.from(this._openRegionsByHeight.values()).flat());\n\t\tfor (const r of unusedRegions) {\n\t\t\trestrictedPixels += r.w * r.h;\n\t\t}\n\n\t\tconst edgeUsedPixels = slabEdgePixels - restrictedPixels;\n\t\twastedPixels = slabEntryPixels - (usedPixels - edgeUsedPixels);\n\n\t\t// usedPixels += slabEdgePixels - restrictedPixels;\n\t\tconst efficiency = usedPixels / (usedPixels + wastedPixels + restrictedPixels);\n\n\t\treturn [\n\t\t\t`page[${this._textureIndex}]:`,\n\t\t\t`     Total: ${totalPixels}px (${w}x${h})`,\n\t\t\t`      Used: ${usedPixels}px (${((usedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`    Wasted: ${wastedPixels}px (${((wastedPixels / totalPixels) * 100).toFixed(2)}%)`,\n\t\t\t`Restricted: ${restrictedPixels}px (${((restrictedPixels / totalPixels) * 100).toFixed(2)}%) (hard to allocate)`,\n\t\t\t`Efficiency: ${efficiency === 1 ? '100' : (efficiency * 100).toFixed(2)}%`,\n\t\t\t`     Slabs: ${this._slabs.length} of ${Math.floor(this._canvas.width / slabW) * Math.floor(this._canvas.height / slabH)}`\n\t\t].join('\\n');\n\t}\n}\n\ninterface ITextureAtlasSlab {\n\tx: number;\n\ty: number;\n\tentryH: number;\n\tentryW: number;\n\tcount: number;\n}\n\ninterface ITextureAtlasSlabUnusedRect {\n\tx: number;\n\ty: number;\n\tw: number;\n\th: number;\n}\n\nfunction addEntryToMapArray<K, V>(map: Map<K, V[]>, key: K, entry: V) {\n\tlet list = map.get(key);\n\tif (!list) {\n\t\tlist = [];\n\t\tmap.set(key, list);\n\t}\n\tlist.push(entry);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 954, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/textureAtlasPage.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/atlas/textureAtlasPage.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/vs/editor/browser/gpu/atlas/textureAtlasPage.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { ILogService, LogLevel } from '../../../../platform/log/common/log.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { IBoundingBox, IGlyphRasterizer } from '../raster/raster.js';\nimport { IReadableTextureAtlasPage, ITextureAtlasAllocator, ITextureAtlasPageGlyph, GlyphMap } from './atlas.js';\nimport { TextureAtlasShelfAllocator } from './textureAtlasShelfAllocator.js';\nimport { TextureAtlasSlabAllocator } from './textureAtlasSlabAllocator.js';\n\nexport type AllocatorType = 'shelf' | 'slab' | ((canvas: OffscreenCanvas, textureIndex: number) => ITextureAtlasAllocator);\n\nexport class TextureAtlasPage extends Disposable implements IReadableTextureAtlasPage {\n\n\tprivate _version: number = 0;\n\tget version(): number { return this._version; }\n\n\t/**\n\t * The maximum number of glyphs that can be drawn to the page. This is currently a hard static\n\t * cap that must not be reached as it will cause the GPU buffer to overflow.\n\t */\n\tstatic readonly maximumGlyphCount = 5_000;\n\n\tprivate _usedArea: IBoundingBox = { left: 0, top: 0, right: 0, bottom: 0 };\n\tpublic get usedArea(): Readonly<IBoundingBox> { return this._usedArea; }\n\n\tprivate readonly _canvas: OffscreenCanvas;\n\tget source(): OffscreenCanvas { return this._canvas; }\n\n\tprivate readonly _glyphMap: GlyphMap<ITextureAtlasPageGlyph> = new NKeyMap();\n\tprivate readonly _glyphInOrderSet: Set<ITextureAtlasPageGlyph> = new Set();\n\tget glyphs(): IterableIterator<ITextureAtlasPageGlyph> {\n\t\treturn this._glyphInOrderSet.values();\n\t}\n\n\tprivate readonly _allocator: ITextureAtlasAllocator;\n\tprivate _colorMap!: string[];\n\n\tconstructor(\n\t\ttextureIndex: number,\n\t\tpageSize: number,\n\t\tallocatorType: AllocatorType,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IThemeService themeService: IThemeService,\n\t) {\n\t\tsuper();\n\n\t\tthis._canvas = new OffscreenCanvas(pageSize, pageSize);\n\t\tthis._colorMap = themeService.getColorTheme().tokenColorMap;\n\n\t\tswitch (allocatorType) {\n\t\t\tcase 'shelf': this._allocator = new TextureAtlasShelfAllocator(this._canvas, textureIndex); break;\n\t\t\tcase 'slab': this._allocator = new TextureAtlasSlabAllocator(this._canvas, textureIndex); break;\n\t\t\tdefault: this._allocator = allocatorType(this._canvas, textureIndex); break;\n\t\t}\n\n\t\t// Reduce impact of a memory leak if this object is not released\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._canvas.width = 1;\n\t\t\tthis._canvas.height = 1;\n\t\t}));\n\t}\n\n\tpublic getGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// IMPORTANT: There are intentionally no intermediate variables here to aid in runtime\n\t\t// optimization as it's a very hot function\n\t\treturn this._glyphMap.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? this._createGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId);\n\t}\n\n\tprivate _createGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// Ensure the glyph can fit on the page\n\t\tif (this._glyphInOrderSet.size >= TextureAtlasPage.maximumGlyphCount) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Rasterize and allocate the glyph\n\t\tconst rasterizedGlyph = rasterizer.rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, this._colorMap);\n\t\tconst glyph = this._allocator.allocate(rasterizedGlyph);\n\n\t\t// Ensure the glyph was allocated\n\t\tif (glyph === undefined) {\n\t\t\t// TODO: undefined here can mean the glyph was too large for a slab on the page, this\n\t\t\t// can lead to big problems if we don't handle it properly https://github.com/microsoft/vscode/issues/232984\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Save the glyph\n\t\tthis._glyphMap.set(glyph, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\tthis._glyphInOrderSet.add(glyph);\n\n\t\t// Update page version and it's tracked used area\n\t\tthis._version++;\n\t\tthis._usedArea.right = Math.max(this._usedArea.right, glyph.x + glyph.w - 1);\n\t\tthis._usedArea.bottom = Math.max(this._usedArea.bottom, glyph.y + glyph.h - 1);\n\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace('New glyph', {\n\t\t\t\tchars,\n\t\t\t\ttokenMetadata,\n\t\t\t\tdecorationStyleSetId,\n\t\t\t\trasterizedGlyph,\n\t\t\t\tglyph\n\t\t\t});\n\t\t}\n\n\t\treturn glyph;\n\t}\n\n\tgetUsagePreview(): Promise<Blob> {\n\t\treturn this._allocator.getUsagePreview();\n\t}\n\n\tgetStats(): string {\n\t\treturn this._allocator.getStats();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { ILogService, LogLevel } from '../../../../platform/log/common/log.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { IBoundingBox, IGlyphRasterizer } from '../raster/raster.js';\nimport { IReadableTextureAtlasPage, ITextureAtlasAllocator, ITextureAtlasPageGlyph, GlyphMap } from './atlas.js';\nimport { TextureAtlasShelfAllocator } from './textureAtlasShelfAllocator.js';\nimport { TextureAtlasSlabAllocator } from './textureAtlasSlabAllocator.js';\n\nexport type AllocatorType = 'shelf' | 'slab' | ((canvas: OffscreenCanvas, textureIndex: number) => ITextureAtlasAllocator);\n\nexport class TextureAtlasPage extends Disposable implements IReadableTextureAtlasPage {\n\n\tprivate _version: number = 0;\n\tget version(): number { return this._version; }\n\n\t/**\n\t * The maximum number of glyphs that can be drawn to the page. This is currently a hard static\n\t * cap that must not be reached as it will cause the GPU buffer to overflow.\n\t */\n\tstatic readonly maximumGlyphCount = 5_000;\n\n\tprivate _usedArea: IBoundingBox = { left: 0, top: 0, right: 0, bottom: 0 };\n\tpublic get usedArea(): Readonly<IBoundingBox> { return this._usedArea; }\n\n\tprivate readonly _canvas: OffscreenCanvas;\n\tget source(): OffscreenCanvas { return this._canvas; }\n\n\tprivate readonly _glyphMap: GlyphMap<ITextureAtlasPageGlyph> = new NKeyMap();\n\tprivate readonly _glyphInOrderSet: Set<ITextureAtlasPageGlyph> = new Set();\n\tget glyphs(): IterableIterator<ITextureAtlasPageGlyph> {\n\t\treturn this._glyphInOrderSet.values();\n\t}\n\n\tprivate readonly _allocator: ITextureAtlasAllocator;\n\tprivate _colorMap!: string[];\n\n\tconstructor(\n\t\ttextureIndex: number,\n\t\tpageSize: number,\n\t\tallocatorType: AllocatorType,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@IThemeService themeService: IThemeService,\n\t) {\n\t\tsuper();\n\n\t\tthis._canvas = new OffscreenCanvas(pageSize, pageSize);\n\t\tthis._colorMap = themeService.getColorTheme().tokenColorMap;\n\n\t\tswitch (allocatorType) {\n\t\t\tcase 'shelf': this._allocator = new TextureAtlasShelfAllocator(this._canvas, textureIndex); break;\n\t\t\tcase 'slab': this._allocator = new TextureAtlasSlabAllocator(this._canvas, textureIndex); break;\n\t\t\tdefault: this._allocator = allocatorType(this._canvas, textureIndex); break;\n\t\t}\n\n\t\t// Reduce impact of a memory leak if this object is not released\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._canvas.width = 1;\n\t\t\tthis._canvas.height = 1;\n\t\t}));\n\t}\n\n\tpublic getGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// IMPORTANT: There are intentionally no intermediate variables here to aid in runtime\n\t\t// optimization as it's a very hot function\n\t\treturn this._glyphMap.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? this._createGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId);\n\t}\n\n\tprivate _createGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> | undefined {\n\t\t// Ensure the glyph can fit on the page\n\t\tif (this._glyphInOrderSet.size >= TextureAtlasPage.maximumGlyphCount) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Rasterize and allocate the glyph\n\t\tconst rasterizedGlyph = rasterizer.rasterizeGlyph(chars, tokenMetadata, decorationStyleSetId, this._colorMap);\n\t\tconst glyph = this._allocator.allocate(rasterizedGlyph);\n\n\t\t// Ensure the glyph was allocated\n\t\tif (glyph === undefined) {\n\t\t\t// TODO: undefined here can mean the glyph was too large for a slab on the page, this\n\t\t\t// can lead to big problems if we don't handle it properly https://github.com/microsoft/vscode/issues/232984\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Save the glyph\n\t\tthis._glyphMap.set(glyph, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\tthis._glyphInOrderSet.add(glyph);\n\n\t\t// Update page version and it's tracked used area\n\t\tthis._version++;\n\t\tthis._usedArea.right = Math.max(this._usedArea.right, glyph.x + glyph.w - 1);\n\t\tthis._usedArea.bottom = Math.max(this._usedArea.bottom, glyph.y + glyph.h - 1);\n\n\t\tif (this._logService.getLevel() === LogLevel.Trace) {\n\t\t\tthis._logService.trace('New glyph', {\n\t\t\t\tchars,\n\t\t\t\ttokenMetadata,\n\t\t\t\tdecorationStyleSetId,\n\t\t\t\trasterizedGlyph,\n\t\t\t\tglyph\n\t\t\t});\n\t\t}\n\n\t\treturn glyph;\n\t}\n\n\tgetUsagePreview(): Promise<Blob> {\n\t\treturn this._allocator.getUsagePreview();\n\t}\n\n\tgetStats(): string {\n\t\treturn this._allocator.getStats();\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1092, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/textureAtlas.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/atlas/textureAtlas.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/atlas/vs/editor/browser/gpu/atlas/textureAtlas.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, dispose, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { MetadataConsts } from '../../../common/encodedTokenAttributes.js';\nimport { DecorationStyleCache } from '../css/decorationStyleCache.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { IGlyphRasterizer } from '../raster/raster.js';\nimport { IdleTaskQueue, type ITaskQueue } from '../taskQueue.js';\nimport { IReadableTextureAtlasPage, ITextureAtlasPageGlyph, GlyphMap } from './atlas.js';\nimport { AllocatorType, TextureAtlasPage } from './textureAtlasPage.js';\n\nexport interface ITextureAtlasOptions {\n\tallocatorType?: AllocatorType;\n}\n\nexport class TextureAtlas extends Disposable {\n\tprivate _colorMap?: string[];\n\tprivate readonly _warmUpTask: MutableDisposable<ITaskQueue> = this._register(new MutableDisposable());\n\tprivate readonly _warmedUpRasterizers = new Set<number>();\n\tprivate readonly _allocatorType: AllocatorType;\n\n\t/**\n\t * The maximum number of texture atlas pages. This is currently a hard static cap that must not\n\t * be reached.\n\t */\n\tstatic readonly maximumPageCount = 16;\n\n\t/**\n\t * The main texture atlas pages which are both larger textures and more efficiently packed\n\t * relative to the scratch page. The idea is the main pages are drawn to and uploaded to the GPU\n\t * much less frequently so as to not drop frames.\n\t */\n\tprivate readonly _pages: TextureAtlasPage[] = [];\n\tget pages(): IReadableTextureAtlasPage[] { return this._pages; }\n\n\treadonly pageSize: number;\n\n\t/**\n\t * A maps of glyph keys to the page to start searching for the glyph. This is set before\n\t * searching to have as little runtime overhead (branching, intermediate variables) as possible,\n\t * so it is not guaranteed to be the actual page the glyph is on. But it is guaranteed that all\n\t * pages with a lower index do not contain the glyph.\n\t */\n\tprivate readonly _glyphPageIndex: GlyphMap<number> = new NKeyMap();\n\n\tprivate readonly _onDidDeleteGlyphs = this._register(new Emitter<void>());\n\treadonly onDidDeleteGlyphs = this._onDidDeleteGlyphs.event;\n\n\tconstructor(\n\t\t/** The maximum texture size supported by the GPU. */\n\t\tprivate readonly _maxTextureSize: number,\n\t\toptions: ITextureAtlasOptions | undefined,\n\t\tprivate readonly _decorationStyleCache: DecorationStyleCache,\n\t\t@IThemeService private readonly _themeService: IThemeService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\tthis._allocatorType = options?.allocatorType ?? 'slab';\n\n\t\tthis._register(Event.runAndSubscribe(this._themeService.onDidColorThemeChange, () => {\n\t\t\tif (this._colorMap) {\n\t\t\t\tthis.clear();\n\t\t\t}\n\t\t\tthis._colorMap = this._themeService.getColorTheme().tokenColorMap;\n\t\t}));\n\n\t\tconst dprFactor = Math.max(1, Math.floor(getActiveWindow().devicePixelRatio));\n\n\t\tthis.pageSize = Math.min(1024 * dprFactor, this._maxTextureSize);\n\t\tthis._initFirstPage();\n\n\t\tthis._register(toDisposable(() => dispose(this._pages)));\n\t}\n\n\tprivate _initFirstPage() {\n\t\tconst firstPage = this._instantiationService.createInstance(TextureAtlasPage, 0, this.pageSize, this._allocatorType);\n\t\tthis._pages.push(firstPage);\n\n\t\t// IMPORTANT: The first glyph on the first page must be an empty glyph such that zeroed out\n\t\t// cells end up rendering nothing\n\t\t// TODO: This currently means the first slab is for 0x0 glyphs and is wasted\n\t\tconst nullRasterizer = new GlyphRasterizer(1, '', 1, this._decorationStyleCache);\n\t\tfirstPage.getGlyph(nullRasterizer, '', 0, 0);\n\t\tnullRasterizer.dispose();\n\t}\n\n\tclear() {\n\t\t// Clear all pages\n\t\tfor (const page of this._pages) {\n\t\t\tpage.dispose();\n\t\t}\n\t\tthis._pages.length = 0;\n\t\tthis._glyphPageIndex.clear();\n\t\tthis._warmedUpRasterizers.clear();\n\t\tthis._warmUpTask.clear();\n\n\t\t// Recreate first\n\t\tthis._initFirstPage();\n\n\t\t// Tell listeners\n\t\tthis._onDidDeleteGlyphs.fire();\n\t}\n\n\tgetGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number, x: number): Readonly<ITextureAtlasPageGlyph> {\n\t\t// TODO: Encode font size and family into key\n\t\t// Ignore metadata that doesn't affect the glyph\n\t\ttokenMetadata &= ~(MetadataConsts.LANGUAGEID_MASK | MetadataConsts.TOKEN_TYPE_MASK | MetadataConsts.BALANCED_BRACKETS_MASK);\n\n\t\t// Add x offset for sub-pixel rendering to the unused portion or tokenMetadata. This\n\t\t// converts the decimal part of the x to a range from 0 to 9, where 0 = 0.0px x offset,\n\t\t// 9 = 0.9px x offset\n\t\ttokenMetadata |= Math.floor((x % 1) * 10);\n\n\t\t// Warm up common glyphs\n\t\tif (!this._warmedUpRasterizers.has(rasterizer.id)) {\n\t\t\tthis._warmUpAtlas(rasterizer);\n\t\t\tthis._warmedUpRasterizers.add(rasterizer.id);\n\t\t}\n\n\t\t// Try get the glyph, overflowing to a new page if necessary\n\t\treturn this._tryGetGlyph(this._glyphPageIndex.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? 0, rasterizer, chars, tokenMetadata, decorationStyleSetId);\n\t}\n\n\tprivate _tryGetGlyph(pageIndex: number, rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> {\n\t\tthis._glyphPageIndex.set(pageIndex, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\treturn (\n\t\t\tthis._pages[pageIndex].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t\t?? (pageIndex + 1 < this._pages.length\n\t\t\t\t? this._tryGetGlyph(pageIndex + 1, rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t\t\t: undefined)\n\t\t\t?? this._getGlyphFromNewPage(rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t);\n\t}\n\n\tprivate _getGlyphFromNewPage(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> {\n\t\tif (this._pages.length >= TextureAtlas.maximumPageCount) {\n\t\t\tthrow new Error(`Attempt to create a texture atlas page past the limit ${TextureAtlas.maximumPageCount}`);\n\t\t}\n\t\tthis._pages.push(this._instantiationService.createInstance(TextureAtlasPage, this._pages.length, this.pageSize, this._allocatorType));\n\t\tthis._glyphPageIndex.set(this._pages.length - 1, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\treturn this._pages[this._pages.length - 1].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId)!;\n\t}\n\n\tpublic getStats(): string[] {\n\t\treturn this._pages.map(e => e.getStats());\n\t}\n\n\t/**\n\t * Warms up the atlas by rasterizing all printable ASCII characters for each token color. This\n\t * is distrubuted over multiple idle callbacks to avoid blocking the main thread.\n\t */\n\tprivate _warmUpAtlas(rasterizer: IGlyphRasterizer): void {\n\t\tconst colorMap = this._colorMap;\n\t\tif (!colorMap) {\n\t\t\tthrow new BugIndicatingError('Cannot warm atlas without color map');\n\t\t}\n\t\tthis._warmUpTask.value?.clear();\n\t\tconst taskQueue = this._warmUpTask.value = this._instantiationService.createInstance(IdleTaskQueue);\n\t\t// Warm up using roughly the larger glyphs first to help optimize atlas allocation\n\t\t// A-Z\n\t\tfor (let code = CharCode.A; code <= CharCode.Z; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// a-z\n\t\tfor (let code = CharCode.a; code <= CharCode.z; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// Remaining ascii\n\t\tfor (let code = CharCode.ExclamationMark; code <= CharCode.Tilde; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable, dispose, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { NKeyMap } from '../../../../base/common/map.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { IThemeService } from '../../../../platform/theme/common/themeService.js';\nimport { MetadataConsts } from '../../../common/encodedTokenAttributes.js';\nimport { DecorationStyleCache } from '../css/decorationStyleCache.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { IGlyphRasterizer } from '../raster/raster.js';\nimport { IdleTaskQueue, type ITaskQueue } from '../taskQueue.js';\nimport { IReadableTextureAtlasPage, ITextureAtlasPageGlyph, GlyphMap } from './atlas.js';\nimport { AllocatorType, TextureAtlasPage } from './textureAtlasPage.js';\n\nexport interface ITextureAtlasOptions {\n\tallocatorType?: AllocatorType;\n}\n\nexport class TextureAtlas extends Disposable {\n\tprivate _colorMap?: string[];\n\tprivate readonly _warmUpTask: MutableDisposable<ITaskQueue> = this._register(new MutableDisposable());\n\tprivate readonly _warmedUpRasterizers = new Set<number>();\n\tprivate readonly _allocatorType: AllocatorType;\n\n\t/**\n\t * The maximum number of texture atlas pages. This is currently a hard static cap that must not\n\t * be reached.\n\t */\n\tstatic readonly maximumPageCount = 16;\n\n\t/**\n\t * The main texture atlas pages which are both larger textures and more efficiently packed\n\t * relative to the scratch page. The idea is the main pages are drawn to and uploaded to the GPU\n\t * much less frequently so as to not drop frames.\n\t */\n\tprivate readonly _pages: TextureAtlasPage[] = [];\n\tget pages(): IReadableTextureAtlasPage[] { return this._pages; }\n\n\treadonly pageSize: number;\n\n\t/**\n\t * A maps of glyph keys to the page to start searching for the glyph. This is set before\n\t * searching to have as little runtime overhead (branching, intermediate variables) as possible,\n\t * so it is not guaranteed to be the actual page the glyph is on. But it is guaranteed that all\n\t * pages with a lower index do not contain the glyph.\n\t */\n\tprivate readonly _glyphPageIndex: GlyphMap<number> = new NKeyMap();\n\n\tprivate readonly _onDidDeleteGlyphs = this._register(new Emitter<void>());\n\treadonly onDidDeleteGlyphs = this._onDidDeleteGlyphs.event;\n\n\tconstructor(\n\t\t/** The maximum texture size supported by the GPU. */\n\t\tprivate readonly _maxTextureSize: number,\n\t\toptions: ITextureAtlasOptions | undefined,\n\t\tprivate readonly _decorationStyleCache: DecorationStyleCache,\n\t\t@IThemeService private readonly _themeService: IThemeService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\tthis._allocatorType = options?.allocatorType ?? 'slab';\n\n\t\tthis._register(Event.runAndSubscribe(this._themeService.onDidColorThemeChange, () => {\n\t\t\tif (this._colorMap) {\n\t\t\t\tthis.clear();\n\t\t\t}\n\t\t\tthis._colorMap = this._themeService.getColorTheme().tokenColorMap;\n\t\t}));\n\n\t\tconst dprFactor = Math.max(1, Math.floor(getActiveWindow().devicePixelRatio));\n\n\t\tthis.pageSize = Math.min(1024 * dprFactor, this._maxTextureSize);\n\t\tthis._initFirstPage();\n\n\t\tthis._register(toDisposable(() => dispose(this._pages)));\n\t}\n\n\tprivate _initFirstPage() {\n\t\tconst firstPage = this._instantiationService.createInstance(TextureAtlasPage, 0, this.pageSize, this._allocatorType);\n\t\tthis._pages.push(firstPage);\n\n\t\t// IMPORTANT: The first glyph on the first page must be an empty glyph such that zeroed out\n\t\t// cells end up rendering nothing\n\t\t// TODO: This currently means the first slab is for 0x0 glyphs and is wasted\n\t\tconst nullRasterizer = new GlyphRasterizer(1, '', 1, this._decorationStyleCache);\n\t\tfirstPage.getGlyph(nullRasterizer, '', 0, 0);\n\t\tnullRasterizer.dispose();\n\t}\n\n\tclear() {\n\t\t// Clear all pages\n\t\tfor (const page of this._pages) {\n\t\t\tpage.dispose();\n\t\t}\n\t\tthis._pages.length = 0;\n\t\tthis._glyphPageIndex.clear();\n\t\tthis._warmedUpRasterizers.clear();\n\t\tthis._warmUpTask.clear();\n\n\t\t// Recreate first\n\t\tthis._initFirstPage();\n\n\t\t// Tell listeners\n\t\tthis._onDidDeleteGlyphs.fire();\n\t}\n\n\tgetGlyph(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number, x: number): Readonly<ITextureAtlasPageGlyph> {\n\t\t// TODO: Encode font size and family into key\n\t\t// Ignore metadata that doesn't affect the glyph\n\t\ttokenMetadata &= ~(MetadataConsts.LANGUAGEID_MASK | MetadataConsts.TOKEN_TYPE_MASK | MetadataConsts.BALANCED_BRACKETS_MASK);\n\n\t\t// Add x offset for sub-pixel rendering to the unused portion or tokenMetadata. This\n\t\t// converts the decimal part of the x to a range from 0 to 9, where 0 = 0.0px x offset,\n\t\t// 9 = 0.9px x offset\n\t\ttokenMetadata |= Math.floor((x % 1) * 10);\n\n\t\t// Warm up common glyphs\n\t\tif (!this._warmedUpRasterizers.has(rasterizer.id)) {\n\t\t\tthis._warmUpAtlas(rasterizer);\n\t\t\tthis._warmedUpRasterizers.add(rasterizer.id);\n\t\t}\n\n\t\t// Try get the glyph, overflowing to a new page if necessary\n\t\treturn this._tryGetGlyph(this._glyphPageIndex.get(chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey) ?? 0, rasterizer, chars, tokenMetadata, decorationStyleSetId);\n\t}\n\n\tprivate _tryGetGlyph(pageIndex: number, rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> {\n\t\tthis._glyphPageIndex.set(pageIndex, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\treturn (\n\t\t\tthis._pages[pageIndex].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t\t?? (pageIndex + 1 < this._pages.length\n\t\t\t\t? this._tryGetGlyph(pageIndex + 1, rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t\t\t: undefined)\n\t\t\t?? this._getGlyphFromNewPage(rasterizer, chars, tokenMetadata, decorationStyleSetId)\n\t\t);\n\t}\n\n\tprivate _getGlyphFromNewPage(rasterizer: IGlyphRasterizer, chars: string, tokenMetadata: number, decorationStyleSetId: number): Readonly<ITextureAtlasPageGlyph> {\n\t\tif (this._pages.length >= TextureAtlas.maximumPageCount) {\n\t\t\tthrow new Error(`Attempt to create a texture atlas page past the limit ${TextureAtlas.maximumPageCount}`);\n\t\t}\n\t\tthis._pages.push(this._instantiationService.createInstance(TextureAtlasPage, this._pages.length, this.pageSize, this._allocatorType));\n\t\tthis._glyphPageIndex.set(this._pages.length - 1, chars, tokenMetadata, decorationStyleSetId, rasterizer.cacheKey);\n\t\treturn this._pages[this._pages.length - 1].getGlyph(rasterizer, chars, tokenMetadata, decorationStyleSetId)!;\n\t}\n\n\tpublic getStats(): string[] {\n\t\treturn this._pages.map(e => e.getStats());\n\t}\n\n\t/**\n\t * Warms up the atlas by rasterizing all printable ASCII characters for each token color. This\n\t * is distrubuted over multiple idle callbacks to avoid blocking the main thread.\n\t */\n\tprivate _warmUpAtlas(rasterizer: IGlyphRasterizer): void {\n\t\tconst colorMap = this._colorMap;\n\t\tif (!colorMap) {\n\t\t\tthrow new BugIndicatingError('Cannot warm atlas without color map');\n\t\t}\n\t\tthis._warmUpTask.value?.clear();\n\t\tconst taskQueue = this._warmUpTask.value = this._instantiationService.createInstance(IdleTaskQueue);\n\t\t// Warm up using roughly the larger glyphs first to help optimize atlas allocation\n\t\t// A-Z\n\t\tfor (let code = CharCode.A; code <= CharCode.Z; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// a-z\n\t\tfor (let code = CharCode.a; code <= CharCode.z; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t// Remaining ascii\n\t\tfor (let code = CharCode.ExclamationMark; code <= CharCode.Tilde; code++) {\n\t\t\tfor (const fgColor of colorMap.keys()) {\n\t\t\t\ttaskQueue.enqueue(() => {\n\t\t\t\t\tfor (let x = 0; x < 1; x += 0.1) {\n\t\t\t\t\t\tthis.getGlyph(rasterizer, String.fromCharCode(code), (fgColor << MetadataConsts.FOREGROUND_OFFSET) & MetadataConsts.FOREGROUND_MASK, 0, x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1285, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/gpuDisposable.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/gpuDisposable.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/vs/editor/browser/gpu/gpuDisposable.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IReference } from '../../../base/common/lifecycle.js';\nimport { isFunction } from '../../../base/common/types.js';\n\nexport namespace GPULifecycle {\n\texport async function requestDevice(fallback?: (message: string) => void): Promise<IReference<GPUDevice>> {\n\t\ttry {\n\t\t\tif (!navigator.gpu) {\n\t\t\t\tthrow new Error('This browser does not support WebGPU');\n\t\t\t}\n\t\t\tconst adapter = (await navigator.gpu.requestAdapter())!;\n\t\t\tif (!adapter) {\n\t\t\t\tthrow new Error('This browser supports WebGPU but it appears to be disabled');\n\t\t\t}\n\t\t\treturn wrapDestroyableInDisposable(await adapter.requestDevice());\n\t\t} catch (e) {\n\t\t\tif (fallback) {\n\t\t\t\tfallback(e.message);\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\texport function createBuffer(device: GPUDevice, descriptor: GPUBufferDescriptor, initialValues?: Float32Array | (() => Float32Array)): IReference<GPUBuffer> {\n\t\tconst buffer = device.createBuffer(descriptor);\n\t\tif (initialValues) {\n\t\t\tdevice.queue.writeBuffer(buffer, 0, (isFunction(initialValues) ? initialValues() : initialValues) as Float32Array<ArrayBuffer>);\n\t\t}\n\t\treturn wrapDestroyableInDisposable(buffer);\n\t}\n\n\texport function createTexture(device: GPUDevice, descriptor: GPUTextureDescriptor): IReference<GPUTexture> {\n\t\treturn wrapDestroyableInDisposable(device.createTexture(descriptor));\n\t}\n}\n\nfunction wrapDestroyableInDisposable<T extends { destroy(): void }>(value: T): IReference<T> {\n\treturn {\n\t\tobject: value,\n\t\tdispose: () => value.destroy()\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IReference } from '../../../base/common/lifecycle.js';\nimport { isFunction } from '../../../base/common/types.js';\n\nexport namespace GPULifecycle {\n\texport async function requestDevice(fallback?: (message: string) => void): Promise<IReference<GPUDevice>> {\n\t\ttry {\n\t\t\tif (!navigator.gpu) {\n\t\t\t\tthrow new Error('This browser does not support WebGPU');\n\t\t\t}\n\t\t\tconst adapter = (await navigator.gpu.requestAdapter())!;\n\t\t\tif (!adapter) {\n\t\t\t\tthrow new Error('This browser supports WebGPU but it appears to be disabled');\n\t\t\t}\n\t\t\treturn wrapDestroyableInDisposable(await adapter.requestDevice());\n\t\t} catch (e) {\n\t\t\tif (fallback) {\n\t\t\t\tfallback(e.message);\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\texport function createBuffer(device: GPUDevice, descriptor: GPUBufferDescriptor, initialValues?: Float32Array | (() => Float32Array)): IReference<GPUBuffer> {\n\t\tconst buffer = device.createBuffer(descriptor);\n\t\tif (initialValues) {\n\t\t\tdevice.queue.writeBuffer(buffer, 0, (isFunction(initialValues) ? initialValues() : initialValues) as Float32Array<ArrayBuffer>);\n\t\t}\n\t\treturn wrapDestroyableInDisposable(buffer);\n\t}\n\n\texport function createTexture(device: GPUDevice, descriptor: GPUTextureDescriptor): IReference<GPUTexture> {\n\t\treturn wrapDestroyableInDisposable(device.createTexture(descriptor));\n\t}\n}\n\nfunction wrapDestroyableInDisposable<T extends { destroy(): void }>(value: T): IReference<T> {\n\treturn {\n\t\tobject: value,\n\t\tdispose: () => value.destroy()\n\t};\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAGhG,OAAO,EAAE,UAAU,EAAE,MAAM,+BAA+B,CAAC;;AAErD,IAAW,YAAY,CA8B5B;AA9BD,CAAA,SAAiB,YAAY;IACrB,KAAK,UAAU,aAAa,CAAC,QAAoC;QACvE,IAAI,CAAC;YACJ,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;gBACpB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;YACzD,CAAC;YACD,MAAM,OAAO,GAAG,AAAC,MAAM,SAAS,CAAC,GAAG,CAAC,cAAc,EAAE,CAAE,CAAC;YACxD,IAAI,CAAC,OAAO,EAAE,CAAC;gBACd,MAAM,IAAI,KAAK,CAAC,4DAA4D,CAAC,CAAC;YAC/E,CAAC;YACD,OAAO,2BAA2B,CAAC,MAAM,OAAO,CAAC,aAAa,EAAE,CAAC,CAAC;QACnE,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;YACZ,IAAI,QAAQ,EAAE,CAAC;gBACd,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;YACrB,CAAC;YACD,MAAM,CAAC,CAAC;QACT,CAAC;IACF,CAAC;IAhBqB,aAAA,aAAa,GAAA,aAgBlC,CAAA;IAED,SAAgB,YAAY,CAAC,MAAiB,EAAE,UAA+B,EAAE,aAAmD;QACnI,MAAM,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;QAC/C,IAAI,aAAa,EAAE,CAAC;YACnB,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,IAAC,sLAAU,EAAC,aAAa,CAAC,CAAC,CAAC,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC,aAAa,CAA8B,CAAC,CAAC;QACjI,CAAC;QACD,OAAO,2BAA2B,CAAC,MAAM,CAAC,CAAC;IAC5C,CAAC;IANe,aAAA,YAAY,GAAA,YAM3B,CAAA;IAED,SAAgB,aAAa,CAAC,MAAiB,EAAE,UAAgC;QAChF,OAAO,2BAA2B,CAAC,MAAM,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC;IACtE,CAAC;IAFe,aAAA,aAAa,GAAA,aAE5B,CAAA;AACF,CAAC,EA9BgB,YAAY,IAAA,CAAZ,YAAY,GAAA,CAAA,CAAA,GA8B5B;AAED,SAAS,2BAA2B,CAAgC,KAAQ;IAC3E,OAAO;QACN,MAAM,EAAE,KAAK;QACb,OAAO,EAAE,GAAG,CAAG,CAAD,IAAM,CAAC,OAAO,EAAE;KAC9B,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 1337, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/bufferDirtyTracker.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/bufferDirtyTracker.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/vs/editor/browser/gpu/bufferDirtyTracker.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IBufferDirtyTrackerReader {\n\t/**\n\t * The index of the first dirty index.\n\t */\n\treadonly dataOffset: number | undefined;\n\t/**\n\t * The index of the last dirty index (inclusive).\n\t */\n\treadonly dirtySize: number | undefined;\n\t/**\n\t * Whether the buffer is dirty.\n\t */\n\treadonly isDirty: boolean;\n\t/**\n\t * Clear the dirty state.\n\t */\n\tclear(): void;\n}\n\n/**\n * A simple tracker for dirty regions in a buffer.\n */\nexport class BufferDirtyTracker implements IBufferDirtyTrackerReader {\n\n\tprivate _startIndex: number | undefined;\n\tprivate _endIndex: number | undefined;\n\n\tget dataOffset(): number | undefined {\n\t\treturn this._startIndex;\n\t}\n\n\tget dirtySize(): number | undefined {\n\t\tif (this._startIndex === undefined || this._endIndex === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._endIndex - this._startIndex + 1;\n\t}\n\n\tget isDirty(): boolean { return this._startIndex !== undefined; }\n\n\t/**\n\t * Flag the index(es) as modified. Returns the index flagged.\n\t * @param index An index to flag.\n\t * @param length An optional length to flag. Defaults to 1.\n\t */\n\tflag(index: number, length: number = 1): number {\n\t\tthis._flag(index);\n\t\tif (length > 1) {\n\t\t\tthis._flag(index + length - 1);\n\t\t}\n\t\treturn index;\n\t}\n\n\tprivate _flag(index: number) {\n\t\tif (this._startIndex === undefined || index < this._startIndex) {\n\t\t\tthis._startIndex = index;\n\t\t}\n\t\tif (this._endIndex === undefined || index > this._endIndex) {\n\t\t\tthis._endIndex = index;\n\t\t}\n\t}\n\n\tclear() {\n\t\tthis._startIndex = undefined;\n\t\tthis._endIndex = undefined;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IBufferDirtyTrackerReader {\n\t/**\n\t * The index of the first dirty index.\n\t */\n\treadonly dataOffset: number | undefined;\n\t/**\n\t * The index of the last dirty index (inclusive).\n\t */\n\treadonly dirtySize: number | undefined;\n\t/**\n\t * Whether the buffer is dirty.\n\t */\n\treadonly isDirty: boolean;\n\t/**\n\t * Clear the dirty state.\n\t */\n\tclear(): void;\n}\n\n/**\n * A simple tracker for dirty regions in a buffer.\n */\nexport class BufferDirtyTracker implements IBufferDirtyTrackerReader {\n\n\tprivate _startIndex: number | undefined;\n\tprivate _endIndex: number | undefined;\n\n\tget dataOffset(): number | undefined {\n\t\treturn this._startIndex;\n\t}\n\n\tget dirtySize(): number | undefined {\n\t\tif (this._startIndex === undefined || this._endIndex === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._endIndex - this._startIndex + 1;\n\t}\n\n\tget isDirty(): boolean { return this._startIndex !== undefined; }\n\n\t/**\n\t * Flag the index(es) as modified. Returns the index flagged.\n\t * @param index An index to flag.\n\t * @param length An optional length to flag. Defaults to 1.\n\t */\n\tflag(index: number, length: number = 1): number {\n\t\tthis._flag(index);\n\t\tif (length > 1) {\n\t\t\tthis._flag(index + length - 1);\n\t\t}\n\t\treturn index;\n\t}\n\n\tprivate _flag(index: number) {\n\t\tif (this._startIndex === undefined || index < this._startIndex) {\n\t\t\tthis._startIndex = index;\n\t\t}\n\t\tif (this._endIndex === undefined || index > this._endIndex) {\n\t\t\tthis._endIndex = index;\n\t\t}\n\t}\n\n\tclear() {\n\t\tthis._startIndex = undefined;\n\t\tthis._endIndex = undefined;\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG,CAqBhG;;GAEG;;;;AACG,MAAO,kBAAkB;IAK9B,IAAI,UAAU,GAAA;QACb,OAAO,IAAI,CAAC,WAAW,CAAC;IACzB,CAAC;IAED,IAAI,SAAS,GAAA;QACZ,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE,CAAC;YACpE,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,OAAO,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;IAC9C,CAAC;IAED,IAAI,OAAO,GAAA;QAAc,OAAO,IAAI,CAAC,WAAW,KAAK,SAAS,CAAC;IAAC,CAAC;IAEjE;;;;OAIG,CACH,IAAI,CAAC,KAAa,EAAE,SAAiB,CAAC,EAAA;QACrC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAClB,IAAI,MAAM,GAAG,CAAC,EAAE,CAAC;YAChB,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC,CAAC;QAChC,CAAC;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAEO,KAAK,CAAC,KAAa,EAAA;QAC1B,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;YAChE,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QAC1B,CAAC;QACD,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,IAAI,KAAK,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;YAC5D,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACxB,CAAC;IACF,CAAC;IAED,KAAK,GAAA;QACJ,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;QAC7B,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC5B,CAAC;CACD","debugId":null}},
    {"offset": {"line": 1387, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/objectCollectionBuffer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/objectCollectionBuffer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/vs/editor/browser/gpu/objectCollectionBuffer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, dispose, toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { BufferDirtyTracker, type IBufferDirtyTrackerReader } from './bufferDirtyTracker.js';\n\nexport interface ObjectCollectionBufferPropertySpec {\n\tname: string;\n}\n\nexport type ObjectCollectionPropertyValues<T extends ObjectCollectionBufferPropertySpec[]> = {\n\t[K in T[number]['name']]: number;\n};\n\nexport interface IObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]> extends IDisposable {\n\t/**\n\t * The underlying buffer. This **should not** be modified externally.\n\t */\n\treadonly buffer: ArrayBufferLike;\n\t/**\n\t * A view of the underlying buffer. This **should not** be modified externally.\n\t */\n\treadonly view: Float32Array;\n\t/**\n\t * The number of entries in the buffer.\n\t */\n\treadonly entryCount: number;\n\n\t/**\n\t * A tracker for dirty regions in the buffer.\n\t */\n\treadonly dirtyTracker: IBufferDirtyTrackerReader;\n\n\t/**\n\t * Fires when the buffer is recreated.\n\t */\n\treadonly onDidChangeBuffer: Event<void>;\n\n\t/**\n\t * Creates an entry in the collection. This will return a managed object that can be modified\n\t * which will update the underlying buffer.\n\t * @param data The data of the entry.\n\t */\n\tcreateEntry(data: ObjectCollectionPropertyValues<T>): IObjectCollectionBufferEntry<T>;\n}\n\n/**\n * An entry in an {@link ObjectCollectionBuffer}. Property values on the entry can be changed and\n * their values will be updated automatically in the buffer.\n */\nexport interface IObjectCollectionBufferEntry<T extends ObjectCollectionBufferPropertySpec[]> extends IDisposable {\n\tsetRaw(data: ArrayLike<number>): void;\n}\n\nexport function createObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]>(\n\tpropertySpecs: T,\n\tcapacity: number\n): IObjectCollectionBuffer<T> {\n\treturn new ObjectCollectionBuffer<T>(propertySpecs, capacity);\n}\n\nclass ObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]> extends Disposable implements IObjectCollectionBuffer<T> {\n\tbuffer: ArrayBufferLike;\n\tview: Float32Array;\n\tget entryCount() {\n\t\treturn this._entries.size;\n\t}\n\n\tprivate _dirtyTracker = new BufferDirtyTracker();\n\tget dirtyTracker(): IBufferDirtyTrackerReader { return this._dirtyTracker; }\n\n\tprivate readonly _propertySpecsMap: Map<string, ObjectCollectionBufferPropertySpec & { offset: number }> = new Map();\n\tprivate readonly _entrySize: number;\n\tprivate readonly _entries: LinkedList<ObjectCollectionBufferEntry<T>> = new LinkedList();\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\tprivate readonly _onDidChangeBuffer = this._register(new Emitter<void>());\n\treadonly onDidChangeBuffer = this._onDidChangeBuffer.event;\n\n\tconstructor(\n\t\tpublic propertySpecs: T,\n\t\tpublic capacity: number\n\t) {\n\t\tsuper();\n\n\t\tthis.view = new Float32Array(capacity * propertySpecs.length);\n\t\tthis.buffer = this.view.buffer;\n\t\tthis._entrySize = propertySpecs.length;\n\t\tfor (let i = 0; i < propertySpecs.length; i++) {\n\t\t\tconst spec = {\n\t\t\t\toffset: i,\n\t\t\t\t...propertySpecs[i]\n\t\t\t};\n\t\t\tthis._propertySpecsMap.set(spec.name, spec);\n\t\t}\n\t\tthis._register(toDisposable(() => dispose(this._entries)));\n\t}\n\n\tcreateEntry(data: ObjectCollectionPropertyValues<T>): IObjectCollectionBufferEntry<T> {\n\t\tif (this._entries.size === this.capacity) {\n\t\t\tthis._expandBuffer();\n\t\t\tthis._onDidChangeBuffer.fire();\n\t\t}\n\n\t\tconst value = new ObjectCollectionBufferEntry(this.view, this._propertySpecsMap, this._dirtyTracker, this._entries.size, data);\n\t\tconst removeFromEntries = this._entries.push(value);\n\t\tconst listeners: IDisposable[] = [];\n\t\tlisteners.push(Event.forward(value.onDidChange, this._onDidChange));\n\t\tlisteners.push(value.onWillDispose(() => {\n\t\t\tconst deletedEntryIndex = value.i;\n\t\t\tremoveFromEntries();\n\n\t\t\t// Shift all entries after the deleted entry to the left\n\t\t\tthis.view.set(this.view.subarray(deletedEntryIndex * this._entrySize + 2, this._entries.size * this._entrySize + 2), deletedEntryIndex * this._entrySize);\n\n\t\t\t// Update entries to reflect the new i\n\t\t\tfor (const entry of this._entries) {\n\t\t\t\tif (entry.i > deletedEntryIndex) {\n\t\t\t\t\tentry.i--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._dirtyTracker.flag(deletedEntryIndex, (this._entries.size - deletedEntryIndex) * this._entrySize);\n\t\t\tdispose(listeners);\n\t\t}));\n\t\treturn value;\n\t}\n\n\tprivate _expandBuffer() {\n\t\tthis.capacity *= 2;\n\t\tconst newView = new Float32Array(this.capacity * this._entrySize);\n\t\tnewView.set(this.view);\n\t\tthis.view = newView;\n\t\tthis.buffer = this.view.buffer;\n\t}\n}\n\nclass ObjectCollectionBufferEntry<T extends ObjectCollectionBufferPropertySpec[]> extends Disposable implements IObjectCollectionBufferEntry<T> {\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\treadonly onDidChange = this._onDidChange.event;\n\tprivate readonly _onWillDispose = this._register(new Emitter<void>());\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\tconstructor(\n\t\tprivate _view: Float32Array,\n\t\tprivate _propertySpecsMap: Map<string, ObjectCollectionBufferPropertySpec & { offset: number }>,\n\t\tprivate _dirtyTracker: BufferDirtyTracker,\n\t\tpublic i: number,\n\t\tdata: ObjectCollectionPropertyValues<T>,\n\t) {\n\t\tsuper();\n\t\tfor (const propertySpec of this._propertySpecsMap.values()) {\n\t\t\tthis._view[this.i * this._propertySpecsMap.size + propertySpec.offset] = data[propertySpec.name as keyof typeof data];\n\t\t}\n\t\tthis._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n\t}\n\n\toverride dispose() {\n\t\tthis._onWillDispose.fire();\n\t\tsuper.dispose();\n\t}\n\n\tsetRaw(data: ArrayLike<number>): void {\n\t\tif (data.length !== this._propertySpecsMap.size) {\n\t\t\tthrow new Error(`Data length ${data.length} does not match the number of properties in the collection (${this._propertySpecsMap.size})`);\n\t\t}\n\t\tthis._view.set(data, this.i * this._propertySpecsMap.size);\n\t\tthis._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, dispose, toDisposable, type IDisposable } from '../../../base/common/lifecycle.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nimport { BufferDirtyTracker, type IBufferDirtyTrackerReader } from './bufferDirtyTracker.js';\n\nexport interface ObjectCollectionBufferPropertySpec {\n\tname: string;\n}\n\nexport type ObjectCollectionPropertyValues<T extends ObjectCollectionBufferPropertySpec[]> = {\n\t[K in T[number]['name']]: number;\n};\n\nexport interface IObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]> extends IDisposable {\n\t/**\n\t * The underlying buffer. This **should not** be modified externally.\n\t */\n\treadonly buffer: ArrayBufferLike;\n\t/**\n\t * A view of the underlying buffer. This **should not** be modified externally.\n\t */\n\treadonly view: Float32Array;\n\t/**\n\t * The number of entries in the buffer.\n\t */\n\treadonly entryCount: number;\n\n\t/**\n\t * A tracker for dirty regions in the buffer.\n\t */\n\treadonly dirtyTracker: IBufferDirtyTrackerReader;\n\n\t/**\n\t * Fires when the buffer is recreated.\n\t */\n\treadonly onDidChangeBuffer: Event<void>;\n\n\t/**\n\t * Creates an entry in the collection. This will return a managed object that can be modified\n\t * which will update the underlying buffer.\n\t * @param data The data of the entry.\n\t */\n\tcreateEntry(data: ObjectCollectionPropertyValues<T>): IObjectCollectionBufferEntry<T>;\n}\n\n/**\n * An entry in an {@link ObjectCollectionBuffer}. Property values on the entry can be changed and\n * their values will be updated automatically in the buffer.\n */\nexport interface IObjectCollectionBufferEntry<T extends ObjectCollectionBufferPropertySpec[]> extends IDisposable {\n\tsetRaw(data: ArrayLike<number>): void;\n}\n\nexport function createObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]>(\n\tpropertySpecs: T,\n\tcapacity: number\n): IObjectCollectionBuffer<T> {\n\treturn new ObjectCollectionBuffer<T>(propertySpecs, capacity);\n}\n\nclass ObjectCollectionBuffer<T extends ObjectCollectionBufferPropertySpec[]> extends Disposable implements IObjectCollectionBuffer<T> {\n\tbuffer: ArrayBufferLike;\n\tview: Float32Array;\n\tget entryCount() {\n\t\treturn this._entries.size;\n\t}\n\n\tprivate _dirtyTracker = new BufferDirtyTracker();\n\tget dirtyTracker(): IBufferDirtyTrackerReader { return this._dirtyTracker; }\n\n\tprivate readonly _propertySpecsMap: Map<string, ObjectCollectionBufferPropertySpec & { offset: number }> = new Map();\n\tprivate readonly _entrySize: number;\n\tprivate readonly _entries: LinkedList<ObjectCollectionBufferEntry<T>> = new LinkedList();\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\tprivate readonly _onDidChangeBuffer = this._register(new Emitter<void>());\n\treadonly onDidChangeBuffer = this._onDidChangeBuffer.event;\n\n\tconstructor(\n\t\tpublic propertySpecs: T,\n\t\tpublic capacity: number\n\t) {\n\t\tsuper();\n\n\t\tthis.view = new Float32Array(capacity * propertySpecs.length);\n\t\tthis.buffer = this.view.buffer;\n\t\tthis._entrySize = propertySpecs.length;\n\t\tfor (let i = 0; i < propertySpecs.length; i++) {\n\t\t\tconst spec = {\n\t\t\t\toffset: i,\n\t\t\t\t...propertySpecs[i]\n\t\t\t};\n\t\t\tthis._propertySpecsMap.set(spec.name, spec);\n\t\t}\n\t\tthis._register(toDisposable(() => dispose(this._entries)));\n\t}\n\n\tcreateEntry(data: ObjectCollectionPropertyValues<T>): IObjectCollectionBufferEntry<T> {\n\t\tif (this._entries.size === this.capacity) {\n\t\t\tthis._expandBuffer();\n\t\t\tthis._onDidChangeBuffer.fire();\n\t\t}\n\n\t\tconst value = new ObjectCollectionBufferEntry(this.view, this._propertySpecsMap, this._dirtyTracker, this._entries.size, data);\n\t\tconst removeFromEntries = this._entries.push(value);\n\t\tconst listeners: IDisposable[] = [];\n\t\tlisteners.push(Event.forward(value.onDidChange, this._onDidChange));\n\t\tlisteners.push(value.onWillDispose(() => {\n\t\t\tconst deletedEntryIndex = value.i;\n\t\t\tremoveFromEntries();\n\n\t\t\t// Shift all entries after the deleted entry to the left\n\t\t\tthis.view.set(this.view.subarray(deletedEntryIndex * this._entrySize + 2, this._entries.size * this._entrySize + 2), deletedEntryIndex * this._entrySize);\n\n\t\t\t// Update entries to reflect the new i\n\t\t\tfor (const entry of this._entries) {\n\t\t\t\tif (entry.i > deletedEntryIndex) {\n\t\t\t\t\tentry.i--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._dirtyTracker.flag(deletedEntryIndex, (this._entries.size - deletedEntryIndex) * this._entrySize);\n\t\t\tdispose(listeners);\n\t\t}));\n\t\treturn value;\n\t}\n\n\tprivate _expandBuffer() {\n\t\tthis.capacity *= 2;\n\t\tconst newView = new Float32Array(this.capacity * this._entrySize);\n\t\tnewView.set(this.view);\n\t\tthis.view = newView;\n\t\tthis.buffer = this.view.buffer;\n\t}\n}\n\nclass ObjectCollectionBufferEntry<T extends ObjectCollectionBufferPropertySpec[]> extends Disposable implements IObjectCollectionBufferEntry<T> {\n\n\tprivate readonly _onDidChange = this._register(new Emitter<void>());\n\treadonly onDidChange = this._onDidChange.event;\n\tprivate readonly _onWillDispose = this._register(new Emitter<void>());\n\treadonly onWillDispose = this._onWillDispose.event;\n\n\tconstructor(\n\t\tprivate _view: Float32Array,\n\t\tprivate _propertySpecsMap: Map<string, ObjectCollectionBufferPropertySpec & { offset: number }>,\n\t\tprivate _dirtyTracker: BufferDirtyTracker,\n\t\tpublic i: number,\n\t\tdata: ObjectCollectionPropertyValues<T>,\n\t) {\n\t\tsuper();\n\t\tfor (const propertySpec of this._propertySpecsMap.values()) {\n\t\t\tthis._view[this.i * this._propertySpecsMap.size + propertySpec.offset] = data[propertySpec.name as keyof typeof data];\n\t\t}\n\t\tthis._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n\t}\n\n\toverride dispose() {\n\t\tthis._onWillDispose.fire();\n\t\tsuper.dispose();\n\t}\n\n\tsetRaw(data: ArrayLike<number>): void {\n\t\tif (data.length !== this._propertySpecsMap.size) {\n\t\t\tthrow new Error(`Data length ${data.length} does not match the number of properties in the collection (${this._propertySpecsMap.size})`);\n\t\t}\n\t\tthis._view.set(data, this.i * this._propertySpecsMap.size);\n\t\tthis._dirtyTracker.flag(this.i * this._propertySpecsMap.size, this._propertySpecsMap.size);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1499, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/rectangleRenderer.wgsl.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/rectangleRenderer.wgsl.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/vs/editor/browser/gpu/rectangleRenderer.wgsl.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum RectangleRendererBindingId {\n\tShapes,\n\tLayoutInfoUniform,\n\tScrollOffset,\n}\n\nexport const rectangleRendererWgsl = /*wgsl*/ `\n\nstruct Vertex {\n\t@location(0) position: vec2f,\n};\n\nstruct LayoutInfo {\n\tcanvasDims: vec2f,\n\tviewportOffset: vec2f,\n\tviewportDims: vec2f,\n}\n\nstruct ScrollOffset {\n\toffset: vec2f,\n}\n\nstruct Shape {\n\tposition: vec2f,\n\tsize: vec2f,\n\tcolor: vec4f,\n};\n\nstruct VSOutput {\n\t@builtin(position) position: vec4f,\n\t@location(1)       color:    vec4f,\n};\n\n// Uniforms\n@group(0) @binding(${RectangleRendererBindingId.LayoutInfoUniform}) var<uniform>       layoutInfo:      LayoutInfo;\n\n// Storage buffers\n@group(0) @binding(${RectangleRendererBindingId.Shapes})            var<storage, read> shapes:          array<Shape>;\n@group(0) @binding(${RectangleRendererBindingId.ScrollOffset})      var<uniform>       scrollOffset:    ScrollOffset;\n\n@vertex fn vs(\n\tvert: Vertex,\n\t@builtin(instance_index) instanceIndex: u32,\n\t@builtin(vertex_index) vertexIndex : u32\n) -> VSOutput {\n\tlet shape = shapes[instanceIndex];\n\n\tvar vsOut: VSOutput;\n\tvsOut.position = vec4f(\n\t\t(\n\t\t\t// Top left corner\n\t\t\tvec2f(-1,  1) +\n\t\t\t// Convert pixel position to clipspace\n\t\t\tvec2f( 2, -2) / layoutInfo.canvasDims *\n\t\t\t// Shape position and size\n\t\t\t(layoutInfo.viewportOffset - scrollOffset.offset + shape.position + vert.position * shape.size)\n\t\t),\n\t\t0.0,\n\t\t1.0\n\t);\n\tvsOut.color = shape.color;\n\treturn vsOut;\n}\n\n@fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {\n\treturn vsOut.color;\n}\n`;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum RectangleRendererBindingId {\n\tShapes,\n\tLayoutInfoUniform,\n\tScrollOffset,\n}\n\nexport const rectangleRendererWgsl = /*wgsl*/ `\n\nstruct Vertex {\n\t@location(0) position: vec2f,\n};\n\nstruct LayoutInfo {\n\tcanvasDims: vec2f,\n\tviewportOffset: vec2f,\n\tviewportDims: vec2f,\n}\n\nstruct ScrollOffset {\n\toffset: vec2f,\n}\n\nstruct Shape {\n\tposition: vec2f,\n\tsize: vec2f,\n\tcolor: vec4f,\n};\n\nstruct VSOutput {\n\t@builtin(position) position: vec4f,\n\t@location(1)       color:    vec4f,\n};\n\n// Uniforms\n@group(0) @binding(${RectangleRendererBindingId.LayoutInfoUniform}) var<uniform>       layoutInfo:      LayoutInfo;\n\n// Storage buffers\n@group(0) @binding(${RectangleRendererBindingId.Shapes})            var<storage, read> shapes:          array<Shape>;\n@group(0) @binding(${RectangleRendererBindingId.ScrollOffset})      var<uniform>       scrollOffset:    ScrollOffset;\n\n@vertex fn vs(\n\tvert: Vertex,\n\t@builtin(instance_index) instanceIndex: u32,\n\t@builtin(vertex_index) vertexIndex : u32\n) -> VSOutput {\n\tlet shape = shapes[instanceIndex];\n\n\tvar vsOut: VSOutput;\n\tvsOut.position = vec4f(\n\t\t(\n\t\t\t// Top left corner\n\t\t\tvec2f(-1,  1) +\n\t\t\t// Convert pixel position to clipspace\n\t\t\tvec2f( 2, -2) / layoutInfo.canvasDims *\n\t\t\t// Shape position and size\n\t\t\t(layoutInfo.viewportOffset - scrollOffset.offset + shape.position + vert.position * shape.size)\n\t\t),\n\t\t0.0,\n\t\t1.0\n\t);\n\tvsOut.color = shape.color;\n\treturn vsOut;\n}\n\n@fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {\n\treturn vsOut.color;\n}\n`;\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAQzF,MAAM,qBAAqB,GAAG,MAAA,EAAQ,CAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBA4BzB,EAAA,gDAAA,EAA4C,EAAA;;;qBAG5C,EAAA,qCAAA,EAAiC,EAAA;qBACjC,EAAA,2CAAA,EAAuC,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6B3D,CAAC","debugId":null}},
    {"offset": {"line": 1572, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/rectangleRenderer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/rectangleRenderer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/vs/editor/browser/gpu/rectangleRenderer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../base/browser/dom.js';\nimport { Event } from '../../../base/common/event.js';\nimport { IReference, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { IObservable } from '../../../base/common/observable.js';\nimport { EditorOption } from '../../common/config/editorOptions.js';\nimport { ViewEventHandler } from '../../common/viewEventHandler.js';\nimport { ViewScrollChangedEvent } from '../../common/viewEvents.js';\nimport { ViewportData } from '../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewContext } from '../../common/viewModel/viewContext.js';\nimport { GPULifecycle } from './gpuDisposable.js';\nimport { observeDevicePixelDimensions, quadVertices } from './gpuUtils.js';\nimport { createObjectCollectionBuffer, type IObjectCollectionBuffer, type IObjectCollectionBufferEntry } from './objectCollectionBuffer.js';\nimport { RectangleRendererBindingId, rectangleRendererWgsl } from './rectangleRenderer.wgsl.js';\n\nexport type RectangleRendererEntrySpec = [\n\t{ name: 'x' },\n\t{ name: 'y' },\n\t{ name: 'width' },\n\t{ name: 'height' },\n\t{ name: 'red' },\n\t{ name: 'green' },\n\t{ name: 'blue' },\n\t{ name: 'alpha' },\n];\n\nexport class RectangleRenderer extends ViewEventHandler {\n\n\tprivate _device!: GPUDevice;\n\tprivate _renderPassDescriptor!: GPURenderPassDescriptor;\n\tprivate _renderPassColorAttachment!: GPURenderPassColorAttachment;\n\tprivate _bindGroup!: GPUBindGroup;\n\tprivate _pipeline!: GPURenderPipeline;\n\n\tprivate _vertexBuffer!: GPUBuffer;\n\tprivate readonly _shapeBindBuffer: MutableDisposable<IReference<GPUBuffer>> = this._register(new MutableDisposable());\n\n\tprivate _scrollOffsetBindBuffer!: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer!: Float32Array;\n\n\tprivate _initialized: boolean = false;\n\n\tprivate readonly _shapeCollection: IObjectCollectionBuffer<RectangleRendererEntrySpec> = this._register(createObjectCollectionBuffer([\n\t\t{ name: 'x' },\n\t\t{ name: 'y' },\n\t\t{ name: 'width' },\n\t\t{ name: 'height' },\n\t\t{ name: 'red' },\n\t\t{ name: 'green' },\n\t\t{ name: 'blue' },\n\t\t{ name: 'alpha' },\n\t], 32));\n\n\tconstructor(\n\t\tprivate readonly _context: ViewContext,\n\t\tprivate readonly _contentLeft: IObservable<number>,\n\t\tprivate readonly _devicePixelRatio: IObservable<number>,\n\t\tprivate readonly _canvas: HTMLCanvasElement,\n\t\tprivate readonly _ctx: GPUCanvasContext,\n\t\tdevice: Promise<GPUDevice>,\n\t) {\n\t\tsuper();\n\n\t\tthis._context.addEventHandler(this);\n\n\t\tthis._initWebgpu(device);\n\t}\n\n\tprivate async _initWebgpu(device: Promise<GPUDevice>) {\n\n\t\t// #region General\n\n\t\tthis._device = await device;\n\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\t\tthis._ctx.configure({\n\t\t\tdevice: this._device,\n\t\t\tformat: presentationFormat,\n\t\t\talphaMode: 'premultiplied',\n\t\t});\n\n\t\tthis._renderPassColorAttachment = {\n\t\t\tview: null!, // Will be filled at render time\n\t\t\tloadOp: 'load',\n\t\t\tstoreOp: 'store',\n\t\t};\n\t\tthis._renderPassDescriptor = {\n\t\t\tlabel: 'Monaco rectangle renderer render pass',\n\t\t\tcolorAttachments: [this._renderPassColorAttachment],\n\t\t};\n\n\t\t// #endregion General\n\n\t\t// #region Uniforms\n\n\t\tlet layoutInfoUniformBuffer: GPUBuffer;\n\t\t{\n\t\t\tconst enum Info {\n\t\t\t\tFloatsPerEntry = 6,\n\t\t\t\tBytesPerEntry = Info.FloatsPerEntry * 4,\n\t\t\t\tOffset_CanvasWidth____ = 0,\n\t\t\t\tOffset_CanvasHeight___ = 1,\n\t\t\t\tOffset_ViewportOffsetX = 2,\n\t\t\t\tOffset_ViewportOffsetY = 3,\n\t\t\t\tOffset_ViewportWidth__ = 4,\n\t\t\t\tOffset_ViewportHeight_ = 5,\n\t\t\t}\n\t\t\tconst bufferValues = new Float32Array(Info.FloatsPerEntry);\n\t\t\tconst updateBufferValues = (canvasDevicePixelWidth: number = this._canvas.width, canvasDevicePixelHeight: number = this._canvas.height) => {\n\t\t\t\tbufferValues[Info.Offset_CanvasWidth____] = canvasDevicePixelWidth;\n\t\t\t\tbufferValues[Info.Offset_CanvasHeight___] = canvasDevicePixelHeight;\n\t\t\t\tbufferValues[Info.Offset_ViewportOffsetX] = Math.ceil(this._context.configuration.options.get(EditorOption.layoutInfo).contentLeft * getActiveWindow().devicePixelRatio);\n\t\t\t\tbufferValues[Info.Offset_ViewportOffsetY] = 0;\n\t\t\t\tbufferValues[Info.Offset_ViewportWidth__] = bufferValues[Info.Offset_CanvasWidth____] - bufferValues[Info.Offset_ViewportOffsetX];\n\t\t\t\tbufferValues[Info.Offset_ViewportHeight_] = bufferValues[Info.Offset_CanvasHeight___] - bufferValues[Info.Offset_ViewportOffsetY];\n\t\t\t\treturn bufferValues;\n\t\t\t};\n\t\t\tlayoutInfoUniformBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: 'Monaco rectangle renderer uniform buffer',\n\t\t\t\tsize: Info.BytesPerEntry,\n\t\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t\t}, () => updateBufferValues())).object;\n\t\t\tthis._register(observeDevicePixelDimensions(this._canvas, getActiveWindow(), (w, h) => {\n\t\t\t\tthis._device.queue.writeBuffer(layoutInfoUniformBuffer, 0, updateBufferValues(w, h));\n\t\t\t}));\n\t\t}\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco rectangle renderer scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\n\t\t// #endregion Uniforms\n\n\t\t// #region Storage buffers\n\n\t\tconst createShapeBindBuffer = () => {\n\t\t\treturn GPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: 'Monaco rectangle renderer shape buffer',\n\t\t\t\tsize: this._shapeCollection.buffer.byteLength,\n\t\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t\t});\n\t\t};\n\t\tthis._shapeBindBuffer.value = createShapeBindBuffer();\n\t\tthis._register(Event.runAndSubscribe(this._shapeCollection.onDidChangeBuffer, () => {\n\t\t\tthis._shapeBindBuffer.value = createShapeBindBuffer();\n\t\t\tif (this._pipeline) {\n\t\t\t\tthis._updateBindGroup(this._pipeline, layoutInfoUniformBuffer);\n\t\t\t}\n\t\t}));\n\n\t\t// #endregion Storage buffers\n\n\t\t// #region Vertex buffer\n\n\t\tthis._vertexBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco rectangle renderer vertex buffer',\n\t\t\tsize: quadVertices.byteLength,\n\t\t\tusage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n\t\t}, quadVertices)).object;\n\n\t\t// #endregion Vertex buffer\n\n\t\t// #region Shader module\n\n\t\tconst module = this._device.createShaderModule({\n\t\t\tlabel: 'Monaco rectangle renderer shader module',\n\t\t\tcode: rectangleRendererWgsl,\n\t\t});\n\n\t\t// #endregion Shader module\n\n\t\t// #region Pipeline\n\n\t\tthis._pipeline = this._device.createRenderPipeline({\n\t\t\tlabel: 'Monaco rectangle renderer render pipeline',\n\t\t\tlayout: 'auto',\n\t\t\tvertex: {\n\t\t\t\tmodule,\n\t\t\t\tbuffers: [\n\t\t\t\t\t{\n\t\t\t\t\t\tarrayStride: 2 * Float32Array.BYTES_PER_ELEMENT, // 2 floats, 4 bytes each\n\t\t\t\t\t\tattributes: [\n\t\t\t\t\t\t\t{ shaderLocation: 0, offset: 0, format: 'float32x2' },  // position\n\t\t\t\t\t\t],\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\tfragment: {\n\t\t\t\tmodule,\n\t\t\t\ttargets: [\n\t\t\t\t\t{\n\t\t\t\t\t\tformat: presentationFormat,\n\t\t\t\t\t\tblend: {\n\t\t\t\t\t\t\tcolor: {\n\t\t\t\t\t\t\t\tsrcFactor: 'src-alpha',\n\t\t\t\t\t\t\t\tdstFactor: 'one-minus-src-alpha'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\talpha: {\n\t\t\t\t\t\t\t\tsrcFactor: 'src-alpha',\n\t\t\t\t\t\t\t\tdstFactor: 'one-minus-src-alpha'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\n\t\t// #endregion Pipeline\n\n\t\t// #region Bind group\n\n\t\tthis._updateBindGroup(this._pipeline, layoutInfoUniformBuffer);\n\n\t\t// endregion Bind group\n\n\t\tthis._initialized = true;\n\t}\n\n\tprivate _updateBindGroup(pipeline: GPURenderPipeline, layoutInfoUniformBuffer: GPUBuffer) {\n\t\tthis._bindGroup = this._device.createBindGroup({\n\t\t\tlabel: 'Monaco rectangle renderer bind group',\n\t\t\tlayout: pipeline.getBindGroupLayout(0),\n\t\t\tentries: [\n\t\t\t\t{ binding: RectangleRendererBindingId.Shapes, resource: { buffer: this._shapeBindBuffer.value!.object } },\n\t\t\t\t{ binding: RectangleRendererBindingId.LayoutInfoUniform, resource: { buffer: layoutInfoUniformBuffer } },\n\t\t\t\t{ binding: RectangleRendererBindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } },\n\t\t\t],\n\t\t});\n\t}\n\n\tregister(x: number, y: number, width: number, height: number, red: number, green: number, blue: number, alpha: number): IObjectCollectionBufferEntry<RectangleRendererEntrySpec> {\n\t\treturn this._shapeCollection.createEntry({ x, y, width, height, red, green, blue, alpha });\n\t}\n\n\t// #region Event handlers\n\n\tpublic override onScrollChanged(e: ViewScrollChangedEvent): boolean {\n\t\tif (this._device) {\n\t\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\t\tthis._scrollOffsetValueBuffer[0] = this._context.viewLayout.getCurrentScrollLeft() * dpr;\n\t\t\tthis._scrollOffsetValueBuffer[1] = this._context.viewLayout.getCurrentScrollTop() * dpr;\n\t\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\t}\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\tprivate _update() {\n\t\tif (!this._device) {\n\t\t\treturn;\n\t\t}\n\t\tconst shapes = this._shapeCollection;\n\t\tif (shapes.dirtyTracker.isDirty) {\n\t\t\tthis._device.queue.writeBuffer(this._shapeBindBuffer.value!.object, 0, shapes.buffer, shapes.dirtyTracker.dataOffset, shapes.dirtyTracker.dirtySize! * shapes.view.BYTES_PER_ELEMENT);\n\t\t\tshapes.dirtyTracker.clear();\n\t\t}\n\t}\n\n\tdraw(viewportData: ViewportData) {\n\t\tif (!this._initialized) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._update();\n\n\t\tconst encoder = this._device.createCommandEncoder({ label: 'Monaco rectangle renderer command encoder' });\n\n\t\tthis._renderPassColorAttachment.view = this._ctx.getCurrentTexture().createView();\n\t\tconst pass = encoder.beginRenderPass(this._renderPassDescriptor);\n\t\tpass.setPipeline(this._pipeline);\n\t\tpass.setVertexBuffer(0, this._vertexBuffer);\n\t\tpass.setBindGroup(0, this._bindGroup);\n\n\t\t// Only draw the content area\n\t\tconst contentLeft = Math.ceil(this._contentLeft.get() * this._devicePixelRatio.get());\n\t\tpass.setScissorRect(contentLeft, 0, this._canvas.width - contentLeft, this._canvas.height);\n\n\t\tpass.draw(quadVertices.length / 2, this._shapeCollection.entryCount);\n\t\tpass.end();\n\n\t\tconst commandBuffer = encoder.finish();\n\t\tthis._device.queue.submit([commandBuffer]);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../base/browser/dom.js';\nimport { Event } from '../../../base/common/event.js';\nimport { IReference, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { IObservable } from '../../../base/common/observable.js';\nimport { EditorOption } from '../../common/config/editorOptions.js';\nimport { ViewEventHandler } from '../../common/viewEventHandler.js';\nimport { ViewScrollChangedEvent } from '../../common/viewEvents.js';\nimport { ViewportData } from '../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewContext } from '../../common/viewModel/viewContext.js';\nimport { GPULifecycle } from './gpuDisposable.js';\nimport { observeDevicePixelDimensions, quadVertices } from './gpuUtils.js';\nimport { createObjectCollectionBuffer, type IObjectCollectionBuffer, type IObjectCollectionBufferEntry } from './objectCollectionBuffer.js';\nimport { RectangleRendererBindingId, rectangleRendererWgsl } from './rectangleRenderer.wgsl.js';\n\nexport type RectangleRendererEntrySpec = [\n\t{ name: 'x' },\n\t{ name: 'y' },\n\t{ name: 'width' },\n\t{ name: 'height' },\n\t{ name: 'red' },\n\t{ name: 'green' },\n\t{ name: 'blue' },\n\t{ name: 'alpha' },\n];\n\nexport class RectangleRenderer extends ViewEventHandler {\n\n\tprivate _device!: GPUDevice;\n\tprivate _renderPassDescriptor!: GPURenderPassDescriptor;\n\tprivate _renderPassColorAttachment!: GPURenderPassColorAttachment;\n\tprivate _bindGroup!: GPUBindGroup;\n\tprivate _pipeline!: GPURenderPipeline;\n\n\tprivate _vertexBuffer!: GPUBuffer;\n\tprivate readonly _shapeBindBuffer: MutableDisposable<IReference<GPUBuffer>> = this._register(new MutableDisposable());\n\n\tprivate _scrollOffsetBindBuffer!: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer!: Float32Array;\n\n\tprivate _initialized: boolean = false;\n\n\tprivate readonly _shapeCollection: IObjectCollectionBuffer<RectangleRendererEntrySpec> = this._register(createObjectCollectionBuffer([\n\t\t{ name: 'x' },\n\t\t{ name: 'y' },\n\t\t{ name: 'width' },\n\t\t{ name: 'height' },\n\t\t{ name: 'red' },\n\t\t{ name: 'green' },\n\t\t{ name: 'blue' },\n\t\t{ name: 'alpha' },\n\t], 32));\n\n\tconstructor(\n\t\tprivate readonly _context: ViewContext,\n\t\tprivate readonly _contentLeft: IObservable<number>,\n\t\tprivate readonly _devicePixelRatio: IObservable<number>,\n\t\tprivate readonly _canvas: HTMLCanvasElement,\n\t\tprivate readonly _ctx: GPUCanvasContext,\n\t\tdevice: Promise<GPUDevice>,\n\t) {\n\t\tsuper();\n\n\t\tthis._context.addEventHandler(this);\n\n\t\tthis._initWebgpu(device);\n\t}\n\n\tprivate async _initWebgpu(device: Promise<GPUDevice>) {\n\n\t\t// #region General\n\n\t\tthis._device = await device;\n\n\t\tif (this._store.isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\t\tthis._ctx.configure({\n\t\t\tdevice: this._device,\n\t\t\tformat: presentationFormat,\n\t\t\talphaMode: 'premultiplied',\n\t\t});\n\n\t\tthis._renderPassColorAttachment = {\n\t\t\tview: null!, // Will be filled at render time\n\t\t\tloadOp: 'load',\n\t\t\tstoreOp: 'store',\n\t\t};\n\t\tthis._renderPassDescriptor = {\n\t\t\tlabel: 'Monaco rectangle renderer render pass',\n\t\t\tcolorAttachments: [this._renderPassColorAttachment],\n\t\t};\n\n\t\t// #endregion General\n\n\t\t// #region Uniforms\n\n\t\tlet layoutInfoUniformBuffer: GPUBuffer;\n\t\t{\n\t\t\tconst enum Info {\n\t\t\t\tFloatsPerEntry = 6,\n\t\t\t\tBytesPerEntry = Info.FloatsPerEntry * 4,\n\t\t\t\tOffset_CanvasWidth____ = 0,\n\t\t\t\tOffset_CanvasHeight___ = 1,\n\t\t\t\tOffset_ViewportOffsetX = 2,\n\t\t\t\tOffset_ViewportOffsetY = 3,\n\t\t\t\tOffset_ViewportWidth__ = 4,\n\t\t\t\tOffset_ViewportHeight_ = 5,\n\t\t\t}\n\t\t\tconst bufferValues = new Float32Array(Info.FloatsPerEntry);\n\t\t\tconst updateBufferValues = (canvasDevicePixelWidth: number = this._canvas.width, canvasDevicePixelHeight: number = this._canvas.height) => {\n\t\t\t\tbufferValues[Info.Offset_CanvasWidth____] = canvasDevicePixelWidth;\n\t\t\t\tbufferValues[Info.Offset_CanvasHeight___] = canvasDevicePixelHeight;\n\t\t\t\tbufferValues[Info.Offset_ViewportOffsetX] = Math.ceil(this._context.configuration.options.get(EditorOption.layoutInfo).contentLeft * getActiveWindow().devicePixelRatio);\n\t\t\t\tbufferValues[Info.Offset_ViewportOffsetY] = 0;\n\t\t\t\tbufferValues[Info.Offset_ViewportWidth__] = bufferValues[Info.Offset_CanvasWidth____] - bufferValues[Info.Offset_ViewportOffsetX];\n\t\t\t\tbufferValues[Info.Offset_ViewportHeight_] = bufferValues[Info.Offset_CanvasHeight___] - bufferValues[Info.Offset_ViewportOffsetY];\n\t\t\t\treturn bufferValues;\n\t\t\t};\n\t\t\tlayoutInfoUniformBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: 'Monaco rectangle renderer uniform buffer',\n\t\t\t\tsize: Info.BytesPerEntry,\n\t\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t\t}, () => updateBufferValues())).object;\n\t\t\tthis._register(observeDevicePixelDimensions(this._canvas, getActiveWindow(), (w, h) => {\n\t\t\t\tthis._device.queue.writeBuffer(layoutInfoUniformBuffer, 0, updateBufferValues(w, h));\n\t\t\t}));\n\t\t}\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco rectangle renderer scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\n\t\t// #endregion Uniforms\n\n\t\t// #region Storage buffers\n\n\t\tconst createShapeBindBuffer = () => {\n\t\t\treturn GPULifecycle.createBuffer(this._device, {\n\t\t\t\tlabel: 'Monaco rectangle renderer shape buffer',\n\t\t\t\tsize: this._shapeCollection.buffer.byteLength,\n\t\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t\t});\n\t\t};\n\t\tthis._shapeBindBuffer.value = createShapeBindBuffer();\n\t\tthis._register(Event.runAndSubscribe(this._shapeCollection.onDidChangeBuffer, () => {\n\t\t\tthis._shapeBindBuffer.value = createShapeBindBuffer();\n\t\t\tif (this._pipeline) {\n\t\t\t\tthis._updateBindGroup(this._pipeline, layoutInfoUniformBuffer);\n\t\t\t}\n\t\t}));\n\n\t\t// #endregion Storage buffers\n\n\t\t// #region Vertex buffer\n\n\t\tthis._vertexBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco rectangle renderer vertex buffer',\n\t\t\tsize: quadVertices.byteLength,\n\t\t\tusage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n\t\t}, quadVertices)).object;\n\n\t\t// #endregion Vertex buffer\n\n\t\t// #region Shader module\n\n\t\tconst module = this._device.createShaderModule({\n\t\t\tlabel: 'Monaco rectangle renderer shader module',\n\t\t\tcode: rectangleRendererWgsl,\n\t\t});\n\n\t\t// #endregion Shader module\n\n\t\t// #region Pipeline\n\n\t\tthis._pipeline = this._device.createRenderPipeline({\n\t\t\tlabel: 'Monaco rectangle renderer render pipeline',\n\t\t\tlayout: 'auto',\n\t\t\tvertex: {\n\t\t\t\tmodule,\n\t\t\t\tbuffers: [\n\t\t\t\t\t{\n\t\t\t\t\t\tarrayStride: 2 * Float32Array.BYTES_PER_ELEMENT, // 2 floats, 4 bytes each\n\t\t\t\t\t\tattributes: [\n\t\t\t\t\t\t\t{ shaderLocation: 0, offset: 0, format: 'float32x2' },  // position\n\t\t\t\t\t\t],\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\tfragment: {\n\t\t\t\tmodule,\n\t\t\t\ttargets: [\n\t\t\t\t\t{\n\t\t\t\t\t\tformat: presentationFormat,\n\t\t\t\t\t\tblend: {\n\t\t\t\t\t\t\tcolor: {\n\t\t\t\t\t\t\t\tsrcFactor: 'src-alpha',\n\t\t\t\t\t\t\t\tdstFactor: 'one-minus-src-alpha'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\talpha: {\n\t\t\t\t\t\t\t\tsrcFactor: 'src-alpha',\n\t\t\t\t\t\t\t\tdstFactor: 'one-minus-src-alpha'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t},\n\t\t});\n\n\t\t// #endregion Pipeline\n\n\t\t// #region Bind group\n\n\t\tthis._updateBindGroup(this._pipeline, layoutInfoUniformBuffer);\n\n\t\t// endregion Bind group\n\n\t\tthis._initialized = true;\n\t}\n\n\tprivate _updateBindGroup(pipeline: GPURenderPipeline, layoutInfoUniformBuffer: GPUBuffer) {\n\t\tthis._bindGroup = this._device.createBindGroup({\n\t\t\tlabel: 'Monaco rectangle renderer bind group',\n\t\t\tlayout: pipeline.getBindGroupLayout(0),\n\t\t\tentries: [\n\t\t\t\t{ binding: RectangleRendererBindingId.Shapes, resource: { buffer: this._shapeBindBuffer.value!.object } },\n\t\t\t\t{ binding: RectangleRendererBindingId.LayoutInfoUniform, resource: { buffer: layoutInfoUniformBuffer } },\n\t\t\t\t{ binding: RectangleRendererBindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } },\n\t\t\t],\n\t\t});\n\t}\n\n\tregister(x: number, y: number, width: number, height: number, red: number, green: number, blue: number, alpha: number): IObjectCollectionBufferEntry<RectangleRendererEntrySpec> {\n\t\treturn this._shapeCollection.createEntry({ x, y, width, height, red, green, blue, alpha });\n\t}\n\n\t// #region Event handlers\n\n\tpublic override onScrollChanged(e: ViewScrollChangedEvent): boolean {\n\t\tif (this._device) {\n\t\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\t\tthis._scrollOffsetValueBuffer[0] = this._context.viewLayout.getCurrentScrollLeft() * dpr;\n\t\t\tthis._scrollOffsetValueBuffer[1] = this._context.viewLayout.getCurrentScrollTop() * dpr;\n\t\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\t}\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\tprivate _update() {\n\t\tif (!this._device) {\n\t\t\treturn;\n\t\t}\n\t\tconst shapes = this._shapeCollection;\n\t\tif (shapes.dirtyTracker.isDirty) {\n\t\t\tthis._device.queue.writeBuffer(this._shapeBindBuffer.value!.object, 0, shapes.buffer, shapes.dirtyTracker.dataOffset, shapes.dirtyTracker.dirtySize! * shapes.view.BYTES_PER_ELEMENT);\n\t\t\tshapes.dirtyTracker.clear();\n\t\t}\n\t}\n\n\tdraw(viewportData: ViewportData) {\n\t\tif (!this._initialized) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._update();\n\n\t\tconst encoder = this._device.createCommandEncoder({ label: 'Monaco rectangle renderer command encoder' });\n\n\t\tthis._renderPassColorAttachment.view = this._ctx.getCurrentTexture().createView();\n\t\tconst pass = encoder.beginRenderPass(this._renderPassDescriptor);\n\t\tpass.setPipeline(this._pipeline);\n\t\tpass.setVertexBuffer(0, this._vertexBuffer);\n\t\tpass.setBindGroup(0, this._bindGroup);\n\n\t\t// Only draw the content area\n\t\tconst contentLeft = Math.ceil(this._contentLeft.get() * this._devicePixelRatio.get());\n\t\tpass.setScissorRect(contentLeft, 0, this._canvas.width - contentLeft, this._canvas.height);\n\n\t\tpass.draw(quadVertices.length / 2, this._shapeCollection.entryCount);\n\t\tpass.end();\n\n\t\tconst commandBuffer = encoder.finish();\n\t\tthis._device.queue.submit([commandBuffer]);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1848, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/css/decorationCssRuleExtractor.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/css/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/css/decorationCssRuleExtractor.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/css/vs/editor/browser/gpu/css/decorationCssRuleExtractor.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { $, getActiveDocument } from '../../../../base/browser/dom.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport './media/decorationCssRuleExtractor.css';\n\n/**\n * Extracts CSS rules that would be applied to certain decoration classes.\n */\nexport class DecorationCssRuleExtractor extends Disposable {\n\tprivate _container: HTMLElement;\n\tprivate _dummyElement: HTMLSpanElement;\n\n\tprivate _ruleCache: Map</* className */string, CSSStyleRule[]> = new Map();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._container = $('div.monaco-decoration-css-rule-extractor');\n\t\tthis._dummyElement = $('span');\n\t\tthis._container.appendChild(this._dummyElement);\n\n\t\tthis._register(toDisposable(() => this._container.remove()));\n\t}\n\n\tgetStyleRules(canvas: HTMLElement, decorationClassName: string): CSSStyleRule[] {\n\t\t// Check cache\n\t\tconst existing = this._ruleCache.get(decorationClassName);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// Set up DOM\n\t\tthis._dummyElement.className = decorationClassName;\n\t\tcanvas.appendChild(this._container);\n\n\t\t// Get rules\n\t\tconst rules = this._getStyleRules(decorationClassName);\n\t\tthis._ruleCache.set(decorationClassName, rules);\n\n\t\t// Tear down DOM\n\t\tcanvas.removeChild(this._container);\n\n\t\treturn rules;\n\t}\n\n\tprivate _getStyleRules(className: string) {\n\t\t// Iterate through all stylesheets and imported stylesheets to find matching rules\n\t\tconst rules = [];\n\t\tconst doc = getActiveDocument();\n\t\tconst stylesheets = [...doc.styleSheets];\n\t\tfor (let i = 0; i < stylesheets.length; i++) {\n\t\t\tconst stylesheet = stylesheets[i];\n\t\t\tfor (const rule of stylesheet.cssRules) {\n\t\t\t\tif (rule instanceof CSSImportRule) {\n\t\t\t\t\tif (rule.styleSheet) {\n\t\t\t\t\t\tstylesheets.push(rule.styleSheet);\n\t\t\t\t\t}\n\t\t\t\t} else if (rule instanceof CSSStyleRule) {\n\t\t\t\t\t// Note that originally `.matches(rule.selectorText)` was used but this would\n\t\t\t\t\t// not pick up pseudo-classes which are important to determine support of the\n\t\t\t\t\t// returned styles.\n\t\t\t\t\t//\n\t\t\t\t\t// Since a selector could contain a class name lookup that is simple a prefix of\n\t\t\t\t\t// the class name we are looking for, we need to also check the character after\n\t\t\t\t\t// it.\n\t\t\t\t\tconst searchTerm = `.${className}`;\n\t\t\t\t\tconst index = rule.selectorText.indexOf(searchTerm);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tconst endOfResult = index + searchTerm.length;\n\t\t\t\t\t\tif (rule.selectorText.length === endOfResult || rule.selectorText.substring(endOfResult, endOfResult + 1).match(/[ :]/)) {\n\t\t\t\t\t\t\trules.push(rule);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn rules;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { $, getActiveDocument } from '../../../../base/browser/dom.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport './media/decorationCssRuleExtractor.css';\n\n/**\n * Extracts CSS rules that would be applied to certain decoration classes.\n */\nexport class DecorationCssRuleExtractor extends Disposable {\n\tprivate _container: HTMLElement;\n\tprivate _dummyElement: HTMLSpanElement;\n\n\tprivate _ruleCache: Map</* className */string, CSSStyleRule[]> = new Map();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis._container = $('div.monaco-decoration-css-rule-extractor');\n\t\tthis._dummyElement = $('span');\n\t\tthis._container.appendChild(this._dummyElement);\n\n\t\tthis._register(toDisposable(() => this._container.remove()));\n\t}\n\n\tgetStyleRules(canvas: HTMLElement, decorationClassName: string): CSSStyleRule[] {\n\t\t// Check cache\n\t\tconst existing = this._ruleCache.get(decorationClassName);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\n\t\t// Set up DOM\n\t\tthis._dummyElement.className = decorationClassName;\n\t\tcanvas.appendChild(this._container);\n\n\t\t// Get rules\n\t\tconst rules = this._getStyleRules(decorationClassName);\n\t\tthis._ruleCache.set(decorationClassName, rules);\n\n\t\t// Tear down DOM\n\t\tcanvas.removeChild(this._container);\n\n\t\treturn rules;\n\t}\n\n\tprivate _getStyleRules(className: string) {\n\t\t// Iterate through all stylesheets and imported stylesheets to find matching rules\n\t\tconst rules = [];\n\t\tconst doc = getActiveDocument();\n\t\tconst stylesheets = [...doc.styleSheets];\n\t\tfor (let i = 0; i < stylesheets.length; i++) {\n\t\t\tconst stylesheet = stylesheets[i];\n\t\t\tfor (const rule of stylesheet.cssRules) {\n\t\t\t\tif (rule instanceof CSSImportRule) {\n\t\t\t\t\tif (rule.styleSheet) {\n\t\t\t\t\t\tstylesheets.push(rule.styleSheet);\n\t\t\t\t\t}\n\t\t\t\t} else if (rule instanceof CSSStyleRule) {\n\t\t\t\t\t// Note that originally `.matches(rule.selectorText)` was used but this would\n\t\t\t\t\t// not pick up pseudo-classes which are important to determine support of the\n\t\t\t\t\t// returned styles.\n\t\t\t\t\t//\n\t\t\t\t\t// Since a selector could contain a class name lookup that is simple a prefix of\n\t\t\t\t\t// the class name we are looking for, we need to also check the character after\n\t\t\t\t\t// it.\n\t\t\t\t\tconst searchTerm = `.${className}`;\n\t\t\t\t\tconst index = rule.selectorText.indexOf(searchTerm);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tconst endOfResult = index + searchTerm.length;\n\t\t\t\t\t\tif (rule.selectorText.length === endOfResult || rule.selectorText.substring(endOfResult, endOfResult + 1).match(/[ :]/)) {\n\t\t\t\t\t\t\trules.push(rule);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn rules;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1925, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/css/decorationStyleCache.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/css/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/css/decorationStyleCache.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/css/vs/editor/browser/gpu/css/decorationStyleCache.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NKeyMap } from '../../../../base/common/map.js';\n\nexport interface IDecorationStyleSet {\n\t/**\n\t * A 24-bit number representing `color`.\n\t */\n\tcolor: number | undefined;\n\t/**\n\t * Whether the text should be rendered in bold.\n\t */\n\tbold: boolean | undefined;\n\t/**\n\t * A number between 0 and 1 representing the opacity of the text.\n\t */\n\topacity: number | undefined;\n}\n\nexport interface IDecorationStyleCacheEntry extends IDecorationStyleSet {\n\t/**\n\t * A unique identifier for this set of styles.\n\t */\n\tid: number;\n}\n\nexport class DecorationStyleCache {\n\n\tprivate _nextId = 1;\n\n\tprivate readonly _cacheById = new Map<number, IDecorationStyleCacheEntry>();\n\tprivate readonly _cacheByStyle = new NKeyMap<IDecorationStyleCacheEntry, [number, number, string]>();\n\n\tgetOrCreateEntry(\n\t\tcolor: number | undefined,\n\t\tbold: boolean | undefined,\n\t\topacity: number | undefined\n\t): number {\n\t\tif (color === undefined && bold === undefined && opacity === undefined) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst result = this._cacheByStyle.get(color ?? 0, bold ? 1 : 0, opacity === undefined ? '' : opacity.toFixed(2));\n\t\tif (result) {\n\t\t\treturn result.id;\n\t\t}\n\t\tconst id = this._nextId++;\n\t\tconst entry = {\n\t\t\tid,\n\t\t\tcolor,\n\t\t\tbold,\n\t\t\topacity,\n\t\t};\n\t\tthis._cacheById.set(id, entry);\n\t\tthis._cacheByStyle.set(entry, color ?? 0, bold ? 1 : 0, opacity === undefined ? '' : opacity.toFixed(2));\n\t\treturn id;\n\t}\n\n\tgetStyleSet(id: number): IDecorationStyleSet | undefined {\n\t\tif (id === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._cacheById.get(id);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NKeyMap } from '../../../../base/common/map.js';\n\nexport interface IDecorationStyleSet {\n\t/**\n\t * A 24-bit number representing `color`.\n\t */\n\tcolor: number | undefined;\n\t/**\n\t * Whether the text should be rendered in bold.\n\t */\n\tbold: boolean | undefined;\n\t/**\n\t * A number between 0 and 1 representing the opacity of the text.\n\t */\n\topacity: number | undefined;\n}\n\nexport interface IDecorationStyleCacheEntry extends IDecorationStyleSet {\n\t/**\n\t * A unique identifier for this set of styles.\n\t */\n\tid: number;\n}\n\nexport class DecorationStyleCache {\n\n\tprivate _nextId = 1;\n\n\tprivate readonly _cacheById = new Map<number, IDecorationStyleCacheEntry>();\n\tprivate readonly _cacheByStyle = new NKeyMap<IDecorationStyleCacheEntry, [number, number, string]>();\n\n\tgetOrCreateEntry(\n\t\tcolor: number | undefined,\n\t\tbold: boolean | undefined,\n\t\topacity: number | undefined\n\t): number {\n\t\tif (color === undefined && bold === undefined && opacity === undefined) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst result = this._cacheByStyle.get(color ?? 0, bold ? 1 : 0, opacity === undefined ? '' : opacity.toFixed(2));\n\t\tif (result) {\n\t\t\treturn result.id;\n\t\t}\n\t\tconst id = this._nextId++;\n\t\tconst entry = {\n\t\t\tid,\n\t\t\tcolor,\n\t\t\tbold,\n\t\t\topacity,\n\t\t};\n\t\tthis._cacheById.set(id, entry);\n\t\tthis._cacheByStyle.set(entry, color ?? 0, bold ? 1 : 0, opacity === undefined ? '' : opacity.toFixed(2));\n\t\treturn id;\n\t}\n\n\tgetStyleSet(id: number): IDecorationStyleSet | undefined {\n\t\tif (id === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._cacheById.get(id);\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,OAAO,EAAE,MAAM,gCAAgC,CAAC;;AAwBnD,MAAO,oBAAoB;IAAjC,aAAA;QAES,IAAA,CAAA,OAAO,GAAG,CAAC,CAAC;QAEH,IAAA,CAAA,UAAU,GAAG,IAAI,GAAG,EAAsC,CAAC;QAC3D,IAAA,CAAA,aAAa,GAAG,IAAI,iLAAO,EAAwD,CAAC;IAgCtG,CAAC;IA9BA,gBAAgB,CACf,KAAyB,EACzB,IAAyB,EACzB,OAA2B,EAAA;QAE3B,IAAI,KAAK,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,IAAI,OAAO,KAAK,SAAS,EAAE,CAAC;YACxE,OAAO,CAAC,CAAC;QACV,CAAC;QACD,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QACjH,IAAI,MAAM,EAAE,CAAC;YACZ,OAAO,MAAM,CAAC,EAAE,CAAC;QAClB,CAAC;QACD,MAAM,EAAE,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QAC1B,MAAM,KAAK,GAAG;YACb,EAAE;YACF,KAAK;YACL,IAAI;YACJ,OAAO;SACP,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;QAC/B,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QACzG,OAAO,EAAE,CAAC;IACX,CAAC;IAED,WAAW,CAAC,EAAU,EAAA;QACrB,IAAI,EAAE,KAAK,CAAC,EAAE,CAAC;YACd,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAChC,CAAC;CACD","debugId":null}},
    {"offset": {"line": 1970, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/viewGpuContext.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/vs/editor/browser/gpu/viewGpuContext.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../../nls.js';\nimport { addDisposableListener, getActiveWindow } from '../../../base/browser/dom.js';\nimport { createFastDomNode, type FastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ViewportData } from '../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewLineOptions } from '../viewParts/viewLines/viewLineOptions.js';\nimport { observableValue, runOnChange, type IObservable } from '../../../base/common/observable.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { TextureAtlas } from './atlas/textureAtlas.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { INotificationService, IPromptChoice, Severity } from '../../../platform/notification/common/notification.js';\nimport { GPULifecycle } from './gpuDisposable.js';\nimport { ensureNonNullable, observeDevicePixelDimensions } from './gpuUtils.js';\nimport { RectangleRenderer } from './rectangleRenderer.js';\nimport { ViewContext } from '../../common/viewModel/viewContext.js';\nimport { DecorationCssRuleExtractor } from './css/decorationCssRuleExtractor.js';\nimport { Event } from '../../../base/common/event.js';\nimport { EditorOption, type IEditorOptions } from '../../common/config/editorOptions.js';\nimport { DecorationStyleCache } from './css/decorationStyleCache.js';\nimport { InlineDecorationType } from '../../common/viewModel/inlineDecorations.js';\n\nexport class ViewGpuContext extends Disposable {\n\t/**\n\t * The hard cap for line columns rendered by the GPU renderer.\n\t */\n\treadonly maxGpuCols = 2000;\n\n\treadonly canvas: FastDomNode<HTMLCanvasElement>;\n\treadonly ctx: GPUCanvasContext;\n\n\tstatic device: Promise<GPUDevice>;\n\tstatic deviceSync: GPUDevice | undefined;\n\n\treadonly rectangleRenderer: RectangleRenderer;\n\n\tprivate static readonly _decorationCssRuleExtractor = new DecorationCssRuleExtractor();\n\tstatic get decorationCssRuleExtractor(): DecorationCssRuleExtractor {\n\t\treturn ViewGpuContext._decorationCssRuleExtractor;\n\t}\n\n\tprivate static readonly _decorationStyleCache = new DecorationStyleCache();\n\tstatic get decorationStyleCache(): DecorationStyleCache {\n\t\treturn ViewGpuContext._decorationStyleCache;\n\t}\n\n\tprivate static _atlas: TextureAtlas | undefined;\n\n\t/**\n\t * The shared texture atlas to use across all views.\n\t *\n\t * @throws if called before the GPU device is resolved\n\t */\n\tstatic get atlas(): TextureAtlas {\n\t\tif (!ViewGpuContext._atlas) {\n\t\t\tthrow new BugIndicatingError('Cannot call ViewGpuContext.textureAtlas before device is resolved');\n\t\t}\n\t\treturn ViewGpuContext._atlas;\n\t}\n\t/**\n\t * The shared texture atlas to use across all views. This is a convenience alias for\n\t * {@link ViewGpuContext.atlas}.\n\t *\n\t * @throws if called before the GPU device is resolved\n\t */\n\tget atlas(): TextureAtlas {\n\t\treturn ViewGpuContext.atlas;\n\t}\n\n\treadonly canvasDevicePixelDimensions: IObservable<{ width: number; height: number }>;\n\treadonly devicePixelRatio: IObservable<number>;\n\treadonly contentLeft: IObservable<number>;\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@INotificationService private readonly _notificationService: INotificationService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t) {\n\t\tsuper();\n\n\t\tthis.canvas = createFastDomNode(document.createElement('canvas'));\n\t\tthis.canvas.setClassName('editorCanvas');\n\n\t\t// Adjust the canvas size to avoid drawing under the scroll bar\n\t\tthis._register(Event.runAndSubscribe(configurationService.onDidChangeConfiguration, e => {\n\t\t\tif (!e || e.affectsConfiguration('editor.scrollbar.verticalScrollbarSize')) {\n\t\t\t\tconst verticalScrollbarSize = configurationService.getValue<IEditorOptions>('editor').scrollbar?.verticalScrollbarSize ?? 14;\n\t\t\t\tthis.canvas.domNode.style.boxSizing = 'border-box';\n\t\t\t\tthis.canvas.domNode.style.paddingRight = `${verticalScrollbarSize}px`;\n\t\t\t}\n\t\t}));\n\n\t\tthis.ctx = ensureNonNullable(this.canvas.domNode.getContext('webgpu'));\n\n\t\t// Request the GPU device, we only want to do this a single time per window as it's async\n\t\t// and can delay the initial render.\n\t\tif (!ViewGpuContext.device) {\n\t\t\tViewGpuContext.device = GPULifecycle.requestDevice((message) => {\n\t\t\t\tconst choices: IPromptChoice[] = [{\n\t\t\t\t\tlabel: nls.localize('editor.dom.render', \"Use DOM-based rendering\"),\n\t\t\t\t\trun: () => this.configurationService.updateValue('editor.experimentalGpuAcceleration', 'off'),\n\t\t\t\t}];\n\t\t\t\tthis._notificationService.prompt(Severity.Warning, message, choices);\n\t\t\t}).then(ref => {\n\t\t\t\tViewGpuContext.deviceSync = ref.object;\n\t\t\t\tif (!ViewGpuContext._atlas) {\n\t\t\t\t\tViewGpuContext._atlas = this._instantiationService.createInstance(TextureAtlas, ref.object.limits.maxTextureDimension2D, undefined, ViewGpuContext.decorationStyleCache);\n\t\t\t\t}\n\t\t\t\treturn ref.object;\n\t\t\t});\n\t\t}\n\n\t\tconst dprObs = observableValue(this, getActiveWindow().devicePixelRatio);\n\t\tthis._register(addDisposableListener(getActiveWindow(), 'resize', () => {\n\t\t\tdprObs.set(getActiveWindow().devicePixelRatio, undefined);\n\t\t}));\n\t\tthis.devicePixelRatio = dprObs;\n\t\tthis._register(runOnChange(this.devicePixelRatio, () => ViewGpuContext.atlas?.clear()));\n\n\t\tconst canvasDevicePixelDimensions = observableValue(this, { width: this.canvas.domNode.width, height: this.canvas.domNode.height });\n\t\tthis._register(observeDevicePixelDimensions(\n\t\t\tthis.canvas.domNode,\n\t\t\tgetActiveWindow(),\n\t\t\t(width, height) => {\n\t\t\t\tthis.canvas.domNode.width = width;\n\t\t\t\tthis.canvas.domNode.height = height;\n\t\t\t\tcanvasDevicePixelDimensions.set({ width, height }, undefined);\n\t\t\t}\n\t\t));\n\t\tthis.canvasDevicePixelDimensions = canvasDevicePixelDimensions;\n\n\t\tconst contentLeft = observableValue(this, 0);\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(e => {\n\t\t\tcontentLeft.set(context.configuration.options.get(EditorOption.layoutInfo).contentLeft, undefined);\n\t\t}));\n\t\tthis.contentLeft = contentLeft;\n\n\t\tthis.rectangleRenderer = this._instantiationService.createInstance(RectangleRenderer, context, this.contentLeft, this.devicePixelRatio, this.canvas.domNode, this.ctx, ViewGpuContext.device);\n\t}\n\n\t/**\n\t * This method determines which lines can be and are allowed to be rendered using the GPU\n\t * renderer. Eventually this should trend all lines, except maybe exceptional cases like\n\t * decorations that use class names.\n\t */\n\tpublic canRender(options: ViewLineOptions, viewportData: ViewportData, lineNumber: number): boolean {\n\t\tconst data = viewportData.getViewLineRenderingData(lineNumber);\n\n\t\t// Check if the line has simple attributes that aren't supported\n\t\tif (\n\t\t\tdata.containsRTL ||\n\t\t\tdata.maxColumn > this.maxGpuCols\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if all inline decorations are supported\n\t\tif (data.inlineDecorations.length > 0) {\n\t\t\tlet supported = true;\n\t\t\tfor (const decoration of data.inlineDecorations) {\n\t\t\t\tif (decoration.type !== InlineDecorationType.Regular) {\n\t\t\t\t\tsupported = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst styleRules = ViewGpuContext._decorationCssRuleExtractor.getStyleRules(this.canvas.domNode, decoration.inlineClassName);\n\t\t\t\tsupported &&= styleRules.every(rule => {\n\t\t\t\t\t// Pseudo classes aren't supported currently\n\t\t\t\t\tif (rule.selectorText.includes(':')) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\tif (!supportsCssRule(r, rule.style)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tif (!supported) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn supported;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Like {@link canRender} but returns detailed information about why the line cannot be rendered.\n\t */\n\tpublic canRenderDetailed(options: ViewLineOptions, viewportData: ViewportData, lineNumber: number): string[] {\n\t\tconst data = viewportData.getViewLineRenderingData(lineNumber);\n\t\tconst reasons: string[] = [];\n\t\tif (data.containsRTL) {\n\t\t\treasons.push('containsRTL');\n\t\t}\n\t\tif (data.maxColumn > this.maxGpuCols) {\n\t\t\treasons.push('maxColumn > maxGpuCols');\n\t\t}\n\t\tif (data.inlineDecorations.length > 0) {\n\t\t\tlet supported = true;\n\t\t\tconst problemTypes: InlineDecorationType[] = [];\n\t\t\tconst problemSelectors: string[] = [];\n\t\t\tconst problemRules: string[] = [];\n\t\t\tfor (const decoration of data.inlineDecorations) {\n\t\t\t\tif (decoration.type !== InlineDecorationType.Regular) {\n\t\t\t\t\tproblemTypes.push(decoration.type);\n\t\t\t\t\tsupported = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst styleRules = ViewGpuContext._decorationCssRuleExtractor.getStyleRules(this.canvas.domNode, decoration.inlineClassName);\n\t\t\t\tsupported &&= styleRules.every(rule => {\n\t\t\t\t\t// Pseudo classes aren't supported currently\n\t\t\t\t\tif (rule.selectorText.includes(':')) {\n\t\t\t\t\t\tproblemSelectors.push(rule.selectorText);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\tif (!supportsCssRule(r, rule.style)) {\n\t\t\t\t\t\t\tproblemRules.push(`${r}: ${rule.style[r as any]}`);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tif (!supported) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (problemTypes.length > 0) {\n\t\t\t\treasons.push(`inlineDecorations with unsupported types (${problemTypes.map(e => `\\`${e}\\``).join(', ')})`);\n\t\t\t}\n\t\t\tif (problemRules.length > 0) {\n\t\t\t\treasons.push(`inlineDecorations with unsupported CSS rules (${problemRules.map(e => `\\`${e}\\``).join(', ')})`);\n\t\t\t}\n\t\t\tif (problemSelectors.length > 0) {\n\t\t\t\treasons.push(`inlineDecorations with unsupported CSS selectors (${problemSelectors.map(e => `\\`${e}\\``).join(', ')})`);\n\t\t\t}\n\t\t}\n\t\treturn reasons;\n\t}\n}\n\n/**\n * A list of supported decoration CSS rules that can be used in the GPU renderer.\n */\nconst gpuSupportedDecorationCssRules = [\n\t'color',\n\t'font-weight',\n\t'opacity',\n];\n\nfunction supportsCssRule(rule: string, style: CSSStyleDeclaration) {\n\tif (!gpuSupportedDecorationCssRules.includes(rule)) {\n\t\treturn false;\n\t}\n\t// Check for values that aren't supported\n\tswitch (rule) {\n\t\tdefault: return true;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2240, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/contentSegmenter.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/contentSegmenter.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/vs/editor/browser/gpu/contentSegmenter.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { safeIntl } from '../../../base/common/date.js';\nimport { ViewLineRenderingData } from '../../common/viewModel.js';\nimport { ViewLineOptions } from '../viewParts/viewLines/viewLineOptions.js';\n\nexport interface IContentSegmenter {\n\t/**\n\t * Gets the content segment at an index within the line data's contents. This will be undefined\n\t * when the index should not be rendered, ie. when it's part of an earlier segment like the tail\n\t * end of an emoji, or when the line is not that long.\n\t * @param index The index within the line data's content string.\n\t */\n\tgetSegmentAtIndex(index: number): string | undefined;\n}\n\nexport function createContentSegmenter(lineData: ViewLineRenderingData, options: ViewLineOptions): IContentSegmenter {\n\tif (lineData.isBasicASCII && options.useMonospaceOptimizations) {\n\t\treturn new AsciiContentSegmenter(lineData);\n\t}\n\treturn new GraphemeContentSegmenter(lineData);\n}\n\nclass AsciiContentSegmenter implements IContentSegmenter {\n\tprivate readonly _content: string;\n\n\tconstructor(lineData: ViewLineRenderingData) {\n\t\tthis._content = lineData.content;\n\t}\n\n\tgetSegmentAtIndex(index: number): string {\n\t\treturn this._content[index];\n\t}\n}\n\n/**\n * This is a more modern version of {@link GraphemeIterator}, relying on browser APIs instead of a\n * manual table approach.\n */\nclass GraphemeContentSegmenter implements IContentSegmenter {\n\tprivate readonly _segments: (Intl.SegmentData | undefined)[] = [];\n\n\tconstructor(lineData: ViewLineRenderingData) {\n\t\tconst content = lineData.content;\n\t\tconst segmenter = safeIntl.Segmenter(undefined, { granularity: 'grapheme' }).value;\n\t\tconst segmentedContent = Array.from(segmenter.segment(content));\n\t\tlet segmenterIndex = 0;\n\n\t\tfor (let x = 0; x < content.length; x++) {\n\t\t\tconst segment = segmentedContent[segmenterIndex];\n\n\t\t\t// No more segments in the string (eg. an emoji is the last segment)\n\t\t\tif (!segment) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// The segment isn't renderable (eg. the tail end of an emoji)\n\t\t\tif (segment.index !== x) {\n\t\t\t\tthis._segments.push(undefined);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsegmenterIndex++;\n\t\t\tthis._segments.push(segment);\n\t\t}\n\t}\n\n\tgetSegmentAtIndex(index: number): string | undefined {\n\t\treturn this._segments[index]?.segment;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { safeIntl } from '../../../base/common/date.js';\nimport { ViewLineRenderingData } from '../../common/viewModel.js';\nimport { ViewLineOptions } from '../viewParts/viewLines/viewLineOptions.js';\n\nexport interface IContentSegmenter {\n\t/**\n\t * Gets the content segment at an index within the line data's contents. This will be undefined\n\t * when the index should not be rendered, ie. when it's part of an earlier segment like the tail\n\t * end of an emoji, or when the line is not that long.\n\t * @param index The index within the line data's content string.\n\t */\n\tgetSegmentAtIndex(index: number): string | undefined;\n}\n\nexport function createContentSegmenter(lineData: ViewLineRenderingData, options: ViewLineOptions): IContentSegmenter {\n\tif (lineData.isBasicASCII && options.useMonospaceOptimizations) {\n\t\treturn new AsciiContentSegmenter(lineData);\n\t}\n\treturn new GraphemeContentSegmenter(lineData);\n}\n\nclass AsciiContentSegmenter implements IContentSegmenter {\n\tprivate readonly _content: string;\n\n\tconstructor(lineData: ViewLineRenderingData) {\n\t\tthis._content = lineData.content;\n\t}\n\n\tgetSegmentAtIndex(index: number): string {\n\t\treturn this._content[index];\n\t}\n}\n\n/**\n * This is a more modern version of {@link GraphemeIterator}, relying on browser APIs instead of a\n * manual table approach.\n */\nclass GraphemeContentSegmenter implements IContentSegmenter {\n\tprivate readonly _segments: (Intl.SegmentData | undefined)[] = [];\n\n\tconstructor(lineData: ViewLineRenderingData) {\n\t\tconst content = lineData.content;\n\t\tconst segmenter = safeIntl.Segmenter(undefined, { granularity: 'grapheme' }).value;\n\t\tconst segmentedContent = Array.from(segmenter.segment(content));\n\t\tlet segmenterIndex = 0;\n\n\t\tfor (let x = 0; x < content.length; x++) {\n\t\t\tconst segment = segmentedContent[segmenterIndex];\n\n\t\t\t// No more segments in the string (eg. an emoji is the last segment)\n\t\t\tif (!segment) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// The segment isn't renderable (eg. the tail end of an emoji)\n\t\t\tif (segment.index !== x) {\n\t\t\t\tthis._segments.push(undefined);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsegmenterIndex++;\n\t\t\tthis._segments.push(segment);\n\t\t}\n\t}\n\n\tgetSegmentAtIndex(index: number): string | undefined {\n\t\treturn this._segments[index]?.segment;\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,QAAQ,EAAE,MAAM,8BAA8B,CAAC;;AAclD,SAAU,sBAAsB,CAAC,QAA+B,EAAE,OAAwB;IAC/F,IAAI,QAAQ,CAAC,YAAY,IAAI,OAAO,CAAC,yBAAyB,EAAE,CAAC;QAChE,OAAO,IAAI,qBAAqB,CAAC,QAAQ,CAAC,CAAC;IAC5C,CAAC;IACD,OAAO,IAAI,wBAAwB,CAAC,QAAQ,CAAC,CAAC;AAC/C,CAAC;AAED,MAAM,qBAAqB;IAG1B,YAAY,QAA+B,CAAA;QAC1C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC;IAClC,CAAC;IAED,iBAAiB,CAAC,KAAa,EAAA;QAC9B,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;CACD;AAED;;;GAGG,CACH,MAAM,wBAAwB;IAG7B,YAAY,QAA+B,CAAA;QAF1B,IAAA,CAAA,SAAS,GAAqC,EAAE,CAAC;QAGjE,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;QACjC,MAAM,SAAS,GAAG,mLAAQ,CAAC,SAAS,CAAC,SAAS,EAAE;YAAE,WAAW,EAAE,UAAU;QAAA,CAAE,CAAC,CAAC,KAAK,CAAC;QACnF,MAAM,gBAAgB,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;QAChE,IAAI,cAAc,GAAG,CAAC,CAAC;QAEvB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;YACzC,MAAM,OAAO,GAAG,gBAAgB,CAAC,cAAc,CAAC,CAAC;YAEjD,oEAAoE;YACpE,IAAI,CAAC,OAAO,EAAE,CAAC;gBACd,MAAM;YACP,CAAC;YAED,8DAA8D;YAC9D,IAAI,OAAO,CAAC,KAAK,KAAK,CAAC,EAAE,CAAC;gBACzB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC/B,SAAS;YACV,CAAC;YAED,cAAc,EAAE,CAAC;YACjB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC9B,CAAC;IACF,CAAC;IAED,iBAAiB,CAAC,KAAa,EAAA;QAC9B,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC;IACvC,CAAC;CACD","debugId":null}},
    {"offset": {"line": 2298, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/baseRenderStrategy.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/renderStrategy/baseRenderStrategy.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/vs/editor/browser/gpu/renderStrategy/baseRenderStrategy.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ViewEventHandler } from '../../../common/viewEventHandler.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { IGpuRenderStrategy } from '../gpu.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\n\nexport abstract class BaseRenderStrategy extends ViewEventHandler implements IGpuRenderStrategy {\n\n\tget glyphRasterizer() { return this._glyphRasterizer.value; }\n\n\tabstract type: string;\n\tabstract wgsl: string;\n\tabstract bindGroupEntries: GPUBindGroupEntry[];\n\n\tconstructor(\n\t\tprotected readonly _context: ViewContext,\n\t\tprotected readonly _viewGpuContext: ViewGpuContext,\n\t\tprotected readonly _device: GPUDevice,\n\t\tprotected readonly _glyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper();\n\n\t\tthis._context.addEventHandler(this);\n\t}\n\n\tabstract reset(): void;\n\tabstract update(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number;\n\tabstract draw(pass: GPURenderPassEncoder, viewportData: ViewportData): void;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ViewEventHandler } from '../../../common/viewEventHandler.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { IGpuRenderStrategy } from '../gpu.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\n\nexport abstract class BaseRenderStrategy extends ViewEventHandler implements IGpuRenderStrategy {\n\n\tget glyphRasterizer() { return this._glyphRasterizer.value; }\n\n\tabstract type: string;\n\tabstract wgsl: string;\n\tabstract bindGroupEntries: GPUBindGroupEntry[];\n\n\tconstructor(\n\t\tprotected readonly _context: ViewContext,\n\t\tprotected readonly _viewGpuContext: ViewGpuContext,\n\t\tprotected readonly _device: GPUDevice,\n\t\tprotected readonly _glyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper();\n\n\t\tthis._context.addEventHandler(this);\n\t}\n\n\tabstract reset(): void;\n\tabstract update(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number;\n\tabstract draw(pass: GPURenderPassEncoder, viewportData: ViewportData): void;\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,gBAAgB,EAAE,MAAM,qCAAqC,CAAC;;AAQjE,MAAgB,kBAAmB,SAAQ,yMAAgB;IAEhE,IAAI,eAAe,GAAA;QAAK,OAAO,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC;IAAC,CAAC;IAM7D,YACoB,QAAqB,EACrB,eAA+B,EAC/B,OAAkB,EAClB,gBAA4C,CAAA;QAE/D,KAAK,EAAE,CAAC;QALW,IAAA,CAAA,QAAQ,GAAR,QAAQ,CAAa;QACrB,IAAA,CAAA,eAAe,GAAf,eAAe,CAAgB;QAC/B,IAAA,CAAA,OAAO,GAAP,OAAO,CAAW;QAClB,IAAA,CAAA,gBAAgB,GAAhB,gBAAgB,CAA4B;QAI/D,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC;CAKD","debugId":null}},
    {"offset": {"line": 2324, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.wgsl.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.wgsl.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.wgsl.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { TextureAtlas } from '../atlas/textureAtlas.js';\nimport { TextureAtlasPage } from '../atlas/textureAtlasPage.js';\nimport { BindingId } from '../gpu.js';\n\nexport const fullFileRenderStrategyWgsl = /*wgsl*/ `\nstruct GlyphInfo {\n\tposition: vec2f,\n\tsize: vec2f,\n\torigin: vec2f,\n};\n\nstruct Vertex {\n\t@location(0) position: vec2f,\n};\n\nstruct Cell {\n\tposition: vec2f,\n\tunused1: vec2f,\n\tglyphIndex: f32,\n\ttextureIndex: f32\n};\n\nstruct LayoutInfo {\n\tcanvasDims: vec2f,\n\tviewportOffset: vec2f,\n\tviewportDims: vec2f,\n}\n\nstruct ScrollOffset {\n\toffset: vec2f\n}\n\nstruct VSOutput {\n\t@builtin(position) position:   vec4f,\n\t@location(1)       layerIndex: f32,\n\t@location(0)       texcoord:   vec2f,\n};\n\n// Uniforms\n@group(0) @binding(${BindingId.LayoutInfoUniform})       var<uniform>       layoutInfo:      LayoutInfo;\n@group(0) @binding(${BindingId.AtlasDimensionsUniform})  var<uniform>       atlasDims:       vec2f;\n@group(0) @binding(${BindingId.ScrollOffset})            var<uniform>       scrollOffset:    ScrollOffset;\n\n// Storage buffers\n@group(0) @binding(${BindingId.GlyphInfo})               var<storage, read> glyphInfo:       array<array<GlyphInfo, ${TextureAtlasPage.maximumGlyphCount}>, ${TextureAtlas.maximumPageCount}>;\n@group(0) @binding(${BindingId.Cells})                   var<storage, read> cells:           array<Cell>;\n\n@vertex fn vs(\n\tvert: Vertex,\n\t@builtin(instance_index) instanceIndex: u32,\n\t@builtin(vertex_index) vertexIndex : u32\n) -> VSOutput {\n\tlet cell = cells[instanceIndex];\n\tvar glyph = glyphInfo[u32(cell.textureIndex)][u32(cell.glyphIndex)];\n\n\tvar vsOut: VSOutput;\n\t// Multiple vert.position by 2,-2 to get it into clipspace which ranged from -1 to 1\n\tvsOut.position = vec4f(\n\t\t// Make everything relative to top left instead of center\n\t\tvec2f(-1, 1) +\n\t\t((vert.position * vec2f(2, -2)) / layoutInfo.canvasDims) * glyph.size +\n\t\t((cell.position * vec2f(2, -2)) / layoutInfo.canvasDims) +\n\t\t((glyph.origin * vec2f(2, -2)) / layoutInfo.canvasDims) +\n\t\t(((layoutInfo.viewportOffset - scrollOffset.offset * vec2(1, -1)) * 2) / layoutInfo.canvasDims),\n\t\t0.0,\n\t\t1.0\n\t);\n\n\tvsOut.layerIndex = cell.textureIndex;\n\t// Textures are flipped from natural direction on the y-axis, so flip it back\n\tvsOut.texcoord = vert.position;\n\tvsOut.texcoord = (\n\t\t// Glyph offset (0-1)\n\t\t(glyph.position / atlasDims) +\n\t\t// Glyph coordinate (0-1)\n\t\t(vsOut.texcoord * (glyph.size / atlasDims))\n\t);\n\n\treturn vsOut;\n}\n\n@group(0) @binding(${BindingId.TextureSampler}) var ourSampler: sampler;\n@group(0) @binding(${BindingId.Texture})        var ourTexture: texture_2d_array<f32>;\n\n@fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {\n\treturn textureSample(ourTexture, ourSampler, vsOut.texcoord, u32(vsOut.layerIndex));\n}\n`;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { TextureAtlas } from '../atlas/textureAtlas.js';\nimport { TextureAtlasPage } from '../atlas/textureAtlasPage.js';\nimport { BindingId } from '../gpu.js';\n\nexport const fullFileRenderStrategyWgsl = /*wgsl*/ `\nstruct GlyphInfo {\n\tposition: vec2f,\n\tsize: vec2f,\n\torigin: vec2f,\n};\n\nstruct Vertex {\n\t@location(0) position: vec2f,\n};\n\nstruct Cell {\n\tposition: vec2f,\n\tunused1: vec2f,\n\tglyphIndex: f32,\n\ttextureIndex: f32\n};\n\nstruct LayoutInfo {\n\tcanvasDims: vec2f,\n\tviewportOffset: vec2f,\n\tviewportDims: vec2f,\n}\n\nstruct ScrollOffset {\n\toffset: vec2f\n}\n\nstruct VSOutput {\n\t@builtin(position) position:   vec4f,\n\t@location(1)       layerIndex: f32,\n\t@location(0)       texcoord:   vec2f,\n};\n\n// Uniforms\n@group(0) @binding(${BindingId.LayoutInfoUniform})       var<uniform>       layoutInfo:      LayoutInfo;\n@group(0) @binding(${BindingId.AtlasDimensionsUniform})  var<uniform>       atlasDims:       vec2f;\n@group(0) @binding(${BindingId.ScrollOffset})            var<uniform>       scrollOffset:    ScrollOffset;\n\n// Storage buffers\n@group(0) @binding(${BindingId.GlyphInfo})               var<storage, read> glyphInfo:       array<array<GlyphInfo, ${TextureAtlasPage.maximumGlyphCount}>, ${TextureAtlas.maximumPageCount}>;\n@group(0) @binding(${BindingId.Cells})                   var<storage, read> cells:           array<Cell>;\n\n@vertex fn vs(\n\tvert: Vertex,\n\t@builtin(instance_index) instanceIndex: u32,\n\t@builtin(vertex_index) vertexIndex : u32\n) -> VSOutput {\n\tlet cell = cells[instanceIndex];\n\tvar glyph = glyphInfo[u32(cell.textureIndex)][u32(cell.glyphIndex)];\n\n\tvar vsOut: VSOutput;\n\t// Multiple vert.position by 2,-2 to get it into clipspace which ranged from -1 to 1\n\tvsOut.position = vec4f(\n\t\t// Make everything relative to top left instead of center\n\t\tvec2f(-1, 1) +\n\t\t((vert.position * vec2f(2, -2)) / layoutInfo.canvasDims) * glyph.size +\n\t\t((cell.position * vec2f(2, -2)) / layoutInfo.canvasDims) +\n\t\t((glyph.origin * vec2f(2, -2)) / layoutInfo.canvasDims) +\n\t\t(((layoutInfo.viewportOffset - scrollOffset.offset * vec2(1, -1)) * 2) / layoutInfo.canvasDims),\n\t\t0.0,\n\t\t1.0\n\t);\n\n\tvsOut.layerIndex = cell.textureIndex;\n\t// Textures are flipped from natural direction on the y-axis, so flip it back\n\tvsOut.texcoord = vert.position;\n\tvsOut.texcoord = (\n\t\t// Glyph offset (0-1)\n\t\t(glyph.position / atlasDims) +\n\t\t// Glyph coordinate (0-1)\n\t\t(vsOut.texcoord * (glyph.size / atlasDims))\n\t);\n\n\treturn vsOut;\n}\n\n@group(0) @binding(${BindingId.TextureSampler}) var ourSampler: sampler;\n@group(0) @binding(${BindingId.Texture})        var ourTexture: texture_2d_array<f32>;\n\n@fragment fn fs(vsOut: VSOutput) -> @location(0) vec4f {\n\treturn textureSample(ourTexture, ourSampler, vsOut.texcoord, u32(vsOut.layerIndex));\n}\n`;\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AACxD,OAAO,EAAE,gBAAgB,EAAE,MAAM,8BAA8B,CAAC;;;AAGzD,MAAM,0BAA0B,GAAG,MAAA,EAAQ,CAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBAmC9B,EAAA,+BAAA,EAA2B,EAAA;qBAC3B,EAAA,oCAAA,EAAgC,EAAA;qBAChC,EAAA,0BAAA,EAAsB,EAAA;;;qBAGtB,EAAA,uBAAA,EAAmB,EAAA,2EAAA,EAA8E,0NAAgB,CAAC,iBAAiB,CAAA,GAAA,EAAM,kNAAY,CAAC,gBAAgB,CAAA;qBACtK,EAAA,mBAAA,EAAe,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBAoCf,EAAA,4BAAA,EAAwB,EAAA;qBACxB,EAAA,qBAAA,EAAiB,EAAA;;;;;CAKrC,CAAC","debugId":null}},
    {"offset": {"line": 2423, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/viewportRenderStrategy.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/renderStrategy/viewportRenderStrategy.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/vs/editor/browser/gpu/renderStrategy/viewportRenderStrategy.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { IViewLineTokens } from '../../../common/tokens/lineTokens.js';\nimport { type ViewConfigurationChangedEvent, type ViewDecorationsChangedEvent, type ViewLineMappingChangedEvent, type ViewLinesChangedEvent, type ViewLinesDeletedEvent, type ViewLinesInsertedEvent, type ViewScrollChangedEvent, type ViewThemeChangedEvent, type ViewTokensChangedEvent, type ViewZonesChangedEvent } from '../../../common/viewEvents.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { InlineDecoration } from '../../../common/viewModel/inlineDecorations.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { ITextureAtlasPageGlyph } from '../atlas/atlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../contentSegmenter.js';\nimport { BindingId } from '../gpu.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\n\nconst enum Constants {\n\tIndicesPerCell = 6,\n\tCellBindBufferCapacityIncrement = 32,\n\tCellBindBufferInitialCapacity = 63, // Will be rounded up to nearest increment\n}\n\nconst enum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\n/**\n * A render strategy that uploads the content of the entire viewport every frame.\n */\nexport class ViewportRenderStrategy extends BaseRenderStrategy {\n\t/**\n\t * The hard cap for line columns that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedColumns = 2000;\n\n\treadonly type = 'viewport';\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate _cellBindBufferLineCapacity = Constants.CellBindBufferInitialCapacity;\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate _visibleObjectCount: number = 0;\n\n\tprivate _scrollOffsetBindBuffer: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer: Float32Array;\n\tprivate _scrollInitialized: boolean = false;\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{ binding: BindingId.Cells, resource: { buffer: this._cellBindBuffer } },\n\t\t\t{ binding: BindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } }\n\t\t];\n\t}\n\n\tprivate readonly _onDidChangeBindGroupEntries = this._register(new Emitter<void>());\n\treadonly onDidChangeBindGroupEntries = this._onDidChangeBindGroupEntries.event;\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tviewGpuContext: ViewGpuContext,\n\t\tdevice: GPUDevice,\n\t\tglyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper(context, viewGpuContext, device, glyphRasterizer);\n\n\t\tthis._rebuildCellBuffer(this._cellBindBufferLineCapacity);\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\t}\n\n\tprivate _rebuildCellBuffer(lineCount: number) {\n\t\tthis._cellBindBuffer?.destroy();\n\n\t\t// Increase in chunks so resizing a window by hand doesn't keep allocating and throwing away\n\t\tconst lineCountWithIncrement = (Math.floor(lineCount / Constants.CellBindBufferCapacityIncrement) + 1) * Constants.CellBindBufferCapacityIncrement;\n\n\t\tconst bufferSize = lineCountWithIncrement * ViewportRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell * Float32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco full file cell buffer',\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\t\tthis._cellBindBufferLineCapacity = lineCountWithIncrement;\n\n\t\tthis._onDidChangeBindGroupEntries.fire();\n\t}\n\n\t// #region Event handlers\n\n\t// The primary job of these handlers is to:\n\t// 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n\t//    it's _within the viewport_.\n\t// 2. Pass relevant events on to the render function so it can force certain line ranges to be\n\t//    re-rendered even if they're not in the viewport. For example when a view zone is added,\n\t//    there are lines that used to be visible but are no longer, so those ranges must be\n\t//    cleared and uploaded to the GPU.\n\n\tpublic override onConfigurationChanged(e: ViewConfigurationChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onDecorationsChanged(e: ViewDecorationsChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onTokensChanged(e: ViewTokensChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesDeleted(e: ViewLinesDeletedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesInserted(e: ViewLinesInsertedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesChanged(e: ViewLinesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onScrollChanged(e?: ViewScrollChangedEvent): boolean {\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tthis._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n\t\tthis._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\treturn true;\n\t}\n\n\tpublic override onThemeChanged(e: ViewThemeChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLineMappingChanged(e: ViewLineMappingChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onZonesChanged(e: ViewZonesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\treset() {\n\t\tfor (const bufferIndex of [0, 1]) {\n\t\t\t// Zero out buffer and upload to GPU to prevent stale rows from rendering\n\t\t\tconst buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n\t\t\tbuffer.fill(0, 0, buffer.length);\n\t\t\tthis._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n\t\t}\n\t}\n\n\tupdate(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number {\n\t\t// IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n\t\t// loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n\t\t// avoid potential additional blocking time in garbage collector which is a common cause of\n\t\t// dropped frames.\n\n\t\tlet chars = '';\n\t\tlet segment: string | undefined;\n\t\tlet charWidth = 0;\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet absoluteOffsetX = 0;\n\t\tlet absoluteOffsetY = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet decorationStyleSetBold: boolean | undefined;\n\t\tlet decorationStyleSetColor: number | undefined;\n\t\tlet decorationStyleSetOpacity: number | undefined;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet decoration: InlineDecoration;\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tlet contentSegmenter: IContentSegmenter;\n\n\t\tif (!this._scrollInitialized) {\n\t\t\tthis.onScrollChanged();\n\t\t\tthis._scrollInitialized = true;\n\t\t}\n\n\t\t// Zero out cell buffer or rebuild if needed\n\t\tif (this._cellBindBufferLineCapacity < viewportData.endLineNumber - viewportData.startLineNumber + 1) {\n\t\t\tthis._rebuildCellBuffer(viewportData.endLineNumber - viewportData.startLineNumber + 1);\n\t\t}\n\t\tconst cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n\t\tcellBuffer.fill(0);\n\n\t\tconst lineIndexCount = ViewportRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\n\t\tfor (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n\n\t\t\t// Only attempt to render lines that the GPU renderer can handle\n\t\t\tif (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\ttabXOffset = 0;\n\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t\tcharWidth = viewLineOptions.spaceWidth * dpr;\n\t\t\tabsoluteOffsetX = 0;\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// Only render lines that do not exceed maximum columns\n\t\t\t\t\tif (x > ViewportRenderStrategy.maxSupportedColumns) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsegment = contentSegmenter.getSegmentAtIndex(x);\n\t\t\t\t\tif (segment === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchars = segment;\n\n\t\t\t\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\t\t\t\tcharWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorationStyleSetColor = undefined;\n\t\t\t\t\tdecorationStyleSetBold = undefined;\n\t\t\t\t\tdecorationStyleSetOpacity = undefined;\n\n\t\t\t\t\t// Apply supported inline decoration styles to the cell metadata\n\t\t\t\t\tfor (decoration of lineData.inlineDecorations) {\n\t\t\t\t\t\t// This is Range.strictContainsPosition except it works at the cell level,\n\t\t\t\t\t\t// it's also inlined to avoid overhead.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n\t\t\t\t\t\t\t(y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n\t\t\t\t\t\t\t(y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n\t\t\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\t\t\tconst value = rule.styleMap.get(r)?.toString() ?? '';\n\t\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\t\tcase 'color': {\n\t\t\t\t\t\t\t\t\t\t// TODO: This parsing and error handling should move into canRender so fallback\n\t\t\t\t\t\t\t\t\t\t//       to DOM works\n\t\t\t\t\t\t\t\t\t\tconst parsedColor = Color.Format.CSS.parse(value);\n\t\t\t\t\t\t\t\t\t\tif (!parsedColor) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new BugIndicatingError('Invalid color format ' + value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetColor = parsedColor.toNumber32Bit();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'font-weight': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssFontWeight(value);\n\t\t\t\t\t\t\t\t\t\tif (parsedValue >= 400) {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = true;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = false;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'opacity': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssOpacity(value);\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetOpacity = parsedValue;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault: throw new BugIndicatingError('Unexpected inline decoration style');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chars === ' ' || chars === '\\t') {\n\t\t\t\t\t\t// Zero out glyph to ensure it doesn't get rendered\n\t\t\t\t\t\tcellIndex = ((y - 1) * ViewportRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\t\tcellBuffer.fill(0, cellIndex, cellIndex + CellBufferInfo.FloatsPerEntry);\n\t\t\t\t\t\t// Adjust xOffset for tab stops\n\t\t\t\t\t\tif (chars === '\\t') {\n\t\t\t\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n\t\t\t\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\t\t\t\ttabXOffset -= x + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n\t\t\t\t\tglyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n\n\t\t\t\t\tabsoluteOffsetY = Math.round(\n\t\t\t\t\t\t// Top of layout box (includes line height)\n\t\t\t\t\t\tviewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n\n\t\t\t\t\t\t// Delta from top of layout box (includes line height) to top of the inline box (no line height)\n\t\t\t\t\t\tMath.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n\n\t\t\t\t\t\t// Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n\t\t\t\t\t\t// with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n\t\t\t\t\t\t// baseline.\n\t\t\t\t\t\tglyph.fontBoundingBoxAscent\n\t\t\t\t\t);\n\n\t\t\t\t\tcellIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = Math.floor(absoluteOffsetX);\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = absoluteOffsetY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] = glyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] = glyph.pageIndex;\n\n\t\t\t\t\t// Adjust the x pixel offset for the next character\n\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + tokenEndIndex) * Constants.IndicesPerCell;\n\t\t\tfillEndIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\t\t}\n\n\t\tconst visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n\n\t\t// This render strategy always uploads the whole viewport\n\t\tthis._device.queue.writeBuffer(\n\t\t\tthis._cellBindBuffer,\n\t\t\t0,\n\t\t\tcellBuffer.buffer,\n\t\t\t0,\n\t\t\t(viewportData.endLineNumber - viewportData.startLineNumber) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT\n\t\t);\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError('Attempt to draw 0 objects');\n\t\t}\n\t\tpass.draw(quadVertices.length / 2, this._visibleObjectCount);\n\t}\n}\n\nfunction parseCssFontWeight(value: string) {\n\tswitch (value) {\n\t\tcase 'lighter':\n\t\tcase 'normal': return 400;\n\t\tcase 'bolder':\n\t\tcase 'bold': return 700;\n\t}\n\treturn parseInt(value);\n}\n\nfunction parseCssOpacity(value: string): number {\n\tif (value.endsWith('%')) {\n\t\treturn parseFloat(value.substring(0, value.length - 1)) / 100;\n\t}\n\tif (value.match(/^\\d+(?:\\.\\d*)/)) {\n\t\treturn parseFloat(value);\n\t}\n\treturn 1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { IViewLineTokens } from '../../../common/tokens/lineTokens.js';\nimport { type ViewConfigurationChangedEvent, type ViewDecorationsChangedEvent, type ViewLineMappingChangedEvent, type ViewLinesChangedEvent, type ViewLinesDeletedEvent, type ViewLinesInsertedEvent, type ViewScrollChangedEvent, type ViewThemeChangedEvent, type ViewTokensChangedEvent, type ViewZonesChangedEvent } from '../../../common/viewEvents.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { InlineDecoration } from '../../../common/viewModel/inlineDecorations.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { ITextureAtlasPageGlyph } from '../atlas/atlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../contentSegmenter.js';\nimport { BindingId } from '../gpu.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\n\nconst enum Constants {\n\tIndicesPerCell = 6,\n\tCellBindBufferCapacityIncrement = 32,\n\tCellBindBufferInitialCapacity = 63, // Will be rounded up to nearest increment\n}\n\nconst enum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\n/**\n * A render strategy that uploads the content of the entire viewport every frame.\n */\nexport class ViewportRenderStrategy extends BaseRenderStrategy {\n\t/**\n\t * The hard cap for line columns that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedColumns = 2000;\n\n\treadonly type = 'viewport';\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate _cellBindBufferLineCapacity = Constants.CellBindBufferInitialCapacity;\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate _visibleObjectCount: number = 0;\n\n\tprivate _scrollOffsetBindBuffer: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer: Float32Array;\n\tprivate _scrollInitialized: boolean = false;\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{ binding: BindingId.Cells, resource: { buffer: this._cellBindBuffer } },\n\t\t\t{ binding: BindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } }\n\t\t];\n\t}\n\n\tprivate readonly _onDidChangeBindGroupEntries = this._register(new Emitter<void>());\n\treadonly onDidChangeBindGroupEntries = this._onDidChangeBindGroupEntries.event;\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tviewGpuContext: ViewGpuContext,\n\t\tdevice: GPUDevice,\n\t\tglyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper(context, viewGpuContext, device, glyphRasterizer);\n\n\t\tthis._rebuildCellBuffer(this._cellBindBufferLineCapacity);\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\t}\n\n\tprivate _rebuildCellBuffer(lineCount: number) {\n\t\tthis._cellBindBuffer?.destroy();\n\n\t\t// Increase in chunks so resizing a window by hand doesn't keep allocating and throwing away\n\t\tconst lineCountWithIncrement = (Math.floor(lineCount / Constants.CellBindBufferCapacityIncrement) + 1) * Constants.CellBindBufferCapacityIncrement;\n\n\t\tconst bufferSize = lineCountWithIncrement * ViewportRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell * Float32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco full file cell buffer',\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\t\tthis._cellBindBufferLineCapacity = lineCountWithIncrement;\n\n\t\tthis._onDidChangeBindGroupEntries.fire();\n\t}\n\n\t// #region Event handlers\n\n\t// The primary job of these handlers is to:\n\t// 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n\t//    it's _within the viewport_.\n\t// 2. Pass relevant events on to the render function so it can force certain line ranges to be\n\t//    re-rendered even if they're not in the viewport. For example when a view zone is added,\n\t//    there are lines that used to be visible but are no longer, so those ranges must be\n\t//    cleared and uploaded to the GPU.\n\n\tpublic override onConfigurationChanged(e: ViewConfigurationChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onDecorationsChanged(e: ViewDecorationsChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onTokensChanged(e: ViewTokensChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesDeleted(e: ViewLinesDeletedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesInserted(e: ViewLinesInsertedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLinesChanged(e: ViewLinesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onScrollChanged(e?: ViewScrollChangedEvent): boolean {\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tthis._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n\t\tthis._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\treturn true;\n\t}\n\n\tpublic override onThemeChanged(e: ViewThemeChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onLineMappingChanged(e: ViewLineMappingChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\tpublic override onZonesChanged(e: ViewZonesChangedEvent): boolean {\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\treset() {\n\t\tfor (const bufferIndex of [0, 1]) {\n\t\t\t// Zero out buffer and upload to GPU to prevent stale rows from rendering\n\t\t\tconst buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n\t\t\tbuffer.fill(0, 0, buffer.length);\n\t\t\tthis._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n\t\t}\n\t}\n\n\tupdate(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number {\n\t\t// IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n\t\t// loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n\t\t// avoid potential additional blocking time in garbage collector which is a common cause of\n\t\t// dropped frames.\n\n\t\tlet chars = '';\n\t\tlet segment: string | undefined;\n\t\tlet charWidth = 0;\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet absoluteOffsetX = 0;\n\t\tlet absoluteOffsetY = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet decorationStyleSetBold: boolean | undefined;\n\t\tlet decorationStyleSetColor: number | undefined;\n\t\tlet decorationStyleSetOpacity: number | undefined;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet decoration: InlineDecoration;\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tlet contentSegmenter: IContentSegmenter;\n\n\t\tif (!this._scrollInitialized) {\n\t\t\tthis.onScrollChanged();\n\t\t\tthis._scrollInitialized = true;\n\t\t}\n\n\t\t// Zero out cell buffer or rebuild if needed\n\t\tif (this._cellBindBufferLineCapacity < viewportData.endLineNumber - viewportData.startLineNumber + 1) {\n\t\t\tthis._rebuildCellBuffer(viewportData.endLineNumber - viewportData.startLineNumber + 1);\n\t\t}\n\t\tconst cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n\t\tcellBuffer.fill(0);\n\n\t\tconst lineIndexCount = ViewportRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\n\t\tfor (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n\n\t\t\t// Only attempt to render lines that the GPU renderer can handle\n\t\t\tif (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\ttabXOffset = 0;\n\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t\tcharWidth = viewLineOptions.spaceWidth * dpr;\n\t\t\tabsoluteOffsetX = 0;\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// Only render lines that do not exceed maximum columns\n\t\t\t\t\tif (x > ViewportRenderStrategy.maxSupportedColumns) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsegment = contentSegmenter.getSegmentAtIndex(x);\n\t\t\t\t\tif (segment === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchars = segment;\n\n\t\t\t\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\t\t\t\tcharWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorationStyleSetColor = undefined;\n\t\t\t\t\tdecorationStyleSetBold = undefined;\n\t\t\t\t\tdecorationStyleSetOpacity = undefined;\n\n\t\t\t\t\t// Apply supported inline decoration styles to the cell metadata\n\t\t\t\t\tfor (decoration of lineData.inlineDecorations) {\n\t\t\t\t\t\t// This is Range.strictContainsPosition except it works at the cell level,\n\t\t\t\t\t\t// it's also inlined to avoid overhead.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n\t\t\t\t\t\t\t(y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n\t\t\t\t\t\t\t(y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n\t\t\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\t\t\tconst value = rule.styleMap.get(r)?.toString() ?? '';\n\t\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\t\tcase 'color': {\n\t\t\t\t\t\t\t\t\t\t// TODO: This parsing and error handling should move into canRender so fallback\n\t\t\t\t\t\t\t\t\t\t//       to DOM works\n\t\t\t\t\t\t\t\t\t\tconst parsedColor = Color.Format.CSS.parse(value);\n\t\t\t\t\t\t\t\t\t\tif (!parsedColor) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new BugIndicatingError('Invalid color format ' + value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetColor = parsedColor.toNumber32Bit();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'font-weight': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssFontWeight(value);\n\t\t\t\t\t\t\t\t\t\tif (parsedValue >= 400) {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = true;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = false;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'opacity': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssOpacity(value);\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetOpacity = parsedValue;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault: throw new BugIndicatingError('Unexpected inline decoration style');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chars === ' ' || chars === '\\t') {\n\t\t\t\t\t\t// Zero out glyph to ensure it doesn't get rendered\n\t\t\t\t\t\tcellIndex = ((y - 1) * ViewportRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\t\tcellBuffer.fill(0, cellIndex, cellIndex + CellBufferInfo.FloatsPerEntry);\n\t\t\t\t\t\t// Adjust xOffset for tab stops\n\t\t\t\t\t\tif (chars === '\\t') {\n\t\t\t\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n\t\t\t\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\t\t\t\ttabXOffset -= x + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n\t\t\t\t\tglyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n\n\t\t\t\t\tabsoluteOffsetY = Math.round(\n\t\t\t\t\t\t// Top of layout box (includes line height)\n\t\t\t\t\t\tviewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n\n\t\t\t\t\t\t// Delta from top of layout box (includes line height) to top of the inline box (no line height)\n\t\t\t\t\t\tMath.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n\n\t\t\t\t\t\t// Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n\t\t\t\t\t\t// with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n\t\t\t\t\t\t// baseline.\n\t\t\t\t\t\tglyph.fontBoundingBoxAscent\n\t\t\t\t\t);\n\n\t\t\t\t\tcellIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = Math.floor(absoluteOffsetX);\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = absoluteOffsetY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] = glyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] = glyph.pageIndex;\n\n\t\t\t\t\t// Adjust the x pixel offset for the next character\n\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns + tokenEndIndex) * Constants.IndicesPerCell;\n\t\t\tfillEndIndex = ((y - viewportData.startLineNumber) * ViewportRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\t\t}\n\n\t\tconst visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n\n\t\t// This render strategy always uploads the whole viewport\n\t\tthis._device.queue.writeBuffer(\n\t\t\tthis._cellBindBuffer,\n\t\t\t0,\n\t\t\tcellBuffer.buffer,\n\t\t\t0,\n\t\t\t(viewportData.endLineNumber - viewportData.startLineNumber) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT\n\t\t);\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError('Attempt to draw 0 objects');\n\t\t}\n\t\tpass.draw(quadVertices.length / 2, this._visibleObjectCount);\n\t}\n}\n\nfunction parseCssFontWeight(value: string) {\n\tswitch (value) {\n\t\tcase 'lighter':\n\t\tcase 'normal': return 400;\n\t\tcase 'bolder':\n\t\tcase 'bold': return 700;\n\t}\n\treturn parseInt(value);\n}\n\nfunction parseCssOpacity(value: string): number {\n\tif (value.endsWith('%')) {\n\t\treturn parseFloat(value.substring(0, value.length - 1)) / 100;\n\t}\n\tif (value.match(/^\\d+(?:\\.\\d*)/)) {\n\t\treturn parseFloat(value);\n\t}\n\treturn 1;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2763, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/browser/gpu/renderStrategy/vs/editor/browser/gpu/renderStrategy/fullFileRenderStrategy.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { IViewLineTokens } from '../../../common/tokens/lineTokens.js';\nimport { ViewEventType, type ViewConfigurationChangedEvent, type ViewDecorationsChangedEvent, type ViewLineMappingChangedEvent, type ViewLinesChangedEvent, type ViewLinesDeletedEvent, type ViewLinesInsertedEvent, type ViewScrollChangedEvent, type ViewThemeChangedEvent, type ViewTokensChangedEvent, type ViewZonesChangedEvent } from '../../../common/viewEvents.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { ITextureAtlasPageGlyph } from '../atlas/atlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../contentSegmenter.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\nimport { BindingId } from '../gpu.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\nimport { InlineDecoration } from '../../../common/viewModel/inlineDecorations.js';\n\nconst enum Constants {\n\tIndicesPerCell = 6,\n}\n\nconst enum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\ntype QueuedBufferEvent = (\n\tViewConfigurationChangedEvent |\n\tViewLineMappingChangedEvent |\n\tViewLinesDeletedEvent |\n\tViewZonesChangedEvent\n);\n\n/**\n * A render strategy that tracks a large buffer, uploading only dirty lines as they change and\n * leveraging heavy caching. This is the most performant strategy but has limitations around long\n * lines and too many lines.\n */\nexport class FullFileRenderStrategy extends BaseRenderStrategy {\n\n\t/**\n\t * The hard cap for line count that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedLines = 3000;\n\n\t/**\n\t * The hard cap for line columns that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedColumns = 200;\n\n\treadonly type = 'fullfile';\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate readonly _upToDateLines: [Set<number>, Set<number>] = [new Set(), new Set()];\n\tprivate _visibleObjectCount: number = 0;\n\tprivate _finalRenderedLine: number = 0;\n\n\tprivate _scrollOffsetBindBuffer: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer: Float32Array;\n\tprivate _scrollInitialized: boolean = false;\n\n\tprivate readonly _queuedBufferUpdates: [QueuedBufferEvent[], QueuedBufferEvent[]] = [[], []];\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{ binding: BindingId.Cells, resource: { buffer: this._cellBindBuffer } },\n\t\t\t{ binding: BindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } }\n\t\t];\n\t}\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tviewGpuContext: ViewGpuContext,\n\t\tdevice: GPUDevice,\n\t\tglyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper(context, viewGpuContext, device, glyphRasterizer);\n\n\t\tconst bufferSize = FullFileRenderStrategy.maxSupportedLines * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell * Float32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco full file cell buffer',\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\t}\n\n\t// #region Event handlers\n\n\t// The primary job of these handlers is to:\n\t// 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n\t//    it's _within the viewport_.\n\t// 2. Pass relevant events on to the render function so it can force certain line ranges to be\n\t//    re-rendered even if they're not in the viewport. For example when a view zone is added,\n\t//    there are lines that used to be visible but are no longer, so those ranges must be\n\t//    cleared and uploaded to the GPU.\n\n\tpublic override onConfigurationChanged(e: ViewConfigurationChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onDecorationsChanged(e: ViewDecorationsChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\treturn true;\n\t}\n\n\tpublic override onTokensChanged(e: ViewTokensChangedEvent): boolean {\n\t\t// TODO: This currently fires for the entire viewport whenever scrolling stops\n\t\t//       https://github.com/microsoft/vscode/issues/233942\n\t\tfor (const range of e.ranges) {\n\t\t\tthis._invalidateLineRange(range.fromLineNumber, range.toLineNumber);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic override onLinesDeleted(e: ViewLinesDeletedEvent): boolean {\n\t\t// TODO: This currently invalidates everything after the deleted line, it could shift the\n\t\t//       line data up to retain some up to date lines\n\t\t// TODO: This does not invalidate lines that are no longer in the file\n\t\tthis._invalidateLinesFrom(e.fromLineNumber);\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onLinesInserted(e: ViewLinesInsertedEvent): boolean {\n\t\t// TODO: This currently invalidates everything after the deleted line, it could shift the\n\t\t//       line data up to retain some up to date lines\n\t\tthis._invalidateLinesFrom(e.fromLineNumber);\n\t\treturn true;\n\t}\n\n\tpublic override onLinesChanged(e: ViewLinesChangedEvent): boolean {\n\t\tthis._invalidateLineRange(e.fromLineNumber, e.fromLineNumber + e.count);\n\t\treturn true;\n\t}\n\n\tpublic override onScrollChanged(e?: ViewScrollChangedEvent): boolean {\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tthis._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n\t\tthis._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\treturn true;\n\t}\n\n\tpublic override onThemeChanged(e: ViewThemeChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\treturn true;\n\t}\n\n\tpublic override onLineMappingChanged(e: ViewLineMappingChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onZonesChanged(e: ViewZonesChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\tprivate _invalidateAllLines(): void {\n\t\tthis._upToDateLines[0].clear();\n\t\tthis._upToDateLines[1].clear();\n\t}\n\n\tprivate _invalidateLinesFrom(lineNumber: number): void {\n\t\tfor (const i of [0, 1]) {\n\t\t\tconst upToDateLines = this._upToDateLines[i];\n\t\t\tfor (const upToDateLine of upToDateLines) {\n\t\t\t\tif (upToDateLine >= lineNumber) {\n\t\t\t\t\tupToDateLines.delete(upToDateLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _invalidateLineRange(fromLineNumber: number, toLineNumber: number): void {\n\t\tfor (let i = fromLineNumber; i <= toLineNumber; i++) {\n\t\t\tthis._upToDateLines[0].delete(i);\n\t\t\tthis._upToDateLines[1].delete(i);\n\t\t}\n\t}\n\n\treset() {\n\t\tthis._invalidateAllLines();\n\t\tfor (const bufferIndex of [0, 1]) {\n\t\t\t// Zero out buffer and upload to GPU to prevent stale rows from rendering\n\t\t\tconst buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n\t\t\tbuffer.fill(0, 0, buffer.length);\n\t\t\tthis._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n\t\t}\n\t\tthis._finalRenderedLine = 0;\n\t}\n\n\tupdate(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number {\n\t\t// IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n\t\t// loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n\t\t// avoid potential additional blocking time in garbage collector which is a common cause of\n\t\t// dropped frames.\n\n\t\tlet chars = '';\n\t\tlet segment: string | undefined;\n\t\tlet charWidth = 0;\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet absoluteOffsetX = 0;\n\t\tlet absoluteOffsetY = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet decorationStyleSetBold: boolean | undefined;\n\t\tlet decorationStyleSetColor: number | undefined;\n\t\tlet decorationStyleSetOpacity: number | undefined;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet decoration: InlineDecoration;\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tlet contentSegmenter: IContentSegmenter;\n\n\t\tif (!this._scrollInitialized) {\n\t\t\tthis.onScrollChanged();\n\t\t\tthis._scrollInitialized = true;\n\t\t}\n\n\t\t// Update cell data\n\t\tconst cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n\t\tconst lineIndexCount = FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\n\t\tconst upToDateLines = this._upToDateLines[this._activeDoubleBufferIndex];\n\t\tlet dirtyLineStart = 3000;\n\t\tlet dirtyLineEnd = 0;\n\n\t\t// Handle any queued buffer updates\n\t\tconst queuedBufferUpdates = this._queuedBufferUpdates[this._activeDoubleBufferIndex];\n\t\twhile (queuedBufferUpdates.length) {\n\t\t\tconst e = queuedBufferUpdates.shift()!;\n\t\t\tswitch (e.type) {\n\t\t\t\t// TODO: Refine these cases so we're not throwing away everything\n\t\t\t\tcase ViewEventType.ViewConfigurationChanged:\n\t\t\t\tcase ViewEventType.ViewLineMappingChanged:\n\t\t\t\tcase ViewEventType.ViewZonesChanged: {\n\t\t\t\t\tcellBuffer.fill(0);\n\n\t\t\t\t\tdirtyLineStart = 1;\n\t\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n\t\t\t\t\tthis._finalRenderedLine = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase ViewEventType.ViewLinesDeleted: {\n\t\t\t\t\t// Shift content below deleted line up\n\t\t\t\t\tconst deletedLineContentStartIndex = (e.fromLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tconst deletedLineContentEndIndex = (e.toLineNumber) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tconst nullContentStartIndex = (this._finalRenderedLine - (e.toLineNumber - e.fromLineNumber + 1)) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer.set(cellBuffer.subarray(deletedLineContentEndIndex), deletedLineContentStartIndex);\n\n\t\t\t\t\t// Zero out content on lines that are no longer valid\n\t\t\t\t\tcellBuffer.fill(0, nullContentStartIndex);\n\n\t\t\t\t\t// Update dirty lines and final rendered line\n\t\t\t\t\tdirtyLineStart = Math.min(dirtyLineStart, e.fromLineNumber);\n\t\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n\t\t\t\t\tthis._finalRenderedLine -= e.toLineNumber - e.fromLineNumber + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n\n\t\t\t// Only attempt to render lines that the GPU renderer can handle\n\t\t\tif (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n\t\t\t\tfillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\t\tfillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Skip updating the line if it's already up to date\n\t\t\tif (upToDateLines.has(y)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\ttabXOffset = 0;\n\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t\tcharWidth = viewLineOptions.spaceWidth * dpr;\n\t\t\tabsoluteOffsetX = 0;\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// Only render lines that do not exceed maximum columns\n\t\t\t\t\tif (x > FullFileRenderStrategy.maxSupportedColumns) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsegment = contentSegmenter.getSegmentAtIndex(x);\n\t\t\t\t\tif (segment === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchars = segment;\n\n\t\t\t\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\t\t\t\tcharWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorationStyleSetColor = undefined;\n\t\t\t\t\tdecorationStyleSetBold = undefined;\n\t\t\t\t\tdecorationStyleSetOpacity = undefined;\n\n\t\t\t\t\t// Apply supported inline decoration styles to the cell metadata\n\t\t\t\t\tfor (decoration of lineData.inlineDecorations) {\n\t\t\t\t\t\t// This is Range.strictContainsPosition except it works at the cell level,\n\t\t\t\t\t\t// it's also inlined to avoid overhead.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n\t\t\t\t\t\t\t(y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n\t\t\t\t\t\t\t(y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n\t\t\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\t\t\tconst value = rule.styleMap.get(r)?.toString() ?? '';\n\t\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\t\tcase 'color': {\n\t\t\t\t\t\t\t\t\t\t// TODO: This parsing and error handling should move into canRender so fallback\n\t\t\t\t\t\t\t\t\t\t//       to DOM works\n\t\t\t\t\t\t\t\t\t\tconst parsedColor = Color.Format.CSS.parse(value);\n\t\t\t\t\t\t\t\t\t\tif (!parsedColor) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new BugIndicatingError('Invalid color format ' + value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetColor = parsedColor.toNumber32Bit();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'font-weight': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssFontWeight(value);\n\t\t\t\t\t\t\t\t\t\tif (parsedValue >= 400) {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = true;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = false;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'opacity': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssOpacity(value);\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetOpacity = parsedValue;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault: throw new BugIndicatingError('Unexpected inline decoration style');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chars === ' ' || chars === '\\t') {\n\t\t\t\t\t\t// Zero out glyph to ensure it doesn't get rendered\n\t\t\t\t\t\tcellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\t\tcellBuffer.fill(0, cellIndex, cellIndex + CellBufferInfo.FloatsPerEntry);\n\t\t\t\t\t\t// Adjust xOffset for tab stops\n\t\t\t\t\t\tif (chars === '\\t') {\n\t\t\t\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n\t\t\t\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\t\t\t\ttabXOffset -= x + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n\t\t\t\t\tglyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n\n\t\t\t\t\tabsoluteOffsetY = Math.round(\n\t\t\t\t\t\t// Top of layout box (includes line height)\n\t\t\t\t\t\tviewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n\n\t\t\t\t\t\t// Delta from top of layout box (includes line height) to top of the inline box (no line height)\n\t\t\t\t\t\tMath.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n\n\t\t\t\t\t\t// Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n\t\t\t\t\t\t// with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n\t\t\t\t\t\t// baseline.\n\t\t\t\t\t\tglyph.fontBoundingBoxAscent\n\t\t\t\t\t);\n\n\t\t\t\t\tcellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = Math.floor(absoluteOffsetX);\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = absoluteOffsetY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] = glyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] = glyph.pageIndex;\n\n\t\t\t\t\t// Adjust the x pixel offset for the next character\n\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + tokenEndIndex) * Constants.IndicesPerCell;\n\t\t\tfillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\tupToDateLines.add(y);\n\t\t}\n\n\t\tconst visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n\n\t\t// Only write when there is changed data\n\t\tdirtyLineStart = Math.min(dirtyLineStart, FullFileRenderStrategy.maxSupportedLines);\n\t\tdirtyLineEnd = Math.min(dirtyLineEnd, FullFileRenderStrategy.maxSupportedLines);\n\t\tif (dirtyLineStart <= dirtyLineEnd) {\n\t\t\t// Write buffer and swap it out to unblock writes\n\t\t\tthis._device.queue.writeBuffer(\n\t\t\t\tthis._cellBindBuffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\tcellBuffer.buffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\t(dirtyLineEnd - dirtyLineStart + 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT\n\t\t\t);\n\t\t}\n\n\t\tthis._finalRenderedLine = Math.max(this._finalRenderedLine, dirtyLineEnd);\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError('Attempt to draw 0 objects');\n\t\t}\n\t\tpass.draw(\n\t\t\tquadVertices.length / 2,\n\t\t\tthis._visibleObjectCount,\n\t\t\tundefined,\n\t\t\t(viewportData.startLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns\n\t\t);\n\t}\n\n\t/**\n\t * Queue updates that need to happen on the active buffer, not just the cache. This will be\n\t * deferred to when the actual cell buffer is changed since the active buffer could be locked by\n\t * the GPU which would block the main thread.\n\t */\n\tprivate _queueBufferUpdate(e: QueuedBufferEvent) {\n\t\tthis._queuedBufferUpdates[0].push(e);\n\t\tthis._queuedBufferUpdates[1].push(e);\n\t}\n}\n\nfunction parseCssFontWeight(value: string) {\n\tswitch (value) {\n\t\tcase 'lighter':\n\t\tcase 'normal': return 400;\n\t\tcase 'bolder':\n\t\tcase 'bold': return 700;\n\t}\n\treturn parseInt(value);\n}\n\nfunction parseCssOpacity(value: string): number {\n\tif (value.endsWith('%')) {\n\t\treturn parseFloat(value.substring(0, value.length - 1)) / 100;\n\t}\n\tif (value.match(/^\\d+(?:\\.\\d*)/)) {\n\t\treturn parseFloat(value);\n\t}\n\treturn 1;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getActiveWindow } from '../../../../base/browser/dom.js';\nimport { Color } from '../../../../base/common/color.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../common/core/cursorColumns.js';\nimport { IViewLineTokens } from '../../../common/tokens/lineTokens.js';\nimport { ViewEventType, type ViewConfigurationChangedEvent, type ViewDecorationsChangedEvent, type ViewLineMappingChangedEvent, type ViewLinesChangedEvent, type ViewLinesDeletedEvent, type ViewLinesInsertedEvent, type ViewScrollChangedEvent, type ViewThemeChangedEvent, type ViewTokensChangedEvent, type ViewZonesChangedEvent } from '../../../common/viewEvents.js';\nimport { ViewportData } from '../../../common/viewLayout/viewLinesViewportData.js';\nimport { ViewLineRenderingData } from '../../../common/viewModel.js';\nimport { ViewContext } from '../../../common/viewModel/viewContext.js';\nimport { ViewLineOptions } from '../../viewParts/viewLines/viewLineOptions.js';\nimport { ITextureAtlasPageGlyph } from '../atlas/atlas.js';\nimport { createContentSegmenter, type IContentSegmenter } from '../contentSegmenter.js';\nimport { fullFileRenderStrategyWgsl } from './fullFileRenderStrategy.wgsl.js';\nimport { BindingId } from '../gpu.js';\nimport { GPULifecycle } from '../gpuDisposable.js';\nimport { quadVertices } from '../gpuUtils.js';\nimport { GlyphRasterizer } from '../raster/glyphRasterizer.js';\nimport { ViewGpuContext } from '../viewGpuContext.js';\nimport { BaseRenderStrategy } from './baseRenderStrategy.js';\nimport { InlineDecoration } from '../../../common/viewModel/inlineDecorations.js';\n\nconst enum Constants {\n\tIndicesPerCell = 6,\n}\n\nconst enum CellBufferInfo {\n\tFloatsPerEntry = 6,\n\tBytesPerEntry = CellBufferInfo.FloatsPerEntry * 4,\n\tOffset_X = 0,\n\tOffset_Y = 1,\n\tOffset_Unused1 = 2,\n\tOffset_Unused2 = 3,\n\tGlyphIndex = 4,\n\tTextureIndex = 5,\n}\n\ntype QueuedBufferEvent = (\n\tViewConfigurationChangedEvent |\n\tViewLineMappingChangedEvent |\n\tViewLinesDeletedEvent |\n\tViewZonesChangedEvent\n);\n\n/**\n * A render strategy that tracks a large buffer, uploading only dirty lines as they change and\n * leveraging heavy caching. This is the most performant strategy but has limitations around long\n * lines and too many lines.\n */\nexport class FullFileRenderStrategy extends BaseRenderStrategy {\n\n\t/**\n\t * The hard cap for line count that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedLines = 3000;\n\n\t/**\n\t * The hard cap for line columns that can be rendered by the GPU renderer.\n\t */\n\tstatic readonly maxSupportedColumns = 200;\n\n\treadonly type = 'fullfile';\n\treadonly wgsl: string = fullFileRenderStrategyWgsl;\n\n\tprivate _cellBindBuffer!: GPUBuffer;\n\n\t/**\n\t * The cell value buffers, these hold the cells and their glyphs. It's double buffers such that\n\t * the thread doesn't block when one is being uploaded to the GPU.\n\t */\n\tprivate _cellValueBuffers!: [ArrayBuffer, ArrayBuffer];\n\tprivate _activeDoubleBufferIndex: 0 | 1 = 0;\n\n\tprivate readonly _upToDateLines: [Set<number>, Set<number>] = [new Set(), new Set()];\n\tprivate _visibleObjectCount: number = 0;\n\tprivate _finalRenderedLine: number = 0;\n\n\tprivate _scrollOffsetBindBuffer: GPUBuffer;\n\tprivate _scrollOffsetValueBuffer: Float32Array;\n\tprivate _scrollInitialized: boolean = false;\n\n\tprivate readonly _queuedBufferUpdates: [QueuedBufferEvent[], QueuedBufferEvent[]] = [[], []];\n\n\tget bindGroupEntries(): GPUBindGroupEntry[] {\n\t\treturn [\n\t\t\t{ binding: BindingId.Cells, resource: { buffer: this._cellBindBuffer } },\n\t\t\t{ binding: BindingId.ScrollOffset, resource: { buffer: this._scrollOffsetBindBuffer } }\n\t\t];\n\t}\n\n\tconstructor(\n\t\tcontext: ViewContext,\n\t\tviewGpuContext: ViewGpuContext,\n\t\tdevice: GPUDevice,\n\t\tglyphRasterizer: { value: GlyphRasterizer },\n\t) {\n\t\tsuper(context, viewGpuContext, device, glyphRasterizer);\n\n\t\tconst bufferSize = FullFileRenderStrategy.maxSupportedLines * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell * Float32Array.BYTES_PER_ELEMENT;\n\t\tthis._cellBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco full file cell buffer',\n\t\t\tsize: bufferSize,\n\t\t\tusage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._cellValueBuffers = [\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t\tnew ArrayBuffer(bufferSize),\n\t\t];\n\n\t\tconst scrollOffsetBufferSize = 2;\n\t\tthis._scrollOffsetBindBuffer = this._register(GPULifecycle.createBuffer(this._device, {\n\t\t\tlabel: 'Monaco scroll offset buffer',\n\t\t\tsize: scrollOffsetBufferSize * Float32Array.BYTES_PER_ELEMENT,\n\t\t\tusage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n\t\t})).object;\n\t\tthis._scrollOffsetValueBuffer = new Float32Array(scrollOffsetBufferSize);\n\t}\n\n\t// #region Event handlers\n\n\t// The primary job of these handlers is to:\n\t// 1. Invalidate the up to date line cache, which will cause the line to be re-rendered when\n\t//    it's _within the viewport_.\n\t// 2. Pass relevant events on to the render function so it can force certain line ranges to be\n\t//    re-rendered even if they're not in the viewport. For example when a view zone is added,\n\t//    there are lines that used to be visible but are no longer, so those ranges must be\n\t//    cleared and uploaded to the GPU.\n\n\tpublic override onConfigurationChanged(e: ViewConfigurationChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onDecorationsChanged(e: ViewDecorationsChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\treturn true;\n\t}\n\n\tpublic override onTokensChanged(e: ViewTokensChangedEvent): boolean {\n\t\t// TODO: This currently fires for the entire viewport whenever scrolling stops\n\t\t//       https://github.com/microsoft/vscode/issues/233942\n\t\tfor (const range of e.ranges) {\n\t\t\tthis._invalidateLineRange(range.fromLineNumber, range.toLineNumber);\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic override onLinesDeleted(e: ViewLinesDeletedEvent): boolean {\n\t\t// TODO: This currently invalidates everything after the deleted line, it could shift the\n\t\t//       line data up to retain some up to date lines\n\t\t// TODO: This does not invalidate lines that are no longer in the file\n\t\tthis._invalidateLinesFrom(e.fromLineNumber);\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onLinesInserted(e: ViewLinesInsertedEvent): boolean {\n\t\t// TODO: This currently invalidates everything after the deleted line, it could shift the\n\t\t//       line data up to retain some up to date lines\n\t\tthis._invalidateLinesFrom(e.fromLineNumber);\n\t\treturn true;\n\t}\n\n\tpublic override onLinesChanged(e: ViewLinesChangedEvent): boolean {\n\t\tthis._invalidateLineRange(e.fromLineNumber, e.fromLineNumber + e.count);\n\t\treturn true;\n\t}\n\n\tpublic override onScrollChanged(e?: ViewScrollChangedEvent): boolean {\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tthis._scrollOffsetValueBuffer[0] = (e?.scrollLeft ?? this._context.viewLayout.getCurrentScrollLeft()) * dpr;\n\t\tthis._scrollOffsetValueBuffer[1] = (e?.scrollTop ?? this._context.viewLayout.getCurrentScrollTop()) * dpr;\n\t\tthis._device.queue.writeBuffer(this._scrollOffsetBindBuffer, 0, this._scrollOffsetValueBuffer as Float32Array<ArrayBuffer>);\n\t\treturn true;\n\t}\n\n\tpublic override onThemeChanged(e: ViewThemeChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\treturn true;\n\t}\n\n\tpublic override onLineMappingChanged(e: ViewLineMappingChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\t\treturn true;\n\t}\n\n\tpublic override onZonesChanged(e: ViewZonesChangedEvent): boolean {\n\t\tthis._invalidateAllLines();\n\t\tthis._queueBufferUpdate(e);\n\n\t\treturn true;\n\t}\n\n\t// #endregion\n\n\tprivate _invalidateAllLines(): void {\n\t\tthis._upToDateLines[0].clear();\n\t\tthis._upToDateLines[1].clear();\n\t}\n\n\tprivate _invalidateLinesFrom(lineNumber: number): void {\n\t\tfor (const i of [0, 1]) {\n\t\t\tconst upToDateLines = this._upToDateLines[i];\n\t\t\tfor (const upToDateLine of upToDateLines) {\n\t\t\t\tif (upToDateLine >= lineNumber) {\n\t\t\t\t\tupToDateLines.delete(upToDateLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _invalidateLineRange(fromLineNumber: number, toLineNumber: number): void {\n\t\tfor (let i = fromLineNumber; i <= toLineNumber; i++) {\n\t\t\tthis._upToDateLines[0].delete(i);\n\t\t\tthis._upToDateLines[1].delete(i);\n\t\t}\n\t}\n\n\treset() {\n\t\tthis._invalidateAllLines();\n\t\tfor (const bufferIndex of [0, 1]) {\n\t\t\t// Zero out buffer and upload to GPU to prevent stale rows from rendering\n\t\t\tconst buffer = new Float32Array(this._cellValueBuffers[bufferIndex]);\n\t\t\tbuffer.fill(0, 0, buffer.length);\n\t\t\tthis._device.queue.writeBuffer(this._cellBindBuffer, 0, buffer.buffer, 0, buffer.byteLength);\n\t\t}\n\t\tthis._finalRenderedLine = 0;\n\t}\n\n\tupdate(viewportData: ViewportData, viewLineOptions: ViewLineOptions): number {\n\t\t// IMPORTANT: This is a hot function. Variables are pre-allocated and shared within the\n\t\t// loop. This is done so we don't need to trust the JIT compiler to do this optimization to\n\t\t// avoid potential additional blocking time in garbage collector which is a common cause of\n\t\t// dropped frames.\n\n\t\tlet chars = '';\n\t\tlet segment: string | undefined;\n\t\tlet charWidth = 0;\n\t\tlet y = 0;\n\t\tlet x = 0;\n\t\tlet absoluteOffsetX = 0;\n\t\tlet absoluteOffsetY = 0;\n\t\tlet tabXOffset = 0;\n\t\tlet glyph: Readonly<ITextureAtlasPageGlyph>;\n\t\tlet cellIndex = 0;\n\n\t\tlet tokenStartIndex = 0;\n\t\tlet tokenEndIndex = 0;\n\t\tlet tokenMetadata = 0;\n\n\t\tlet decorationStyleSetBold: boolean | undefined;\n\t\tlet decorationStyleSetColor: number | undefined;\n\t\tlet decorationStyleSetOpacity: number | undefined;\n\n\t\tlet lineData: ViewLineRenderingData;\n\t\tlet decoration: InlineDecoration;\n\t\tlet fillStartIndex = 0;\n\t\tlet fillEndIndex = 0;\n\n\t\tlet tokens: IViewLineTokens;\n\n\t\tconst dpr = getActiveWindow().devicePixelRatio;\n\t\tlet contentSegmenter: IContentSegmenter;\n\n\t\tif (!this._scrollInitialized) {\n\t\t\tthis.onScrollChanged();\n\t\t\tthis._scrollInitialized = true;\n\t\t}\n\n\t\t// Update cell data\n\t\tconst cellBuffer = new Float32Array(this._cellValueBuffers[this._activeDoubleBufferIndex]);\n\t\tconst lineIndexCount = FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\n\t\tconst upToDateLines = this._upToDateLines[this._activeDoubleBufferIndex];\n\t\tlet dirtyLineStart = 3000;\n\t\tlet dirtyLineEnd = 0;\n\n\t\t// Handle any queued buffer updates\n\t\tconst queuedBufferUpdates = this._queuedBufferUpdates[this._activeDoubleBufferIndex];\n\t\twhile (queuedBufferUpdates.length) {\n\t\t\tconst e = queuedBufferUpdates.shift()!;\n\t\t\tswitch (e.type) {\n\t\t\t\t// TODO: Refine these cases so we're not throwing away everything\n\t\t\t\tcase ViewEventType.ViewConfigurationChanged:\n\t\t\t\tcase ViewEventType.ViewLineMappingChanged:\n\t\t\t\tcase ViewEventType.ViewZonesChanged: {\n\t\t\t\t\tcellBuffer.fill(0);\n\n\t\t\t\t\tdirtyLineStart = 1;\n\t\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n\t\t\t\t\tthis._finalRenderedLine = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase ViewEventType.ViewLinesDeleted: {\n\t\t\t\t\t// Shift content below deleted line up\n\t\t\t\t\tconst deletedLineContentStartIndex = (e.fromLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tconst deletedLineContentEndIndex = (e.toLineNumber) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tconst nullContentStartIndex = (this._finalRenderedLine - (e.toLineNumber - e.fromLineNumber + 1)) * FullFileRenderStrategy.maxSupportedColumns * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer.set(cellBuffer.subarray(deletedLineContentEndIndex), deletedLineContentStartIndex);\n\n\t\t\t\t\t// Zero out content on lines that are no longer valid\n\t\t\t\t\tcellBuffer.fill(0, nullContentStartIndex);\n\n\t\t\t\t\t// Update dirty lines and final rendered line\n\t\t\t\t\tdirtyLineStart = Math.min(dirtyLineStart, e.fromLineNumber);\n\t\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, this._finalRenderedLine);\n\t\t\t\t\tthis._finalRenderedLine -= e.toLineNumber - e.fromLineNumber + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (y = viewportData.startLineNumber; y <= viewportData.endLineNumber; y++) {\n\n\t\t\t// Only attempt to render lines that the GPU renderer can handle\n\t\t\tif (!this._viewGpuContext.canRender(viewLineOptions, viewportData, y)) {\n\t\t\t\tfillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\t\tfillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Skip updating the line if it's already up to date\n\t\t\tif (upToDateLines.has(y)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdirtyLineStart = Math.min(dirtyLineStart, y);\n\t\t\tdirtyLineEnd = Math.max(dirtyLineEnd, y);\n\n\t\t\tlineData = viewportData.getViewLineRenderingData(y);\n\t\t\ttabXOffset = 0;\n\n\t\t\tcontentSegmenter = createContentSegmenter(lineData, viewLineOptions);\n\t\t\tcharWidth = viewLineOptions.spaceWidth * dpr;\n\t\t\tabsoluteOffsetX = 0;\n\n\t\t\ttokens = lineData.tokens;\n\t\t\ttokenStartIndex = lineData.minColumn - 1;\n\t\t\ttokenEndIndex = 0;\n\t\t\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\t\t\ttokenEndIndex = tokens.getEndOffset(tokenIndex);\n\t\t\t\tif (tokenEndIndex <= tokenStartIndex) {\n\t\t\t\t\t// The faux indent part of the line should have no token type\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttokenMetadata = tokens.getMetadata(tokenIndex);\n\n\t\t\t\tfor (x = tokenStartIndex; x < tokenEndIndex; x++) {\n\t\t\t\t\t// Only render lines that do not exceed maximum columns\n\t\t\t\t\tif (x > FullFileRenderStrategy.maxSupportedColumns) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsegment = contentSegmenter.getSegmentAtIndex(x);\n\t\t\t\t\tif (segment === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tchars = segment;\n\n\t\t\t\t\tif (!(lineData.isBasicASCII && viewLineOptions.useMonospaceOptimizations)) {\n\t\t\t\t\t\tcharWidth = this.glyphRasterizer.getTextMetrics(chars).width;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorationStyleSetColor = undefined;\n\t\t\t\t\tdecorationStyleSetBold = undefined;\n\t\t\t\t\tdecorationStyleSetOpacity = undefined;\n\n\t\t\t\t\t// Apply supported inline decoration styles to the cell metadata\n\t\t\t\t\tfor (decoration of lineData.inlineDecorations) {\n\t\t\t\t\t\t// This is Range.strictContainsPosition except it works at the cell level,\n\t\t\t\t\t\t// it's also inlined to avoid overhead.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t(y < decoration.range.startLineNumber || y > decoration.range.endLineNumber) ||\n\t\t\t\t\t\t\t(y === decoration.range.startLineNumber && x < decoration.range.startColumn - 1) ||\n\t\t\t\t\t\t\t(y === decoration.range.endLineNumber && x >= decoration.range.endColumn - 1)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rules = ViewGpuContext.decorationCssRuleExtractor.getStyleRules(this._viewGpuContext.canvas.domNode, decoration.inlineClassName);\n\t\t\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\t\t\tfor (const r of rule.style) {\n\t\t\t\t\t\t\t\tconst value = rule.styleMap.get(r)?.toString() ?? '';\n\t\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\t\tcase 'color': {\n\t\t\t\t\t\t\t\t\t\t// TODO: This parsing and error handling should move into canRender so fallback\n\t\t\t\t\t\t\t\t\t\t//       to DOM works\n\t\t\t\t\t\t\t\t\t\tconst parsedColor = Color.Format.CSS.parse(value);\n\t\t\t\t\t\t\t\t\t\tif (!parsedColor) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new BugIndicatingError('Invalid color format ' + value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetColor = parsedColor.toNumber32Bit();\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'font-weight': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssFontWeight(value);\n\t\t\t\t\t\t\t\t\t\tif (parsedValue >= 400) {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = true;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set bold (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdecorationStyleSetBold = false;\n\t\t\t\t\t\t\t\t\t\t\t// TODO: Set normal (https://github.com/microsoft/vscode/issues/237584)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'opacity': {\n\t\t\t\t\t\t\t\t\t\tconst parsedValue = parseCssOpacity(value);\n\t\t\t\t\t\t\t\t\t\tdecorationStyleSetOpacity = parsedValue;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdefault: throw new BugIndicatingError('Unexpected inline decoration style');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chars === ' ' || chars === '\\t') {\n\t\t\t\t\t\t// Zero out glyph to ensure it doesn't get rendered\n\t\t\t\t\t\tcellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\t\tcellBuffer.fill(0, cellIndex, cellIndex + CellBufferInfo.FloatsPerEntry);\n\t\t\t\t\t\t// Adjust xOffset for tab stops\n\t\t\t\t\t\tif (chars === '\\t') {\n\t\t\t\t\t\t\t// Find the pixel offset between the current position and the next tab stop\n\t\t\t\t\t\t\tconst offsetBefore = x + tabXOffset;\n\t\t\t\t\t\t\ttabXOffset = CursorColumns.nextRenderTabStop(x + tabXOffset, lineData.tabSize);\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth * (tabXOffset - offsetBefore);\n\t\t\t\t\t\t\t// Convert back to offset excluding x and the current character\n\t\t\t\t\t\t\ttabXOffset -= x + 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst decorationStyleSetId = ViewGpuContext.decorationStyleCache.getOrCreateEntry(decorationStyleSetColor, decorationStyleSetBold, decorationStyleSetOpacity);\n\t\t\t\t\tglyph = this._viewGpuContext.atlas.getGlyph(this.glyphRasterizer, chars, tokenMetadata, decorationStyleSetId, absoluteOffsetX);\n\n\t\t\t\t\tabsoluteOffsetY = Math.round(\n\t\t\t\t\t\t// Top of layout box (includes line height)\n\t\t\t\t\t\tviewportData.relativeVerticalOffset[y - viewportData.startLineNumber] * dpr +\n\n\t\t\t\t\t\t// Delta from top of layout box (includes line height) to top of the inline box (no line height)\n\t\t\t\t\t\tMath.floor((viewportData.lineHeight * dpr - (glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent)) / 2) +\n\n\t\t\t\t\t\t// Delta from top of inline box (no line height) to top of glyph origin. If the glyph was drawn\n\t\t\t\t\t\t// with a top baseline for example, this ends up drawing the glyph correctly using the alphabetical\n\t\t\t\t\t\t// baseline.\n\t\t\t\t\t\tglyph.fontBoundingBoxAscent\n\t\t\t\t\t);\n\n\t\t\t\t\tcellIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + x) * Constants.IndicesPerCell;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_X] = Math.floor(absoluteOffsetX);\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.Offset_Y] = absoluteOffsetY;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.GlyphIndex] = glyph.glyphIndex;\n\t\t\t\t\tcellBuffer[cellIndex + CellBufferInfo.TextureIndex] = glyph.pageIndex;\n\n\t\t\t\t\t// Adjust the x pixel offset for the next character\n\t\t\t\t\tabsoluteOffsetX += charWidth;\n\t\t\t\t}\n\n\t\t\t\ttokenStartIndex = tokenEndIndex;\n\t\t\t}\n\n\t\t\t// Clear to end of line\n\t\t\tfillStartIndex = ((y - 1) * FullFileRenderStrategy.maxSupportedColumns + tokenEndIndex) * Constants.IndicesPerCell;\n\t\t\tfillEndIndex = (y * FullFileRenderStrategy.maxSupportedColumns) * Constants.IndicesPerCell;\n\t\t\tcellBuffer.fill(0, fillStartIndex, fillEndIndex);\n\n\t\t\tupToDateLines.add(y);\n\t\t}\n\n\t\tconst visibleObjectCount = (viewportData.endLineNumber - viewportData.startLineNumber + 1) * lineIndexCount;\n\n\t\t// Only write when there is changed data\n\t\tdirtyLineStart = Math.min(dirtyLineStart, FullFileRenderStrategy.maxSupportedLines);\n\t\tdirtyLineEnd = Math.min(dirtyLineEnd, FullFileRenderStrategy.maxSupportedLines);\n\t\tif (dirtyLineStart <= dirtyLineEnd) {\n\t\t\t// Write buffer and swap it out to unblock writes\n\t\t\tthis._device.queue.writeBuffer(\n\t\t\t\tthis._cellBindBuffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\tcellBuffer.buffer,\n\t\t\t\t(dirtyLineStart - 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT,\n\t\t\t\t(dirtyLineEnd - dirtyLineStart + 1) * lineIndexCount * Float32Array.BYTES_PER_ELEMENT\n\t\t\t);\n\t\t}\n\n\t\tthis._finalRenderedLine = Math.max(this._finalRenderedLine, dirtyLineEnd);\n\n\t\tthis._activeDoubleBufferIndex = this._activeDoubleBufferIndex ? 0 : 1;\n\n\t\tthis._visibleObjectCount = visibleObjectCount;\n\n\t\treturn visibleObjectCount;\n\t}\n\n\tdraw(pass: GPURenderPassEncoder, viewportData: ViewportData): void {\n\t\tif (this._visibleObjectCount <= 0) {\n\t\t\tthrow new BugIndicatingError('Attempt to draw 0 objects');\n\t\t}\n\t\tpass.draw(\n\t\t\tquadVertices.length / 2,\n\t\t\tthis._visibleObjectCount,\n\t\t\tundefined,\n\t\t\t(viewportData.startLineNumber - 1) * FullFileRenderStrategy.maxSupportedColumns\n\t\t);\n\t}\n\n\t/**\n\t * Queue updates that need to happen on the active buffer, not just the cache. This will be\n\t * deferred to when the actual cell buffer is changed since the active buffer could be locked by\n\t * the GPU which would block the main thread.\n\t */\n\tprivate _queueBufferUpdate(e: QueuedBufferEvent) {\n\t\tthis._queuedBufferUpdates[0].push(e);\n\t\tthis._queuedBufferUpdates[1].push(e);\n\t}\n}\n\nfunction parseCssFontWeight(value: string) {\n\tswitch (value) {\n\t\tcase 'lighter':\n\t\tcase 'normal': return 400;\n\t\tcase 'bolder':\n\t\tcase 'bold': return 700;\n\t}\n\treturn parseInt(value);\n}\n\nfunction parseCssOpacity(value: string): number {\n\tif (value.endsWith('%')) {\n\t\treturn parseFloat(value.substring(0, value.length - 1)) / 100;\n\t}\n\tif (value.match(/^\\d+(?:\\.\\d*)/)) {\n\t\treturn parseFloat(value);\n\t}\n\treturn 1;\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}