{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/viewLayout/lineDecorations.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/vs/editor/common/viewLayout/lineDecorations.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport { Constants } from '../../../base/common/uint.js';\nimport { InlineDecoration, InlineDecorationType } from '../viewModel/inlineDecorations.js';\nimport { LinePartMetadata } from './linePart.js';\n\nexport class LineDecoration {\n\t_lineDecorationBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumn: number,\n\t\tpublic readonly className: string,\n\t\tpublic readonly type: InlineDecorationType\n\t) {\n\t}\n\n\tprivate static _equals(a: LineDecoration, b: LineDecoration): boolean {\n\t\treturn (\n\t\t\ta.startColumn === b.startColumn\n\t\t\t&& a.endColumn === b.endColumn\n\t\t\t&& a.className === b.className\n\t\t\t&& a.type === b.type\n\t\t);\n\t}\n\n\tpublic static equalsArr(a: LineDecoration[], b: LineDecoration[]): boolean {\n\t\tconst aLen = a.length;\n\t\tconst bLen = b.length;\n\t\tif (aLen !== bLen) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < aLen; i++) {\n\t\t\tif (!LineDecoration._equals(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static extractWrapped(arr: LineDecoration[], startOffset: number, endOffset: number): LineDecoration[] {\n\t\tif (arr.length === 0) {\n\t\t\treturn arr;\n\t\t}\n\t\tconst startColumn = startOffset + 1;\n\t\tconst endColumn = endOffset + 1;\n\t\tconst lineLength = endOffset - startOffset;\n\t\tconst r = [];\n\t\tlet rLength = 0;\n\t\tfor (const dec of arr) {\n\t\t\tif (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic static filter(lineDecorations: InlineDecoration[], lineNumber: number, minLineColumn: number, maxLineColumn: number): LineDecoration[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: LineDecoration[] = [];\n\t\tlet resultLen = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tconst d = lineDecorations[i];\n\t\t\tconst range = d.range;\n\n\t\t\tif (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n\t\t\t\t// Ignore decorations that sit outside this line\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (range.isEmpty() && (d.type === InlineDecorationType.Regular || d.type === InlineDecorationType.RegularAffectingLetterSpacing)) {\n\t\t\t\t// Ignore empty range decorations\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n\t\t\tconst endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n\n\t\t\tresult[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _typeCompare(a: InlineDecorationType, b: InlineDecorationType): number {\n\t\tconst ORDER = [2, 0, 1, 3];\n\t\treturn ORDER[a] - ORDER[b];\n\t}\n\n\tpublic static compare(a: LineDecoration, b: LineDecoration): number {\n\t\tif (a.startColumn !== b.startColumn) {\n\t\t\treturn a.startColumn - b.startColumn;\n\t\t}\n\n\t\tif (a.endColumn !== b.endColumn) {\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\n\t\tconst typeCmp = LineDecoration._typeCompare(a.type, b.type);\n\t\tif (typeCmp !== 0) {\n\t\t\treturn typeCmp;\n\t\t}\n\n\t\tif (a.className !== b.className) {\n\t\t\treturn a.className < b.className ? -1 : 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\nexport class DecorationSegment {\n\tstartOffset: number;\n\tendOffset: number;\n\tclassName: string;\n\tmetadata: number;\n\n\tconstructor(startOffset: number, endOffset: number, className: string, metadata: number) {\n\t\tthis.startOffset = startOffset;\n\t\tthis.endOffset = endOffset;\n\t\tthis.className = className;\n\t\tthis.metadata = metadata;\n\t}\n}\n\nclass Stack {\n\tpublic count: number;\n\tprivate readonly stopOffsets: number[];\n\tprivate readonly classNames: string[];\n\tprivate readonly metadata: number[];\n\n\tconstructor() {\n\t\tthis.stopOffsets = [];\n\t\tthis.classNames = [];\n\t\tthis.metadata = [];\n\t\tthis.count = 0;\n\t}\n\n\tprivate static _metadata(metadata: number[]): number {\n\t\tlet result = 0;\n\t\tfor (let i = 0, len = metadata.length; i < len; i++) {\n\t\t\tresult |= metadata[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic consumeLowerThan(maxStopOffset: number, nextStartOffset: number, result: DecorationSegment[]): number {\n\n\t\twhile (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n\t\t\tlet i = 0;\n\n\t\t\t// Take all equal stopping offsets\n\t\t\twhile (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// Basically we are consuming the first i + 1 elements of the stack\n\t\t\tresult.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n\t\t\tnextStartOffset = this.stopOffsets[i] + 1;\n\n\t\t\t// Consume them\n\t\t\tthis.stopOffsets.splice(0, i + 1);\n\t\t\tthis.classNames.splice(0, i + 1);\n\t\t\tthis.metadata.splice(0, i + 1);\n\t\t\tthis.count -= (i + 1);\n\t\t}\n\n\t\tif (this.count > 0 && nextStartOffset < maxStopOffset) {\n\t\t\tresult.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n\t\t\tnextStartOffset = maxStopOffset;\n\t\t}\n\n\t\treturn nextStartOffset;\n\t}\n\n\tpublic insert(stopOffset: number, className: string, metadata: number): void {\n\t\tif (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n\t\t\t// Insert at the end\n\t\t\tthis.stopOffsets.push(stopOffset);\n\t\t\tthis.classNames.push(className);\n\t\t\tthis.metadata.push(metadata);\n\t\t} else {\n\t\t\t// Find the insertion position for `stopOffset`\n\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\tif (this.stopOffsets[i] >= stopOffset) {\n\t\t\t\t\tthis.stopOffsets.splice(i, 0, stopOffset);\n\t\t\t\t\tthis.classNames.splice(i, 0, className);\n\t\t\t\t\tthis.metadata.splice(i, 0, metadata);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.count++;\n\t\treturn;\n\t}\n}\n\nexport class LineDecorationsNormalizer {\n\t/**\n\t * Normalize line decorations. Overlapping decorations will generate multiple segments\n\t */\n\tpublic static normalize(lineContent: string, lineDecorations: LineDecoration[]): DecorationSegment[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: DecorationSegment[] = [];\n\n\t\tconst stack = new Stack();\n\t\tlet nextStartOffset = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tconst d = lineDecorations[i];\n\t\t\tlet startColumn = d.startColumn;\n\t\t\tlet endColumn = d.endColumn;\n\t\t\tconst className = d.className;\n\t\t\tconst metadata = (\n\t\t\t\td.type === InlineDecorationType.Before\n\t\t\t\t\t? LinePartMetadata.PSEUDO_BEFORE\n\t\t\t\t\t: d.type === InlineDecorationType.After\n\t\t\t\t\t\t? LinePartMetadata.PSEUDO_AFTER\n\t\t\t\t\t\t: 0\n\t\t\t);\n\n\t\t\t// If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n\t\t\tif (startColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (endColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tendColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst currentStartOffset = startColumn - 1;\n\t\t\tconst currentEndOffset = endColumn - 2;\n\n\t\t\tnextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n\n\t\t\tif (stack.count === 0) {\n\t\t\t\tnextStartOffset = currentStartOffset;\n\t\t\t}\n\t\t\tstack.insert(currentEndOffset, className, metadata);\n\t\t}\n\n\t\tstack.consumeLowerThan(Constants.MAX_SAFE_SMALL_INTEGER, nextStartOffset, result);\n\n\t\treturn result;\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from '../../../base/common/strings.js';\nimport { Constants } from '../../../base/common/uint.js';\nimport { InlineDecoration, InlineDecorationType } from '../viewModel/inlineDecorations.js';\nimport { LinePartMetadata } from './linePart.js';\n\nexport class LineDecoration {\n\t_lineDecorationBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly startColumn: number,\n\t\tpublic readonly endColumn: number,\n\t\tpublic readonly className: string,\n\t\tpublic readonly type: InlineDecorationType\n\t) {\n\t}\n\n\tprivate static _equals(a: LineDecoration, b: LineDecoration): boolean {\n\t\treturn (\n\t\t\ta.startColumn === b.startColumn\n\t\t\t&& a.endColumn === b.endColumn\n\t\t\t&& a.className === b.className\n\t\t\t&& a.type === b.type\n\t\t);\n\t}\n\n\tpublic static equalsArr(a: LineDecoration[], b: LineDecoration[]): boolean {\n\t\tconst aLen = a.length;\n\t\tconst bLen = b.length;\n\t\tif (aLen !== bLen) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < aLen; i++) {\n\t\t\tif (!LineDecoration._equals(a[i], b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static extractWrapped(arr: LineDecoration[], startOffset: number, endOffset: number): LineDecoration[] {\n\t\tif (arr.length === 0) {\n\t\t\treturn arr;\n\t\t}\n\t\tconst startColumn = startOffset + 1;\n\t\tconst endColumn = endOffset + 1;\n\t\tconst lineLength = endOffset - startOffset;\n\t\tconst r = [];\n\t\tlet rLength = 0;\n\t\tfor (const dec of arr) {\n\t\t\tif (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic static filter(lineDecorations: InlineDecoration[], lineNumber: number, minLineColumn: number, maxLineColumn: number): LineDecoration[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: LineDecoration[] = [];\n\t\tlet resultLen = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tconst d = lineDecorations[i];\n\t\t\tconst range = d.range;\n\n\t\t\tif (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n\t\t\t\t// Ignore decorations that sit outside this line\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (range.isEmpty() && (d.type === InlineDecorationType.Regular || d.type === InlineDecorationType.RegularAffectingLetterSpacing)) {\n\t\t\t\t// Ignore empty range decorations\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n\t\t\tconst endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n\n\t\t\tresult[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _typeCompare(a: InlineDecorationType, b: InlineDecorationType): number {\n\t\tconst ORDER = [2, 0, 1, 3];\n\t\treturn ORDER[a] - ORDER[b];\n\t}\n\n\tpublic static compare(a: LineDecoration, b: LineDecoration): number {\n\t\tif (a.startColumn !== b.startColumn) {\n\t\t\treturn a.startColumn - b.startColumn;\n\t\t}\n\n\t\tif (a.endColumn !== b.endColumn) {\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\n\t\tconst typeCmp = LineDecoration._typeCompare(a.type, b.type);\n\t\tif (typeCmp !== 0) {\n\t\t\treturn typeCmp;\n\t\t}\n\n\t\tif (a.className !== b.className) {\n\t\t\treturn a.className < b.className ? -1 : 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\nexport class DecorationSegment {\n\tstartOffset: number;\n\tendOffset: number;\n\tclassName: string;\n\tmetadata: number;\n\n\tconstructor(startOffset: number, endOffset: number, className: string, metadata: number) {\n\t\tthis.startOffset = startOffset;\n\t\tthis.endOffset = endOffset;\n\t\tthis.className = className;\n\t\tthis.metadata = metadata;\n\t}\n}\n\nclass Stack {\n\tpublic count: number;\n\tprivate readonly stopOffsets: number[];\n\tprivate readonly classNames: string[];\n\tprivate readonly metadata: number[];\n\n\tconstructor() {\n\t\tthis.stopOffsets = [];\n\t\tthis.classNames = [];\n\t\tthis.metadata = [];\n\t\tthis.count = 0;\n\t}\n\n\tprivate static _metadata(metadata: number[]): number {\n\t\tlet result = 0;\n\t\tfor (let i = 0, len = metadata.length; i < len; i++) {\n\t\t\tresult |= metadata[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic consumeLowerThan(maxStopOffset: number, nextStartOffset: number, result: DecorationSegment[]): number {\n\n\t\twhile (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n\t\t\tlet i = 0;\n\n\t\t\t// Take all equal stopping offsets\n\t\t\twhile (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// Basically we are consuming the first i + 1 elements of the stack\n\t\t\tresult.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n\t\t\tnextStartOffset = this.stopOffsets[i] + 1;\n\n\t\t\t// Consume them\n\t\t\tthis.stopOffsets.splice(0, i + 1);\n\t\t\tthis.classNames.splice(0, i + 1);\n\t\t\tthis.metadata.splice(0, i + 1);\n\t\t\tthis.count -= (i + 1);\n\t\t}\n\n\t\tif (this.count > 0 && nextStartOffset < maxStopOffset) {\n\t\t\tresult.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n\t\t\tnextStartOffset = maxStopOffset;\n\t\t}\n\n\t\treturn nextStartOffset;\n\t}\n\n\tpublic insert(stopOffset: number, className: string, metadata: number): void {\n\t\tif (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n\t\t\t// Insert at the end\n\t\t\tthis.stopOffsets.push(stopOffset);\n\t\t\tthis.classNames.push(className);\n\t\t\tthis.metadata.push(metadata);\n\t\t} else {\n\t\t\t// Find the insertion position for `stopOffset`\n\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\tif (this.stopOffsets[i] >= stopOffset) {\n\t\t\t\t\tthis.stopOffsets.splice(i, 0, stopOffset);\n\t\t\t\t\tthis.classNames.splice(i, 0, className);\n\t\t\t\t\tthis.metadata.splice(i, 0, metadata);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.count++;\n\t\treturn;\n\t}\n}\n\nexport class LineDecorationsNormalizer {\n\t/**\n\t * Normalize line decorations. Overlapping decorations will generate multiple segments\n\t */\n\tpublic static normalize(lineContent: string, lineDecorations: LineDecoration[]): DecorationSegment[] {\n\t\tif (lineDecorations.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: DecorationSegment[] = [];\n\n\t\tconst stack = new Stack();\n\t\tlet nextStartOffset = 0;\n\n\t\tfor (let i = 0, len = lineDecorations.length; i < len; i++) {\n\t\t\tconst d = lineDecorations[i];\n\t\t\tlet startColumn = d.startColumn;\n\t\t\tlet endColumn = d.endColumn;\n\t\t\tconst className = d.className;\n\t\t\tconst metadata = (\n\t\t\t\td.type === InlineDecorationType.Before\n\t\t\t\t\t? LinePartMetadata.PSEUDO_BEFORE\n\t\t\t\t\t: d.type === InlineDecorationType.After\n\t\t\t\t\t\t? LinePartMetadata.PSEUDO_AFTER\n\t\t\t\t\t\t: 0\n\t\t\t);\n\n\t\t\t// If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n\t\t\tif (startColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tstartColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (endColumn > 1) {\n\t\t\t\tconst charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n\t\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\t\tendColumn--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst currentStartOffset = startColumn - 1;\n\t\t\tconst currentEndOffset = endColumn - 2;\n\n\t\t\tnextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n\n\t\t\tif (stack.count === 0) {\n\t\t\t\tnextStartOffset = currentStartOffset;\n\t\t\t}\n\t\t\tstack.insert(currentEndOffset, className, metadata);\n\t\t}\n\n\t\tstack.consumeLowerThan(Constants.MAX_SAFE_SMALL_INTEGER, nextStartOffset, result);\n\n\t\treturn result;\n\t}\n\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linePart.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/viewLayout/linePart.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/vs/editor/common/viewLayout/linePart.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum LinePartMetadata {\n\tIS_WHITESPACE = 1,\n\tPSEUDO_BEFORE = 2,\n\tPSEUDO_AFTER = 4,\n\n\tIS_WHITESPACE_MASK = 0b001,\n\tPSEUDO_BEFORE_MASK = 0b010,\n\tPSEUDO_AFTER_MASK = 0b100,\n}\n\nexport class LinePart {\n\t_linePartBrand: void = undefined;\n\n\tconstructor(\n\t\t/**\n\t\t * last char index of this token (not inclusive).\n\t\t */\n\t\tpublic readonly endIndex: number,\n\t\tpublic readonly type: string,\n\t\tpublic readonly metadata: number,\n\t\tpublic readonly containsRTL: boolean\n\t) { }\n\n\tpublic isWhitespace(): boolean {\n\t\treturn (this.metadata & LinePartMetadata.IS_WHITESPACE_MASK ? true : false);\n\t}\n\n\tpublic isPseudoAfter(): boolean {\n\t\treturn (this.metadata & LinePartMetadata.PSEUDO_AFTER_MASK ? true : false);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport const enum LinePartMetadata {\n\tIS_WHITESPACE = 1,\n\tPSEUDO_BEFORE = 2,\n\tPSEUDO_AFTER = 4,\n\n\tIS_WHITESPACE_MASK = 0b001,\n\tPSEUDO_BEFORE_MASK = 0b010,\n\tPSEUDO_AFTER_MASK = 0b100,\n}\n\nexport class LinePart {\n\t_linePartBrand: void = undefined;\n\n\tconstructor(\n\t\t/**\n\t\t * last char index of this token (not inclusive).\n\t\t */\n\t\tpublic readonly endIndex: number,\n\t\tpublic readonly type: string,\n\t\tpublic readonly metadata: number,\n\t\tpublic readonly containsRTL: boolean\n\t) { }\n\n\tpublic isWhitespace(): boolean {\n\t\treturn (this.metadata & LinePartMetadata.IS_WHITESPACE_MASK ? true : false);\n\t}\n\n\tpublic isPseudoAfter(): boolean {\n\t\treturn (this.metadata & LinePartMetadata.PSEUDO_AFTER_MASK ? true : false);\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAY1F,MAAO,QAAQ;IAab,YAAY,GAAA;QAClB,OAAQ,AAAD,IAAK,CAAC,QAAQ,GAAA,EAAA,uCAAA,EAAsC,CAAC,CAAC,EAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IAC7E,CAAC;IAEM,aAAa,GAAA;QACnB,OAAO,AAAC,IAAI,CAAC,QAAQ,GAAA,EAAA,sCAAA,EAAqC,CAAC,CAAC,EAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IAC5E,CAAC;IAhBD,YACC;;OAEG,CACa,QAAgB,EAChB,IAAY,EACZ,QAAgB,EAChB,WAAoB,CAAA;QAHpB,IAAA,CAAA,QAAQ,GAAR,QAAQ,CAAQ;QAChB,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAQ;QACZ,IAAA,CAAA,QAAQ,GAAR,QAAQ,CAAQ;QAChB,IAAA,CAAA,WAAW,GAAX,WAAW,CAAS;QATrC,IAAA,CAAA,cAAc,GAAS,SAAS,CAAC;IAU7B,CAAC;CASL","debugId":null}},
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/vs/editor/common/viewLayout/viewLineRenderer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../../nls.js';\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { IViewLineTokens } from '../tokens/lineTokens.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart, LinePartMetadata } from './linePart.js';\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { InlineDecorationType } from '../viewModel/inlineDecorations.js';\nimport { TextDirection } from '../model.js';\n\nexport const enum RenderWhitespace {\n\tNone = 0,\n\tBoundary = 1,\n\tSelection = 2,\n\tTrailing = 3,\n\tAll = 4\n}\n\nexport class RenderLineInput {\n\n\tpublic readonly useMonospaceOptimizations: boolean;\n\tpublic readonly canUseHalfwidthRightwardsArrow: boolean;\n\tpublic readonly lineContent: string;\n\tpublic readonly continuesWithWrappedLine: boolean;\n\tpublic readonly isBasicASCII: boolean;\n\tpublic readonly containsRTL: boolean;\n\tpublic readonly fauxIndentLength: number;\n\tpublic readonly lineTokens: IViewLineTokens;\n\tpublic readonly lineDecorations: LineDecoration[];\n\tpublic readonly tabSize: number;\n\tpublic readonly startVisibleColumn: number;\n\tpublic readonly spaceWidth: number;\n\tpublic readonly renderSpaceWidth: number;\n\tpublic readonly renderSpaceCharCode: number;\n\tpublic readonly stopRenderingLineAfter: number;\n\tpublic readonly renderWhitespace: RenderWhitespace;\n\tpublic readonly renderControlCharacters: boolean;\n\tpublic readonly fontLigatures: boolean;\n\tpublic readonly textDirection: TextDirection | null;\n\tpublic readonly verticalScrollbarSize: number;\n\n\t/**\n\t * Defined only when renderWhitespace is 'selection'. Selections are non-overlapping,\n\t * and ordered by position within the line.\n\t */\n\tpublic readonly selectionsOnLine: OffsetRange[] | null;\n\t/**\n\t * When rendering an empty line, whether to render a new line instead\n\t */\n\tpublic readonly renderNewLineWhenEmpty: boolean;\n\n\tpublic get isLTR(): boolean {\n\t\treturn !this.containsRTL && this.textDirection !== TextDirection.RTL;\n\t}\n\n\tconstructor(\n\t\tuseMonospaceOptimizations: boolean,\n\t\tcanUseHalfwidthRightwardsArrow: boolean,\n\t\tlineContent: string,\n\t\tcontinuesWithWrappedLine: boolean,\n\t\tisBasicASCII: boolean,\n\t\tcontainsRTL: boolean,\n\t\tfauxIndentLength: number,\n\t\tlineTokens: IViewLineTokens,\n\t\tlineDecorations: LineDecoration[],\n\t\ttabSize: number,\n\t\tstartVisibleColumn: number,\n\t\tspaceWidth: number,\n\t\tmiddotWidth: number,\n\t\twsmiddotWidth: number,\n\t\tstopRenderingLineAfter: number,\n\t\trenderWhitespace: 'none' | 'boundary' | 'selection' | 'trailing' | 'all',\n\t\trenderControlCharacters: boolean,\n\t\tfontLigatures: boolean,\n\t\tselectionsOnLine: OffsetRange[] | null,\n\t\ttextDirection: TextDirection | null,\n\t\tverticalScrollbarSize: number,\n\t\trenderNewLineWhenEmpty: boolean = false,\n\t) {\n\t\tthis.useMonospaceOptimizations = useMonospaceOptimizations;\n\t\tthis.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n\t\tthis.lineContent = lineContent;\n\t\tthis.continuesWithWrappedLine = continuesWithWrappedLine;\n\t\tthis.isBasicASCII = isBasicASCII;\n\t\tthis.containsRTL = containsRTL;\n\t\tthis.fauxIndentLength = fauxIndentLength;\n\t\tthis.lineTokens = lineTokens;\n\t\tthis.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n\t\tthis.tabSize = tabSize;\n\t\tthis.startVisibleColumn = startVisibleColumn;\n\t\tthis.spaceWidth = spaceWidth;\n\t\tthis.stopRenderingLineAfter = stopRenderingLineAfter;\n\t\tthis.renderWhitespace = (\n\t\t\trenderWhitespace === 'all'\n\t\t\t\t? RenderWhitespace.All\n\t\t\t\t: renderWhitespace === 'boundary'\n\t\t\t\t\t? RenderWhitespace.Boundary\n\t\t\t\t\t: renderWhitespace === 'selection'\n\t\t\t\t\t\t? RenderWhitespace.Selection\n\t\t\t\t\t\t: renderWhitespace === 'trailing'\n\t\t\t\t\t\t\t? RenderWhitespace.Trailing\n\t\t\t\t\t\t\t: RenderWhitespace.None\n\t\t);\n\t\tthis.renderControlCharacters = renderControlCharacters;\n\t\tthis.fontLigatures = fontLigatures;\n\t\tthis.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.start < b.start ? -1 : 1);\n\t\tthis.renderNewLineWhenEmpty = renderNewLineWhenEmpty;\n\t\tthis.textDirection = textDirection;\n\t\tthis.verticalScrollbarSize = verticalScrollbarSize;\n\n\t\tconst wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n\t\tconst middotDiff = Math.abs(middotWidth - spaceWidth);\n\t\tif (wsmiddotDiff < middotDiff) {\n\t\t\tthis.renderSpaceWidth = wsmiddotWidth;\n\t\t\tthis.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n\t\t} else {\n\t\t\tthis.renderSpaceWidth = middotWidth;\n\t\t\tthis.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n\t\t}\n\t}\n\n\tprivate sameSelection(otherSelections: OffsetRange[] | null): boolean {\n\t\tif (this.selectionsOnLine === null) {\n\t\t\treturn otherSelections === null;\n\t\t}\n\n\t\tif (otherSelections === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (otherSelections.length !== this.selectionsOnLine.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < this.selectionsOnLine.length; i++) {\n\t\t\tif (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic equals(other: RenderLineInput): boolean {\n\t\treturn (\n\t\t\tthis.useMonospaceOptimizations === other.useMonospaceOptimizations\n\t\t\t&& this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n\t\t\t&& this.lineContent === other.lineContent\n\t\t\t&& this.continuesWithWrappedLine === other.continuesWithWrappedLine\n\t\t\t&& this.isBasicASCII === other.isBasicASCII\n\t\t\t&& this.containsRTL === other.containsRTL\n\t\t\t&& this.fauxIndentLength === other.fauxIndentLength\n\t\t\t&& this.tabSize === other.tabSize\n\t\t\t&& this.startVisibleColumn === other.startVisibleColumn\n\t\t\t&& this.spaceWidth === other.spaceWidth\n\t\t\t&& this.renderSpaceWidth === other.renderSpaceWidth\n\t\t\t&& this.renderSpaceCharCode === other.renderSpaceCharCode\n\t\t\t&& this.stopRenderingLineAfter === other.stopRenderingLineAfter\n\t\t\t&& this.renderWhitespace === other.renderWhitespace\n\t\t\t&& this.renderControlCharacters === other.renderControlCharacters\n\t\t\t&& this.fontLigatures === other.fontLigatures\n\t\t\t&& LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n\t\t\t&& this.lineTokens.equals(other.lineTokens)\n\t\t\t&& this.sameSelection(other.selectionsOnLine)\n\t\t\t&& this.textDirection === other.textDirection\n\t\t\t&& this.verticalScrollbarSize === other.verticalScrollbarSize\n\t\t\t&& this.renderNewLineWhenEmpty === other.renderNewLineWhenEmpty\n\t\t);\n\t}\n}\n\nconst enum CharacterMappingConstants {\n\tPART_INDEX_MASK = 0b11111111111111110000000000000000,\n\tCHAR_INDEX_MASK = 0b00000000000000001111111111111111,\n\n\tCHAR_INDEX_OFFSET = 0,\n\tPART_INDEX_OFFSET = 16\n}\n\nexport class DomPosition {\n\tconstructor(\n\t\tpublic readonly partIndex: number,\n\t\tpublic readonly charIndex: number\n\t) { }\n}\n\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n\n\tprivate static getPartIndex(partData: number): number {\n\t\treturn (partData & CharacterMappingConstants.PART_INDEX_MASK) >>> CharacterMappingConstants.PART_INDEX_OFFSET;\n\t}\n\n\tprivate static getCharIndex(partData: number): number {\n\t\treturn (partData & CharacterMappingConstants.CHAR_INDEX_MASK) >>> CharacterMappingConstants.CHAR_INDEX_OFFSET;\n\t}\n\n\tpublic readonly length: number;\n\tprivate readonly _data: Uint32Array;\n\tprivate readonly _horizontalOffset: Uint32Array;\n\n\tconstructor(length: number, partCount: number) {\n\t\tthis.length = length;\n\t\tthis._data = new Uint32Array(this.length);\n\t\tthis._horizontalOffset = new Uint32Array(this.length);\n\t}\n\n\tpublic setColumnInfo(column: number, partIndex: number, charIndex: number, horizontalOffset: number): void {\n\t\tconst partData = (\n\t\t\t(partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n\t\t\t| (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)\n\t\t) >>> 0;\n\t\tthis._data[column - 1] = partData;\n\t\tthis._horizontalOffset[column - 1] = horizontalOffset;\n\t}\n\n\tpublic getHorizontalOffset(column: number): number {\n\t\tif (this._horizontalOffset.length === 0) {\n\t\t\t// No characters on this line\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._horizontalOffset[column - 1];\n\t}\n\n\tprivate charOffsetToPartData(charOffset: number): number {\n\t\tif (this.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (charOffset < 0) {\n\t\t\treturn this._data[0];\n\t\t}\n\t\tif (charOffset >= this.length) {\n\t\t\treturn this._data[this.length - 1];\n\t\t}\n\t\treturn this._data[charOffset];\n\t}\n\n\tpublic getDomPosition(column: number): DomPosition {\n\t\tconst partData = this.charOffsetToPartData(column - 1);\n\t\tconst partIndex = CharacterMapping.getPartIndex(partData);\n\t\tconst charIndex = CharacterMapping.getCharIndex(partData);\n\t\treturn new DomPosition(partIndex, charIndex);\n\t}\n\n\tpublic getColumn(domPosition: DomPosition, partLength: number): number {\n\t\tconst charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n\t\treturn charOffset + 1;\n\t}\n\n\tprivate partDataToCharOffset(partIndex: number, partLength: number, charIndex: number): number {\n\t\tif (this.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst searchEntry = (\n\t\t\t(partIndex << CharacterMappingConstants.PART_INDEX_OFFSET)\n\t\t\t| (charIndex << CharacterMappingConstants.CHAR_INDEX_OFFSET)\n\t\t) >>> 0;\n\n\t\tlet min = 0;\n\t\tlet max = this.length - 1;\n\t\twhile (min + 1 < max) {\n\t\t\tconst mid = ((min + max) >>> 1);\n\t\t\tconst midEntry = this._data[mid];\n\t\t\tif (midEntry === searchEntry) {\n\t\t\t\treturn mid;\n\t\t\t} else if (midEntry > searchEntry) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid;\n\t\t\t}\n\t\t}\n\n\t\tif (min === max) {\n\t\t\treturn min;\n\t\t}\n\n\t\tconst minEntry = this._data[min];\n\t\tconst maxEntry = this._data[max];\n\n\t\tif (minEntry === searchEntry) {\n\t\t\treturn min;\n\t\t}\n\t\tif (maxEntry === searchEntry) {\n\t\t\treturn max;\n\t\t}\n\n\t\tconst minPartIndex = CharacterMapping.getPartIndex(minEntry);\n\t\tconst minCharIndex = CharacterMapping.getCharIndex(minEntry);\n\n\t\tconst maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n\t\tlet maxCharIndex: number;\n\n\t\tif (minPartIndex !== maxPartIndex) {\n\t\t\t// sitting between parts\n\t\t\tmaxCharIndex = partLength;\n\t\t} else {\n\t\t\tmaxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n\t\t}\n\n\t\tconst minEntryDistance = charIndex - minCharIndex;\n\t\tconst maxEntryDistance = maxCharIndex - charIndex;\n\n\t\tif (minEntryDistance <= maxEntryDistance) {\n\t\t\treturn min;\n\t\t}\n\t\treturn max;\n\t}\n}\n\nexport const enum ForeignElementType {\n\tNone = 0,\n\tBefore = 1,\n\tAfter = 2\n}\n\nexport class RenderLineOutput {\n\t_renderLineOutputBrand: void = undefined;\n\n\treadonly characterMapping: CharacterMapping;\n\treadonly containsForeignElements: ForeignElementType;\n\n\tconstructor(characterMapping: CharacterMapping, containsForeignElements: ForeignElementType) {\n\t\tthis.characterMapping = characterMapping;\n\t\tthis.containsForeignElements = containsForeignElements;\n\t}\n}\n\nexport function renderViewLine(input: RenderLineInput, sb: StringBuilder): RenderLineOutput {\n\tif (input.lineContent.length === 0) {\n\n\t\tif (input.lineDecorations.length > 0) {\n\t\t\t// This line is empty, but it contains inline decorations\n\t\t\tsb.appendString(`<span>`);\n\n\t\t\tlet beforeCount = 0;\n\t\t\tlet afterCount = 0;\n\t\t\tlet containsForeignElements = ForeignElementType.None;\n\t\t\tfor (const lineDecoration of input.lineDecorations) {\n\t\t\t\tif (lineDecoration.type === InlineDecorationType.Before || lineDecoration.type === InlineDecorationType.After) {\n\t\t\t\t\tsb.appendString(`<span class=\"`);\n\t\t\t\t\tsb.appendString(lineDecoration.className);\n\t\t\t\t\tsb.appendString(`\"></span>`);\n\n\t\t\t\t\tif (lineDecoration.type === InlineDecorationType.Before) {\n\t\t\t\t\t\tcontainsForeignElements |= ForeignElementType.Before;\n\t\t\t\t\t\tbeforeCount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (lineDecoration.type === InlineDecorationType.After) {\n\t\t\t\t\t\tcontainsForeignElements |= ForeignElementType.After;\n\t\t\t\t\t\tafterCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsb.appendString(`</span>`);\n\n\t\t\tconst characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n\t\t\tcharacterMapping.setColumnInfo(1, beforeCount, 0, 0);\n\n\t\t\treturn new RenderLineOutput(\n\t\t\t\tcharacterMapping,\n\t\t\t\tcontainsForeignElements\n\t\t\t);\n\t\t}\n\n\t\t// completely empty line\n\t\tif (input.renderNewLineWhenEmpty) {\n\t\t\tsb.appendString('<span><span>\\n</span></span>');\n\t\t} else {\n\t\t\tsb.appendString('<span><span></span></span>');\n\t\t}\n\t\treturn new RenderLineOutput(\n\t\t\tnew CharacterMapping(0, 0),\n\t\t\tForeignElementType.None\n\t\t);\n\t}\n\n\treturn _renderLine(resolveRenderLineInput(input), sb);\n}\n\nexport class RenderLineOutput2 {\n\tconstructor(\n\t\tpublic readonly characterMapping: CharacterMapping,\n\t\tpublic readonly html: string,\n\t\tpublic readonly containsForeignElements: ForeignElementType\n\t) {\n\t}\n}\n\nexport function renderViewLine2(input: RenderLineInput): RenderLineOutput2 {\n\tconst sb = new StringBuilder(10000);\n\tconst out = renderViewLine(input, sb);\n\treturn new RenderLineOutput2(out.characterMapping, sb.build(), out.containsForeignElements);\n}\n\nclass ResolvedRenderLineInput {\n\tconstructor(\n\t\tpublic readonly fontIsMonospace: boolean,\n\t\tpublic readonly canUseHalfwidthRightwardsArrow: boolean,\n\t\tpublic readonly lineContent: string,\n\t\tpublic readonly len: number,\n\t\tpublic readonly isOverflowing: boolean,\n\t\tpublic readonly overflowingCharCount: number,\n\t\tpublic readonly parts: LinePart[],\n\t\tpublic readonly containsForeignElements: ForeignElementType,\n\t\tpublic readonly fauxIndentLength: number,\n\t\tpublic readonly tabSize: number,\n\t\tpublic readonly startVisibleColumn: number,\n\t\tpublic readonly spaceWidth: number,\n\t\tpublic readonly renderSpaceCharCode: number,\n\t\tpublic readonly renderWhitespace: RenderWhitespace,\n\t\tpublic readonly renderControlCharacters: boolean,\n\t) {\n\t\t//\n\t}\n}\n\nfunction resolveRenderLineInput(input: RenderLineInput): ResolvedRenderLineInput {\n\tconst lineContent = input.lineContent;\n\n\tlet isOverflowing: boolean;\n\tlet overflowingCharCount: number;\n\tlet len: number;\n\n\tif (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n\t\tisOverflowing = true;\n\t\toverflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n\t\tlen = input.stopRenderingLineAfter;\n\t} else {\n\t\tisOverflowing = false;\n\t\toverflowingCharCount = 0;\n\t\tlen = lineContent.length;\n\t}\n\n\tlet tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n\tif (input.renderControlCharacters && !input.isBasicASCII) {\n\t\t// Calling `extractControlCharacters` before adding (possibly empty) line parts\n\t\t// for inline decorations. `extractControlCharacters` removes empty line parts.\n\t\ttokens = extractControlCharacters(lineContent, tokens);\n\t}\n\tif (input.renderWhitespace === RenderWhitespace.All ||\n\t\tinput.renderWhitespace === RenderWhitespace.Boundary ||\n\t\t(input.renderWhitespace === RenderWhitespace.Selection && !!input.selectionsOnLine) ||\n\t\t(input.renderWhitespace === RenderWhitespace.Trailing && !input.continuesWithWrappedLine)\n\t) {\n\t\ttokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n\t}\n\tlet containsForeignElements = ForeignElementType.None;\n\tif (input.lineDecorations.length > 0) {\n\t\tfor (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n\t\t\tconst lineDecoration = input.lineDecorations[i];\n\t\t\tif (lineDecoration.type === InlineDecorationType.RegularAffectingLetterSpacing) {\n\t\t\t\t// Pretend there are foreign elements... although not 100% accurate.\n\t\t\t\tcontainsForeignElements |= ForeignElementType.Before;\n\t\t\t} else if (lineDecoration.type === InlineDecorationType.Before) {\n\t\t\t\tcontainsForeignElements |= ForeignElementType.Before;\n\t\t\t} else if (lineDecoration.type === InlineDecorationType.After) {\n\t\t\t\tcontainsForeignElements |= ForeignElementType.After;\n\t\t\t}\n\t\t}\n\t\ttokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n\t}\n\tif (!input.containsRTL) {\n\t\t// We can never split RTL text, as it ruins the rendering\n\t\ttokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n\t}\n\n\treturn new ResolvedRenderLineInput(\n\t\tinput.useMonospaceOptimizations,\n\t\tinput.canUseHalfwidthRightwardsArrow,\n\t\tlineContent,\n\t\tlen,\n\t\tisOverflowing,\n\t\toverflowingCharCount,\n\t\ttokens,\n\t\tcontainsForeignElements,\n\t\tinput.fauxIndentLength,\n\t\tinput.tabSize,\n\t\tinput.startVisibleColumn,\n\t\tinput.spaceWidth,\n\t\tinput.renderSpaceCharCode,\n\t\tinput.renderWhitespace,\n\t\tinput.renderControlCharacters\n\t);\n}\n\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent: string, lineContainsRTL: boolean, tokens: IViewLineTokens, fauxIndentLength: number, len: number): LinePart[] {\n\tconst result: LinePart[] = [];\n\tlet resultLen = 0;\n\n\t// The faux indent part of the line should have no token type\n\tif (fauxIndentLength > 0) {\n\t\tresult[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n\t}\n\tlet startOffset = fauxIndentLength;\n\tfor (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n\t\tconst endIndex = tokens.getEndOffset(tokenIndex);\n\t\tif (endIndex <= fauxIndentLength) {\n\t\t\t// The faux indent part of the line should have no token type\n\t\t\tcontinue;\n\t\t}\n\t\tconst type = tokens.getClassName(tokenIndex);\n\t\tif (endIndex >= len) {\n\t\t\tconst tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false);\n\t\t\tresult[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n\t\t\tbreak;\n\t\t}\n\t\tconst tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n\t\tresult[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n\t\tstartOffset = endIndex;\n\t}\n\n\treturn result;\n}\n\n/**\n * written as a const enum to get value inlining.\n */\nconst enum Constants {\n\tLongToken = 50\n}\n\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent: string, tokens: LinePart[], onlyAtSpaces: boolean): LinePart[] {\n\tlet lastTokenEndIndex = 0;\n\tconst result: LinePart[] = [];\n\tlet resultLen = 0;\n\n\tif (onlyAtSpaces) {\n\t\t// Split only at spaces => we need to walk each character\n\t\tfor (let i = 0, len = tokens.length; i < len; i++) {\n\t\t\tconst token = tokens[i];\n\t\t\tconst tokenEndIndex = token.endIndex;\n\t\t\tif (lastTokenEndIndex + Constants.LongToken < tokenEndIndex) {\n\t\t\t\tconst tokenType = token.type;\n\t\t\t\tconst tokenMetadata = token.metadata;\n\t\t\t\tconst tokenContainsRTL = token.containsRTL;\n\n\t\t\t\tlet lastSpaceOffset = -1;\n\t\t\t\tlet currTokenStart = lastTokenEndIndex;\n\t\t\t\tfor (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n\t\t\t\t\tif (lineContent.charCodeAt(j) === CharCode.Space) {\n\t\t\t\t\t\tlastSpaceOffset = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (lastSpaceOffset !== -1 && j - currTokenStart >= Constants.LongToken) {\n\t\t\t\t\t\t// Split at `lastSpaceOffset` + 1\n\t\t\t\t\t\tresult[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t\t\t\tcurrTokenStart = lastSpaceOffset + 1;\n\t\t\t\t\t\tlastSpaceOffset = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currTokenStart !== tokenEndIndex) {\n\t\t\t\t\tresult[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = token;\n\t\t\t}\n\n\t\t\tlastTokenEndIndex = tokenEndIndex;\n\t\t}\n\t} else {\n\t\t// Split anywhere => we don't need to walk each character\n\t\tfor (let i = 0, len = tokens.length; i < len; i++) {\n\t\t\tconst token = tokens[i];\n\t\t\tconst tokenEndIndex = token.endIndex;\n\t\t\tconst diff = (tokenEndIndex - lastTokenEndIndex);\n\t\t\tif (diff > Constants.LongToken) {\n\t\t\t\tconst tokenType = token.type;\n\t\t\t\tconst tokenMetadata = token.metadata;\n\t\t\t\tconst tokenContainsRTL = token.containsRTL;\n\t\t\t\tconst piecesCount = Math.ceil(diff / Constants.LongToken);\n\t\t\t\tfor (let j = 1; j < piecesCount; j++) {\n\t\t\t\t\tconst pieceEndIndex = lastTokenEndIndex + (j * Constants.LongToken);\n\t\t\t\t\tresult[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t\t}\n\t\t\t\tresult[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t} else {\n\t\t\t\tresult[resultLen++] = token;\n\t\t\t}\n\t\t\tlastTokenEndIndex = tokenEndIndex;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction isControlCharacter(charCode: number): boolean {\n\tif (charCode < 32) {\n\t\treturn (charCode !== CharCode.Tab);\n\t}\n\tif (charCode === 127) {\n\t\t// DEL\n\t\treturn true;\n\t}\n\n\tif (\n\t\t(charCode >= 0x202A && charCode <= 0x202E)\n\t\t|| (charCode >= 0x2066 && charCode <= 0x2069)\n\t\t|| (charCode >= 0x200E && charCode <= 0x200F)\n\t\t|| charCode === 0x061C\n\t) {\n\t\t// Unicode Directional Formatting Characters\n\t\t// LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n\t\t// RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n\t\t// PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n\t\t// LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n\t\t// RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n\t\t// LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n\t\t// RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n\t\t// FSI\tU+2068\tFIRST STRONG ISOLATE\n\t\t// PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n\t\t// LRM\tU+200E\tLEFT-TO-RIGHT MARK\n\t\t// RLM\tU+200F\tRIGHT-TO-LEFT MARK\n\t\t// ALM\tU+061C\tARABIC LETTER MARK\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nfunction extractControlCharacters(lineContent: string, tokens: LinePart[]): LinePart[] {\n\tconst result: LinePart[] = [];\n\tlet lastLinePart: LinePart = new LinePart(0, '', 0, false);\n\tlet charOffset = 0;\n\tfor (const token of tokens) {\n\t\tconst tokenEndIndex = token.endIndex;\n\t\tfor (; charOffset < tokenEndIndex; charOffset++) {\n\t\t\tconst charCode = lineContent.charCodeAt(charOffset);\n\t\t\tif (isControlCharacter(charCode)) {\n\t\t\t\tif (charOffset > lastLinePart.endIndex) {\n\t\t\t\t\t// emit previous part if it has text\n\t\t\t\t\tlastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n\t\t\t\t\tresult.push(lastLinePart);\n\t\t\t\t}\n\t\t\t\tlastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n\t\t\t\tresult.push(lastLinePart);\n\t\t\t}\n\t\t}\n\t\tif (charOffset > lastLinePart.endIndex) {\n\t\t\t// emit previous part if it has text\n\t\t\tlastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n\t\t\tresult.push(lastLinePart);\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input: RenderLineInput, lineContent: string, len: number, tokens: LinePart[]): LinePart[] {\n\n\tconst continuesWithWrappedLine = input.continuesWithWrappedLine;\n\tconst fauxIndentLength = input.fauxIndentLength;\n\tconst tabSize = input.tabSize;\n\tconst startVisibleColumn = input.startVisibleColumn;\n\tconst useMonospaceOptimizations = input.useMonospaceOptimizations;\n\tconst selections = input.selectionsOnLine;\n\tconst onlyBoundary = (input.renderWhitespace === RenderWhitespace.Boundary);\n\tconst onlyTrailing = (input.renderWhitespace === RenderWhitespace.Trailing);\n\tconst generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n\n\tconst result: LinePart[] = [];\n\tlet resultLen = 0;\n\tlet tokenIndex = 0;\n\tlet tokenType = tokens[tokenIndex].type;\n\tlet tokenContainsRTL = tokens[tokenIndex].containsRTL;\n\tlet tokenEndIndex = tokens[tokenIndex].endIndex;\n\tconst tokensLength = tokens.length;\n\n\tlet lineIsEmptyOrWhitespace = false;\n\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\tlet lastNonWhitespaceIndex: number;\n\tif (firstNonWhitespaceIndex === -1) {\n\t\tlineIsEmptyOrWhitespace = true;\n\t\tfirstNonWhitespaceIndex = len;\n\t\tlastNonWhitespaceIndex = len;\n\t} else {\n\t\tlastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n\t}\n\n\tlet wasInWhitespace = false;\n\tlet currentSelectionIndex = 0;\n\tlet currentSelection = selections && selections[currentSelectionIndex];\n\tlet tmpIndent = startVisibleColumn % tabSize;\n\tfor (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n\t\tconst chCode = lineContent.charCodeAt(charIndex);\n\n\t\tif (currentSelection && currentSelection.endExclusive <= charIndex) {\n\t\t\tcurrentSelectionIndex++;\n\t\t\tcurrentSelection = selections && selections[currentSelectionIndex];\n\t\t}\n\n\t\tlet isInWhitespace: boolean;\n\t\tif (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n\t\t\t// in leading or trailing whitespace\n\t\t\tisInWhitespace = true;\n\t\t} else if (chCode === CharCode.Tab) {\n\t\t\t// a tab character is rendered both in all and boundary cases\n\t\t\tisInWhitespace = true;\n\t\t} else if (chCode === CharCode.Space) {\n\t\t\t// hit a space character\n\t\t\tif (onlyBoundary) {\n\t\t\t\t// rendering only boundary whitespace\n\t\t\t\tif (wasInWhitespace) {\n\t\t\t\t\tisInWhitespace = true;\n\t\t\t\t} else {\n\t\t\t\t\tconst nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : CharCode.Null);\n\t\t\t\t\tisInWhitespace = (nextChCode === CharCode.Space || nextChCode === CharCode.Tab);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisInWhitespace = true;\n\t\t\t}\n\t\t} else {\n\t\t\tisInWhitespace = false;\n\t\t}\n\n\t\t// If rendering whitespace on selection, check that the charIndex falls within a selection\n\t\tif (isInWhitespace && selections) {\n\t\t\tisInWhitespace = !!currentSelection && currentSelection.start <= charIndex && charIndex < currentSelection.endExclusive;\n\t\t}\n\n\t\t// If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n\t\tif (isInWhitespace && onlyTrailing) {\n\t\t\tisInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n\t\t}\n\n\t\tif (isInWhitespace && tokenContainsRTL) {\n\t\t\t// If the token contains RTL text, breaking it up into multiple line parts\n\t\t\t// to render whitespace might affect the browser's bidi layout.\n\t\t\t//\n\t\t\t// We render whitespace in such tokens only if the whitespace\n\t\t\t// is the leading or the trailing whitespace of the line,\n\t\t\t// which doesn't affect the browser's bidi layout.\n\t\t\tif (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n\t\t\t\tisInWhitespace = false;\n\t\t\t}\n\t\t}\n\n\t\tif (wasInWhitespace) {\n\t\t\t// was in whitespace token\n\t\t\tif (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n\t\t\t\t// leaving whitespace token or entering a new indent\n\t\t\t\tif (generateLinePartForEachWhitespace) {\n\t\t\t\t\tconst lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n\t\t\t\t\tfor (let i = lastEndIndex + 1; i <= charIndex; i++) {\n\t\t\t\t\t\tresult[resultLen++] = new LinePart(i, 'mtkw', LinePartMetadata.IS_WHITESPACE, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult[resultLen++] = new LinePart(charIndex, 'mtkw', LinePartMetadata.IS_WHITESPACE, false);\n\t\t\t\t}\n\t\t\t\ttmpIndent = tmpIndent % tabSize;\n\t\t\t}\n\t\t} else {\n\t\t\t// was in regular token\n\t\t\tif (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n\t\t\t\tresult[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n\t\t\t\ttmpIndent = tmpIndent % tabSize;\n\t\t\t}\n\t\t}\n\n\t\tif (chCode === CharCode.Tab) {\n\t\t\ttmpIndent = tabSize;\n\t\t} else if (strings.isFullWidthCharacter(chCode)) {\n\t\t\ttmpIndent += 2;\n\t\t} else {\n\t\t\ttmpIndent++;\n\t\t}\n\n\t\twasInWhitespace = isInWhitespace;\n\n\t\twhile (charIndex === tokenEndIndex) {\n\t\t\ttokenIndex++;\n\t\t\tif (tokenIndex < tokensLength) {\n\t\t\t\ttokenType = tokens[tokenIndex].type;\n\t\t\t\ttokenContainsRTL = tokens[tokenIndex].containsRTL;\n\t\t\t\ttokenEndIndex = tokens[tokenIndex].endIndex;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet generateWhitespace = false;\n\tif (wasInWhitespace) {\n\t\t// was in whitespace token\n\t\tif (continuesWithWrappedLine && onlyBoundary) {\n\t\t\tconst lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : CharCode.Null);\n\t\t\tconst prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : CharCode.Null);\n\t\t\tconst isSingleTrailingSpace = (lastCharCode === CharCode.Space && (prevCharCode !== CharCode.Space && prevCharCode !== CharCode.Tab));\n\t\t\tif (!isSingleTrailingSpace) {\n\t\t\t\tgenerateWhitespace = true;\n\t\t\t}\n\t\t} else {\n\t\t\tgenerateWhitespace = true;\n\t\t}\n\t}\n\n\tif (generateWhitespace) {\n\t\tif (generateLinePartForEachWhitespace) {\n\t\t\tconst lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n\t\t\tfor (let i = lastEndIndex + 1; i <= len; i++) {\n\t\t\t\tresult[resultLen++] = new LinePart(i, 'mtkw', LinePartMetadata.IS_WHITESPACE, false);\n\t\t\t}\n\t\t} else {\n\t\t\tresult[resultLen++] = new LinePart(len, 'mtkw', LinePartMetadata.IS_WHITESPACE, false);\n\t\t}\n\t} else {\n\t\tresult[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n\t}\n\n\treturn result;\n}\n\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent: string, len: number, tokens: LinePart[], _lineDecorations: LineDecoration[]): LinePart[] {\n\t_lineDecorations.sort(LineDecoration.compare);\n\tconst lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n\tconst lineDecorationsLen = lineDecorations.length;\n\n\tlet lineDecorationIndex = 0;\n\tconst result: LinePart[] = [];\n\tlet resultLen = 0;\n\tlet lastResultEndIndex = 0;\n\tfor (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n\t\tconst token = tokens[tokenIndex];\n\t\tconst tokenEndIndex = token.endIndex;\n\t\tconst tokenType = token.type;\n\t\tconst tokenMetadata = token.metadata;\n\t\tconst tokenContainsRTL = token.containsRTL;\n\n\t\twhile (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n\t\t\tconst lineDecoration = lineDecorations[lineDecorationIndex];\n\n\t\t\tif (lineDecoration.startOffset > lastResultEndIndex) {\n\t\t\t\tlastResultEndIndex = lineDecoration.startOffset;\n\t\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t\t}\n\n\t\t\tif (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n\t\t\t\t// This line decoration ends before this token ends\n\t\t\t\tlastResultEndIndex = lineDecoration.endOffset + 1;\n\t\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n\t\t\t\tlineDecorationIndex++;\n\t\t\t} else {\n\t\t\t\t// This line decoration continues on to the next token\n\t\t\t\tlastResultEndIndex = tokenEndIndex;\n\t\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (tokenEndIndex > lastResultEndIndex) {\n\t\t\tlastResultEndIndex = tokenEndIndex;\n\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n\t\t}\n\t}\n\n\tconst lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n\tif (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n\t\twhile (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n\t\t\tconst lineDecoration = lineDecorations[lineDecorationIndex];\n\t\t\tresult[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n\t\t\tlineDecorationIndex++;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input: ResolvedRenderLineInput, sb: StringBuilder): RenderLineOutput {\n\tconst fontIsMonospace = input.fontIsMonospace;\n\tconst canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n\tconst containsForeignElements = input.containsForeignElements;\n\tconst lineContent = input.lineContent;\n\tconst len = input.len;\n\tconst isOverflowing = input.isOverflowing;\n\tconst overflowingCharCount = input.overflowingCharCount;\n\tconst parts = input.parts;\n\tconst fauxIndentLength = input.fauxIndentLength;\n\tconst tabSize = input.tabSize;\n\tconst startVisibleColumn = input.startVisibleColumn;\n\tconst spaceWidth = input.spaceWidth;\n\tconst renderSpaceCharCode = input.renderSpaceCharCode;\n\tconst renderWhitespace = input.renderWhitespace;\n\tconst renderControlCharacters = input.renderControlCharacters;\n\n\tconst characterMapping = new CharacterMapping(len + 1, parts.length);\n\tlet lastCharacterMappingDefined = false;\n\n\tlet charIndex = 0;\n\tlet visibleColumn = startVisibleColumn;\n\tlet charOffsetInPart = 0; // the character offset in the current part\n\tlet charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n\n\tlet partDisplacement = 0;\n\n\tsb.appendString('<span>');\n\n\tfor (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n\n\t\tconst part = parts[partIndex];\n\t\tconst partEndIndex = part.endIndex;\n\t\tconst partType = part.type;\n\t\tconst partContainsRTL = part.containsRTL;\n\t\tconst partRendersWhitespace = (renderWhitespace !== RenderWhitespace.None && part.isWhitespace());\n\t\tconst partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw'/*only whitespace*/ || !containsForeignElements);\n\t\tconst partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n\t\tcharOffsetInPart = 0;\n\n\t\tsb.appendString('<span ');\n\t\tif (partContainsRTL) {\n\t\t\tsb.appendString('style=\"unicode-bidi:isolate\" ');\n\t\t}\n\t\tsb.appendString('class=\"');\n\t\tsb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n\t\tsb.appendASCIICharCode(CharCode.DoubleQuote);\n\n\t\tif (partRendersWhitespace) {\n\n\t\t\tlet partWidth = 0;\n\t\t\t{\n\t\t\t\tlet _charIndex = charIndex;\n\t\t\t\tlet _visibleColumn = visibleColumn;\n\n\t\t\t\tfor (; _charIndex < partEndIndex; _charIndex++) {\n\t\t\t\t\tconst charCode = lineContent.charCodeAt(_charIndex);\n\t\t\t\t\tconst charWidth = (charCode === CharCode.Tab ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n\t\t\t\t\tpartWidth += charWidth;\n\t\t\t\t\tif (_charIndex >= fauxIndentLength) {\n\t\t\t\t\t\t_visibleColumn += charWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (partRendersWhitespaceWithWidth) {\n\t\t\t\tsb.appendString(' style=\"width:');\n\t\t\t\tsb.appendString(String(spaceWidth * partWidth));\n\t\t\t\tsb.appendString('px\"');\n\t\t\t}\n\t\t\tsb.appendASCIICharCode(CharCode.GreaterThan);\n\n\t\t\tfor (; charIndex < partEndIndex; charIndex++) {\n\t\t\t\tcharacterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n\t\t\t\tpartDisplacement = 0;\n\t\t\t\tconst charCode = lineContent.charCodeAt(charIndex);\n\n\t\t\t\tlet producedCharacters: number;\n\t\t\t\tlet charWidth: number;\n\n\t\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\t\tproducedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n\t\t\t\t\tcharWidth = producedCharacters;\n\n\t\t\t\t\tif (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n\t\t\t\t\t\tsb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n\t\t\t\t\t}\n\t\t\t\t\tfor (let space = 2; space <= charWidth; space++) {\n\t\t\t\t\t\tsb.appendCharCode(0xA0); // &nbsp;\n\t\t\t\t\t}\n\n\t\t\t\t} else { // must be CharCode.Space\n\t\t\t\t\tproducedCharacters = 2;\n\t\t\t\t\tcharWidth = 1;\n\n\t\t\t\t\tsb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n\t\t\t\t\tsb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n\t\t\t\t}\n\n\t\t\t\tcharOffsetInPart += producedCharacters;\n\t\t\t\tcharHorizontalOffset += charWidth;\n\t\t\t\tif (charIndex >= fauxIndentLength) {\n\t\t\t\t\tvisibleColumn += charWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tsb.appendASCIICharCode(CharCode.GreaterThan);\n\n\t\t\tfor (; charIndex < partEndIndex; charIndex++) {\n\t\t\t\tcharacterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n\t\t\t\tpartDisplacement = 0;\n\t\t\t\tconst charCode = lineContent.charCodeAt(charIndex);\n\n\t\t\t\tlet producedCharacters = 1;\n\t\t\t\tlet charWidth = 1;\n\n\t\t\t\tswitch (charCode) {\n\t\t\t\t\tcase CharCode.Tab:\n\t\t\t\t\t\tproducedCharacters = (tabSize - (visibleColumn % tabSize));\n\t\t\t\t\t\tcharWidth = producedCharacters;\n\t\t\t\t\t\tfor (let space = 1; space <= producedCharacters; space++) {\n\t\t\t\t\t\t\tsb.appendCharCode(0xA0); // &nbsp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.Space:\n\t\t\t\t\t\tsb.appendCharCode(0xA0); // &nbsp;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.LessThan:\n\t\t\t\t\t\tsb.appendString('&lt;');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.GreaterThan:\n\t\t\t\t\t\tsb.appendString('&gt;');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.Ampersand:\n\t\t\t\t\t\tsb.appendString('&amp;');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.Null:\n\t\t\t\t\t\tif (renderControlCharacters) {\n\t\t\t\t\t\t\t// See https://unicode-table.com/en/blocks/control-pictures/\n\t\t\t\t\t\t\tsb.appendCharCode(9216);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsb.appendString('&#00;');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CharCode.UTF8_BOM:\n\t\t\t\t\tcase CharCode.LINE_SEPARATOR:\n\t\t\t\t\tcase CharCode.PARAGRAPH_SEPARATOR:\n\t\t\t\t\tcase CharCode.NEXT_LINE:\n\t\t\t\t\t\tsb.appendCharCode(0xFFFD);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (strings.isFullWidthCharacter(charCode)) {\n\t\t\t\t\t\t\tcharWidth++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// See https://unicode-table.com/en/blocks/control-pictures/\n\t\t\t\t\t\tif (renderControlCharacters && charCode < 32) {\n\t\t\t\t\t\t\tsb.appendCharCode(9216 + charCode);\n\t\t\t\t\t\t} else if (renderControlCharacters && charCode === 127) {\n\t\t\t\t\t\t\t// DEL\n\t\t\t\t\t\t\tsb.appendCharCode(9249);\n\t\t\t\t\t\t} else if (renderControlCharacters && isControlCharacter(charCode)) {\n\t\t\t\t\t\t\tsb.appendString('[U+');\n\t\t\t\t\t\t\tsb.appendString(to4CharHex(charCode));\n\t\t\t\t\t\t\tsb.appendString(']');\n\t\t\t\t\t\t\tproducedCharacters = 8;\n\t\t\t\t\t\t\tcharWidth = producedCharacters;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsb.appendCharCode(charCode);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcharOffsetInPart += producedCharacters;\n\t\t\t\tcharHorizontalOffset += charWidth;\n\t\t\t\tif (charIndex >= fauxIndentLength) {\n\t\t\t\t\tvisibleColumn += charWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (partIsEmptyAndHasPseudoAfter) {\n\t\t\tpartDisplacement++;\n\t\t} else {\n\t\t\tpartDisplacement = 0;\n\t\t}\n\n\t\tif (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n\t\t\tlastCharacterMappingDefined = true;\n\t\t\tcharacterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n\t\t}\n\n\t\tsb.appendString('</span>');\n\n\t}\n\n\tif (!lastCharacterMappingDefined) {\n\t\t// When getting client rects for the last character, we will position the\n\t\t// text range at the end of the span, insteaf of at the beginning of next span\n\t\tcharacterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n\t}\n\n\tif (isOverflowing) {\n\t\tsb.appendString('<span class=\"mtkoverflow\">');\n\t\tsb.appendString(nls.localize('showMore', \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n\t\tsb.appendString('</span>');\n\t}\n\n\tsb.appendString('</span>');\n\n\treturn new RenderLineOutput(characterMapping, containsForeignElements);\n}\n\nfunction to4CharHex(n: number): string {\n\treturn n.toString(16).toUpperCase().padStart(4, '0');\n}\n\nfunction renderOverflowingCharCount(n: number): string {\n\tif (n < 1024) {\n\t\treturn nls.localize('overflow.chars', \"{0} chars\", n);\n\t}\n\tif (n < 1024 * 1024) {\n\t\treturn `${(n / 1024).toFixed(1)} KB`;\n\t}\n\treturn `${(n / 1024 / 1024).toFixed(1)} MB`;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1094, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/viewLayout/viewLinesViewportData.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/vs/editor/common/viewLayout/viewLinesViewportData.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { IPartialViewLinesViewportData, IViewModel, IViewWhitespaceViewportData, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecoration } from '../viewModel/viewModelDecoration.js';\n\n/**\n * Contains all data needed to render at a specific viewport.\n */\nexport class ViewportData {\n\n\tpublic readonly selections: Selection[];\n\n\t/**\n\t * The line number at which to start rendering (inclusive).\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The line number at which to end rendering (inclusive).\n\t */\n\tpublic readonly endLineNumber: number;\n\n\t/**\n\t * relativeVerticalOffset[i] is the `top` position for line at `i` + `startLineNumber`.\n\t */\n\tpublic readonly relativeVerticalOffset: number[];\n\n\t/**\n\t * The viewport as a range (startLineNumber,1) -> (endLineNumber,maxColumn(endLineNumber)).\n\t */\n\tpublic readonly visibleRange: Range;\n\n\t/**\n\t * Value to be substracted from `scrollTop` (in order to vertical offset numbers < 1MM)\n\t */\n\tpublic readonly bigNumbersDelta: number;\n\n\t/**\n\t * Positioning information about gaps whitespace.\n\t */\n\tpublic readonly whitespaceViewportData: IViewWhitespaceViewportData[];\n\n\tprivate readonly _model: IViewModel;\n\n\tpublic readonly lineHeight: number;\n\n\tconstructor(\n\t\tselections: Selection[],\n\t\tpartialData: IPartialViewLinesViewportData,\n\t\twhitespaceViewportData: IViewWhitespaceViewportData[],\n\t\tmodel: IViewModel\n\t) {\n\t\tthis.selections = selections;\n\t\tthis.startLineNumber = partialData.startLineNumber | 0;\n\t\tthis.endLineNumber = partialData.endLineNumber | 0;\n\t\tthis.relativeVerticalOffset = partialData.relativeVerticalOffset;\n\t\tthis.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n\t\tthis.lineHeight = partialData.lineHeight | 0;\n\t\tthis.whitespaceViewportData = whitespaceViewportData;\n\n\t\tthis._model = model;\n\n\t\tthis.visibleRange = new Range(\n\t\t\tpartialData.startLineNumber,\n\t\t\tthis._model.getLineMinColumn(partialData.startLineNumber),\n\t\t\tpartialData.endLineNumber,\n\t\t\tthis._model.getLineMaxColumn(partialData.endLineNumber)\n\t\t);\n\t}\n\n\tpublic getViewLineRenderingData(lineNumber: number): ViewLineRenderingData {\n\t\treturn this._model.getViewportViewLineRenderingData(this.visibleRange, lineNumber);\n\t}\n\n\tpublic getDecorationsInViewport(): ViewModelDecoration[] {\n\t\treturn this._model.getDecorationsInViewport(this.visibleRange);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { IPartialViewLinesViewportData, IViewModel, IViewWhitespaceViewportData, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecoration } from '../viewModel/viewModelDecoration.js';\n\n/**\n * Contains all data needed to render at a specific viewport.\n */\nexport class ViewportData {\n\n\tpublic readonly selections: Selection[];\n\n\t/**\n\t * The line number at which to start rendering (inclusive).\n\t */\n\tpublic readonly startLineNumber: number;\n\n\t/**\n\t * The line number at which to end rendering (inclusive).\n\t */\n\tpublic readonly endLineNumber: number;\n\n\t/**\n\t * relativeVerticalOffset[i] is the `top` position for line at `i` + `startLineNumber`.\n\t */\n\tpublic readonly relativeVerticalOffset: number[];\n\n\t/**\n\t * The viewport as a range (startLineNumber,1) -> (endLineNumber,maxColumn(endLineNumber)).\n\t */\n\tpublic readonly visibleRange: Range;\n\n\t/**\n\t * Value to be substracted from `scrollTop` (in order to vertical offset numbers < 1MM)\n\t */\n\tpublic readonly bigNumbersDelta: number;\n\n\t/**\n\t * Positioning information about gaps whitespace.\n\t */\n\tpublic readonly whitespaceViewportData: IViewWhitespaceViewportData[];\n\n\tprivate readonly _model: IViewModel;\n\n\tpublic readonly lineHeight: number;\n\n\tconstructor(\n\t\tselections: Selection[],\n\t\tpartialData: IPartialViewLinesViewportData,\n\t\twhitespaceViewportData: IViewWhitespaceViewportData[],\n\t\tmodel: IViewModel\n\t) {\n\t\tthis.selections = selections;\n\t\tthis.startLineNumber = partialData.startLineNumber | 0;\n\t\tthis.endLineNumber = partialData.endLineNumber | 0;\n\t\tthis.relativeVerticalOffset = partialData.relativeVerticalOffset;\n\t\tthis.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n\t\tthis.lineHeight = partialData.lineHeight | 0;\n\t\tthis.whitespaceViewportData = whitespaceViewportData;\n\n\t\tthis._model = model;\n\n\t\tthis.visibleRange = new Range(\n\t\t\tpartialData.startLineNumber,\n\t\t\tthis._model.getLineMinColumn(partialData.startLineNumber),\n\t\t\tpartialData.endLineNumber,\n\t\t\tthis._model.getLineMaxColumn(partialData.endLineNumber)\n\t\t);\n\t}\n\n\tpublic getViewLineRenderingData(lineNumber: number): ViewLineRenderingData {\n\t\treturn this._model.getViewportViewLineRenderingData(this.visibleRange, lineNumber);\n\t}\n\n\tpublic getDecorationsInViewport(): ViewModelDecoration[] {\n\t\treturn this._model.getDecorationsInViewport(this.visibleRange);\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAC;;AAQnC,MAAO,YAAY;IA8DjB,wBAAwB,CAAC,UAAkB,EAAA;QACjD,OAAO,IAAI,CAAC,MAAM,CAAC,gCAAgC,CAAC,IAAI,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;IACpF,CAAC;IAEM,wBAAwB,GAAA;QAC9B,OAAO,IAAI,CAAC,MAAM,CAAC,wBAAwB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAChE,CAAC;IA9BD,YACC,UAAuB,EACvB,WAA0C,EAC1C,sBAAqD,EACrD,KAAiB,CAAA;QAEjB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,eAAe,GAAG,WAAW,CAAC,eAAe,GAAG,CAAC,CAAC;QACvD,IAAI,CAAC,aAAa,GAAG,WAAW,CAAC,aAAa,GAAG,CAAC,CAAC;QACnD,IAAI,CAAC,sBAAsB,GAAG,WAAW,CAAC,sBAAsB,CAAC;QACjE,IAAI,CAAC,eAAe,GAAG,WAAW,CAAC,eAAe,GAAG,CAAC,CAAC;QACvD,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,UAAU,GAAG,CAAC,CAAC;QAC7C,IAAI,CAAC,sBAAsB,GAAG,sBAAsB,CAAC;QAErD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QAEpB,IAAI,CAAC,YAAY,GAAG,IAAI,8LAAK,CAC5B,WAAW,CAAC,eAAe,EAC3B,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,WAAW,CAAC,eAAe,CAAC,EACzD,WAAW,CAAC,aAAa,EACzB,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,WAAW,CAAC,aAAa,CAAC,CACvD,CAAC;IACH,CAAC;CASD","debugId":null}},
    {"offset": {"line": 1126, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineHeights.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/viewLayout/lineHeights.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/vs/editor/common/viewLayout/lineHeights.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { binarySearch2 } from '../../../base/common/arrays.js';\nimport { intersection } from '../../../base/common/collections.js';\n\nexport class CustomLine {\n\n\tpublic index: number;\n\tpublic lineNumber: number;\n\tpublic specialHeight: number;\n\tpublic prefixSum: number;\n\tpublic maximumSpecialHeight: number;\n\tpublic decorationId: string;\n\tpublic deleted: boolean;\n\n\tconstructor(decorationId: string, index: number, lineNumber: number, specialHeight: number, prefixSum: number) {\n\t\tthis.decorationId = decorationId;\n\t\tthis.index = index;\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.specialHeight = specialHeight;\n\t\tthis.prefixSum = prefixSum;\n\t\tthis.maximumSpecialHeight = specialHeight;\n\t\tthis.deleted = false;\n\t}\n}\n\n/**\n * Manages line heights in the editor with support for custom line heights from decorations.\n *\n * This class maintains an ordered collection of line heights, where each line can have either\n * the default height or a custom height specified by decorations. It supports efficient querying\n * of individual line heights as well as accumulated heights up to a specific line.\n *\n * Line heights are stored in a sorted array for efficient binary search operations. Each line\n * with custom height is represented by a {@link CustomLine} object which tracks its special height,\n * accumulated height prefix sum, and associated decoration ID.\n *\n * The class optimizes performance by:\n * - Using binary search to locate lines in the ordered array\n * - Batching updates through a pending changes mechanism\n * - Computing prefix sums for O(1) accumulated height lookup\n * - Tracking maximum height for lines with multiple decorations\n * - Efficiently handling document changes (line insertions and deletions)\n *\n * When lines are inserted or deleted, the manager updates line numbers and prefix sums\n * for all affected lines. It also handles special cases like decorations that span\n * the insertion/deletion points by re-applying those decorations appropriately.\n *\n * All query operations automatically commit pending changes to ensure consistent results.\n * Clients can modify line heights by adding or removing custom line height decorations,\n * which are tracked by their unique decoration IDs.\n */\nexport class LineHeightsManager {\n\n\tprivate _decorationIDToCustomLine: ArrayMap<string, CustomLine> = new ArrayMap<string, CustomLine>();\n\tprivate _orderedCustomLines: CustomLine[] = [];\n\tprivate _pendingSpecialLinesToInsert: CustomLine[] = [];\n\tprivate _invalidIndex: number = 0;\n\tprivate _defaultLineHeight: number;\n\tprivate _hasPending: boolean = false;\n\n\tconstructor(defaultLineHeight: number, customLineHeightData: ICustomLineHeightData[]) {\n\t\tthis._defaultLineHeight = defaultLineHeight;\n\t\tif (customLineHeightData.length > 0) {\n\t\t\tfor (const data of customLineHeightData) {\n\t\t\t\tthis.insertOrChangeCustomLineHeight(data.decorationId, data.startLineNumber, data.endLineNumber, data.lineHeight);\n\t\t\t}\n\t\t\tthis.commit();\n\t\t}\n\t}\n\n\tset defaultLineHeight(defaultLineHeight: number) {\n\t\tthis._defaultLineHeight = defaultLineHeight;\n\t}\n\n\tget defaultLineHeight() {\n\t\treturn this._defaultLineHeight;\n\t}\n\n\tpublic removeCustomLineHeight(decorationID: string): void {\n\t\tconst customLines = this._decorationIDToCustomLine.get(decorationID);\n\t\tif (!customLines) {\n\t\t\treturn;\n\t\t}\n\t\tthis._decorationIDToCustomLine.delete(decorationID);\n\t\tfor (const customLine of customLines) {\n\t\t\tcustomLine.deleted = true;\n\t\t\tthis._invalidIndex = Math.min(this._invalidIndex, customLine.index);\n\t\t}\n\t\tthis._hasPending = true;\n\t}\n\n\tpublic insertOrChangeCustomLineHeight(decorationId: string, startLineNumber: number, endLineNumber: number, lineHeight: number): void {\n\t\tthis.removeCustomLineHeight(decorationId);\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst customLine = new CustomLine(decorationId, -1, lineNumber, lineHeight, 0);\n\t\t\tthis._pendingSpecialLinesToInsert.push(customLine);\n\t\t}\n\t\tthis._hasPending = true;\n\t}\n\n\tpublic heightForLineNumber(lineNumber: number): number {\n\t\tconst searchIndex = this._binarySearchOverOrderedCustomLinesArray(lineNumber);\n\t\tif (searchIndex >= 0) {\n\t\t\treturn this._orderedCustomLines[searchIndex].maximumSpecialHeight;\n\t\t}\n\t\treturn this._defaultLineHeight;\n\t}\n\n\tpublic getAccumulatedLineHeightsIncludingLineNumber(lineNumber: number): number {\n\t\tconst searchIndex = this._binarySearchOverOrderedCustomLinesArray(lineNumber);\n\t\tif (searchIndex >= 0) {\n\t\t\treturn this._orderedCustomLines[searchIndex].prefixSum + this._orderedCustomLines[searchIndex].maximumSpecialHeight;\n\t\t}\n\t\tif (searchIndex === -1) {\n\t\t\treturn this._defaultLineHeight * lineNumber;\n\t\t}\n\t\tconst modifiedIndex = -(searchIndex + 1);\n\t\tconst previousSpecialLine = this._orderedCustomLines[modifiedIndex - 1];\n\t\treturn previousSpecialLine.prefixSum + previousSpecialLine.maximumSpecialHeight + this._defaultLineHeight * (lineNumber - previousSpecialLine.lineNumber);\n\t}\n\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tconst deleteCount = toLineNumber - fromLineNumber + 1;\n\t\tconst numberOfCustomLines = this._orderedCustomLines.length;\n\t\tconst candidateStartIndexOfDeletion = this._binarySearchOverOrderedCustomLinesArray(fromLineNumber);\n\t\tlet startIndexOfDeletion: number;\n\t\tif (candidateStartIndexOfDeletion >= 0) {\n\t\t\tstartIndexOfDeletion = candidateStartIndexOfDeletion;\n\t\t\tfor (let i = candidateStartIndexOfDeletion - 1; i >= 0; i--) {\n\t\t\t\tif (this._orderedCustomLines[i].lineNumber === fromLineNumber) {\n\t\t\t\t\tstartIndexOfDeletion--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstartIndexOfDeletion = candidateStartIndexOfDeletion === -(numberOfCustomLines + 1) && candidateStartIndexOfDeletion !== -1 ? numberOfCustomLines - 1 : - (candidateStartIndexOfDeletion + 1);\n\t\t}\n\t\tconst candidateEndIndexOfDeletion = this._binarySearchOverOrderedCustomLinesArray(toLineNumber);\n\t\tlet endIndexOfDeletion: number;\n\t\tif (candidateEndIndexOfDeletion >= 0) {\n\t\t\tendIndexOfDeletion = candidateEndIndexOfDeletion;\n\t\t\tfor (let i = candidateEndIndexOfDeletion + 1; i < numberOfCustomLines; i++) {\n\t\t\t\tif (this._orderedCustomLines[i].lineNumber === toLineNumber) {\n\t\t\t\t\tendIndexOfDeletion++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tendIndexOfDeletion = candidateEndIndexOfDeletion === -(numberOfCustomLines + 1) && candidateEndIndexOfDeletion !== -1 ? numberOfCustomLines - 1 : - (candidateEndIndexOfDeletion + 1);\n\t\t}\n\t\tconst isEndIndexBiggerThanStartIndex = endIndexOfDeletion > startIndexOfDeletion;\n\t\tconst isEndIndexEqualToStartIndexAndCoversCustomLine = endIndexOfDeletion === startIndexOfDeletion\n\t\t\t&& this._orderedCustomLines[startIndexOfDeletion]\n\t\t\t&& this._orderedCustomLines[startIndexOfDeletion].lineNumber >= fromLineNumber\n\t\t\t&& this._orderedCustomLines[startIndexOfDeletion].lineNumber <= toLineNumber;\n\n\t\tif (isEndIndexBiggerThanStartIndex || isEndIndexEqualToStartIndexAndCoversCustomLine) {\n\t\t\tlet maximumSpecialHeightOnDeletedInterval = 0;\n\t\t\tfor (let i = startIndexOfDeletion; i <= endIndexOfDeletion; i++) {\n\t\t\t\tmaximumSpecialHeightOnDeletedInterval = Math.max(maximumSpecialHeightOnDeletedInterval, this._orderedCustomLines[i].maximumSpecialHeight);\n\t\t\t}\n\t\t\tlet prefixSumOnDeletedInterval = 0;\n\t\t\tif (startIndexOfDeletion > 0) {\n\t\t\t\tconst previousSpecialLine = this._orderedCustomLines[startIndexOfDeletion - 1];\n\t\t\t\tprefixSumOnDeletedInterval = previousSpecialLine.prefixSum + previousSpecialLine.maximumSpecialHeight + this._defaultLineHeight * (fromLineNumber - previousSpecialLine.lineNumber - 1);\n\t\t\t} else {\n\t\t\t\tprefixSumOnDeletedInterval = fromLineNumber > 0 ? (fromLineNumber - 1) * this._defaultLineHeight : 0;\n\t\t\t}\n\t\t\tconst firstSpecialLineDeleted = this._orderedCustomLines[startIndexOfDeletion];\n\t\t\tconst lastSpecialLineDeleted = this._orderedCustomLines[endIndexOfDeletion];\n\t\t\tconst firstSpecialLineAfterDeletion = this._orderedCustomLines[endIndexOfDeletion + 1];\n\t\t\tconst heightOfFirstLineAfterDeletion = firstSpecialLineAfterDeletion && firstSpecialLineAfterDeletion.lineNumber === toLineNumber + 1 ? firstSpecialLineAfterDeletion.maximumSpecialHeight : this._defaultLineHeight;\n\t\t\tconst totalHeightDeleted = lastSpecialLineDeleted.prefixSum\n\t\t\t\t+ lastSpecialLineDeleted.maximumSpecialHeight\n\t\t\t\t- firstSpecialLineDeleted.prefixSum\n\t\t\t\t+ this._defaultLineHeight * (toLineNumber - lastSpecialLineDeleted.lineNumber)\n\t\t\t\t+ this._defaultLineHeight * (firstSpecialLineDeleted.lineNumber - fromLineNumber)\n\t\t\t\t+ heightOfFirstLineAfterDeletion - maximumSpecialHeightOnDeletedInterval;\n\n\t\t\tconst decorationIdsSeen = new Set<string>();\n\t\t\tconst newOrderedCustomLines: CustomLine[] = [];\n\t\t\tconst newDecorationIDToSpecialLine = new ArrayMap<string, CustomLine>();\n\t\t\tlet numberOfDeletions = 0;\n\t\t\tfor (let i = 0; i < this._orderedCustomLines.length; i++) {\n\t\t\t\tconst customLine = this._orderedCustomLines[i];\n\t\t\t\tif (i < startIndexOfDeletion) {\n\t\t\t\t\tnewOrderedCustomLines.push(customLine);\n\t\t\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t\t\t} else if (i >= startIndexOfDeletion && i <= endIndexOfDeletion) {\n\t\t\t\t\tconst decorationId = customLine.decorationId;\n\t\t\t\t\tif (!decorationIdsSeen.has(decorationId)) {\n\t\t\t\t\t\tcustomLine.index -= numberOfDeletions;\n\t\t\t\t\t\tcustomLine.lineNumber = fromLineNumber;\n\t\t\t\t\t\tcustomLine.prefixSum = prefixSumOnDeletedInterval;\n\t\t\t\t\t\tcustomLine.maximumSpecialHeight = maximumSpecialHeightOnDeletedInterval;\n\t\t\t\t\t\tnewOrderedCustomLines.push(customLine);\n\t\t\t\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnumberOfDeletions++;\n\t\t\t\t\t}\n\t\t\t\t} else if (i > endIndexOfDeletion) {\n\t\t\t\t\tcustomLine.index -= numberOfDeletions;\n\t\t\t\t\tcustomLine.lineNumber -= deleteCount;\n\t\t\t\t\tcustomLine.prefixSum -= totalHeightDeleted;\n\t\t\t\t\tnewOrderedCustomLines.push(customLine);\n\t\t\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t\t\t}\n\t\t\t\tdecorationIdsSeen.add(customLine.decorationId);\n\t\t\t}\n\t\t\tthis._orderedCustomLines = newOrderedCustomLines;\n\t\t\tthis._decorationIDToCustomLine = newDecorationIDToSpecialLine;\n\t\t} else {\n\t\t\tconst totalHeightDeleted = deleteCount * this._defaultLineHeight;\n\t\t\tfor (let i = endIndexOfDeletion; i < this._orderedCustomLines.length; i++) {\n\t\t\t\tconst customLine = this._orderedCustomLines[i];\n\t\t\t\tif (customLine.lineNumber > toLineNumber) {\n\t\t\t\t\tcustomLine.lineNumber -= deleteCount;\n\t\t\t\t\tcustomLine.prefixSum -= totalHeightDeleted;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tconst insertCount = toLineNumber - fromLineNumber + 1;\n\t\tconst candidateStartIndexOfInsertion = this._binarySearchOverOrderedCustomLinesArray(fromLineNumber);\n\t\tlet startIndexOfInsertion: number;\n\t\tif (candidateStartIndexOfInsertion >= 0) {\n\t\t\tstartIndexOfInsertion = candidateStartIndexOfInsertion;\n\t\t\tfor (let i = candidateStartIndexOfInsertion - 1; i >= 0; i--) {\n\t\t\t\tif (this._orderedCustomLines[i].lineNumber === fromLineNumber) {\n\t\t\t\t\tstartIndexOfInsertion--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstartIndexOfInsertion = -(candidateStartIndexOfInsertion + 1);\n\t\t}\n\t\tconst toReAdd: ICustomLineHeightData[] = [];\n\t\tconst decorationsImmediatelyAfter = new Set<string>();\n\t\tfor (let i = startIndexOfInsertion; i < this._orderedCustomLines.length; i++) {\n\t\t\tif (this._orderedCustomLines[i].lineNumber === fromLineNumber) {\n\t\t\t\tdecorationsImmediatelyAfter.add(this._orderedCustomLines[i].decorationId);\n\t\t\t}\n\t\t}\n\t\tconst decorationsImmediatelyBefore = new Set<string>();\n\t\tfor (let i = startIndexOfInsertion - 1; i >= 0; i--) {\n\t\t\tif (this._orderedCustomLines[i].lineNumber === fromLineNumber - 1) {\n\t\t\t\tdecorationsImmediatelyBefore.add(this._orderedCustomLines[i].decorationId);\n\t\t\t}\n\t\t}\n\t\tconst decorationsWithGaps = intersection(decorationsImmediatelyBefore, decorationsImmediatelyAfter);\n\t\tfor (let i = startIndexOfInsertion; i < this._orderedCustomLines.length; i++) {\n\t\t\tthis._orderedCustomLines[i].lineNumber += insertCount;\n\t\t\tthis._orderedCustomLines[i].prefixSum += this._defaultLineHeight * insertCount;\n\t\t}\n\n\t\tif (decorationsWithGaps.size > 0) {\n\t\t\tfor (const decorationId of decorationsWithGaps) {\n\t\t\t\tconst decoration = this._decorationIDToCustomLine.get(decorationId);\n\t\t\t\tif (decoration) {\n\t\t\t\t\tconst startLineNumber = decoration.reduce((min, l) => Math.min(min, l.lineNumber), fromLineNumber); // min\n\t\t\t\t\tconst endLineNumber = decoration.reduce((max, l) => Math.max(max, l.lineNumber), fromLineNumber); // max\n\t\t\t\t\tconst lineHeight = decoration.reduce((max, l) => Math.max(max, l.specialHeight), 0);\n\t\t\t\t\ttoReAdd.push({\n\t\t\t\t\t\tdecorationId,\n\t\t\t\t\t\tstartLineNumber,\n\t\t\t\t\t\tendLineNumber,\n\t\t\t\t\t\tlineHeight\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const dec of toReAdd) {\n\t\t\t\tthis.insertOrChangeCustomLineHeight(dec.decorationId, dec.startLineNumber, dec.endLineNumber, dec.lineHeight);\n\t\t\t}\n\t\t\tthis.commit();\n\t\t}\n\t}\n\n\tpublic commit(): void {\n\t\tif (!this._hasPending) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const pendingChange of this._pendingSpecialLinesToInsert) {\n\t\t\tconst candidateInsertionIndex = this._binarySearchOverOrderedCustomLinesArray(pendingChange.lineNumber);\n\t\t\tconst insertionIndex = candidateInsertionIndex >= 0 ? candidateInsertionIndex : -(candidateInsertionIndex + 1);\n\t\t\tthis._orderedCustomLines.splice(insertionIndex, 0, pendingChange);\n\t\t\tthis._invalidIndex = Math.min(this._invalidIndex, insertionIndex);\n\t\t}\n\t\tthis._pendingSpecialLinesToInsert = [];\n\t\tconst newDecorationIDToSpecialLine = new ArrayMap<string, CustomLine>();\n\t\tconst newOrderedSpecialLines: CustomLine[] = [];\n\n\t\tfor (let i = 0; i < this._invalidIndex; i++) {\n\t\t\tconst customLine = this._orderedCustomLines[i];\n\t\t\tnewOrderedSpecialLines.push(customLine);\n\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t}\n\n\t\tlet numberOfDeletions = 0;\n\t\tlet previousSpecialLine: CustomLine | undefined = (this._invalidIndex > 0) ? newOrderedSpecialLines[this._invalidIndex - 1] : undefined;\n\t\tfor (let i = this._invalidIndex; i < this._orderedCustomLines.length; i++) {\n\t\t\tconst customLine = this._orderedCustomLines[i];\n\t\t\tif (customLine.deleted) {\n\t\t\t\tnumberOfDeletions++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcustomLine.index = i - numberOfDeletions;\n\t\t\tif (previousSpecialLine && previousSpecialLine.lineNumber === customLine.lineNumber) {\n\t\t\t\tcustomLine.maximumSpecialHeight = previousSpecialLine.maximumSpecialHeight;\n\t\t\t\tcustomLine.prefixSum = previousSpecialLine.prefixSum;\n\t\t\t} else {\n\t\t\t\tlet maximumSpecialHeight = customLine.specialHeight;\n\t\t\t\tfor (let j = i; j < this._orderedCustomLines.length; j++) {\n\t\t\t\t\tconst nextSpecialLine = this._orderedCustomLines[j];\n\t\t\t\t\tif (nextSpecialLine.deleted) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nextSpecialLine.lineNumber !== customLine.lineNumber) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmaximumSpecialHeight = Math.max(maximumSpecialHeight, nextSpecialLine.specialHeight);\n\t\t\t\t}\n\t\t\t\tcustomLine.maximumSpecialHeight = maximumSpecialHeight;\n\n\t\t\t\tlet prefixSum: number;\n\t\t\t\tif (previousSpecialLine) {\n\t\t\t\t\tprefixSum = previousSpecialLine.prefixSum + previousSpecialLine.maximumSpecialHeight + this._defaultLineHeight * (customLine.lineNumber - previousSpecialLine.lineNumber - 1);\n\t\t\t\t} else {\n\t\t\t\t\tprefixSum = this._defaultLineHeight * (customLine.lineNumber - 1);\n\t\t\t\t}\n\t\t\t\tcustomLine.prefixSum = prefixSum;\n\t\t\t}\n\t\t\tpreviousSpecialLine = customLine;\n\t\t\tnewOrderedSpecialLines.push(customLine);\n\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t}\n\t\tthis._orderedCustomLines = newOrderedSpecialLines;\n\t\tthis._decorationIDToCustomLine = newDecorationIDToSpecialLine;\n\t\tthis._invalidIndex = Infinity;\n\t\tthis._hasPending = false;\n\t}\n\n\tprivate _binarySearchOverOrderedCustomLinesArray(lineNumber: number): number {\n\t\treturn binarySearch2(this._orderedCustomLines.length, (index) => {\n\t\t\tconst line = this._orderedCustomLines[index];\n\t\t\tif (line.lineNumber === lineNumber) {\n\t\t\t\treturn 0;\n\t\t\t} else if (line.lineNumber < lineNumber) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport interface ICustomLineHeightData {\n\treadonly decorationId: string;\n\treadonly startLineNumber: number;\n\treadonly endLineNumber: number;\n\treadonly lineHeight: number;\n}\n\nclass ArrayMap<K, T> {\n\n\tprivate _map: Map<K, T[]> = new Map<K, T[]>();\n\n\tconstructor() { }\n\n\tadd(key: K, value: T) {\n\t\tconst array = this._map.get(key);\n\t\tif (!array) {\n\t\t\tthis._map.set(key, [value]);\n\t\t} else {\n\t\t\tarray.push(value);\n\t\t}\n\t}\n\n\tget(key: K): T[] | undefined {\n\t\treturn this._map.get(key);\n\t}\n\n\tdelete(key: K): void {\n\t\tthis._map.delete(key);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { binarySearch2 } from '../../../base/common/arrays.js';\nimport { intersection } from '../../../base/common/collections.js';\n\nexport class CustomLine {\n\n\tpublic index: number;\n\tpublic lineNumber: number;\n\tpublic specialHeight: number;\n\tpublic prefixSum: number;\n\tpublic maximumSpecialHeight: number;\n\tpublic decorationId: string;\n\tpublic deleted: boolean;\n\n\tconstructor(decorationId: string, index: number, lineNumber: number, specialHeight: number, prefixSum: number) {\n\t\tthis.decorationId = decorationId;\n\t\tthis.index = index;\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.specialHeight = specialHeight;\n\t\tthis.prefixSum = prefixSum;\n\t\tthis.maximumSpecialHeight = specialHeight;\n\t\tthis.deleted = false;\n\t}\n}\n\n/**\n * Manages line heights in the editor with support for custom line heights from decorations.\n *\n * This class maintains an ordered collection of line heights, where each line can have either\n * the default height or a custom height specified by decorations. It supports efficient querying\n * of individual line heights as well as accumulated heights up to a specific line.\n *\n * Line heights are stored in a sorted array for efficient binary search operations. Each line\n * with custom height is represented by a {@link CustomLine} object which tracks its special height,\n * accumulated height prefix sum, and associated decoration ID.\n *\n * The class optimizes performance by:\n * - Using binary search to locate lines in the ordered array\n * - Batching updates through a pending changes mechanism\n * - Computing prefix sums for O(1) accumulated height lookup\n * - Tracking maximum height for lines with multiple decorations\n * - Efficiently handling document changes (line insertions and deletions)\n *\n * When lines are inserted or deleted, the manager updates line numbers and prefix sums\n * for all affected lines. It also handles special cases like decorations that span\n * the insertion/deletion points by re-applying those decorations appropriately.\n *\n * All query operations automatically commit pending changes to ensure consistent results.\n * Clients can modify line heights by adding or removing custom line height decorations,\n * which are tracked by their unique decoration IDs.\n */\nexport class LineHeightsManager {\n\n\tprivate _decorationIDToCustomLine: ArrayMap<string, CustomLine> = new ArrayMap<string, CustomLine>();\n\tprivate _orderedCustomLines: CustomLine[] = [];\n\tprivate _pendingSpecialLinesToInsert: CustomLine[] = [];\n\tprivate _invalidIndex: number = 0;\n\tprivate _defaultLineHeight: number;\n\tprivate _hasPending: boolean = false;\n\n\tconstructor(defaultLineHeight: number, customLineHeightData: ICustomLineHeightData[]) {\n\t\tthis._defaultLineHeight = defaultLineHeight;\n\t\tif (customLineHeightData.length > 0) {\n\t\t\tfor (const data of customLineHeightData) {\n\t\t\t\tthis.insertOrChangeCustomLineHeight(data.decorationId, data.startLineNumber, data.endLineNumber, data.lineHeight);\n\t\t\t}\n\t\t\tthis.commit();\n\t\t}\n\t}\n\n\tset defaultLineHeight(defaultLineHeight: number) {\n\t\tthis._defaultLineHeight = defaultLineHeight;\n\t}\n\n\tget defaultLineHeight() {\n\t\treturn this._defaultLineHeight;\n\t}\n\n\tpublic removeCustomLineHeight(decorationID: string): void {\n\t\tconst customLines = this._decorationIDToCustomLine.get(decorationID);\n\t\tif (!customLines) {\n\t\t\treturn;\n\t\t}\n\t\tthis._decorationIDToCustomLine.delete(decorationID);\n\t\tfor (const customLine of customLines) {\n\t\t\tcustomLine.deleted = true;\n\t\t\tthis._invalidIndex = Math.min(this._invalidIndex, customLine.index);\n\t\t}\n\t\tthis._hasPending = true;\n\t}\n\n\tpublic insertOrChangeCustomLineHeight(decorationId: string, startLineNumber: number, endLineNumber: number, lineHeight: number): void {\n\t\tthis.removeCustomLineHeight(decorationId);\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst customLine = new CustomLine(decorationId, -1, lineNumber, lineHeight, 0);\n\t\t\tthis._pendingSpecialLinesToInsert.push(customLine);\n\t\t}\n\t\tthis._hasPending = true;\n\t}\n\n\tpublic heightForLineNumber(lineNumber: number): number {\n\t\tconst searchIndex = this._binarySearchOverOrderedCustomLinesArray(lineNumber);\n\t\tif (searchIndex >= 0) {\n\t\t\treturn this._orderedCustomLines[searchIndex].maximumSpecialHeight;\n\t\t}\n\t\treturn this._defaultLineHeight;\n\t}\n\n\tpublic getAccumulatedLineHeightsIncludingLineNumber(lineNumber: number): number {\n\t\tconst searchIndex = this._binarySearchOverOrderedCustomLinesArray(lineNumber);\n\t\tif (searchIndex >= 0) {\n\t\t\treturn this._orderedCustomLines[searchIndex].prefixSum + this._orderedCustomLines[searchIndex].maximumSpecialHeight;\n\t\t}\n\t\tif (searchIndex === -1) {\n\t\t\treturn this._defaultLineHeight * lineNumber;\n\t\t}\n\t\tconst modifiedIndex = -(searchIndex + 1);\n\t\tconst previousSpecialLine = this._orderedCustomLines[modifiedIndex - 1];\n\t\treturn previousSpecialLine.prefixSum + previousSpecialLine.maximumSpecialHeight + this._defaultLineHeight * (lineNumber - previousSpecialLine.lineNumber);\n\t}\n\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tconst deleteCount = toLineNumber - fromLineNumber + 1;\n\t\tconst numberOfCustomLines = this._orderedCustomLines.length;\n\t\tconst candidateStartIndexOfDeletion = this._binarySearchOverOrderedCustomLinesArray(fromLineNumber);\n\t\tlet startIndexOfDeletion: number;\n\t\tif (candidateStartIndexOfDeletion >= 0) {\n\t\t\tstartIndexOfDeletion = candidateStartIndexOfDeletion;\n\t\t\tfor (let i = candidateStartIndexOfDeletion - 1; i >= 0; i--) {\n\t\t\t\tif (this._orderedCustomLines[i].lineNumber === fromLineNumber) {\n\t\t\t\t\tstartIndexOfDeletion--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstartIndexOfDeletion = candidateStartIndexOfDeletion === -(numberOfCustomLines + 1) && candidateStartIndexOfDeletion !== -1 ? numberOfCustomLines - 1 : - (candidateStartIndexOfDeletion + 1);\n\t\t}\n\t\tconst candidateEndIndexOfDeletion = this._binarySearchOverOrderedCustomLinesArray(toLineNumber);\n\t\tlet endIndexOfDeletion: number;\n\t\tif (candidateEndIndexOfDeletion >= 0) {\n\t\t\tendIndexOfDeletion = candidateEndIndexOfDeletion;\n\t\t\tfor (let i = candidateEndIndexOfDeletion + 1; i < numberOfCustomLines; i++) {\n\t\t\t\tif (this._orderedCustomLines[i].lineNumber === toLineNumber) {\n\t\t\t\t\tendIndexOfDeletion++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tendIndexOfDeletion = candidateEndIndexOfDeletion === -(numberOfCustomLines + 1) && candidateEndIndexOfDeletion !== -1 ? numberOfCustomLines - 1 : - (candidateEndIndexOfDeletion + 1);\n\t\t}\n\t\tconst isEndIndexBiggerThanStartIndex = endIndexOfDeletion > startIndexOfDeletion;\n\t\tconst isEndIndexEqualToStartIndexAndCoversCustomLine = endIndexOfDeletion === startIndexOfDeletion\n\t\t\t&& this._orderedCustomLines[startIndexOfDeletion]\n\t\t\t&& this._orderedCustomLines[startIndexOfDeletion].lineNumber >= fromLineNumber\n\t\t\t&& this._orderedCustomLines[startIndexOfDeletion].lineNumber <= toLineNumber;\n\n\t\tif (isEndIndexBiggerThanStartIndex || isEndIndexEqualToStartIndexAndCoversCustomLine) {\n\t\t\tlet maximumSpecialHeightOnDeletedInterval = 0;\n\t\t\tfor (let i = startIndexOfDeletion; i <= endIndexOfDeletion; i++) {\n\t\t\t\tmaximumSpecialHeightOnDeletedInterval = Math.max(maximumSpecialHeightOnDeletedInterval, this._orderedCustomLines[i].maximumSpecialHeight);\n\t\t\t}\n\t\t\tlet prefixSumOnDeletedInterval = 0;\n\t\t\tif (startIndexOfDeletion > 0) {\n\t\t\t\tconst previousSpecialLine = this._orderedCustomLines[startIndexOfDeletion - 1];\n\t\t\t\tprefixSumOnDeletedInterval = previousSpecialLine.prefixSum + previousSpecialLine.maximumSpecialHeight + this._defaultLineHeight * (fromLineNumber - previousSpecialLine.lineNumber - 1);\n\t\t\t} else {\n\t\t\t\tprefixSumOnDeletedInterval = fromLineNumber > 0 ? (fromLineNumber - 1) * this._defaultLineHeight : 0;\n\t\t\t}\n\t\t\tconst firstSpecialLineDeleted = this._orderedCustomLines[startIndexOfDeletion];\n\t\t\tconst lastSpecialLineDeleted = this._orderedCustomLines[endIndexOfDeletion];\n\t\t\tconst firstSpecialLineAfterDeletion = this._orderedCustomLines[endIndexOfDeletion + 1];\n\t\t\tconst heightOfFirstLineAfterDeletion = firstSpecialLineAfterDeletion && firstSpecialLineAfterDeletion.lineNumber === toLineNumber + 1 ? firstSpecialLineAfterDeletion.maximumSpecialHeight : this._defaultLineHeight;\n\t\t\tconst totalHeightDeleted = lastSpecialLineDeleted.prefixSum\n\t\t\t\t+ lastSpecialLineDeleted.maximumSpecialHeight\n\t\t\t\t- firstSpecialLineDeleted.prefixSum\n\t\t\t\t+ this._defaultLineHeight * (toLineNumber - lastSpecialLineDeleted.lineNumber)\n\t\t\t\t+ this._defaultLineHeight * (firstSpecialLineDeleted.lineNumber - fromLineNumber)\n\t\t\t\t+ heightOfFirstLineAfterDeletion - maximumSpecialHeightOnDeletedInterval;\n\n\t\t\tconst decorationIdsSeen = new Set<string>();\n\t\t\tconst newOrderedCustomLines: CustomLine[] = [];\n\t\t\tconst newDecorationIDToSpecialLine = new ArrayMap<string, CustomLine>();\n\t\t\tlet numberOfDeletions = 0;\n\t\t\tfor (let i = 0; i < this._orderedCustomLines.length; i++) {\n\t\t\t\tconst customLine = this._orderedCustomLines[i];\n\t\t\t\tif (i < startIndexOfDeletion) {\n\t\t\t\t\tnewOrderedCustomLines.push(customLine);\n\t\t\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t\t\t} else if (i >= startIndexOfDeletion && i <= endIndexOfDeletion) {\n\t\t\t\t\tconst decorationId = customLine.decorationId;\n\t\t\t\t\tif (!decorationIdsSeen.has(decorationId)) {\n\t\t\t\t\t\tcustomLine.index -= numberOfDeletions;\n\t\t\t\t\t\tcustomLine.lineNumber = fromLineNumber;\n\t\t\t\t\t\tcustomLine.prefixSum = prefixSumOnDeletedInterval;\n\t\t\t\t\t\tcustomLine.maximumSpecialHeight = maximumSpecialHeightOnDeletedInterval;\n\t\t\t\t\t\tnewOrderedCustomLines.push(customLine);\n\t\t\t\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnumberOfDeletions++;\n\t\t\t\t\t}\n\t\t\t\t} else if (i > endIndexOfDeletion) {\n\t\t\t\t\tcustomLine.index -= numberOfDeletions;\n\t\t\t\t\tcustomLine.lineNumber -= deleteCount;\n\t\t\t\t\tcustomLine.prefixSum -= totalHeightDeleted;\n\t\t\t\t\tnewOrderedCustomLines.push(customLine);\n\t\t\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t\t\t}\n\t\t\t\tdecorationIdsSeen.add(customLine.decorationId);\n\t\t\t}\n\t\t\tthis._orderedCustomLines = newOrderedCustomLines;\n\t\t\tthis._decorationIDToCustomLine = newDecorationIDToSpecialLine;\n\t\t} else {\n\t\t\tconst totalHeightDeleted = deleteCount * this._defaultLineHeight;\n\t\t\tfor (let i = endIndexOfDeletion; i < this._orderedCustomLines.length; i++) {\n\t\t\t\tconst customLine = this._orderedCustomLines[i];\n\t\t\t\tif (customLine.lineNumber > toLineNumber) {\n\t\t\t\t\tcustomLine.lineNumber -= deleteCount;\n\t\t\t\t\tcustomLine.prefixSum -= totalHeightDeleted;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tconst insertCount = toLineNumber - fromLineNumber + 1;\n\t\tconst candidateStartIndexOfInsertion = this._binarySearchOverOrderedCustomLinesArray(fromLineNumber);\n\t\tlet startIndexOfInsertion: number;\n\t\tif (candidateStartIndexOfInsertion >= 0) {\n\t\t\tstartIndexOfInsertion = candidateStartIndexOfInsertion;\n\t\t\tfor (let i = candidateStartIndexOfInsertion - 1; i >= 0; i--) {\n\t\t\t\tif (this._orderedCustomLines[i].lineNumber === fromLineNumber) {\n\t\t\t\t\tstartIndexOfInsertion--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tstartIndexOfInsertion = -(candidateStartIndexOfInsertion + 1);\n\t\t}\n\t\tconst toReAdd: ICustomLineHeightData[] = [];\n\t\tconst decorationsImmediatelyAfter = new Set<string>();\n\t\tfor (let i = startIndexOfInsertion; i < this._orderedCustomLines.length; i++) {\n\t\t\tif (this._orderedCustomLines[i].lineNumber === fromLineNumber) {\n\t\t\t\tdecorationsImmediatelyAfter.add(this._orderedCustomLines[i].decorationId);\n\t\t\t}\n\t\t}\n\t\tconst decorationsImmediatelyBefore = new Set<string>();\n\t\tfor (let i = startIndexOfInsertion - 1; i >= 0; i--) {\n\t\t\tif (this._orderedCustomLines[i].lineNumber === fromLineNumber - 1) {\n\t\t\t\tdecorationsImmediatelyBefore.add(this._orderedCustomLines[i].decorationId);\n\t\t\t}\n\t\t}\n\t\tconst decorationsWithGaps = intersection(decorationsImmediatelyBefore, decorationsImmediatelyAfter);\n\t\tfor (let i = startIndexOfInsertion; i < this._orderedCustomLines.length; i++) {\n\t\t\tthis._orderedCustomLines[i].lineNumber += insertCount;\n\t\t\tthis._orderedCustomLines[i].prefixSum += this._defaultLineHeight * insertCount;\n\t\t}\n\n\t\tif (decorationsWithGaps.size > 0) {\n\t\t\tfor (const decorationId of decorationsWithGaps) {\n\t\t\t\tconst decoration = this._decorationIDToCustomLine.get(decorationId);\n\t\t\t\tif (decoration) {\n\t\t\t\t\tconst startLineNumber = decoration.reduce((min, l) => Math.min(min, l.lineNumber), fromLineNumber); // min\n\t\t\t\t\tconst endLineNumber = decoration.reduce((max, l) => Math.max(max, l.lineNumber), fromLineNumber); // max\n\t\t\t\t\tconst lineHeight = decoration.reduce((max, l) => Math.max(max, l.specialHeight), 0);\n\t\t\t\t\ttoReAdd.push({\n\t\t\t\t\t\tdecorationId,\n\t\t\t\t\t\tstartLineNumber,\n\t\t\t\t\t\tendLineNumber,\n\t\t\t\t\t\tlineHeight\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const dec of toReAdd) {\n\t\t\t\tthis.insertOrChangeCustomLineHeight(dec.decorationId, dec.startLineNumber, dec.endLineNumber, dec.lineHeight);\n\t\t\t}\n\t\t\tthis.commit();\n\t\t}\n\t}\n\n\tpublic commit(): void {\n\t\tif (!this._hasPending) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const pendingChange of this._pendingSpecialLinesToInsert) {\n\t\t\tconst candidateInsertionIndex = this._binarySearchOverOrderedCustomLinesArray(pendingChange.lineNumber);\n\t\t\tconst insertionIndex = candidateInsertionIndex >= 0 ? candidateInsertionIndex : -(candidateInsertionIndex + 1);\n\t\t\tthis._orderedCustomLines.splice(insertionIndex, 0, pendingChange);\n\t\t\tthis._invalidIndex = Math.min(this._invalidIndex, insertionIndex);\n\t\t}\n\t\tthis._pendingSpecialLinesToInsert = [];\n\t\tconst newDecorationIDToSpecialLine = new ArrayMap<string, CustomLine>();\n\t\tconst newOrderedSpecialLines: CustomLine[] = [];\n\n\t\tfor (let i = 0; i < this._invalidIndex; i++) {\n\t\t\tconst customLine = this._orderedCustomLines[i];\n\t\t\tnewOrderedSpecialLines.push(customLine);\n\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t}\n\n\t\tlet numberOfDeletions = 0;\n\t\tlet previousSpecialLine: CustomLine | undefined = (this._invalidIndex > 0) ? newOrderedSpecialLines[this._invalidIndex - 1] : undefined;\n\t\tfor (let i = this._invalidIndex; i < this._orderedCustomLines.length; i++) {\n\t\t\tconst customLine = this._orderedCustomLines[i];\n\t\t\tif (customLine.deleted) {\n\t\t\t\tnumberOfDeletions++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcustomLine.index = i - numberOfDeletions;\n\t\t\tif (previousSpecialLine && previousSpecialLine.lineNumber === customLine.lineNumber) {\n\t\t\t\tcustomLine.maximumSpecialHeight = previousSpecialLine.maximumSpecialHeight;\n\t\t\t\tcustomLine.prefixSum = previousSpecialLine.prefixSum;\n\t\t\t} else {\n\t\t\t\tlet maximumSpecialHeight = customLine.specialHeight;\n\t\t\t\tfor (let j = i; j < this._orderedCustomLines.length; j++) {\n\t\t\t\t\tconst nextSpecialLine = this._orderedCustomLines[j];\n\t\t\t\t\tif (nextSpecialLine.deleted) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nextSpecialLine.lineNumber !== customLine.lineNumber) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmaximumSpecialHeight = Math.max(maximumSpecialHeight, nextSpecialLine.specialHeight);\n\t\t\t\t}\n\t\t\t\tcustomLine.maximumSpecialHeight = maximumSpecialHeight;\n\n\t\t\t\tlet prefixSum: number;\n\t\t\t\tif (previousSpecialLine) {\n\t\t\t\t\tprefixSum = previousSpecialLine.prefixSum + previousSpecialLine.maximumSpecialHeight + this._defaultLineHeight * (customLine.lineNumber - previousSpecialLine.lineNumber - 1);\n\t\t\t\t} else {\n\t\t\t\t\tprefixSum = this._defaultLineHeight * (customLine.lineNumber - 1);\n\t\t\t\t}\n\t\t\t\tcustomLine.prefixSum = prefixSum;\n\t\t\t}\n\t\t\tpreviousSpecialLine = customLine;\n\t\t\tnewOrderedSpecialLines.push(customLine);\n\t\t\tnewDecorationIDToSpecialLine.add(customLine.decorationId, customLine);\n\t\t}\n\t\tthis._orderedCustomLines = newOrderedSpecialLines;\n\t\tthis._decorationIDToCustomLine = newDecorationIDToSpecialLine;\n\t\tthis._invalidIndex = Infinity;\n\t\tthis._hasPending = false;\n\t}\n\n\tprivate _binarySearchOverOrderedCustomLinesArray(lineNumber: number): number {\n\t\treturn binarySearch2(this._orderedCustomLines.length, (index) => {\n\t\t\tconst line = this._orderedCustomLines[index];\n\t\t\tif (line.lineNumber === lineNumber) {\n\t\t\t\treturn 0;\n\t\t\t} else if (line.lineNumber < lineNumber) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport interface ICustomLineHeightData {\n\treadonly decorationId: string;\n\treadonly startLineNumber: number;\n\treadonly endLineNumber: number;\n\treadonly lineHeight: number;\n}\n\nclass ArrayMap<K, T> {\n\n\tprivate _map: Map<K, T[]> = new Map<K, T[]>();\n\n\tconstructor() { }\n\n\tadd(key: K, value: T) {\n\t\tconst array = this._map.get(key);\n\t\tif (!array) {\n\t\t\tthis._map.set(key, [value]);\n\t\t} else {\n\t\t\tarray.push(value);\n\t\t}\n\t}\n\n\tget(key: K): T[] | undefined {\n\t\treturn this._map.get(key);\n\t}\n\n\tdelete(key: K): void {\n\t\tthis._map.delete(key);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1456, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/viewLayout/linesLayout.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/vs/editor/common/viewLayout/linesLayout.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IEditorWhitespace, IPartialViewLinesViewportData, ILineHeightChangeAccessor, IViewWhitespaceViewportData, IWhitespaceChangeAccessor } from '../viewModel.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ICustomLineHeightData, LineHeightsManager } from './lineHeights.js';\n\ninterface IPendingChange { id: string; newAfterLineNumber: number; newHeight: number }\ninterface IPendingRemove { id: string }\n\nclass PendingChanges {\n\tprivate _hasPending: boolean;\n\tprivate _inserts: EditorWhitespace[];\n\tprivate _changes: IPendingChange[];\n\tprivate _removes: IPendingRemove[];\n\n\tconstructor() {\n\t\tthis._hasPending = false;\n\t\tthis._inserts = [];\n\t\tthis._changes = [];\n\t\tthis._removes = [];\n\t}\n\n\tpublic insert(x: EditorWhitespace): void {\n\t\tthis._hasPending = true;\n\t\tthis._inserts.push(x);\n\t}\n\n\tpublic change(x: IPendingChange): void {\n\t\tthis._hasPending = true;\n\t\tthis._changes.push(x);\n\t}\n\n\tpublic remove(x: IPendingRemove): void {\n\t\tthis._hasPending = true;\n\t\tthis._removes.push(x);\n\t}\n\n\tpublic commit(linesLayout: LinesLayout): void {\n\t\tif (!this._hasPending) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst inserts = this._inserts;\n\t\tconst changes = this._changes;\n\t\tconst removes = this._removes;\n\n\t\tthis._hasPending = false;\n\t\tthis._inserts = [];\n\t\tthis._changes = [];\n\t\tthis._removes = [];\n\n\t\tlinesLayout._commitPendingChanges(inserts, changes, removes);\n\t}\n}\n\nexport class EditorWhitespace implements IEditorWhitespace {\n\tpublic id: string;\n\tpublic afterLineNumber: number;\n\tpublic ordinal: number;\n\tpublic height: number;\n\tpublic minWidth: number;\n\tpublic prefixSum: number;\n\n\tconstructor(id: string, afterLineNumber: number, ordinal: number, height: number, minWidth: number) {\n\t\tthis.id = id;\n\t\tthis.afterLineNumber = afterLineNumber;\n\t\tthis.ordinal = ordinal;\n\t\tthis.height = height;\n\t\tthis.minWidth = minWidth;\n\t\tthis.prefixSum = 0;\n\t}\n}\n\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n\n\tprivate static INSTANCE_COUNT = 0;\n\n\tprivate readonly _instanceId: string;\n\tprivate readonly _pendingChanges: PendingChanges;\n\tprivate _lastWhitespaceId: number;\n\tprivate _arr: EditorWhitespace[];\n\tprivate _prefixSumValidIndex: number;\n\tprivate _minWidth: number;\n\tprivate _lineCount: number;\n\tprivate _paddingTop: number;\n\tprivate _paddingBottom: number;\n\tprivate _lineHeightsManager: LineHeightsManager;\n\n\tconstructor(lineCount: number, defaultLineHeight: number, paddingTop: number, paddingBottom: number, customLineHeightData: ICustomLineHeightData[]) {\n\t\tthis._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n\t\tthis._pendingChanges = new PendingChanges();\n\t\tthis._lastWhitespaceId = 0;\n\t\tthis._arr = [];\n\t\tthis._prefixSumValidIndex = -1;\n\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\tthis._lineCount = lineCount;\n\t\tthis._paddingTop = paddingTop;\n\t\tthis._paddingBottom = paddingBottom;\n\t\tthis._lineHeightsManager = new LineHeightsManager(defaultLineHeight, customLineHeightData);\n\t}\n\n\t/**\n\t * Find the insertion index for a new value inside a sorted array of values.\n\t * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n\t */\n\tpublic static findInsertionIndex(arr: EditorWhitespace[], afterLineNumber: number, ordinal: number): number {\n\t\tlet low = 0;\n\t\tlet high = arr.length;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = ((low + high) >>> 1);\n\n\t\t\tif (afterLineNumber === arr[mid].afterLineNumber) {\n\t\t\t\tif (ordinal < arr[mid].ordinal) {\n\t\t\t\t\thigh = mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t}\n\t\t\t} else if (afterLineNumber < arr[mid].afterLineNumber) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/**\n\t * Change the height of a line in pixels.\n\t */\n\tpublic setDefaultLineHeight(lineHeight: number): void {\n\t\tthis._lineHeightsManager.defaultLineHeight = lineHeight;\n\t}\n\n\t/**\n\t * Changes the padding used to calculate vertical offsets.\n\t */\n\tpublic setPadding(paddingTop: number, paddingBottom: number): void {\n\t\tthis._paddingTop = paddingTop;\n\t\tthis._paddingBottom = paddingBottom;\n\t}\n\n\t/**\n\t * Set the number of lines.\n\t *\n\t * @param lineCount New number of lines.\n\t */\n\tpublic onFlushed(lineCount: number, customLineHeightData: ICustomLineHeightData[]): void {\n\t\tthis._lineCount = lineCount;\n\t\tthis._lineHeightsManager = new LineHeightsManager(this._lineHeightsManager.defaultLineHeight, customLineHeightData);\n\t}\n\n\tpublic changeLineHeights(callback: (accessor: ILineHeightChangeAccessor) => void): boolean {\n\t\tlet hadAChange = false;\n\t\ttry {\n\t\t\tconst accessor: ILineHeightChangeAccessor = {\n\t\t\t\tinsertOrChangeCustomLineHeight: (decorationId: string, startLineNumber: number, endLineNumber: number, lineHeight: number): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._lineHeightsManager.insertOrChangeCustomLineHeight(decorationId, startLineNumber, endLineNumber, lineHeight);\n\t\t\t\t},\n\t\t\t\tremoveCustomLineHeight: (decorationId: string): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._lineHeightsManager.removeCustomLineHeight(decorationId);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcallback(accessor);\n\t\t} finally {\n\t\t\tthis._lineHeightsManager.commit();\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic changeWhitespace(callback: (accessor: IWhitespaceChangeAccessor) => void): boolean {\n\t\tlet hadAChange = false;\n\t\ttry {\n\t\t\tconst accessor: IWhitespaceChangeAccessor = {\n\t\t\t\tinsertWhitespace: (afterLineNumber: number, ordinal: number, heightInPx: number, minWidth: number): string => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tafterLineNumber = afterLineNumber | 0;\n\t\t\t\t\tordinal = ordinal | 0;\n\t\t\t\t\theightInPx = heightInPx | 0;\n\t\t\t\t\tminWidth = minWidth | 0;\n\t\t\t\t\tconst id = this._instanceId + (++this._lastWhitespaceId);\n\t\t\t\t\tthis._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n\t\t\t\t\treturn id;\n\t\t\t\t},\n\t\t\t\tchangeOneWhitespace: (id: string, newAfterLineNumber: number, newHeight: number): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tnewAfterLineNumber = newAfterLineNumber | 0;\n\t\t\t\t\tnewHeight = newHeight | 0;\n\t\t\t\t\tthis._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n\t\t\t\t},\n\t\t\t\tremoveWhitespace: (id: string): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._pendingChanges.remove({ id });\n\t\t\t\t}\n\t\t\t};\n\t\t\tcallback(accessor);\n\t\t} finally {\n\t\t\tthis._pendingChanges.commit(this);\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic _commitPendingChanges(inserts: EditorWhitespace[], changes: IPendingChange[], removes: IPendingRemove[]): void {\n\t\tif (inserts.length > 0 || removes.length > 0) {\n\t\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\t}\n\n\t\tif (inserts.length + changes.length + removes.length <= 1) {\n\t\t\t// when only one thing happened, handle it \"delicately\"\n\t\t\tfor (const insert of inserts) {\n\t\t\t\tthis._insertWhitespace(insert);\n\t\t\t}\n\t\t\tfor (const change of changes) {\n\t\t\t\tthis._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n\t\t\t}\n\t\t\tfor (const remove of removes) {\n\t\t\t\tconst index = this._findWhitespaceIndex(remove.id);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._removeWhitespace(index);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// simply rebuild the entire datastructure\n\n\t\tconst toRemove = new Set<string>();\n\t\tfor (const remove of removes) {\n\t\t\ttoRemove.add(remove.id);\n\t\t}\n\n\t\tconst toChange = new Map<string, IPendingChange>();\n\t\tfor (const change of changes) {\n\t\t\ttoChange.set(change.id, change);\n\t\t}\n\n\t\tconst applyRemoveAndChange = (whitespaces: EditorWhitespace[]): EditorWhitespace[] => {\n\t\t\tconst result: EditorWhitespace[] = [];\n\t\t\tfor (const whitespace of whitespaces) {\n\t\t\t\tif (toRemove.has(whitespace.id)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (toChange.has(whitespace.id)) {\n\t\t\t\t\tconst change = toChange.get(whitespace.id)!;\n\t\t\t\t\twhitespace.afterLineNumber = change.newAfterLineNumber;\n\t\t\t\t\twhitespace.height = change.newHeight;\n\t\t\t\t}\n\t\t\t\tresult.push(whitespace);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tconst result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n\t\tresult.sort((a, b) => {\n\t\t\tif (a.afterLineNumber === b.afterLineNumber) {\n\t\t\t\treturn a.ordinal - b.ordinal;\n\t\t\t}\n\t\t\treturn a.afterLineNumber - b.afterLineNumber;\n\t\t});\n\n\t\tthis._arr = result;\n\t\tthis._prefixSumValidIndex = -1;\n\t}\n\n\tprivate _insertWhitespace(whitespace: EditorWhitespace): void {\n\t\tconst insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n\t\tthis._arr.splice(insertIndex, 0, whitespace);\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n\t}\n\n\tprivate _findWhitespaceIndex(id: string): number {\n\t\tconst arr = this._arr;\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i].id === id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate _changeOneWhitespace(id: string, newAfterLineNumber: number, newHeight: number): void {\n\t\tconst index = this._findWhitespaceIndex(id);\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._arr[index].height !== newHeight) {\n\t\t\tthis._arr[index].height = newHeight;\n\t\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n\t\t}\n\t\tif (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n\t\t\t// `afterLineNumber` changed for this whitespace\n\n\t\t\t// Record old whitespace\n\t\t\tconst whitespace = this._arr[index];\n\n\t\t\t// Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n\t\t\tthis._removeWhitespace(index);\n\n\t\t\twhitespace.afterLineNumber = newAfterLineNumber;\n\n\t\t\t// And add it again\n\t\t\tthis._insertWhitespace(whitespace);\n\t\t}\n\t}\n\n\tprivate _removeWhitespace(removeIndex: number): void {\n\t\tthis._arr.splice(removeIndex, 1);\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been deleted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the deletion started, inclusive\n\t * @param toLineNumber The line number at which the deletion ended, inclusive\n\t */\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tthis._lineCount -= (toLineNumber - fromLineNumber + 1);\n\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\tconst afterLineNumber = this._arr[i].afterLineNumber;\n\n\t\t\tif (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been deleted\n\t\t\t\t//  => move whitespace to before first deleted line\n\t\t\t\tthis._arr[i].afterLineNumber = fromLineNumber - 1;\n\t\t\t} else if (afterLineNumber > toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been moved up\n\t\t\t\t//  => move whitespace up\n\t\t\t\tthis._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t\tthis._lineHeightsManager.onLinesDeleted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been inserted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the insertion started, inclusive\n\t * @param toLineNumber The line number at which the insertion ended, inclusive.\n\t */\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tthis._lineCount += (toLineNumber - fromLineNumber + 1);\n\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\tconst afterLineNumber = this._arr[i].afterLineNumber;\n\n\t\t\tif (fromLineNumber <= afterLineNumber) {\n\t\t\t\tthis._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t\tthis._lineHeightsManager.onLinesInserted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Get the sum of all the whitespaces.\n\t */\n\tpublic getWhitespacesTotalHeight(): number {\n\t\tif (this._arr.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n\t}\n\n\t/**\n\t * Return the sum of the heights of the whitespaces at [0..index].\n\t * This includes the whitespace at `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n\t */\n\tpublic getWhitespacesAccumulatedHeight(index: number): number {\n\t\tindex = index | 0;\n\n\t\tlet startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n\t\tif (startIndex === 0) {\n\t\t\tthis._arr[0].prefixSum = this._arr[0].height;\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n\t\t}\n\t\tthis._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n\t\treturn this._arr[index].prefixSum;\n\t}\n\n\t/**\n\t * Get the sum of heights for all objects.\n\t *\n\t * @return The sum of heights for all objects.\n\t */\n\tpublic getLinesTotalHeight(): number {\n\t\tconst linesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(this._lineCount);\n\t\tconst whitespacesHeight = this.getWhitespacesTotalHeight();\n\n\t\treturn linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n\t}\n\n\t/**\n\t * Returns the accumulated height of whitespaces before the given line number.\n\t *\n\t * @param lineNumber The line number\n\t */\n\tpublic getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tconst lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n\t\tif (lastWhitespaceBeforeLineNumber === -1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n\t}\n\n\tprivate _findLastWhitespaceBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\t// Find the whitespace before line number\n\t\tconst arr = this._arr;\n\t\tlet low = 0;\n\t\tlet high = arr.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst delta = (high - low) | 0;\n\t\t\tconst halfDelta = (delta / 2) | 0;\n\t\t\tconst mid = (low + halfDelta) | 0;\n\n\t\t\tif (arr[mid].afterLineNumber < lineNumber) {\n\t\t\t\tif (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n\t\t\t\t\treturn mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = (mid + 1) | 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thigh = (mid - 1) | 0;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findFirstWhitespaceAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tconst lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\t\tconst firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n\n\t\tif (firstWhitespaceAfterLineNumber < this._arr.length) {\n\t\t\treturn firstWhitespaceAfterLineNumber;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n\t * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n\t */\n\tpublic getFirstWhitespaceIndexAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\treturn this._findFirstWhitespaceAfterLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n\t *\n\t * @param lineNumber The line number\n\t * @return The sum of heights for all objects above `lineNumber`.\n\t */\n\tpublic getVerticalOffsetForLineNumber(lineNumber: number, includeViewZones = false): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tlet previousLinesHeight: number;\n\t\tif (lineNumber > 1) {\n\t\t\tpreviousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber - 1);\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tconst previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\tpublic getLineHeightForLineNumber(lineNumber: number): number {\n\t\treturn this._lineHeightsManager.heightForLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * Get the vertical offset (the sum of heights for all objects above) a certain line number and also the line height of the line.\n\t *\n\t * @param lineNumber The line number\n\t * @return The sum of heights for all objects above `lineNumber`.\n\t */\n\tpublic getVerticalOffsetAfterLineNumber(lineNumber: number, includeViewZones = false): number {\n\t\tlineNumber = lineNumber | 0;\n\t\tconst previousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber);\n\t\tconst previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\t/**\n\t * The maximum min width for all whitespaces.\n\t */\n\tpublic getWhitespaceMinWidth(): number {\n\t\tif (this._minWidth === -1) {\n\t\t\tlet minWidth = 0;\n\t\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\t\tminWidth = Math.max(minWidth, this._arr[i].minWidth);\n\t\t\t}\n\t\t\tthis._minWidth = minWidth;\n\t\t}\n\t\treturn this._minWidth;\n\t}\n\n\t/**\n\t * Check if `verticalOffset` is below all lines.\n\t */\n\tpublic isAfterLines(verticalOffset: number): boolean {\n\t\tconst totalHeight = this.getLinesTotalHeight();\n\t\treturn verticalOffset > totalHeight;\n\t}\n\n\tpublic isInTopPadding(verticalOffset: number): boolean {\n\t\tif (this._paddingTop === 0) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (verticalOffset < this._paddingTop);\n\t}\n\n\tpublic isInBottomPadding(verticalOffset: number): boolean {\n\t\tif (this._paddingBottom === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst totalHeight = this.getLinesTotalHeight();\n\t\treturn (verticalOffset >= totalHeight - this._paddingBottom);\n\t}\n\n\t/**\n\t * Find the first line number that is at or after vertical offset `verticalOffset`.\n\t * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n\t * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n\t *\n\t * @param verticalOffset The vertical offset to search at.\n\t * @return The line number at or after vertical offset `verticalOffset`.\n\t */\n\tpublic getLineNumberAtOrAfterVerticalOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tif (verticalOffset < 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst linesCount = this._lineCount | 0;\n\t\tlet minLineNumber = 1;\n\t\tlet maxLineNumber = linesCount;\n\n\t\twhile (minLineNumber < maxLineNumber) {\n\t\t\tconst midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n\n\t\t\tconst lineHeight = this.getLineHeightForLineNumber(midLineNumber);\n\t\t\tconst midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n\n\t\t\tif (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n\t\t\t\t// vertical offset is after mid line number\n\t\t\t\tminLineNumber = midLineNumber + 1;\n\t\t\t} else if (verticalOffset >= midLineNumberVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midLineNumber;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before mid line number, but mid line number could still be what we're searching for\n\t\t\t\tmaxLineNumber = midLineNumber;\n\t\t\t}\n\t\t}\n\n\t\tif (minLineNumber > linesCount) {\n\t\t\treturn linesCount;\n\t\t}\n\n\t\treturn minLineNumber;\n\t}\n\n\t/**\n\t * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n\t */\n\tpublic getLinesViewportData(verticalOffset1: number, verticalOffset2: number): IPartialViewLinesViewportData {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\n\t\t// Find first line number\n\t\t// We don't live in a perfect world, so the line number might start before or after verticalOffset1\n\t\tconst startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n\t\tconst startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n\n\t\tlet endLineNumber = this._lineCount | 0;\n\n\t\t// Also keep track of what whitespace we've got\n\t\tlet whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n\t\tconst whitespaceCount = this.getWhitespacesCount() | 0;\n\t\tlet currentWhitespaceHeight: number;\n\t\tlet currentWhitespaceAfterLineNumber: number;\n\n\t\tif (whitespaceIndex === -1) {\n\t\t\twhitespaceIndex = whitespaceCount;\n\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\tcurrentWhitespaceHeight = 0;\n\t\t} else {\n\t\t\tcurrentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\tcurrentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t}\n\n\t\tlet currentVerticalOffset = startLineNumberVerticalOffset;\n\t\tlet currentLineRelativeOffset = currentVerticalOffset;\n\n\t\t// IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n\t\tconst STEP_SIZE = 500000;\n\t\tlet bigNumbersDelta = 0;\n\t\tif (startLineNumberVerticalOffset >= STEP_SIZE) {\n\t\t\t// Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n\t\t\tbigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n\t\t\tbigNumbersDelta = Math.floor(bigNumbersDelta / this._lineHeightsManager.defaultLineHeight) * this._lineHeightsManager.defaultLineHeight;\n\n\t\t\tcurrentLineRelativeOffset -= bigNumbersDelta;\n\t\t}\n\n\t\tconst linesOffsets: number[] = [];\n\n\t\tconst verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n\t\tlet centeredLineNumber = -1;\n\n\t\t// Figure out how far the lines go\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst lineHeight = this.getLineHeightForLineNumber(lineNumber);\n\t\t\tif (centeredLineNumber === -1) {\n\t\t\t\tconst currentLineTop = currentVerticalOffset;\n\t\t\t\tconst currentLineBottom = currentVerticalOffset + lineHeight;\n\t\t\t\tif ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n\t\t\t\t\tcenteredLineNumber = lineNumber;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Count current line height in the vertical offsets\n\t\t\tcurrentVerticalOffset += lineHeight;\n\t\t\tlinesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n\n\t\t\t// Next line starts immediately after this one\n\t\t\tcurrentLineRelativeOffset += lineHeight;\n\t\t\twhile (currentWhitespaceAfterLineNumber === lineNumber) {\n\t\t\t\t// Push down next line with the height of the current whitespace\n\t\t\t\tcurrentLineRelativeOffset += currentWhitespaceHeight;\n\n\t\t\t\t// Count current whitespace in the vertical offsets\n\t\t\t\tcurrentVerticalOffset += currentWhitespaceHeight;\n\t\t\t\twhitespaceIndex++;\n\n\t\t\t\tif (whitespaceIndex >= whitespaceCount) {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t\tcurrentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentVerticalOffset >= verticalOffset2) {\n\t\t\t\t// We have covered the entire viewport area, time to stop\n\t\t\t\tendLineNumber = lineNumber;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (centeredLineNumber === -1) {\n\t\t\tcenteredLineNumber = endLineNumber;\n\t\t}\n\n\t\tconst endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n\n\t\tlet completelyVisibleStartLineNumber = startLineNumber;\n\t\tlet completelyVisibleEndLineNumber = endLineNumber;\n\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tif (startLineNumberVerticalOffset < verticalOffset1) {\n\t\t\t\tcompletelyVisibleStartLineNumber++;\n\t\t\t}\n\t\t}\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tconst endLineHeight = this.getLineHeightForLineNumber(endLineNumber);\n\t\t\tif (endLineNumberVerticalOffset + endLineHeight > verticalOffset2) {\n\t\t\t\tcompletelyVisibleEndLineNumber--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tbigNumbersDelta: bigNumbersDelta,\n\t\t\tstartLineNumber: startLineNumber,\n\t\t\tendLineNumber: endLineNumber,\n\t\t\trelativeVerticalOffset: linesOffsets,\n\t\t\tcenteredLineNumber: centeredLineNumber,\n\t\t\tcompletelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n\t\t\tcompletelyVisibleEndLineNumber: completelyVisibleEndLineNumber,\n\t\t\tlineHeight: this._lineHeightsManager.defaultLineHeight,\n\t\t};\n\t}\n\n\tpublic getVerticalOffsetForWhitespaceIndex(whitespaceIndex: number): number {\n\t\twhitespaceIndex = whitespaceIndex | 0;\n\n\t\tconst afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n\n\t\tlet previousLinesHeight: number;\n\t\tif (afterLineNumber >= 1) {\n\t\t\tpreviousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(afterLineNumber);\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tlet previousWhitespacesHeight: number;\n\t\tif (whitespaceIndex > 0) {\n\t\t\tpreviousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n\t\t} else {\n\t\t\tpreviousWhitespacesHeight = 0;\n\t\t}\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\tpublic getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tlet minWhitespaceIndex = 0;\n\t\tlet maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n\n\t\tif (maxWhitespaceIndex < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Special case: nothing to be found\n\t\tconst maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n\t\tconst maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n\t\tif (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (minWhitespaceIndex < maxWhitespaceIndex) {\n\t\t\tconst midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n\n\t\t\tconst midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n\t\t\tconst midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n\n\t\t\tif (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n\t\t\t\t// vertical offset is after whitespace\n\t\t\t\tminWhitespaceIndex = midWhitespaceIndex + 1;\n\t\t\t} else if (verticalOffset >= midWhitespaceVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midWhitespaceIndex;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n\t\t\t\tmaxWhitespaceIndex = midWhitespaceIndex;\n\t\t\t}\n\t\t}\n\t\treturn minWhitespaceIndex;\n\t}\n\n\t/**\n\t * Get exactly the whitespace that is layouted at `verticalOffset`.\n\t *\n\t * @param verticalOffset The vertical offset.\n\t * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n\t */\n\tpublic getWhitespaceAtVerticalOffset(verticalOffset: number): IViewWhitespaceViewportData | null {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tconst candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n\n\t\tif (candidateIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (candidateIndex >= this.getWhitespacesCount()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n\n\t\tif (candidateTop > verticalOffset) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n\t\tconst candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n\t\tconst candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n\n\t\treturn {\n\t\t\tid: candidateId,\n\t\t\tafterLineNumber: candidateAfterLineNumber,\n\t\t\tverticalOffset: candidateTop,\n\t\t\theight: candidateHeight\n\t\t};\n\t}\n\n\t/**\n\t * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n\t */\n\tpublic getWhitespaceViewportData(verticalOffset1: number, verticalOffset2: number): IViewWhitespaceViewportData[] {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\n\t\tconst startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n\t\tconst endIndex = this.getWhitespacesCount() - 1;\n\n\t\tif (startIndex < 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IViewWhitespaceViewportData[] = [];\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tconst top = this.getVerticalOffsetForWhitespaceIndex(i);\n\t\t\tconst height = this.getHeightForWhitespaceIndex(i);\n\t\t\tif (top >= verticalOffset2) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tid: this.getIdForWhitespaceIndex(i),\n\t\t\t\tafterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n\t\t\t\tverticalOffset: top,\n\t\t\t\theight: height\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get all whitespaces.\n\t */\n\tpublic getWhitespaces(): IEditorWhitespace[] {\n\t\treturn this._arr.slice(0);\n\t}\n\n\t/**\n\t * The number of whitespaces.\n\t */\n\tpublic getWhitespacesCount(): number {\n\t\treturn this._arr.length;\n\t}\n\n\t/**\n\t * Get the `id` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `id` of whitespace at `index`.\n\t */\n\tpublic getIdForWhitespaceIndex(index: number): string {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].id;\n\t}\n\n\t/**\n\t * Get the `afterLineNumber` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `afterLineNumber` of whitespace at `index`.\n\t */\n\tpublic getAfterLineNumberForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].afterLineNumber;\n\t}\n\n\t/**\n\t * Get the `height` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `height` of whitespace at `index`.\n\t */\n\tpublic getHeightForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].height;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IEditorWhitespace, IPartialViewLinesViewportData, ILineHeightChangeAccessor, IViewWhitespaceViewportData, IWhitespaceChangeAccessor } from '../viewModel.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ICustomLineHeightData, LineHeightsManager } from './lineHeights.js';\n\ninterface IPendingChange { id: string; newAfterLineNumber: number; newHeight: number }\ninterface IPendingRemove { id: string }\n\nclass PendingChanges {\n\tprivate _hasPending: boolean;\n\tprivate _inserts: EditorWhitespace[];\n\tprivate _changes: IPendingChange[];\n\tprivate _removes: IPendingRemove[];\n\n\tconstructor() {\n\t\tthis._hasPending = false;\n\t\tthis._inserts = [];\n\t\tthis._changes = [];\n\t\tthis._removes = [];\n\t}\n\n\tpublic insert(x: EditorWhitespace): void {\n\t\tthis._hasPending = true;\n\t\tthis._inserts.push(x);\n\t}\n\n\tpublic change(x: IPendingChange): void {\n\t\tthis._hasPending = true;\n\t\tthis._changes.push(x);\n\t}\n\n\tpublic remove(x: IPendingRemove): void {\n\t\tthis._hasPending = true;\n\t\tthis._removes.push(x);\n\t}\n\n\tpublic commit(linesLayout: LinesLayout): void {\n\t\tif (!this._hasPending) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst inserts = this._inserts;\n\t\tconst changes = this._changes;\n\t\tconst removes = this._removes;\n\n\t\tthis._hasPending = false;\n\t\tthis._inserts = [];\n\t\tthis._changes = [];\n\t\tthis._removes = [];\n\n\t\tlinesLayout._commitPendingChanges(inserts, changes, removes);\n\t}\n}\n\nexport class EditorWhitespace implements IEditorWhitespace {\n\tpublic id: string;\n\tpublic afterLineNumber: number;\n\tpublic ordinal: number;\n\tpublic height: number;\n\tpublic minWidth: number;\n\tpublic prefixSum: number;\n\n\tconstructor(id: string, afterLineNumber: number, ordinal: number, height: number, minWidth: number) {\n\t\tthis.id = id;\n\t\tthis.afterLineNumber = afterLineNumber;\n\t\tthis.ordinal = ordinal;\n\t\tthis.height = height;\n\t\tthis.minWidth = minWidth;\n\t\tthis.prefixSum = 0;\n\t}\n}\n\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n\n\tprivate static INSTANCE_COUNT = 0;\n\n\tprivate readonly _instanceId: string;\n\tprivate readonly _pendingChanges: PendingChanges;\n\tprivate _lastWhitespaceId: number;\n\tprivate _arr: EditorWhitespace[];\n\tprivate _prefixSumValidIndex: number;\n\tprivate _minWidth: number;\n\tprivate _lineCount: number;\n\tprivate _paddingTop: number;\n\tprivate _paddingBottom: number;\n\tprivate _lineHeightsManager: LineHeightsManager;\n\n\tconstructor(lineCount: number, defaultLineHeight: number, paddingTop: number, paddingBottom: number, customLineHeightData: ICustomLineHeightData[]) {\n\t\tthis._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n\t\tthis._pendingChanges = new PendingChanges();\n\t\tthis._lastWhitespaceId = 0;\n\t\tthis._arr = [];\n\t\tthis._prefixSumValidIndex = -1;\n\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\tthis._lineCount = lineCount;\n\t\tthis._paddingTop = paddingTop;\n\t\tthis._paddingBottom = paddingBottom;\n\t\tthis._lineHeightsManager = new LineHeightsManager(defaultLineHeight, customLineHeightData);\n\t}\n\n\t/**\n\t * Find the insertion index for a new value inside a sorted array of values.\n\t * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n\t */\n\tpublic static findInsertionIndex(arr: EditorWhitespace[], afterLineNumber: number, ordinal: number): number {\n\t\tlet low = 0;\n\t\tlet high = arr.length;\n\n\t\twhile (low < high) {\n\t\t\tconst mid = ((low + high) >>> 1);\n\n\t\t\tif (afterLineNumber === arr[mid].afterLineNumber) {\n\t\t\t\tif (ordinal < arr[mid].ordinal) {\n\t\t\t\t\thigh = mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = mid + 1;\n\t\t\t\t}\n\t\t\t} else if (afterLineNumber < arr[mid].afterLineNumber) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/**\n\t * Change the height of a line in pixels.\n\t */\n\tpublic setDefaultLineHeight(lineHeight: number): void {\n\t\tthis._lineHeightsManager.defaultLineHeight = lineHeight;\n\t}\n\n\t/**\n\t * Changes the padding used to calculate vertical offsets.\n\t */\n\tpublic setPadding(paddingTop: number, paddingBottom: number): void {\n\t\tthis._paddingTop = paddingTop;\n\t\tthis._paddingBottom = paddingBottom;\n\t}\n\n\t/**\n\t * Set the number of lines.\n\t *\n\t * @param lineCount New number of lines.\n\t */\n\tpublic onFlushed(lineCount: number, customLineHeightData: ICustomLineHeightData[]): void {\n\t\tthis._lineCount = lineCount;\n\t\tthis._lineHeightsManager = new LineHeightsManager(this._lineHeightsManager.defaultLineHeight, customLineHeightData);\n\t}\n\n\tpublic changeLineHeights(callback: (accessor: ILineHeightChangeAccessor) => void): boolean {\n\t\tlet hadAChange = false;\n\t\ttry {\n\t\t\tconst accessor: ILineHeightChangeAccessor = {\n\t\t\t\tinsertOrChangeCustomLineHeight: (decorationId: string, startLineNumber: number, endLineNumber: number, lineHeight: number): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._lineHeightsManager.insertOrChangeCustomLineHeight(decorationId, startLineNumber, endLineNumber, lineHeight);\n\t\t\t\t},\n\t\t\t\tremoveCustomLineHeight: (decorationId: string): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._lineHeightsManager.removeCustomLineHeight(decorationId);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcallback(accessor);\n\t\t} finally {\n\t\t\tthis._lineHeightsManager.commit();\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic changeWhitespace(callback: (accessor: IWhitespaceChangeAccessor) => void): boolean {\n\t\tlet hadAChange = false;\n\t\ttry {\n\t\t\tconst accessor: IWhitespaceChangeAccessor = {\n\t\t\t\tinsertWhitespace: (afterLineNumber: number, ordinal: number, heightInPx: number, minWidth: number): string => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tafterLineNumber = afterLineNumber | 0;\n\t\t\t\t\tordinal = ordinal | 0;\n\t\t\t\t\theightInPx = heightInPx | 0;\n\t\t\t\t\tminWidth = minWidth | 0;\n\t\t\t\t\tconst id = this._instanceId + (++this._lastWhitespaceId);\n\t\t\t\t\tthis._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n\t\t\t\t\treturn id;\n\t\t\t\t},\n\t\t\t\tchangeOneWhitespace: (id: string, newAfterLineNumber: number, newHeight: number): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tnewAfterLineNumber = newAfterLineNumber | 0;\n\t\t\t\t\tnewHeight = newHeight | 0;\n\t\t\t\t\tthis._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n\t\t\t\t},\n\t\t\t\tremoveWhitespace: (id: string): void => {\n\t\t\t\t\thadAChange = true;\n\t\t\t\t\tthis._pendingChanges.remove({ id });\n\t\t\t\t}\n\t\t\t};\n\t\t\tcallback(accessor);\n\t\t} finally {\n\t\t\tthis._pendingChanges.commit(this);\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic _commitPendingChanges(inserts: EditorWhitespace[], changes: IPendingChange[], removes: IPendingRemove[]): void {\n\t\tif (inserts.length > 0 || removes.length > 0) {\n\t\t\tthis._minWidth = -1; /* marker for not being computed */\n\t\t}\n\n\t\tif (inserts.length + changes.length + removes.length <= 1) {\n\t\t\t// when only one thing happened, handle it \"delicately\"\n\t\t\tfor (const insert of inserts) {\n\t\t\t\tthis._insertWhitespace(insert);\n\t\t\t}\n\t\t\tfor (const change of changes) {\n\t\t\t\tthis._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n\t\t\t}\n\t\t\tfor (const remove of removes) {\n\t\t\t\tconst index = this._findWhitespaceIndex(remove.id);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._removeWhitespace(index);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// simply rebuild the entire datastructure\n\n\t\tconst toRemove = new Set<string>();\n\t\tfor (const remove of removes) {\n\t\t\ttoRemove.add(remove.id);\n\t\t}\n\n\t\tconst toChange = new Map<string, IPendingChange>();\n\t\tfor (const change of changes) {\n\t\t\ttoChange.set(change.id, change);\n\t\t}\n\n\t\tconst applyRemoveAndChange = (whitespaces: EditorWhitespace[]): EditorWhitespace[] => {\n\t\t\tconst result: EditorWhitespace[] = [];\n\t\t\tfor (const whitespace of whitespaces) {\n\t\t\t\tif (toRemove.has(whitespace.id)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (toChange.has(whitespace.id)) {\n\t\t\t\t\tconst change = toChange.get(whitespace.id)!;\n\t\t\t\t\twhitespace.afterLineNumber = change.newAfterLineNumber;\n\t\t\t\t\twhitespace.height = change.newHeight;\n\t\t\t\t}\n\t\t\t\tresult.push(whitespace);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tconst result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n\t\tresult.sort((a, b) => {\n\t\t\tif (a.afterLineNumber === b.afterLineNumber) {\n\t\t\t\treturn a.ordinal - b.ordinal;\n\t\t\t}\n\t\t\treturn a.afterLineNumber - b.afterLineNumber;\n\t\t});\n\n\t\tthis._arr = result;\n\t\tthis._prefixSumValidIndex = -1;\n\t}\n\n\tprivate _insertWhitespace(whitespace: EditorWhitespace): void {\n\t\tconst insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n\t\tthis._arr.splice(insertIndex, 0, whitespace);\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n\t}\n\n\tprivate _findWhitespaceIndex(id: string): number {\n\t\tconst arr = this._arr;\n\t\tfor (let i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i].id === id) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate _changeOneWhitespace(id: string, newAfterLineNumber: number, newHeight: number): void {\n\t\tconst index = this._findWhitespaceIndex(id);\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._arr[index].height !== newHeight) {\n\t\t\tthis._arr[index].height = newHeight;\n\t\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n\t\t}\n\t\tif (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n\t\t\t// `afterLineNumber` changed for this whitespace\n\n\t\t\t// Record old whitespace\n\t\t\tconst whitespace = this._arr[index];\n\n\t\t\t// Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n\t\t\tthis._removeWhitespace(index);\n\n\t\t\twhitespace.afterLineNumber = newAfterLineNumber;\n\n\t\t\t// And add it again\n\t\t\tthis._insertWhitespace(whitespace);\n\t\t}\n\t}\n\n\tprivate _removeWhitespace(removeIndex: number): void {\n\t\tthis._arr.splice(removeIndex, 1);\n\t\tthis._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been deleted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the deletion started, inclusive\n\t * @param toLineNumber The line number at which the deletion ended, inclusive\n\t */\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tthis._lineCount -= (toLineNumber - fromLineNumber + 1);\n\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\tconst afterLineNumber = this._arr[i].afterLineNumber;\n\n\t\t\tif (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been deleted\n\t\t\t\t//  => move whitespace to before first deleted line\n\t\t\t\tthis._arr[i].afterLineNumber = fromLineNumber - 1;\n\t\t\t} else if (afterLineNumber > toLineNumber) {\n\t\t\t\t// The line this whitespace was after has been moved up\n\t\t\t\t//  => move whitespace up\n\t\t\t\tthis._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t\tthis._lineHeightsManager.onLinesDeleted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Notify the layouter that lines have been inserted (a continuous zone of lines).\n\t *\n\t * @param fromLineNumber The line number at which the insertion started, inclusive\n\t * @param toLineNumber The line number at which the insertion ended, inclusive.\n\t */\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tfromLineNumber = fromLineNumber | 0;\n\t\ttoLineNumber = toLineNumber | 0;\n\n\t\tthis._lineCount += (toLineNumber - fromLineNumber + 1);\n\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\tconst afterLineNumber = this._arr[i].afterLineNumber;\n\n\t\t\tif (fromLineNumber <= afterLineNumber) {\n\t\t\t\tthis._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n\t\t\t}\n\t\t}\n\t\tthis._lineHeightsManager.onLinesInserted(fromLineNumber, toLineNumber);\n\t}\n\n\t/**\n\t * Get the sum of all the whitespaces.\n\t */\n\tpublic getWhitespacesTotalHeight(): number {\n\t\tif (this._arr.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n\t}\n\n\t/**\n\t * Return the sum of the heights of the whitespaces at [0..index].\n\t * This includes the whitespace at `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n\t */\n\tpublic getWhitespacesAccumulatedHeight(index: number): number {\n\t\tindex = index | 0;\n\n\t\tlet startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n\t\tif (startIndex === 0) {\n\t\t\tthis._arr[0].prefixSum = this._arr[0].height;\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n\t\t}\n\t\tthis._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n\t\treturn this._arr[index].prefixSum;\n\t}\n\n\t/**\n\t * Get the sum of heights for all objects.\n\t *\n\t * @return The sum of heights for all objects.\n\t */\n\tpublic getLinesTotalHeight(): number {\n\t\tconst linesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(this._lineCount);\n\t\tconst whitespacesHeight = this.getWhitespacesTotalHeight();\n\n\t\treturn linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n\t}\n\n\t/**\n\t * Returns the accumulated height of whitespaces before the given line number.\n\t *\n\t * @param lineNumber The line number\n\t */\n\tpublic getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tconst lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n\t\tif (lastWhitespaceBeforeLineNumber === -1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n\t}\n\n\tprivate _findLastWhitespaceBeforeLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\t// Find the whitespace before line number\n\t\tconst arr = this._arr;\n\t\tlet low = 0;\n\t\tlet high = arr.length - 1;\n\n\t\twhile (low <= high) {\n\t\t\tconst delta = (high - low) | 0;\n\t\t\tconst halfDelta = (delta / 2) | 0;\n\t\t\tconst mid = (low + halfDelta) | 0;\n\n\t\t\tif (arr[mid].afterLineNumber < lineNumber) {\n\t\t\t\tif (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n\t\t\t\t\treturn mid;\n\t\t\t\t} else {\n\t\t\t\t\tlow = (mid + 1) | 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thigh = (mid - 1) | 0;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tprivate _findFirstWhitespaceAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tconst lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\t\tconst firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n\n\t\tif (firstWhitespaceAfterLineNumber < this._arr.length) {\n\t\t\treturn firstWhitespaceAfterLineNumber;\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n\t * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n\t */\n\tpublic getFirstWhitespaceIndexAfterLineNumber(lineNumber: number): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\treturn this._findFirstWhitespaceAfterLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n\t *\n\t * @param lineNumber The line number\n\t * @return The sum of heights for all objects above `lineNumber`.\n\t */\n\tpublic getVerticalOffsetForLineNumber(lineNumber: number, includeViewZones = false): number {\n\t\tlineNumber = lineNumber | 0;\n\n\t\tlet previousLinesHeight: number;\n\t\tif (lineNumber > 1) {\n\t\t\tpreviousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber - 1);\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tconst previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\tpublic getLineHeightForLineNumber(lineNumber: number): number {\n\t\treturn this._lineHeightsManager.heightForLineNumber(lineNumber);\n\t}\n\n\t/**\n\t * Get the vertical offset (the sum of heights for all objects above) a certain line number and also the line height of the line.\n\t *\n\t * @param lineNumber The line number\n\t * @return The sum of heights for all objects above `lineNumber`.\n\t */\n\tpublic getVerticalOffsetAfterLineNumber(lineNumber: number, includeViewZones = false): number {\n\t\tlineNumber = lineNumber | 0;\n\t\tconst previousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(lineNumber);\n\t\tconst previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\t/**\n\t * The maximum min width for all whitespaces.\n\t */\n\tpublic getWhitespaceMinWidth(): number {\n\t\tif (this._minWidth === -1) {\n\t\t\tlet minWidth = 0;\n\t\t\tfor (let i = 0, len = this._arr.length; i < len; i++) {\n\t\t\t\tminWidth = Math.max(minWidth, this._arr[i].minWidth);\n\t\t\t}\n\t\t\tthis._minWidth = minWidth;\n\t\t}\n\t\treturn this._minWidth;\n\t}\n\n\t/**\n\t * Check if `verticalOffset` is below all lines.\n\t */\n\tpublic isAfterLines(verticalOffset: number): boolean {\n\t\tconst totalHeight = this.getLinesTotalHeight();\n\t\treturn verticalOffset > totalHeight;\n\t}\n\n\tpublic isInTopPadding(verticalOffset: number): boolean {\n\t\tif (this._paddingTop === 0) {\n\t\t\treturn false;\n\t\t}\n\t\treturn (verticalOffset < this._paddingTop);\n\t}\n\n\tpublic isInBottomPadding(verticalOffset: number): boolean {\n\t\tif (this._paddingBottom === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst totalHeight = this.getLinesTotalHeight();\n\t\treturn (verticalOffset >= totalHeight - this._paddingBottom);\n\t}\n\n\t/**\n\t * Find the first line number that is at or after vertical offset `verticalOffset`.\n\t * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n\t * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n\t *\n\t * @param verticalOffset The vertical offset to search at.\n\t * @return The line number at or after vertical offset `verticalOffset`.\n\t */\n\tpublic getLineNumberAtOrAfterVerticalOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tif (verticalOffset < 0) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst linesCount = this._lineCount | 0;\n\t\tlet minLineNumber = 1;\n\t\tlet maxLineNumber = linesCount;\n\n\t\twhile (minLineNumber < maxLineNumber) {\n\t\t\tconst midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n\n\t\t\tconst lineHeight = this.getLineHeightForLineNumber(midLineNumber);\n\t\t\tconst midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n\n\t\t\tif (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n\t\t\t\t// vertical offset is after mid line number\n\t\t\t\tminLineNumber = midLineNumber + 1;\n\t\t\t} else if (verticalOffset >= midLineNumberVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midLineNumber;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before mid line number, but mid line number could still be what we're searching for\n\t\t\t\tmaxLineNumber = midLineNumber;\n\t\t\t}\n\t\t}\n\n\t\tif (minLineNumber > linesCount) {\n\t\t\treturn linesCount;\n\t\t}\n\n\t\treturn minLineNumber;\n\t}\n\n\t/**\n\t * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n\t */\n\tpublic getLinesViewportData(verticalOffset1: number, verticalOffset2: number): IPartialViewLinesViewportData {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\n\t\t// Find first line number\n\t\t// We don't live in a perfect world, so the line number might start before or after verticalOffset1\n\t\tconst startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n\t\tconst startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n\n\t\tlet endLineNumber = this._lineCount | 0;\n\n\t\t// Also keep track of what whitespace we've got\n\t\tlet whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n\t\tconst whitespaceCount = this.getWhitespacesCount() | 0;\n\t\tlet currentWhitespaceHeight: number;\n\t\tlet currentWhitespaceAfterLineNumber: number;\n\n\t\tif (whitespaceIndex === -1) {\n\t\t\twhitespaceIndex = whitespaceCount;\n\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\tcurrentWhitespaceHeight = 0;\n\t\t} else {\n\t\t\tcurrentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\tcurrentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t}\n\n\t\tlet currentVerticalOffset = startLineNumberVerticalOffset;\n\t\tlet currentLineRelativeOffset = currentVerticalOffset;\n\n\t\t// IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n\t\tconst STEP_SIZE = 500000;\n\t\tlet bigNumbersDelta = 0;\n\t\tif (startLineNumberVerticalOffset >= STEP_SIZE) {\n\t\t\t// Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n\t\t\tbigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n\t\t\tbigNumbersDelta = Math.floor(bigNumbersDelta / this._lineHeightsManager.defaultLineHeight) * this._lineHeightsManager.defaultLineHeight;\n\n\t\t\tcurrentLineRelativeOffset -= bigNumbersDelta;\n\t\t}\n\n\t\tconst linesOffsets: number[] = [];\n\n\t\tconst verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n\t\tlet centeredLineNumber = -1;\n\n\t\t// Figure out how far the lines go\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst lineHeight = this.getLineHeightForLineNumber(lineNumber);\n\t\t\tif (centeredLineNumber === -1) {\n\t\t\t\tconst currentLineTop = currentVerticalOffset;\n\t\t\t\tconst currentLineBottom = currentVerticalOffset + lineHeight;\n\t\t\t\tif ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n\t\t\t\t\tcenteredLineNumber = lineNumber;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Count current line height in the vertical offsets\n\t\t\tcurrentVerticalOffset += lineHeight;\n\t\t\tlinesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n\n\t\t\t// Next line starts immediately after this one\n\t\t\tcurrentLineRelativeOffset += lineHeight;\n\t\t\twhile (currentWhitespaceAfterLineNumber === lineNumber) {\n\t\t\t\t// Push down next line with the height of the current whitespace\n\t\t\t\tcurrentLineRelativeOffset += currentWhitespaceHeight;\n\n\t\t\t\t// Count current whitespace in the vertical offsets\n\t\t\t\tcurrentVerticalOffset += currentWhitespaceHeight;\n\t\t\t\twhitespaceIndex++;\n\n\t\t\t\tif (whitespaceIndex >= whitespaceCount) {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = endLineNumber + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t\tcurrentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentVerticalOffset >= verticalOffset2) {\n\t\t\t\t// We have covered the entire viewport area, time to stop\n\t\t\t\tendLineNumber = lineNumber;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (centeredLineNumber === -1) {\n\t\t\tcenteredLineNumber = endLineNumber;\n\t\t}\n\n\t\tconst endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n\n\t\tlet completelyVisibleStartLineNumber = startLineNumber;\n\t\tlet completelyVisibleEndLineNumber = endLineNumber;\n\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tif (startLineNumberVerticalOffset < verticalOffset1) {\n\t\t\t\tcompletelyVisibleStartLineNumber++;\n\t\t\t}\n\t\t}\n\t\tif (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n\t\t\tconst endLineHeight = this.getLineHeightForLineNumber(endLineNumber);\n\t\t\tif (endLineNumberVerticalOffset + endLineHeight > verticalOffset2) {\n\t\t\t\tcompletelyVisibleEndLineNumber--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tbigNumbersDelta: bigNumbersDelta,\n\t\t\tstartLineNumber: startLineNumber,\n\t\t\tendLineNumber: endLineNumber,\n\t\t\trelativeVerticalOffset: linesOffsets,\n\t\t\tcenteredLineNumber: centeredLineNumber,\n\t\t\tcompletelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n\t\t\tcompletelyVisibleEndLineNumber: completelyVisibleEndLineNumber,\n\t\t\tlineHeight: this._lineHeightsManager.defaultLineHeight,\n\t\t};\n\t}\n\n\tpublic getVerticalOffsetForWhitespaceIndex(whitespaceIndex: number): number {\n\t\twhitespaceIndex = whitespaceIndex | 0;\n\n\t\tconst afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n\n\t\tlet previousLinesHeight: number;\n\t\tif (afterLineNumber >= 1) {\n\t\t\tpreviousLinesHeight = this._lineHeightsManager.getAccumulatedLineHeightsIncludingLineNumber(afterLineNumber);\n\t\t} else {\n\t\t\tpreviousLinesHeight = 0;\n\t\t}\n\n\t\tlet previousWhitespacesHeight: number;\n\t\tif (whitespaceIndex > 0) {\n\t\t\tpreviousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n\t\t} else {\n\t\t\tpreviousWhitespacesHeight = 0;\n\t\t}\n\t\treturn previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n\t}\n\n\tpublic getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset: number): number {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tlet minWhitespaceIndex = 0;\n\t\tlet maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n\n\t\tif (maxWhitespaceIndex < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Special case: nothing to be found\n\t\tconst maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n\t\tconst maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n\t\tif (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (minWhitespaceIndex < maxWhitespaceIndex) {\n\t\t\tconst midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n\n\t\t\tconst midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n\t\t\tconst midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n\n\t\t\tif (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n\t\t\t\t// vertical offset is after whitespace\n\t\t\t\tminWhitespaceIndex = midWhitespaceIndex + 1;\n\t\t\t} else if (verticalOffset >= midWhitespaceVerticalOffset) {\n\t\t\t\t// Hit\n\t\t\t\treturn midWhitespaceIndex;\n\t\t\t} else {\n\t\t\t\t// vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n\t\t\t\tmaxWhitespaceIndex = midWhitespaceIndex;\n\t\t\t}\n\t\t}\n\t\treturn minWhitespaceIndex;\n\t}\n\n\t/**\n\t * Get exactly the whitespace that is layouted at `verticalOffset`.\n\t *\n\t * @param verticalOffset The vertical offset.\n\t * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n\t */\n\tpublic getWhitespaceAtVerticalOffset(verticalOffset: number): IViewWhitespaceViewportData | null {\n\t\tverticalOffset = verticalOffset | 0;\n\n\t\tconst candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n\n\t\tif (candidateIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (candidateIndex >= this.getWhitespacesCount()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n\n\t\tif (candidateTop > verticalOffset) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n\t\tconst candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n\t\tconst candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n\n\t\treturn {\n\t\t\tid: candidateId,\n\t\t\tafterLineNumber: candidateAfterLineNumber,\n\t\t\tverticalOffset: candidateTop,\n\t\t\theight: candidateHeight\n\t\t};\n\t}\n\n\t/**\n\t * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n\t *\n\t * @param verticalOffset1 The beginning of the viewport.\n\t * @param verticalOffset2 The end of the viewport.\n\t * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n\t */\n\tpublic getWhitespaceViewportData(verticalOffset1: number, verticalOffset2: number): IViewWhitespaceViewportData[] {\n\t\tverticalOffset1 = verticalOffset1 | 0;\n\t\tverticalOffset2 = verticalOffset2 | 0;\n\n\t\tconst startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n\t\tconst endIndex = this.getWhitespacesCount() - 1;\n\n\t\tif (startIndex < 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result: IViewWhitespaceViewportData[] = [];\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tconst top = this.getVerticalOffsetForWhitespaceIndex(i);\n\t\t\tconst height = this.getHeightForWhitespaceIndex(i);\n\t\t\tif (top >= verticalOffset2) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult.push({\n\t\t\t\tid: this.getIdForWhitespaceIndex(i),\n\t\t\t\tafterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n\t\t\t\tverticalOffset: top,\n\t\t\t\theight: height\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get all whitespaces.\n\t */\n\tpublic getWhitespaces(): IEditorWhitespace[] {\n\t\treturn this._arr.slice(0);\n\t}\n\n\t/**\n\t * The number of whitespaces.\n\t */\n\tpublic getWhitespacesCount(): number {\n\t\treturn this._arr.length;\n\t}\n\n\t/**\n\t * Get the `id` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `id` of whitespace at `index`.\n\t */\n\tpublic getIdForWhitespaceIndex(index: number): string {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].id;\n\t}\n\n\t/**\n\t * Get the `afterLineNumber` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `afterLineNumber` of whitespace at `index`.\n\t */\n\tpublic getAfterLineNumberForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].afterLineNumber;\n\t}\n\n\t/**\n\t * Get the `height` for whitespace at index `index`.\n\t *\n\t * @param index The index of the whitespace.\n\t * @return `height` of whitespace at `index`.\n\t */\n\tpublic getHeightForWhitespaceIndex(index: number): number {\n\t\tindex = index | 0;\n\n\t\treturn this._arr[index].height;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2190, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/viewLayout/viewLayout.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/vs/editor/common/viewLayout/viewLayout.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from '../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { IScrollPosition, ScrollEvent, Scrollable, ScrollbarVisibility, INewScrollPosition } from '../../../base/common/scrollable.js';\nimport { ConfigurationChangedEvent, EditorOption } from '../config/editorOptions.js';\nimport { ScrollType } from '../editorCommon.js';\nimport { IEditorConfiguration } from '../config/editorConfiguration.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { IEditorWhitespace, IPartialViewLinesViewportData, ILineHeightChangeAccessor, IViewLayout, IViewWhitespaceViewportData, IWhitespaceChangeAccessor, Viewport } from '../viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ICustomLineHeightData } from './lineHeights.js';\n\nconst SMOOTH_SCROLLING_TIME = 125;\n\nclass EditorScrollDimensions {\n\n\tpublic readonly width: number;\n\tpublic readonly contentWidth: number;\n\tpublic readonly scrollWidth: number;\n\n\tpublic readonly height: number;\n\tpublic readonly contentHeight: number;\n\tpublic readonly scrollHeight: number;\n\n\tconstructor(\n\t\twidth: number,\n\t\tcontentWidth: number,\n\t\theight: number,\n\t\tcontentHeight: number,\n\t) {\n\t\twidth = width | 0;\n\t\tcontentWidth = contentWidth | 0;\n\t\theight = height | 0;\n\t\tcontentHeight = contentHeight | 0;\n\n\t\tif (width < 0) {\n\t\t\twidth = 0;\n\t\t}\n\t\tif (contentWidth < 0) {\n\t\t\tcontentWidth = 0;\n\t\t}\n\n\t\tif (height < 0) {\n\t\t\theight = 0;\n\t\t}\n\t\tif (contentHeight < 0) {\n\t\t\tcontentHeight = 0;\n\t\t}\n\n\t\tthis.width = width;\n\t\tthis.contentWidth = contentWidth;\n\t\tthis.scrollWidth = Math.max(width, contentWidth);\n\n\t\tthis.height = height;\n\t\tthis.contentHeight = contentHeight;\n\t\tthis.scrollHeight = Math.max(height, contentHeight);\n\t}\n\n\tpublic equals(other: EditorScrollDimensions): boolean {\n\t\treturn (\n\t\t\tthis.width === other.width\n\t\t\t&& this.contentWidth === other.contentWidth\n\t\t\t&& this.height === other.height\n\t\t\t&& this.contentHeight === other.contentHeight\n\t\t);\n\t}\n}\n\nclass EditorScrollable extends Disposable {\n\n\tprivate readonly _scrollable: Scrollable;\n\tprivate _dimensions: EditorScrollDimensions;\n\n\tpublic readonly onDidScroll: Event<ScrollEvent>;\n\n\tprivate readonly _onDidContentSizeChange = this._register(new Emitter<ContentSizeChangedEvent>());\n\tpublic readonly onDidContentSizeChange: Event<ContentSizeChangedEvent> = this._onDidContentSizeChange.event;\n\n\tconstructor(smoothScrollDuration: number, scheduleAtNextAnimationFrame: (callback: () => void) => IDisposable) {\n\t\tsuper();\n\t\tthis._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n\t\tthis._scrollable = this._register(new Scrollable({\n\t\t\tforceIntegerValues: true,\n\t\t\tsmoothScrollDuration,\n\t\t\tscheduleAtNextAnimationFrame\n\t\t}));\n\t\tthis.onDidScroll = this._scrollable.onScroll;\n\t}\n\n\tpublic getScrollable(): Scrollable {\n\t\treturn this._scrollable;\n\t}\n\n\tpublic setSmoothScrollDuration(smoothScrollDuration: number): void {\n\t\tthis._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n\t}\n\n\tpublic validateScrollPosition(scrollPosition: INewScrollPosition): IScrollPosition {\n\t\treturn this._scrollable.validateScrollPosition(scrollPosition);\n\t}\n\n\tpublic getScrollDimensions(): EditorScrollDimensions {\n\t\treturn this._dimensions;\n\t}\n\n\tpublic setScrollDimensions(dimensions: EditorScrollDimensions): void {\n\t\tif (this._dimensions.equals(dimensions)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldDimensions = this._dimensions;\n\t\tthis._dimensions = dimensions;\n\n\t\tthis._scrollable.setScrollDimensions({\n\t\t\twidth: dimensions.width,\n\t\t\tscrollWidth: dimensions.scrollWidth,\n\t\t\theight: dimensions.height,\n\t\t\tscrollHeight: dimensions.scrollHeight\n\t\t}, true);\n\n\t\tconst contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n\t\tconst contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n\t\tif (contentWidthChanged || contentHeightChanged) {\n\t\t\tthis._onDidContentSizeChange.fire(new ContentSizeChangedEvent(\n\t\t\t\toldDimensions.contentWidth, oldDimensions.contentHeight,\n\t\t\t\tdimensions.contentWidth, dimensions.contentHeight\n\t\t\t));\n\t\t}\n\t}\n\n\tpublic getFutureScrollPosition(): IScrollPosition {\n\t\treturn this._scrollable.getFutureScrollPosition();\n\t}\n\n\tpublic getCurrentScrollPosition(): IScrollPosition {\n\t\treturn this._scrollable.getCurrentScrollPosition();\n\t}\n\n\tpublic setScrollPositionNow(update: INewScrollPosition): void {\n\t\tthis._scrollable.setScrollPositionNow(update);\n\t}\n\n\tpublic setScrollPositionSmooth(update: INewScrollPosition): void {\n\t\tthis._scrollable.setScrollPositionSmooth(update);\n\t}\n\n\tpublic hasPendingScrollAnimation(): boolean {\n\t\treturn this._scrollable.hasPendingScrollAnimation();\n\t}\n}\n\nexport class ViewLayout extends Disposable implements IViewLayout {\n\n\tprivate readonly _configuration: IEditorConfiguration;\n\tprivate readonly _linesLayout: LinesLayout;\n\tprivate _maxLineWidth: number;\n\tprivate _overlayWidgetsMinWidth: number;\n\n\tprivate readonly _scrollable: EditorScrollable;\n\tpublic readonly onDidScroll: Event<ScrollEvent>;\n\tpublic readonly onDidContentSizeChange: Event<ContentSizeChangedEvent>;\n\n\tconstructor(configuration: IEditorConfiguration, lineCount: number, customLineHeightData: ICustomLineHeightData[], scheduleAtNextAnimationFrame: (callback: () => void) => IDisposable) {\n\t\tsuper();\n\n\t\tthis._configuration = configuration;\n\t\tconst options = this._configuration.options;\n\t\tconst layoutInfo = options.get(EditorOption.layoutInfo);\n\t\tconst padding = options.get(EditorOption.padding);\n\n\t\tthis._linesLayout = new LinesLayout(lineCount, options.get(EditorOption.lineHeight), padding.top, padding.bottom, customLineHeightData);\n\t\tthis._maxLineWidth = 0;\n\t\tthis._overlayWidgetsMinWidth = 0;\n\n\t\tthis._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n\t\tthis._configureSmoothScrollDuration();\n\n\t\tthis._scrollable.setScrollDimensions(new EditorScrollDimensions(\n\t\t\tlayoutInfo.contentWidth,\n\t\t\t0,\n\t\t\tlayoutInfo.height,\n\t\t\t0\n\t\t));\n\t\tthis.onDidScroll = this._scrollable.onDidScroll;\n\t\tthis.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n\n\t\tthis._updateHeight();\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t}\n\n\tpublic getScrollable(): Scrollable {\n\t\treturn this._scrollable.getScrollable();\n\t}\n\n\tpublic onHeightMaybeChanged(): void {\n\t\tthis._updateHeight();\n\t}\n\n\tprivate _configureSmoothScrollDuration(): void {\n\t\tthis._scrollable.setSmoothScrollDuration(this._configuration.options.get(EditorOption.smoothScrolling) ? SMOOTH_SCROLLING_TIME : 0);\n\t}\n\n\t// ---- begin view event handlers\n\n\tpublic onConfigurationChanged(e: ConfigurationChangedEvent): void {\n\t\tconst options = this._configuration.options;\n\t\tif (e.hasChanged(EditorOption.lineHeight)) {\n\t\t\tthis._linesLayout.setDefaultLineHeight(options.get(EditorOption.lineHeight));\n\t\t}\n\t\tif (e.hasChanged(EditorOption.padding)) {\n\t\t\tconst padding = options.get(EditorOption.padding);\n\t\t\tthis._linesLayout.setPadding(padding.top, padding.bottom);\n\t\t}\n\t\tif (e.hasChanged(EditorOption.layoutInfo)) {\n\t\t\tconst layoutInfo = options.get(EditorOption.layoutInfo);\n\t\t\tconst width = layoutInfo.contentWidth;\n\t\t\tconst height = layoutInfo.height;\n\t\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\t\tconst contentWidth = scrollDimensions.contentWidth;\n\t\t\tthis._scrollable.setScrollDimensions(new EditorScrollDimensions(\n\t\t\t\twidth,\n\t\t\t\tscrollDimensions.contentWidth,\n\t\t\t\theight,\n\t\t\t\tthis._getContentHeight(width, height, contentWidth)\n\t\t\t));\n\t\t} else {\n\t\t\tthis._updateHeight();\n\t\t}\n\t\tif (e.hasChanged(EditorOption.smoothScrolling)) {\n\t\t\tthis._configureSmoothScrollDuration();\n\t\t}\n\t}\n\tpublic onFlushed(lineCount: number, customLineHeightData: ICustomLineHeightData[]): void {\n\t\tthis._linesLayout.onFlushed(lineCount, customLineHeightData);\n\t}\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tthis._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n\t}\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tthis._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n\t}\n\n\t// ---- end view event handlers\n\n\tprivate _getHorizontalScrollbarHeight(width: number, scrollWidth: number): number {\n\t\tconst options = this._configuration.options;\n\t\tconst scrollbar = options.get(EditorOption.scrollbar);\n\t\tif (scrollbar.horizontal === ScrollbarVisibility.Hidden) {\n\t\t\t// horizontal scrollbar not visible\n\t\t\treturn 0;\n\t\t}\n\t\tif (width >= scrollWidth) {\n\t\t\t// horizontal scrollbar not visible\n\t\t\treturn 0;\n\t\t}\n\t\treturn scrollbar.horizontalScrollbarSize;\n\t}\n\n\tprivate _getContentHeight(width: number, height: number, contentWidth: number): number {\n\t\tconst options = this._configuration.options;\n\n\t\tlet result = this._linesLayout.getLinesTotalHeight();\n\t\tif (options.get(EditorOption.scrollBeyondLastLine)) {\n\t\t\tresult += Math.max(0, height - options.get(EditorOption.lineHeight) - options.get(EditorOption.padding).bottom);\n\t\t} else if (!options.get(EditorOption.scrollbar).ignoreHorizontalScrollbarInContentHeight) {\n\t\t\tresult += this._getHorizontalScrollbarHeight(width, contentWidth);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _updateHeight(): void {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tconst width = scrollDimensions.width;\n\t\tconst height = scrollDimensions.height;\n\t\tconst contentWidth = scrollDimensions.contentWidth;\n\t\tthis._scrollable.setScrollDimensions(new EditorScrollDimensions(\n\t\t\twidth,\n\t\t\tscrollDimensions.contentWidth,\n\t\t\theight,\n\t\t\tthis._getContentHeight(width, height, contentWidth)\n\t\t));\n\t}\n\n\t// ---- Layouting logic\n\n\tpublic getCurrentViewport(): Viewport {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tconst currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n\t\treturn new Viewport(\n\t\t\tcurrentScrollPosition.scrollTop,\n\t\t\tcurrentScrollPosition.scrollLeft,\n\t\t\tscrollDimensions.width,\n\t\t\tscrollDimensions.height\n\t\t);\n\t}\n\n\tpublic getFutureViewport(): Viewport {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tconst currentScrollPosition = this._scrollable.getFutureScrollPosition();\n\t\treturn new Viewport(\n\t\t\tcurrentScrollPosition.scrollTop,\n\t\t\tcurrentScrollPosition.scrollLeft,\n\t\t\tscrollDimensions.width,\n\t\t\tscrollDimensions.height\n\t\t);\n\t}\n\n\tprivate _computeContentWidth(): number {\n\t\tconst options = this._configuration.options;\n\t\tconst maxLineWidth = this._maxLineWidth;\n\t\tconst wrappingInfo = options.get(EditorOption.wrappingInfo);\n\t\tconst fontInfo = options.get(EditorOption.fontInfo);\n\t\tconst layoutInfo = options.get(EditorOption.layoutInfo);\n\t\tif (wrappingInfo.isViewportWrapping) {\n\t\t\tconst minimap = options.get(EditorOption.minimap);\n\t\t\tif (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n\t\t\t\t// This is a case where viewport wrapping is on, but the line extends above the viewport\n\t\t\t\tif (minimap.enabled && minimap.side === 'right') {\n\t\t\t\t\t// We need to accomodate the scrollbar width\n\t\t\t\t\treturn maxLineWidth + layoutInfo.verticalScrollbarWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxLineWidth;\n\t\t} else {\n\t\t\tconst extraHorizontalSpace = options.get(EditorOption.scrollBeyondLastColumn) * fontInfo.typicalHalfwidthCharacterWidth;\n\t\t\tconst whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n\t\t\treturn Math.max(maxLineWidth + extraHorizontalSpace + layoutInfo.verticalScrollbarWidth, whitespaceMinWidth, this._overlayWidgetsMinWidth);\n\t\t}\n\t}\n\n\tpublic setMaxLineWidth(maxLineWidth: number): void {\n\t\tthis._maxLineWidth = maxLineWidth;\n\t\tthis._updateContentWidth();\n\t}\n\n\tpublic setOverlayWidgetsMinWidth(maxMinWidth: number): void {\n\t\tthis._overlayWidgetsMinWidth = maxMinWidth;\n\t\tthis._updateContentWidth();\n\t}\n\n\tprivate _updateContentWidth(): void {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tthis._scrollable.setScrollDimensions(new EditorScrollDimensions(\n\t\t\tscrollDimensions.width,\n\t\t\tthis._computeContentWidth(),\n\t\t\tscrollDimensions.height,\n\t\t\tscrollDimensions.contentHeight\n\t\t));\n\n\t\t// The height might depend on the fact that there is a horizontal scrollbar or not\n\t\tthis._updateHeight();\n\t}\n\n\t// ---- view state\n\n\tpublic saveState(): { scrollTop: number; scrollTopWithoutViewZones: number; scrollLeft: number } {\n\t\tconst currentScrollPosition = this._scrollable.getFutureScrollPosition();\n\t\tconst scrollTop = currentScrollPosition.scrollTop;\n\t\tconst firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n\t\tconst whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n\t\treturn {\n\t\t\tscrollTop: scrollTop,\n\t\t\tscrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n\t\t\tscrollLeft: currentScrollPosition.scrollLeft\n\t\t};\n\t}\n\n\t// ----\n\tpublic changeWhitespace(callback: (accessor: IWhitespaceChangeAccessor) => void): boolean {\n\t\tconst hadAChange = this._linesLayout.changeWhitespace(callback);\n\t\tif (hadAChange) {\n\t\t\tthis.onHeightMaybeChanged();\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic changeSpecialLineHeights(callback: (accessor: ILineHeightChangeAccessor) => void): boolean {\n\t\tconst hadAChange = this._linesLayout.changeLineHeights(callback);\n\t\tif (hadAChange) {\n\t\t\tthis.onHeightMaybeChanged();\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic getVerticalOffsetForLineNumber(lineNumber: number, includeViewZones: boolean = false): number {\n\t\treturn this._linesLayout.getVerticalOffsetForLineNumber(lineNumber, includeViewZones);\n\t}\n\tpublic getVerticalOffsetAfterLineNumber(lineNumber: number, includeViewZones: boolean = false): number {\n\t\treturn this._linesLayout.getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones);\n\t}\n\tpublic getLineHeightForLineNumber(lineNumber: number): number {\n\t\treturn this._linesLayout.getLineHeightForLineNumber(lineNumber);\n\t}\n\tpublic isAfterLines(verticalOffset: number): boolean {\n\t\treturn this._linesLayout.isAfterLines(verticalOffset);\n\t}\n\tpublic isInTopPadding(verticalOffset: number): boolean {\n\t\treturn this._linesLayout.isInTopPadding(verticalOffset);\n\t}\n\tpublic isInBottomPadding(verticalOffset: number): boolean {\n\t\treturn this._linesLayout.isInBottomPadding(verticalOffset);\n\t}\n\n\tpublic getLineNumberAtVerticalOffset(verticalOffset: number): number {\n\t\treturn this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n\t}\n\n\tpublic getWhitespaceAtVerticalOffset(verticalOffset: number): IViewWhitespaceViewportData | null {\n\t\treturn this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n\t}\n\tpublic getLinesViewportData(): IPartialViewLinesViewportData {\n\t\tconst visibleBox = this.getCurrentViewport();\n\t\treturn this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n\t}\n\tpublic getLinesViewportDataAtScrollTop(scrollTop: number): IPartialViewLinesViewportData {\n\t\t// do some minimal validations on scrollTop\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tif (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n\t\t\tscrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n\t\t}\n\t\tif (scrollTop < 0) {\n\t\t\tscrollTop = 0;\n\t\t}\n\t\treturn this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n\t}\n\tpublic getWhitespaceViewportData(): IViewWhitespaceViewportData[] {\n\t\tconst visibleBox = this.getCurrentViewport();\n\t\treturn this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n\t}\n\tpublic getWhitespaces(): IEditorWhitespace[] {\n\t\treturn this._linesLayout.getWhitespaces();\n\t}\n\n\t// ----\n\n\tpublic getContentWidth(): number {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\treturn scrollDimensions.contentWidth;\n\t}\n\tpublic getScrollWidth(): number {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\treturn scrollDimensions.scrollWidth;\n\t}\n\tpublic getContentHeight(): number {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\treturn scrollDimensions.contentHeight;\n\t}\n\tpublic getScrollHeight(): number {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\treturn scrollDimensions.scrollHeight;\n\t}\n\n\tpublic getCurrentScrollLeft(): number {\n\t\tconst currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n\t\treturn currentScrollPosition.scrollLeft;\n\t}\n\tpublic getCurrentScrollTop(): number {\n\t\tconst currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n\t\treturn currentScrollPosition.scrollTop;\n\t}\n\n\tpublic validateScrollPosition(scrollPosition: INewScrollPosition): IScrollPosition {\n\t\treturn this._scrollable.validateScrollPosition(scrollPosition);\n\t}\n\n\tpublic setScrollPosition(position: INewScrollPosition, type: ScrollType): void {\n\t\tif (type === ScrollType.Immediate) {\n\t\t\tthis._scrollable.setScrollPositionNow(position);\n\t\t} else {\n\t\t\tthis._scrollable.setScrollPositionSmooth(position);\n\t\t}\n\t}\n\n\tpublic hasPendingScrollAnimation(): boolean {\n\t\treturn this._scrollable.hasPendingScrollAnimation();\n\t}\n\n\tpublic deltaScrollNow(deltaScrollLeft: number, deltaScrollTop: number): void {\n\t\tconst currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n\t\tthis._scrollable.setScrollPositionNow({\n\t\t\tscrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n\t\t\tscrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n\t\t});\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter } from '../../../base/common/event.js';\nimport { Disposable, IDisposable } from '../../../base/common/lifecycle.js';\nimport { IScrollPosition, ScrollEvent, Scrollable, ScrollbarVisibility, INewScrollPosition } from '../../../base/common/scrollable.js';\nimport { ConfigurationChangedEvent, EditorOption } from '../config/editorOptions.js';\nimport { ScrollType } from '../editorCommon.js';\nimport { IEditorConfiguration } from '../config/editorConfiguration.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { IEditorWhitespace, IPartialViewLinesViewportData, ILineHeightChangeAccessor, IViewLayout, IViewWhitespaceViewportData, IWhitespaceChangeAccessor, Viewport } from '../viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ICustomLineHeightData } from './lineHeights.js';\n\nconst SMOOTH_SCROLLING_TIME = 125;\n\nclass EditorScrollDimensions {\n\n\tpublic readonly width: number;\n\tpublic readonly contentWidth: number;\n\tpublic readonly scrollWidth: number;\n\n\tpublic readonly height: number;\n\tpublic readonly contentHeight: number;\n\tpublic readonly scrollHeight: number;\n\n\tconstructor(\n\t\twidth: number,\n\t\tcontentWidth: number,\n\t\theight: number,\n\t\tcontentHeight: number,\n\t) {\n\t\twidth = width | 0;\n\t\tcontentWidth = contentWidth | 0;\n\t\theight = height | 0;\n\t\tcontentHeight = contentHeight | 0;\n\n\t\tif (width < 0) {\n\t\t\twidth = 0;\n\t\t}\n\t\tif (contentWidth < 0) {\n\t\t\tcontentWidth = 0;\n\t\t}\n\n\t\tif (height < 0) {\n\t\t\theight = 0;\n\t\t}\n\t\tif (contentHeight < 0) {\n\t\t\tcontentHeight = 0;\n\t\t}\n\n\t\tthis.width = width;\n\t\tthis.contentWidth = contentWidth;\n\t\tthis.scrollWidth = Math.max(width, contentWidth);\n\n\t\tthis.height = height;\n\t\tthis.contentHeight = contentHeight;\n\t\tthis.scrollHeight = Math.max(height, contentHeight);\n\t}\n\n\tpublic equals(other: EditorScrollDimensions): boolean {\n\t\treturn (\n\t\t\tthis.width === other.width\n\t\t\t&& this.contentWidth === other.contentWidth\n\t\t\t&& this.height === other.height\n\t\t\t&& this.contentHeight === other.contentHeight\n\t\t);\n\t}\n}\n\nclass EditorScrollable extends Disposable {\n\n\tprivate readonly _scrollable: Scrollable;\n\tprivate _dimensions: EditorScrollDimensions;\n\n\tpublic readonly onDidScroll: Event<ScrollEvent>;\n\n\tprivate readonly _onDidContentSizeChange = this._register(new Emitter<ContentSizeChangedEvent>());\n\tpublic readonly onDidContentSizeChange: Event<ContentSizeChangedEvent> = this._onDidContentSizeChange.event;\n\n\tconstructor(smoothScrollDuration: number, scheduleAtNextAnimationFrame: (callback: () => void) => IDisposable) {\n\t\tsuper();\n\t\tthis._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n\t\tthis._scrollable = this._register(new Scrollable({\n\t\t\tforceIntegerValues: true,\n\t\t\tsmoothScrollDuration,\n\t\t\tscheduleAtNextAnimationFrame\n\t\t}));\n\t\tthis.onDidScroll = this._scrollable.onScroll;\n\t}\n\n\tpublic getScrollable(): Scrollable {\n\t\treturn this._scrollable;\n\t}\n\n\tpublic setSmoothScrollDuration(smoothScrollDuration: number): void {\n\t\tthis._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n\t}\n\n\tpublic validateScrollPosition(scrollPosition: INewScrollPosition): IScrollPosition {\n\t\treturn this._scrollable.validateScrollPosition(scrollPosition);\n\t}\n\n\tpublic getScrollDimensions(): EditorScrollDimensions {\n\t\treturn this._dimensions;\n\t}\n\n\tpublic setScrollDimensions(dimensions: EditorScrollDimensions): void {\n\t\tif (this._dimensions.equals(dimensions)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldDimensions = this._dimensions;\n\t\tthis._dimensions = dimensions;\n\n\t\tthis._scrollable.setScrollDimensions({\n\t\t\twidth: dimensions.width,\n\t\t\tscrollWidth: dimensions.scrollWidth,\n\t\t\theight: dimensions.height,\n\t\t\tscrollHeight: dimensions.scrollHeight\n\t\t}, true);\n\n\t\tconst contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n\t\tconst contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n\t\tif (contentWidthChanged || contentHeightChanged) {\n\t\t\tthis._onDidContentSizeChange.fire(new ContentSizeChangedEvent(\n\t\t\t\toldDimensions.contentWidth, oldDimensions.contentHeight,\n\t\t\t\tdimensions.contentWidth, dimensions.contentHeight\n\t\t\t));\n\t\t}\n\t}\n\n\tpublic getFutureScrollPosition(): IScrollPosition {\n\t\treturn this._scrollable.getFutureScrollPosition();\n\t}\n\n\tpublic getCurrentScrollPosition(): IScrollPosition {\n\t\treturn this._scrollable.getCurrentScrollPosition();\n\t}\n\n\tpublic setScrollPositionNow(update: INewScrollPosition): void {\n\t\tthis._scrollable.setScrollPositionNow(update);\n\t}\n\n\tpublic setScrollPositionSmooth(update: INewScrollPosition): void {\n\t\tthis._scrollable.setScrollPositionSmooth(update);\n\t}\n\n\tpublic hasPendingScrollAnimation(): boolean {\n\t\treturn this._scrollable.hasPendingScrollAnimation();\n\t}\n}\n\nexport class ViewLayout extends Disposable implements IViewLayout {\n\n\tprivate readonly _configuration: IEditorConfiguration;\n\tprivate readonly _linesLayout: LinesLayout;\n\tprivate _maxLineWidth: number;\n\tprivate _overlayWidgetsMinWidth: number;\n\n\tprivate readonly _scrollable: EditorScrollable;\n\tpublic readonly onDidScroll: Event<ScrollEvent>;\n\tpublic readonly onDidContentSizeChange: Event<ContentSizeChangedEvent>;\n\n\tconstructor(configuration: IEditorConfiguration, lineCount: number, customLineHeightData: ICustomLineHeightData[], scheduleAtNextAnimationFrame: (callback: () => void) => IDisposable) {\n\t\tsuper();\n\n\t\tthis._configuration = configuration;\n\t\tconst options = this._configuration.options;\n\t\tconst layoutInfo = options.get(EditorOption.layoutInfo);\n\t\tconst padding = options.get(EditorOption.padding);\n\n\t\tthis._linesLayout = new LinesLayout(lineCount, options.get(EditorOption.lineHeight), padding.top, padding.bottom, customLineHeightData);\n\t\tthis._maxLineWidth = 0;\n\t\tthis._overlayWidgetsMinWidth = 0;\n\n\t\tthis._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n\t\tthis._configureSmoothScrollDuration();\n\n\t\tthis._scrollable.setScrollDimensions(new EditorScrollDimensions(\n\t\t\tlayoutInfo.contentWidth,\n\t\t\t0,\n\t\t\tlayoutInfo.height,\n\t\t\t0\n\t\t));\n\t\tthis.onDidScroll = this._scrollable.onDidScroll;\n\t\tthis.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n\n\t\tthis._updateHeight();\n\t}\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t}\n\n\tpublic getScrollable(): Scrollable {\n\t\treturn this._scrollable.getScrollable();\n\t}\n\n\tpublic onHeightMaybeChanged(): void {\n\t\tthis._updateHeight();\n\t}\n\n\tprivate _configureSmoothScrollDuration(): void {\n\t\tthis._scrollable.setSmoothScrollDuration(this._configuration.options.get(EditorOption.smoothScrolling) ? SMOOTH_SCROLLING_TIME : 0);\n\t}\n\n\t// ---- begin view event handlers\n\n\tpublic onConfigurationChanged(e: ConfigurationChangedEvent): void {\n\t\tconst options = this._configuration.options;\n\t\tif (e.hasChanged(EditorOption.lineHeight)) {\n\t\t\tthis._linesLayout.setDefaultLineHeight(options.get(EditorOption.lineHeight));\n\t\t}\n\t\tif (e.hasChanged(EditorOption.padding)) {\n\t\t\tconst padding = options.get(EditorOption.padding);\n\t\t\tthis._linesLayout.setPadding(padding.top, padding.bottom);\n\t\t}\n\t\tif (e.hasChanged(EditorOption.layoutInfo)) {\n\t\t\tconst layoutInfo = options.get(EditorOption.layoutInfo);\n\t\t\tconst width = layoutInfo.contentWidth;\n\t\t\tconst height = layoutInfo.height;\n\t\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\t\tconst contentWidth = scrollDimensions.contentWidth;\n\t\t\tthis._scrollable.setScrollDimensions(new EditorScrollDimensions(\n\t\t\t\twidth,\n\t\t\t\tscrollDimensions.contentWidth,\n\t\t\t\theight,\n\t\t\t\tthis._getContentHeight(width, height, contentWidth)\n\t\t\t));\n\t\t} else {\n\t\t\tthis._updateHeight();\n\t\t}\n\t\tif (e.hasChanged(EditorOption.smoothScrolling)) {\n\t\t\tthis._configureSmoothScrollDuration();\n\t\t}\n\t}\n\tpublic onFlushed(lineCount: number, customLineHeightData: ICustomLineHeightData[]): void {\n\t\tthis._linesLayout.onFlushed(lineCount, customLineHeightData);\n\t}\n\tpublic onLinesDeleted(fromLineNumber: number, toLineNumber: number): void {\n\t\tthis._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n\t}\n\tpublic onLinesInserted(fromLineNumber: number, toLineNumber: number): void {\n\t\tthis._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n\t}\n\n\t// ---- end view event handlers\n\n\tprivate _getHorizontalScrollbarHeight(width: number, scrollWidth: number): number {\n\t\tconst options = this._configuration.options;\n\t\tconst scrollbar = options.get(EditorOption.scrollbar);\n\t\tif (scrollbar.horizontal === ScrollbarVisibility.Hidden) {\n\t\t\t// horizontal scrollbar not visible\n\t\t\treturn 0;\n\t\t}\n\t\tif (width >= scrollWidth) {\n\t\t\t// horizontal scrollbar not visible\n\t\t\treturn 0;\n\t\t}\n\t\treturn scrollbar.horizontalScrollbarSize;\n\t}\n\n\tprivate _getContentHeight(width: number, height: number, contentWidth: number): number {\n\t\tconst options = this._configuration.options;\n\n\t\tlet result = this._linesLayout.getLinesTotalHeight();\n\t\tif (options.get(EditorOption.scrollBeyondLastLine)) {\n\t\t\tresult += Math.max(0, height - options.get(EditorOption.lineHeight) - options.get(EditorOption.padding).bottom);\n\t\t} else if (!options.get(EditorOption.scrollbar).ignoreHorizontalScrollbarInContentHeight) {\n\t\t\tresult += this._getHorizontalScrollbarHeight(width, contentWidth);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate _updateHeight(): void {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tconst width = scrollDimensions.width;\n\t\tconst height = scrollDimensions.height;\n\t\tconst contentWidth = scrollDimensions.contentWidth;\n\t\tthis._scrollable.setScrollDimensions(new EditorScrollDimensions(\n\t\t\twidth,\n\t\t\tscrollDimensions.contentWidth,\n\t\t\theight,\n\t\t\tthis._getContentHeight(width, height, contentWidth)\n\t\t));\n\t}\n\n\t// ---- Layouting logic\n\n\tpublic getCurrentViewport(): Viewport {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tconst currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n\t\treturn new Viewport(\n\t\t\tcurrentScrollPosition.scrollTop,\n\t\t\tcurrentScrollPosition.scrollLeft,\n\t\t\tscrollDimensions.width,\n\t\t\tscrollDimensions.height\n\t\t);\n\t}\n\n\tpublic getFutureViewport(): Viewport {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tconst currentScrollPosition = this._scrollable.getFutureScrollPosition();\n\t\treturn new Viewport(\n\t\t\tcurrentScrollPosition.scrollTop,\n\t\t\tcurrentScrollPosition.scrollLeft,\n\t\t\tscrollDimensions.width,\n\t\t\tscrollDimensions.height\n\t\t);\n\t}\n\n\tprivate _computeContentWidth(): number {\n\t\tconst options = this._configuration.options;\n\t\tconst maxLineWidth = this._maxLineWidth;\n\t\tconst wrappingInfo = options.get(EditorOption.wrappingInfo);\n\t\tconst fontInfo = options.get(EditorOption.fontInfo);\n\t\tconst layoutInfo = options.get(EditorOption.layoutInfo);\n\t\tif (wrappingInfo.isViewportWrapping) {\n\t\t\tconst minimap = options.get(EditorOption.minimap);\n\t\t\tif (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n\t\t\t\t// This is a case where viewport wrapping is on, but the line extends above the viewport\n\t\t\t\tif (minimap.enabled && minimap.side === 'right') {\n\t\t\t\t\t// We need to accomodate the scrollbar width\n\t\t\t\t\treturn maxLineWidth + layoutInfo.verticalScrollbarWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxLineWidth;\n\t\t} else {\n\t\t\tconst extraHorizontalSpace = options.get(EditorOption.scrollBeyondLastColumn) * fontInfo.typicalHalfwidthCharacterWidth;\n\t\t\tconst whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n\t\t\treturn Math.max(maxLineWidth + extraHorizontalSpace + layoutInfo.verticalScrollbarWidth, whitespaceMinWidth, this._overlayWidgetsMinWidth);\n\t\t}\n\t}\n\n\tpublic setMaxLineWidth(maxLineWidth: number): void {\n\t\tthis._maxLineWidth = maxLineWidth;\n\t\tthis._updateContentWidth();\n\t}\n\n\tpublic setOverlayWidgetsMinWidth(maxMinWidth: number): void {\n\t\tthis._overlayWidgetsMinWidth = maxMinWidth;\n\t\tthis._updateContentWidth();\n\t}\n\n\tprivate _updateContentWidth(): void {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tthis._scrollable.setScrollDimensions(new EditorScrollDimensions(\n\t\t\tscrollDimensions.width,\n\t\t\tthis._computeContentWidth(),\n\t\t\tscrollDimensions.height,\n\t\t\tscrollDimensions.contentHeight\n\t\t));\n\n\t\t// The height might depend on the fact that there is a horizontal scrollbar or not\n\t\tthis._updateHeight();\n\t}\n\n\t// ---- view state\n\n\tpublic saveState(): { scrollTop: number; scrollTopWithoutViewZones: number; scrollLeft: number } {\n\t\tconst currentScrollPosition = this._scrollable.getFutureScrollPosition();\n\t\tconst scrollTop = currentScrollPosition.scrollTop;\n\t\tconst firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n\t\tconst whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n\t\treturn {\n\t\t\tscrollTop: scrollTop,\n\t\t\tscrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n\t\t\tscrollLeft: currentScrollPosition.scrollLeft\n\t\t};\n\t}\n\n\t// ----\n\tpublic changeWhitespace(callback: (accessor: IWhitespaceChangeAccessor) => void): boolean {\n\t\tconst hadAChange = this._linesLayout.changeWhitespace(callback);\n\t\tif (hadAChange) {\n\t\t\tthis.onHeightMaybeChanged();\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic changeSpecialLineHeights(callback: (accessor: ILineHeightChangeAccessor) => void): boolean {\n\t\tconst hadAChange = this._linesLayout.changeLineHeights(callback);\n\t\tif (hadAChange) {\n\t\t\tthis.onHeightMaybeChanged();\n\t\t}\n\t\treturn hadAChange;\n\t}\n\n\tpublic getVerticalOffsetForLineNumber(lineNumber: number, includeViewZones: boolean = false): number {\n\t\treturn this._linesLayout.getVerticalOffsetForLineNumber(lineNumber, includeViewZones);\n\t}\n\tpublic getVerticalOffsetAfterLineNumber(lineNumber: number, includeViewZones: boolean = false): number {\n\t\treturn this._linesLayout.getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones);\n\t}\n\tpublic getLineHeightForLineNumber(lineNumber: number): number {\n\t\treturn this._linesLayout.getLineHeightForLineNumber(lineNumber);\n\t}\n\tpublic isAfterLines(verticalOffset: number): boolean {\n\t\treturn this._linesLayout.isAfterLines(verticalOffset);\n\t}\n\tpublic isInTopPadding(verticalOffset: number): boolean {\n\t\treturn this._linesLayout.isInTopPadding(verticalOffset);\n\t}\n\tpublic isInBottomPadding(verticalOffset: number): boolean {\n\t\treturn this._linesLayout.isInBottomPadding(verticalOffset);\n\t}\n\n\tpublic getLineNumberAtVerticalOffset(verticalOffset: number): number {\n\t\treturn this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n\t}\n\n\tpublic getWhitespaceAtVerticalOffset(verticalOffset: number): IViewWhitespaceViewportData | null {\n\t\treturn this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n\t}\n\tpublic getLinesViewportData(): IPartialViewLinesViewportData {\n\t\tconst visibleBox = this.getCurrentViewport();\n\t\treturn this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n\t}\n\tpublic getLinesViewportDataAtScrollTop(scrollTop: number): IPartialViewLinesViewportData {\n\t\t// do some minimal validations on scrollTop\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\tif (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n\t\t\tscrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n\t\t}\n\t\tif (scrollTop < 0) {\n\t\t\tscrollTop = 0;\n\t\t}\n\t\treturn this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n\t}\n\tpublic getWhitespaceViewportData(): IViewWhitespaceViewportData[] {\n\t\tconst visibleBox = this.getCurrentViewport();\n\t\treturn this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n\t}\n\tpublic getWhitespaces(): IEditorWhitespace[] {\n\t\treturn this._linesLayout.getWhitespaces();\n\t}\n\n\t// ----\n\n\tpublic getContentWidth(): number {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\treturn scrollDimensions.contentWidth;\n\t}\n\tpublic getScrollWidth(): number {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\treturn scrollDimensions.scrollWidth;\n\t}\n\tpublic getContentHeight(): number {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\treturn scrollDimensions.contentHeight;\n\t}\n\tpublic getScrollHeight(): number {\n\t\tconst scrollDimensions = this._scrollable.getScrollDimensions();\n\t\treturn scrollDimensions.scrollHeight;\n\t}\n\n\tpublic getCurrentScrollLeft(): number {\n\t\tconst currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n\t\treturn currentScrollPosition.scrollLeft;\n\t}\n\tpublic getCurrentScrollTop(): number {\n\t\tconst currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n\t\treturn currentScrollPosition.scrollTop;\n\t}\n\n\tpublic validateScrollPosition(scrollPosition: INewScrollPosition): IScrollPosition {\n\t\treturn this._scrollable.validateScrollPosition(scrollPosition);\n\t}\n\n\tpublic setScrollPosition(position: INewScrollPosition, type: ScrollType): void {\n\t\tif (type === ScrollType.Immediate) {\n\t\t\tthis._scrollable.setScrollPositionNow(position);\n\t\t} else {\n\t\t\tthis._scrollable.setScrollPositionSmooth(position);\n\t\t}\n\t}\n\n\tpublic hasPendingScrollAnimation(): boolean {\n\t\treturn this._scrollable.hasPendingScrollAnimation();\n\t}\n\n\tpublic deltaScrollNow(deltaScrollLeft: number, deltaScrollTop: number): void {\n\t\tconst currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n\t\tthis._scrollable.setScrollPositionNow({\n\t\t\tscrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n\t\t\tscrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n\t\t});\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}