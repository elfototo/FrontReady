{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/textModelPart.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/textModelPart.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../base/common/lifecycle.js';\n\nexport class TextModelPart extends Disposable {\n\tprivate _isDisposed = false;\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._isDisposed = true;\n\t}\n\tprotected assertNotDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('TextModelPart is disposed!');\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from '../../../base/common/lifecycle.js';\n\nexport class TextModelPart extends Disposable {\n\tprivate _isDisposed = false;\n\n\tpublic override dispose(): void {\n\t\tsuper.dispose();\n\t\tthis._isDisposed = true;\n\t}\n\tprotected assertNotDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('TextModelPart is disposed!');\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,UAAU,EAAE,MAAM,mCAAmC,CAAC;;AAEzD,MAAO,aAAc,SAAQ,6LAAU;IAG5B,OAAO,GAAA;QACtB,KAAK,CAAC,OAAO,EAAE,CAAC;QAChB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;IACzB,CAAC;IACS,iBAAiB,GAAA;QAC1B,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACtB,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;QAC/C,CAAC;IACF,CAAC;IAXF,aAAA;;QACS,IAAA,CAAA,WAAW,GAAG,KAAK,CAAC;IAW7B,CAAC;CAAA","debugId":null}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/utils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/utils.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/utils.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\n\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line: string, tabSize: number): number {\n\tlet indent = 0;\n\tlet i = 0;\n\tconst len = line.length;\n\n\twhile (i < len) {\n\t\tconst chCode = line.charCodeAt(i);\n\t\tif (chCode === CharCode.Space) {\n\t\t\tindent++;\n\t\t} else if (chCode === CharCode.Tab) {\n\t\t\tindent = indent - indent % tabSize + tabSize;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (i === len) {\n\t\treturn -1; // line only consists of whitespace\n\t}\n\n\treturn indent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\n\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line: string, tabSize: number): number {\n\tlet indent = 0;\n\tlet i = 0;\n\tconst len = line.length;\n\n\twhile (i < len) {\n\t\tconst chCode = line.charCodeAt(i);\n\t\tif (chCode === CharCode.Space) {\n\t\t\tindent++;\n\t\t} else if (chCode === CharCode.Tab) {\n\t\t\tindent = indent - indent % tabSize + tabSize;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (i === len) {\n\t\treturn -1; // line only consists of whitespace\n\t}\n\n\treturn indent;\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG,CAIhG;;;;GAIG;;;;AACG,SAAU,kBAAkB,CAAC,IAAY,EAAE,OAAe;IAC/D,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;IAExB,MAAO,CAAC,GAAG,GAAG,CAAE,CAAC;QAChB,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAClC,IAAI,MAAM,KAAA,GAAA,kBAAA,EAAmB,GAAE,CAAC;YAC/B,MAAM,EAAE,CAAC;QACV,CAAC,MAAM,IAAI,MAAM,KAAA,EAAA,gBAAA,EAAiB,GAAE,CAAC;YACpC,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,OAAO,CAAC;QAC9C,CAAC,MAAM,CAAC;YACP,MAAM;QACP,CAAC;QACD,CAAC,EAAE,CAAC;IACL,CAAC;IAED,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QACf,OAAO,CAAC,CAAC,CAAC,CAAC,mCAAmC;IAC/C,CAAC;IAED,OAAO,MAAM,CAAC;AACf,CAAC","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/guidesTextModelPart.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/guidesTextModelPart.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { IPosition, Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TextModel } from './textModel.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { ILanguageConfigurationService, ResolvedLanguageConfiguration } from '../languages/languageConfigurationRegistry.js';\nimport { BracketGuideOptions, HorizontalGuidesState, IActiveIndentGuideInfo, IGuidesTextModelPart, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n\nexport class GuidesTextModelPart extends TextModelPart implements IGuidesTextModelPart {\n\tconstructor(\n\t\tprivate readonly textModel: TextModel,\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getLanguageConfiguration(\n\t\tlanguageId: string\n\t): ResolvedLanguageConfiguration {\n\t\treturn this.languageConfigurationService.getLanguageConfiguration(\n\t\t\tlanguageId\n\t\t);\n\t}\n\n\tprivate _computeIndentLevel(lineIndex: number): number {\n\t\treturn computeIndentLevel(\n\t\t\tthis.textModel.getLineContent(lineIndex + 1),\n\t\t\tthis.textModel.getOptions().tabSize\n\t\t);\n\t}\n\n\tpublic getActiveIndentGuide(\n\t\tlineNumber: number,\n\t\tminLineNumber: number,\n\t\tmaxLineNumber: number\n\t): IActiveIndentGuideInfo {\n\t\tthis.assertNotDisposed();\n\t\tconst lineCount = this.textModel.getLineCount();\n\n\t\tif (lineNumber < 1 || lineNumber > lineCount) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\n\t\tconst foldingRules = this.getLanguageConfiguration(\n\t\t\tthis.textModel.getLanguageId()\n\t\t).foldingRules;\n\t\tconst offSide = Boolean(foldingRules && foldingRules.offSide);\n\n\t\tlet up_aboveContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet up_aboveContentLineIndent = -1;\n\t\tlet up_belowContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet up_belowContentLineIndent = -1;\n\t\tconst up_resolveIndents = (lineNumber: number) => {\n\t\t\tif (\n\t\t\t\tup_aboveContentLineIndex !== -1 &&\n\t\t\t\t(up_aboveContentLineIndex === -2 ||\n\t\t\t\t\tup_aboveContentLineIndex > lineNumber - 1)\n\t\t\t) {\n\t\t\t\tup_aboveContentLineIndex = -1;\n\t\t\t\tup_aboveContentLineIndent = -1;\n\n\t\t\t\t// must find previous line with content\n\t\t\t\tfor (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tup_aboveContentLineIndex = lineIndex;\n\t\t\t\t\t\tup_aboveContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (up_belowContentLineIndex === -2) {\n\t\t\t\tup_belowContentLineIndex = -1;\n\t\t\t\tup_belowContentLineIndent = -1;\n\n\t\t\t\t// must find next line with content\n\t\t\t\tfor (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tup_belowContentLineIndex = lineIndex;\n\t\t\t\t\t\tup_belowContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet down_aboveContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet down_aboveContentLineIndent = -1;\n\t\tlet down_belowContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet down_belowContentLineIndent = -1;\n\t\tconst down_resolveIndents = (lineNumber: number) => {\n\t\t\tif (down_aboveContentLineIndex === -2) {\n\t\t\t\tdown_aboveContentLineIndex = -1;\n\t\t\t\tdown_aboveContentLineIndent = -1;\n\n\t\t\t\t// must find previous line with content\n\t\t\t\tfor (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tdown_aboveContentLineIndex = lineIndex;\n\t\t\t\t\t\tdown_aboveContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tdown_belowContentLineIndex !== -1 &&\n\t\t\t\t(down_belowContentLineIndex === -2 ||\n\t\t\t\t\tdown_belowContentLineIndex < lineNumber - 1)\n\t\t\t) {\n\t\t\t\tdown_belowContentLineIndex = -1;\n\t\t\t\tdown_belowContentLineIndent = -1;\n\n\t\t\t\t// must find next line with content\n\t\t\t\tfor (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tdown_belowContentLineIndex = lineIndex;\n\t\t\t\t\t\tdown_belowContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet startLineNumber = 0;\n\t\tlet goUp = true;\n\t\tlet endLineNumber = 0;\n\t\tlet goDown = true;\n\t\tlet indent = 0;\n\n\t\tlet initialIndent = 0;\n\n\t\tfor (let distance = 0; goUp || goDown; distance++) {\n\t\t\tconst upLineNumber = lineNumber - distance;\n\t\t\tconst downLineNumber = lineNumber + distance;\n\n\t\t\tif (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n\t\t\t\tgoUp = false;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tdistance > 1 &&\n\t\t\t\t(downLineNumber > lineCount || downLineNumber > maxLineNumber)\n\t\t\t) {\n\t\t\t\tgoDown = false;\n\t\t\t}\n\t\t\tif (distance > 50000) {\n\t\t\t\t// stop processing\n\t\t\t\tgoUp = false;\n\t\t\t\tgoDown = false;\n\t\t\t}\n\n\t\t\tlet upLineIndentLevel: number = -1;\n\t\t\tif (goUp && upLineNumber >= 1) {\n\t\t\t\t// compute indent level going up\n\t\t\t\tconst currentIndent = this._computeIndentLevel(upLineNumber - 1);\n\t\t\t\tif (currentIndent >= 0) {\n\t\t\t\t\t// This line has content (besides whitespace)\n\t\t\t\t\t// Use the line's indent\n\t\t\t\t\tup_belowContentLineIndex = upLineNumber - 1;\n\t\t\t\t\tup_belowContentLineIndent = currentIndent;\n\t\t\t\t\tupLineIndentLevel = Math.ceil(\n\t\t\t\t\t\tcurrentIndent / this.textModel.getOptions().indentSize\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tup_resolveIndents(upLineNumber);\n\t\t\t\t\tupLineIndentLevel = this._getIndentLevelForWhitespaceLine(\n\t\t\t\t\t\toffSide,\n\t\t\t\t\t\tup_aboveContentLineIndent,\n\t\t\t\t\t\tup_belowContentLineIndent\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet downLineIndentLevel = -1;\n\t\t\tif (goDown && downLineNumber <= lineCount) {\n\t\t\t\t// compute indent level going down\n\t\t\t\tconst currentIndent = this._computeIndentLevel(downLineNumber - 1);\n\t\t\t\tif (currentIndent >= 0) {\n\t\t\t\t\t// This line has content (besides whitespace)\n\t\t\t\t\t// Use the line's indent\n\t\t\t\t\tdown_aboveContentLineIndex = downLineNumber - 1;\n\t\t\t\t\tdown_aboveContentLineIndent = currentIndent;\n\t\t\t\t\tdownLineIndentLevel = Math.ceil(\n\t\t\t\t\t\tcurrentIndent / this.textModel.getOptions().indentSize\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tdown_resolveIndents(downLineNumber);\n\t\t\t\t\tdownLineIndentLevel = this._getIndentLevelForWhitespaceLine(\n\t\t\t\t\t\toffSide,\n\t\t\t\t\t\tdown_aboveContentLineIndent,\n\t\t\t\t\t\tdown_belowContentLineIndent\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (distance === 0) {\n\t\t\t\tinitialIndent = upLineIndentLevel;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (distance === 1) {\n\t\t\t\tif (\n\t\t\t\t\tdownLineNumber <= lineCount &&\n\t\t\t\t\tdownLineIndentLevel >= 0 &&\n\t\t\t\t\tinitialIndent + 1 === downLineIndentLevel\n\t\t\t\t) {\n\t\t\t\t\t// This is the beginning of a scope, we have special handling here, since we want the\n\t\t\t\t\t// child scope indent to be active, not the parent scope\n\t\t\t\t\tgoUp = false;\n\t\t\t\t\tstartLineNumber = downLineNumber;\n\t\t\t\t\tendLineNumber = downLineNumber;\n\t\t\t\t\tindent = downLineIndentLevel;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tupLineNumber >= 1 &&\n\t\t\t\t\tupLineIndentLevel >= 0 &&\n\t\t\t\t\tupLineIndentLevel - 1 === initialIndent\n\t\t\t\t) {\n\t\t\t\t\t// This is the end of a scope, just like above\n\t\t\t\t\tgoDown = false;\n\t\t\t\t\tstartLineNumber = upLineNumber;\n\t\t\t\t\tendLineNumber = upLineNumber;\n\t\t\t\t\tindent = upLineIndentLevel;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstartLineNumber = lineNumber;\n\t\t\t\tendLineNumber = lineNumber;\n\t\t\t\tindent = initialIndent;\n\t\t\t\tif (indent === 0) {\n\t\t\t\t\t// No need to continue\n\t\t\t\t\treturn { startLineNumber, endLineNumber, indent };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (goUp) {\n\t\t\t\tif (upLineIndentLevel >= indent) {\n\t\t\t\t\tstartLineNumber = upLineNumber;\n\t\t\t\t} else {\n\t\t\t\t\tgoUp = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (goDown) {\n\t\t\t\tif (downLineIndentLevel >= indent) {\n\t\t\t\t\tendLineNumber = downLineNumber;\n\t\t\t\t} else {\n\t\t\t\t\tgoDown = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { startLineNumber, endLineNumber, indent };\n\t}\n\n\tpublic getLinesBracketGuides(\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number,\n\t\tactivePosition: IPosition | null,\n\t\toptions: BracketGuideOptions\n\t): IndentGuide[][] {\n\t\tconst result: IndentGuide[][] = [];\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tresult.push([]);\n\t\t}\n\n\t\t// If requested, this could be made configurable.\n\t\tconst includeSingleLinePairs = true;\n\n\t\tconst bracketPairs =\n\t\t\tthis.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(\n\t\t\t\tnew Range(\n\t\t\t\t\tstartLineNumber,\n\t\t\t\t\t1,\n\t\t\t\t\tendLineNumber,\n\t\t\t\t\tthis.textModel.getLineMaxColumn(endLineNumber)\n\t\t\t\t)\n\t\t\t).toArray();\n\n\t\tlet activeBracketPairRange: Range | undefined = undefined;\n\t\tif (activePosition && bracketPairs.length > 0) {\n\t\t\tconst bracketsContainingActivePosition = (\n\t\t\t\tstartLineNumber <= activePosition.lineNumber &&\n\t\t\t\t\tactivePosition.lineNumber <= endLineNumber\n\t\t\t\t\t// We don't need to query the brackets again if the cursor is in the viewport\n\t\t\t\t\t? bracketPairs\n\t\t\t\t\t: this.textModel.bracketPairs.getBracketPairsInRange(\n\t\t\t\t\t\tRange.fromPositions(activePosition)\n\t\t\t\t\t).toArray()\n\t\t\t).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n\n\t\t\tactiveBracketPairRange = findLast(\n\t\t\t\tbracketsContainingActivePosition,\n\t\t\t\t(i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber\n\t\t\t)?.range;\n\t\t}\n\n\t\tconst independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n\t\tconst colorProvider = new BracketPairGuidesClassNames();\n\n\t\tfor (const pair of bracketPairs) {\n\t\t\t/*\n\n\n\t\t\t\t\t{\n\t\t\t\t\t|\n\t\t\t\t\t}\n\n\t\t\t\t\t{\n\t\t\t\t\t|\n\t\t\t\t\t----}\n\n\t\t\t\t____{\n\t\t\t\t|test\n\t\t\t\t----}\n\n\t\t\t\trenderHorizontalEndLineAtTheBottom:\n\t\t\t\t\t{\n\t\t\t\t\t|\n\t\t\t\t\t|x}\n\t\t\t\t\t--\n\t\t\t\trenderHorizontalEndLineAtTheBottom:\n\t\t\t\t____{\n\t\t\t\t|test\n\t\t\t\t| x }\n\t\t\t\t----\n\t\t\t*/\n\n\t\t\tif (!pair.closingBracketRange) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n\n\t\t\tif (!isActive && !options.includeInactive) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst className =\n\t\t\t\tcolorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n\t\t\t\t(options.highlightActive && isActive\n\t\t\t\t\t? ' ' + colorProvider.activeClassName\n\t\t\t\t\t: '');\n\n\n\t\t\tconst start = pair.openingBracketRange.getStartPosition();\n\t\t\tconst end = pair.closingBracketRange.getStartPosition();\n\n\t\t\tconst horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n\n\t\t\tif (pair.range.startLineNumber === pair.range.endLineNumber) {\n\t\t\t\tif (includeSingleLinePairs && horizontalGuides) {\n\n\t\t\t\t\tresult[pair.range.startLineNumber - startLineNumber].push(\n\t\t\t\t\t\tnew IndentGuide(\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\tpair.openingBracketRange.getEndPosition().column,\n\t\t\t\t\t\t\tclassName,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(false, end.column),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst endVisibleColumn = this.getVisibleColumnFromPosition(end);\n\t\t\tconst startVisibleColumn = this.getVisibleColumnFromPosition(\n\t\t\t\tpair.openingBracketRange.getStartPosition()\n\t\t\t);\n\t\t\tconst guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n\n\t\t\tlet renderHorizontalEndLineAtTheBottom = false;\n\n\n\t\t\tconst firstNonWsIndex = strings.firstNonWhitespaceIndex(\n\t\t\t\tthis.textModel.getLineContent(\n\t\t\t\t\tpair.closingBracketRange.startLineNumber\n\t\t\t\t)\n\t\t\t);\n\t\t\tconst hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n\t\t\tif (hasTextBeforeClosingBracket) {\n\t\t\t\trenderHorizontalEndLineAtTheBottom = true;\n\t\t\t}\n\n\n\t\t\tconst visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n\t\t\tconst visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n\n\t\t\tconst offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n\n\t\t\tfor (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n\t\t\t\tresult[l - startLineNumber].push(\n\t\t\t\t\tnew IndentGuide(\n\t\t\t\t\t\tguideVisibleColumn,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\tclassName,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tl === start.lineNumber ? start.column : -1,\n\t\t\t\t\t\tl === end.lineNumber ? end.column : -1\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (horizontalGuides) {\n\t\t\t\tif (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n\t\t\t\t\tresult[start.lineNumber - startLineNumber].push(\n\t\t\t\t\t\tnew IndentGuide(\n\t\t\t\t\t\t\tguideVisibleColumn,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\tclassName,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(false, start.column),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n\t\t\t\t\tresult[end.lineNumber - startLineNumber].push(\n\t\t\t\t\t\tnew IndentGuide(\n\t\t\t\t\t\t\tguideVisibleColumn,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\tclassName,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const guides of result) {\n\t\t\tguides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate getVisibleColumnFromPosition(position: Position): number {\n\t\treturn (\n\t\t\tCursorColumns.visibleColumnFromColumn(\n\t\t\t\tthis.textModel.getLineContent(position.lineNumber),\n\t\t\t\tposition.column,\n\t\t\t\tthis.textModel.getOptions().tabSize\n\t\t\t) + 1\n\t\t);\n\t}\n\n\tpublic getLinesIndentGuides(\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number\n\t): number[] {\n\t\tthis.assertNotDisposed();\n\t\tconst lineCount = this.textModel.getLineCount();\n\n\t\tif (startLineNumber < 1 || startLineNumber > lineCount) {\n\t\t\tthrow new Error('Illegal value for startLineNumber');\n\t\t}\n\t\tif (endLineNumber < 1 || endLineNumber > lineCount) {\n\t\t\tthrow new Error('Illegal value for endLineNumber');\n\t\t}\n\n\t\tconst options = this.textModel.getOptions();\n\t\tconst foldingRules = this.getLanguageConfiguration(\n\t\t\tthis.textModel.getLanguageId()\n\t\t).foldingRules;\n\t\tconst offSide = Boolean(foldingRules && foldingRules.offSide);\n\n\t\tconst result: number[] = new Array<number>(\n\t\t\tendLineNumber - startLineNumber + 1\n\t\t);\n\n\t\tlet aboveContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet aboveContentLineIndent = -1;\n\n\t\tlet belowContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet belowContentLineIndent = -1;\n\n\t\tfor (\n\t\t\tlet lineNumber = startLineNumber;\n\t\t\tlineNumber <= endLineNumber;\n\t\t\tlineNumber++\n\t\t) {\n\t\t\tconst resultIndex = lineNumber - startLineNumber;\n\n\t\t\tconst currentIndent = this._computeIndentLevel(lineNumber - 1);\n\t\t\tif (currentIndent >= 0) {\n\t\t\t\t// This line has content (besides whitespace)\n\t\t\t\t// Use the line's indent\n\t\t\t\taboveContentLineIndex = lineNumber - 1;\n\t\t\t\taboveContentLineIndent = currentIndent;\n\t\t\t\tresult[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (aboveContentLineIndex === -2) {\n\t\t\t\taboveContentLineIndex = -1;\n\t\t\t\taboveContentLineIndent = -1;\n\n\t\t\t\t// must find previous line with content\n\t\t\t\tfor (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\taboveContentLineIndex = lineIndex;\n\t\t\t\t\t\taboveContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tbelowContentLineIndex !== -1 &&\n\t\t\t\t(belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)\n\t\t\t) {\n\t\t\t\tbelowContentLineIndex = -1;\n\t\t\t\tbelowContentLineIndent = -1;\n\n\t\t\t\t// must find next line with content\n\t\t\t\tfor (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tbelowContentLineIndex = lineIndex;\n\t\t\t\t\t\tbelowContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult[resultIndex] = this._getIndentLevelForWhitespaceLine(\n\t\t\t\toffSide,\n\t\t\t\taboveContentLineIndent,\n\t\t\t\tbelowContentLineIndent\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _getIndentLevelForWhitespaceLine(\n\t\toffSide: boolean,\n\t\taboveContentLineIndent: number,\n\t\tbelowContentLineIndent: number\n\t): number {\n\t\tconst options = this.textModel.getOptions();\n\n\t\tif (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n\t\t\t// At the top or bottom of the file\n\t\t\treturn 0;\n\t\t} else if (aboveContentLineIndent < belowContentLineIndent) {\n\t\t\t// we are inside the region above\n\t\t\treturn 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n\t\t} else if (aboveContentLineIndent === belowContentLineIndent) {\n\t\t\t// we are in between two regions\n\t\t\treturn Math.ceil(belowContentLineIndent / options.indentSize);\n\t\t} else {\n\t\t\tif (offSide) {\n\t\t\t\t// same level as region below\n\t\t\t\treturn Math.ceil(belowContentLineIndent / options.indentSize);\n\t\t\t} else {\n\t\t\t\t// we are inside the region that ends below\n\t\t\t\treturn 1 + Math.floor(belowContentLineIndent / options.indentSize);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class BracketPairGuidesClassNames {\n\tpublic readonly activeClassName = 'indent-active';\n\n\tgetInlineClassName(nestingLevel: number, nestingLevelOfEqualBracketType: number, independentColorPoolPerBracketType: boolean): string {\n\t\treturn this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n\t}\n\n\tgetInlineClassNameOfLevel(level: number): string {\n\t\t// To support a dynamic amount of colors up to 6 colors,\n\t\t// we use a number that is a lcm of all numbers from 1 to 6.\n\t\treturn `bracket-indent-guide lvl-${level % 30}`;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { IPosition, Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TextModel } from './textModel.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { ILanguageConfigurationService, ResolvedLanguageConfiguration } from '../languages/languageConfigurationRegistry.js';\nimport { BracketGuideOptions, HorizontalGuidesState, IActiveIndentGuideInfo, IGuidesTextModelPart, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n\nexport class GuidesTextModelPart extends TextModelPart implements IGuidesTextModelPart {\n\tconstructor(\n\t\tprivate readonly textModel: TextModel,\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getLanguageConfiguration(\n\t\tlanguageId: string\n\t): ResolvedLanguageConfiguration {\n\t\treturn this.languageConfigurationService.getLanguageConfiguration(\n\t\t\tlanguageId\n\t\t);\n\t}\n\n\tprivate _computeIndentLevel(lineIndex: number): number {\n\t\treturn computeIndentLevel(\n\t\t\tthis.textModel.getLineContent(lineIndex + 1),\n\t\t\tthis.textModel.getOptions().tabSize\n\t\t);\n\t}\n\n\tpublic getActiveIndentGuide(\n\t\tlineNumber: number,\n\t\tminLineNumber: number,\n\t\tmaxLineNumber: number\n\t): IActiveIndentGuideInfo {\n\t\tthis.assertNotDisposed();\n\t\tconst lineCount = this.textModel.getLineCount();\n\n\t\tif (lineNumber < 1 || lineNumber > lineCount) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\n\t\tconst foldingRules = this.getLanguageConfiguration(\n\t\t\tthis.textModel.getLanguageId()\n\t\t).foldingRules;\n\t\tconst offSide = Boolean(foldingRules && foldingRules.offSide);\n\n\t\tlet up_aboveContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet up_aboveContentLineIndent = -1;\n\t\tlet up_belowContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet up_belowContentLineIndent = -1;\n\t\tconst up_resolveIndents = (lineNumber: number) => {\n\t\t\tif (\n\t\t\t\tup_aboveContentLineIndex !== -1 &&\n\t\t\t\t(up_aboveContentLineIndex === -2 ||\n\t\t\t\t\tup_aboveContentLineIndex > lineNumber - 1)\n\t\t\t) {\n\t\t\t\tup_aboveContentLineIndex = -1;\n\t\t\t\tup_aboveContentLineIndent = -1;\n\n\t\t\t\t// must find previous line with content\n\t\t\t\tfor (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tup_aboveContentLineIndex = lineIndex;\n\t\t\t\t\t\tup_aboveContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (up_belowContentLineIndex === -2) {\n\t\t\t\tup_belowContentLineIndex = -1;\n\t\t\t\tup_belowContentLineIndent = -1;\n\n\t\t\t\t// must find next line with content\n\t\t\t\tfor (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tup_belowContentLineIndex = lineIndex;\n\t\t\t\t\t\tup_belowContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet down_aboveContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet down_aboveContentLineIndent = -1;\n\t\tlet down_belowContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet down_belowContentLineIndent = -1;\n\t\tconst down_resolveIndents = (lineNumber: number) => {\n\t\t\tif (down_aboveContentLineIndex === -2) {\n\t\t\t\tdown_aboveContentLineIndex = -1;\n\t\t\t\tdown_aboveContentLineIndent = -1;\n\n\t\t\t\t// must find previous line with content\n\t\t\t\tfor (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tdown_aboveContentLineIndex = lineIndex;\n\t\t\t\t\t\tdown_aboveContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tdown_belowContentLineIndex !== -1 &&\n\t\t\t\t(down_belowContentLineIndex === -2 ||\n\t\t\t\t\tdown_belowContentLineIndex < lineNumber - 1)\n\t\t\t) {\n\t\t\t\tdown_belowContentLineIndex = -1;\n\t\t\t\tdown_belowContentLineIndent = -1;\n\n\t\t\t\t// must find next line with content\n\t\t\t\tfor (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tdown_belowContentLineIndex = lineIndex;\n\t\t\t\t\t\tdown_belowContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet startLineNumber = 0;\n\t\tlet goUp = true;\n\t\tlet endLineNumber = 0;\n\t\tlet goDown = true;\n\t\tlet indent = 0;\n\n\t\tlet initialIndent = 0;\n\n\t\tfor (let distance = 0; goUp || goDown; distance++) {\n\t\t\tconst upLineNumber = lineNumber - distance;\n\t\t\tconst downLineNumber = lineNumber + distance;\n\n\t\t\tif (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n\t\t\t\tgoUp = false;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tdistance > 1 &&\n\t\t\t\t(downLineNumber > lineCount || downLineNumber > maxLineNumber)\n\t\t\t) {\n\t\t\t\tgoDown = false;\n\t\t\t}\n\t\t\tif (distance > 50000) {\n\t\t\t\t// stop processing\n\t\t\t\tgoUp = false;\n\t\t\t\tgoDown = false;\n\t\t\t}\n\n\t\t\tlet upLineIndentLevel: number = -1;\n\t\t\tif (goUp && upLineNumber >= 1) {\n\t\t\t\t// compute indent level going up\n\t\t\t\tconst currentIndent = this._computeIndentLevel(upLineNumber - 1);\n\t\t\t\tif (currentIndent >= 0) {\n\t\t\t\t\t// This line has content (besides whitespace)\n\t\t\t\t\t// Use the line's indent\n\t\t\t\t\tup_belowContentLineIndex = upLineNumber - 1;\n\t\t\t\t\tup_belowContentLineIndent = currentIndent;\n\t\t\t\t\tupLineIndentLevel = Math.ceil(\n\t\t\t\t\t\tcurrentIndent / this.textModel.getOptions().indentSize\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tup_resolveIndents(upLineNumber);\n\t\t\t\t\tupLineIndentLevel = this._getIndentLevelForWhitespaceLine(\n\t\t\t\t\t\toffSide,\n\t\t\t\t\t\tup_aboveContentLineIndent,\n\t\t\t\t\t\tup_belowContentLineIndent\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet downLineIndentLevel = -1;\n\t\t\tif (goDown && downLineNumber <= lineCount) {\n\t\t\t\t// compute indent level going down\n\t\t\t\tconst currentIndent = this._computeIndentLevel(downLineNumber - 1);\n\t\t\t\tif (currentIndent >= 0) {\n\t\t\t\t\t// This line has content (besides whitespace)\n\t\t\t\t\t// Use the line's indent\n\t\t\t\t\tdown_aboveContentLineIndex = downLineNumber - 1;\n\t\t\t\t\tdown_aboveContentLineIndent = currentIndent;\n\t\t\t\t\tdownLineIndentLevel = Math.ceil(\n\t\t\t\t\t\tcurrentIndent / this.textModel.getOptions().indentSize\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tdown_resolveIndents(downLineNumber);\n\t\t\t\t\tdownLineIndentLevel = this._getIndentLevelForWhitespaceLine(\n\t\t\t\t\t\toffSide,\n\t\t\t\t\t\tdown_aboveContentLineIndent,\n\t\t\t\t\t\tdown_belowContentLineIndent\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (distance === 0) {\n\t\t\t\tinitialIndent = upLineIndentLevel;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (distance === 1) {\n\t\t\t\tif (\n\t\t\t\t\tdownLineNumber <= lineCount &&\n\t\t\t\t\tdownLineIndentLevel >= 0 &&\n\t\t\t\t\tinitialIndent + 1 === downLineIndentLevel\n\t\t\t\t) {\n\t\t\t\t\t// This is the beginning of a scope, we have special handling here, since we want the\n\t\t\t\t\t// child scope indent to be active, not the parent scope\n\t\t\t\t\tgoUp = false;\n\t\t\t\t\tstartLineNumber = downLineNumber;\n\t\t\t\t\tendLineNumber = downLineNumber;\n\t\t\t\t\tindent = downLineIndentLevel;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tupLineNumber >= 1 &&\n\t\t\t\t\tupLineIndentLevel >= 0 &&\n\t\t\t\t\tupLineIndentLevel - 1 === initialIndent\n\t\t\t\t) {\n\t\t\t\t\t// This is the end of a scope, just like above\n\t\t\t\t\tgoDown = false;\n\t\t\t\t\tstartLineNumber = upLineNumber;\n\t\t\t\t\tendLineNumber = upLineNumber;\n\t\t\t\t\tindent = upLineIndentLevel;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstartLineNumber = lineNumber;\n\t\t\t\tendLineNumber = lineNumber;\n\t\t\t\tindent = initialIndent;\n\t\t\t\tif (indent === 0) {\n\t\t\t\t\t// No need to continue\n\t\t\t\t\treturn { startLineNumber, endLineNumber, indent };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (goUp) {\n\t\t\t\tif (upLineIndentLevel >= indent) {\n\t\t\t\t\tstartLineNumber = upLineNumber;\n\t\t\t\t} else {\n\t\t\t\t\tgoUp = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (goDown) {\n\t\t\t\tif (downLineIndentLevel >= indent) {\n\t\t\t\t\tendLineNumber = downLineNumber;\n\t\t\t\t} else {\n\t\t\t\t\tgoDown = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { startLineNumber, endLineNumber, indent };\n\t}\n\n\tpublic getLinesBracketGuides(\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number,\n\t\tactivePosition: IPosition | null,\n\t\toptions: BracketGuideOptions\n\t): IndentGuide[][] {\n\t\tconst result: IndentGuide[][] = [];\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tresult.push([]);\n\t\t}\n\n\t\t// If requested, this could be made configurable.\n\t\tconst includeSingleLinePairs = true;\n\n\t\tconst bracketPairs =\n\t\t\tthis.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(\n\t\t\t\tnew Range(\n\t\t\t\t\tstartLineNumber,\n\t\t\t\t\t1,\n\t\t\t\t\tendLineNumber,\n\t\t\t\t\tthis.textModel.getLineMaxColumn(endLineNumber)\n\t\t\t\t)\n\t\t\t).toArray();\n\n\t\tlet activeBracketPairRange: Range | undefined = undefined;\n\t\tif (activePosition && bracketPairs.length > 0) {\n\t\t\tconst bracketsContainingActivePosition = (\n\t\t\t\tstartLineNumber <= activePosition.lineNumber &&\n\t\t\t\t\tactivePosition.lineNumber <= endLineNumber\n\t\t\t\t\t// We don't need to query the brackets again if the cursor is in the viewport\n\t\t\t\t\t? bracketPairs\n\t\t\t\t\t: this.textModel.bracketPairs.getBracketPairsInRange(\n\t\t\t\t\t\tRange.fromPositions(activePosition)\n\t\t\t\t\t).toArray()\n\t\t\t).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n\n\t\t\tactiveBracketPairRange = findLast(\n\t\t\t\tbracketsContainingActivePosition,\n\t\t\t\t(i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber\n\t\t\t)?.range;\n\t\t}\n\n\t\tconst independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n\t\tconst colorProvider = new BracketPairGuidesClassNames();\n\n\t\tfor (const pair of bracketPairs) {\n\t\t\t/*\n\n\n\t\t\t\t\t{\n\t\t\t\t\t|\n\t\t\t\t\t}\n\n\t\t\t\t\t{\n\t\t\t\t\t|\n\t\t\t\t\t----}\n\n\t\t\t\t____{\n\t\t\t\t|test\n\t\t\t\t----}\n\n\t\t\t\trenderHorizontalEndLineAtTheBottom:\n\t\t\t\t\t{\n\t\t\t\t\t|\n\t\t\t\t\t|x}\n\t\t\t\t\t--\n\t\t\t\trenderHorizontalEndLineAtTheBottom:\n\t\t\t\t____{\n\t\t\t\t|test\n\t\t\t\t| x }\n\t\t\t\t----\n\t\t\t*/\n\n\t\t\tif (!pair.closingBracketRange) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n\n\t\t\tif (!isActive && !options.includeInactive) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst className =\n\t\t\t\tcolorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n\t\t\t\t(options.highlightActive && isActive\n\t\t\t\t\t? ' ' + colorProvider.activeClassName\n\t\t\t\t\t: '');\n\n\n\t\t\tconst start = pair.openingBracketRange.getStartPosition();\n\t\t\tconst end = pair.closingBracketRange.getStartPosition();\n\n\t\t\tconst horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n\n\t\t\tif (pair.range.startLineNumber === pair.range.endLineNumber) {\n\t\t\t\tif (includeSingleLinePairs && horizontalGuides) {\n\n\t\t\t\t\tresult[pair.range.startLineNumber - startLineNumber].push(\n\t\t\t\t\t\tnew IndentGuide(\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\tpair.openingBracketRange.getEndPosition().column,\n\t\t\t\t\t\t\tclassName,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(false, end.column),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst endVisibleColumn = this.getVisibleColumnFromPosition(end);\n\t\t\tconst startVisibleColumn = this.getVisibleColumnFromPosition(\n\t\t\t\tpair.openingBracketRange.getStartPosition()\n\t\t\t);\n\t\t\tconst guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n\n\t\t\tlet renderHorizontalEndLineAtTheBottom = false;\n\n\n\t\t\tconst firstNonWsIndex = strings.firstNonWhitespaceIndex(\n\t\t\t\tthis.textModel.getLineContent(\n\t\t\t\t\tpair.closingBracketRange.startLineNumber\n\t\t\t\t)\n\t\t\t);\n\t\t\tconst hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n\t\t\tif (hasTextBeforeClosingBracket) {\n\t\t\t\trenderHorizontalEndLineAtTheBottom = true;\n\t\t\t}\n\n\n\t\t\tconst visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n\t\t\tconst visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n\n\t\t\tconst offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n\n\t\t\tfor (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n\t\t\t\tresult[l - startLineNumber].push(\n\t\t\t\t\tnew IndentGuide(\n\t\t\t\t\t\tguideVisibleColumn,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\tclassName,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tl === start.lineNumber ? start.column : -1,\n\t\t\t\t\t\tl === end.lineNumber ? end.column : -1\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (horizontalGuides) {\n\t\t\t\tif (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n\t\t\t\t\tresult[start.lineNumber - startLineNumber].push(\n\t\t\t\t\t\tnew IndentGuide(\n\t\t\t\t\t\t\tguideVisibleColumn,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\tclassName,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(false, start.column),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n\t\t\t\t\tresult[end.lineNumber - startLineNumber].push(\n\t\t\t\t\t\tnew IndentGuide(\n\t\t\t\t\t\t\tguideVisibleColumn,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\tclassName,\n\t\t\t\t\t\t\tnew IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column),\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const guides of result) {\n\t\t\tguides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate getVisibleColumnFromPosition(position: Position): number {\n\t\treturn (\n\t\t\tCursorColumns.visibleColumnFromColumn(\n\t\t\t\tthis.textModel.getLineContent(position.lineNumber),\n\t\t\t\tposition.column,\n\t\t\t\tthis.textModel.getOptions().tabSize\n\t\t\t) + 1\n\t\t);\n\t}\n\n\tpublic getLinesIndentGuides(\n\t\tstartLineNumber: number,\n\t\tendLineNumber: number\n\t): number[] {\n\t\tthis.assertNotDisposed();\n\t\tconst lineCount = this.textModel.getLineCount();\n\n\t\tif (startLineNumber < 1 || startLineNumber > lineCount) {\n\t\t\tthrow new Error('Illegal value for startLineNumber');\n\t\t}\n\t\tif (endLineNumber < 1 || endLineNumber > lineCount) {\n\t\t\tthrow new Error('Illegal value for endLineNumber');\n\t\t}\n\n\t\tconst options = this.textModel.getOptions();\n\t\tconst foldingRules = this.getLanguageConfiguration(\n\t\t\tthis.textModel.getLanguageId()\n\t\t).foldingRules;\n\t\tconst offSide = Boolean(foldingRules && foldingRules.offSide);\n\n\t\tconst result: number[] = new Array<number>(\n\t\t\tendLineNumber - startLineNumber + 1\n\t\t);\n\n\t\tlet aboveContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet aboveContentLineIndent = -1;\n\n\t\tlet belowContentLineIndex =\n\t\t\t-2; /* -2 is a marker for not having computed it */\n\t\tlet belowContentLineIndent = -1;\n\n\t\tfor (\n\t\t\tlet lineNumber = startLineNumber;\n\t\t\tlineNumber <= endLineNumber;\n\t\t\tlineNumber++\n\t\t) {\n\t\t\tconst resultIndex = lineNumber - startLineNumber;\n\n\t\t\tconst currentIndent = this._computeIndentLevel(lineNumber - 1);\n\t\t\tif (currentIndent >= 0) {\n\t\t\t\t// This line has content (besides whitespace)\n\t\t\t\t// Use the line's indent\n\t\t\t\taboveContentLineIndex = lineNumber - 1;\n\t\t\t\taboveContentLineIndent = currentIndent;\n\t\t\t\tresult[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (aboveContentLineIndex === -2) {\n\t\t\t\taboveContentLineIndex = -1;\n\t\t\t\taboveContentLineIndent = -1;\n\n\t\t\t\t// must find previous line with content\n\t\t\t\tfor (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\taboveContentLineIndex = lineIndex;\n\t\t\t\t\t\taboveContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tbelowContentLineIndex !== -1 &&\n\t\t\t\t(belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)\n\t\t\t) {\n\t\t\t\tbelowContentLineIndex = -1;\n\t\t\t\tbelowContentLineIndent = -1;\n\n\t\t\t\t// must find next line with content\n\t\t\t\tfor (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n\t\t\t\t\tconst indent = this._computeIndentLevel(lineIndex);\n\t\t\t\t\tif (indent >= 0) {\n\t\t\t\t\t\tbelowContentLineIndex = lineIndex;\n\t\t\t\t\t\tbelowContentLineIndent = indent;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult[resultIndex] = this._getIndentLevelForWhitespaceLine(\n\t\t\t\toffSide,\n\t\t\t\taboveContentLineIndent,\n\t\t\t\tbelowContentLineIndent\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _getIndentLevelForWhitespaceLine(\n\t\toffSide: boolean,\n\t\taboveContentLineIndent: number,\n\t\tbelowContentLineIndent: number\n\t): number {\n\t\tconst options = this.textModel.getOptions();\n\n\t\tif (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n\t\t\t// At the top or bottom of the file\n\t\t\treturn 0;\n\t\t} else if (aboveContentLineIndent < belowContentLineIndent) {\n\t\t\t// we are inside the region above\n\t\t\treturn 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n\t\t} else if (aboveContentLineIndent === belowContentLineIndent) {\n\t\t\t// we are in between two regions\n\t\t\treturn Math.ceil(belowContentLineIndent / options.indentSize);\n\t\t} else {\n\t\t\tif (offSide) {\n\t\t\t\t// same level as region below\n\t\t\t\treturn Math.ceil(belowContentLineIndent / options.indentSize);\n\t\t\t} else {\n\t\t\t\t// we are inside the region that ends below\n\t\t\t\treturn 1 + Math.floor(belowContentLineIndent / options.indentSize);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class BracketPairGuidesClassNames {\n\tpublic readonly activeClassName = 'indent-active';\n\n\tgetInlineClassName(nestingLevel: number, nestingLevelOfEqualBracketType: number, independentColorPoolPerBracketType: boolean): string {\n\t\treturn this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n\t}\n\n\tgetInlineClassNameOfLevel(level: number): string {\n\t\t// To support a dynamic amount of colors up to 6 colors,\n\t\t// we use a number that is a lcm of all numbers from 1 to 6.\n\t\treturn `bracket-indent-guide lvl-${level % 30}`;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Position } from '../../../core/position.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/text/textLength.js';\n\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount: number, startColumnCount: number, endLineCount: number, endColumnCount: number): Length {\n\treturn (startLineCount !== endLineCount)\n\t\t? toLength(endLineCount - startLineCount, endColumnCount)\n\t\t: toLength(0, endColumnCount - startColumnCount);\n}\n\n/**\n * Represents a non-negative length in terms of line and column count.\n * Does not allocate.\n*/\nexport type Length = { _brand: 'Length' };\n\nexport const lengthZero = 0 as any as Length;\n\nexport function lengthIsZero(length: Length): boolean {\n\treturn length as any as number === 0;\n}\n\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\n\nexport function toLength(lineCount: number, columnCount: number): Length {\n\t// llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n\t//       line count (26 bits)    column count (26 bits)\n\n\t// If there is no overflow (all values/sums below 2^26 = 67108864),\n\t// we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n\n\treturn (lineCount * factor + columnCount) as any as Length;\n}\n\nexport function lengthToObj(length: Length): TextLength {\n\tconst l = length as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst columnCount = l - lineCount * factor;\n\treturn new TextLength(lineCount, columnCount);\n}\n\nexport function lengthGetLineCount(length: Length): number {\n\treturn Math.floor(length as any as number / factor);\n}\n\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length: Length): number {\n\treturn length as any as number;\n}\n\n\n// [10 lines, 5 cols] + [ 0 lines, 3 cols] = [10 lines, 8 cols]\n// [10 lines, 5 cols] + [20 lines, 3 cols] = [30 lines, 3 cols]\nexport function lengthAdd(length1: Length, length2: Length): Length;\nexport function lengthAdd(l1: any, l2: any): Length {\n\tlet r = l1 + l2;\n\tif (l2 >= factor) { r = r - (l1 % factor); }\n\treturn r;\n}\n\nexport function sumLengths<T>(items: readonly T[], lengthFn: (item: T) => Length): Length {\n\treturn items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\n\nexport function lengthEquals(length1: Length, length2: Length): boolean {\n\treturn length1 === length2;\n}\n\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1: Length, length2: Length): Length {\n\tconst l1 = length1 as any as number;\n\tconst l2 = length2 as any as number;\n\n\tconst diff = l2 - l1;\n\tif (diff <= 0) {\n\t\t// line-count of length1 is higher than line-count of length2\n\t\t// or they are equal and column-count of length1 is higher than column-count of length2\n\t\treturn lengthZero;\n\t}\n\n\tconst lineCount1 = Math.floor(l1 / factor);\n\tconst lineCount2 = Math.floor(l2 / factor);\n\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\tif (lineCount1 === lineCount2) {\n\t\tconst colCount1 = l1 - lineCount1 * factor;\n\t\treturn toLength(0, colCount2 - colCount1);\n\t} else {\n\t\treturn toLength(lineCount2 - lineCount1, colCount2);\n\t}\n}\n\nexport function lengthLessThan(length1: Length, length2: Length): boolean {\n\t// First, compare line counts, then column counts.\n\treturn (length1 as any as number) < (length2 as any as number);\n}\n\nexport function lengthLessThanEqual(length1: Length, length2: Length): boolean {\n\treturn (length1 as any as number) <= (length2 as any as number);\n}\n\nexport function lengthGreaterThanEqual(length1: Length, length2: Length): boolean {\n\treturn (length1 as any as number) >= (length2 as any as number);\n}\n\nexport function positionToLength(position: Position): Length {\n\treturn toLength(position.lineNumber - 1, position.column - 1);\n}\n\nexport function lengthsToRange(lengthStart: Length, lengthEnd: Length): Range {\n\tconst l = lengthStart as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst colCount = l - lineCount * factor;\n\n\tconst l2 = lengthEnd as any as number;\n\tconst lineCount2 = Math.floor(l2 / factor);\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\treturn new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\n\nexport function lengthOfString(str: string): Length {\n\tconst lines = splitLines(str);\n\treturn toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Position } from '../../../core/position.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/text/textLength.js';\n\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount: number, startColumnCount: number, endLineCount: number, endColumnCount: number): Length {\n\treturn (startLineCount !== endLineCount)\n\t\t? toLength(endLineCount - startLineCount, endColumnCount)\n\t\t: toLength(0, endColumnCount - startColumnCount);\n}\n\n/**\n * Represents a non-negative length in terms of line and column count.\n * Does not allocate.\n*/\nexport type Length = { _brand: 'Length' };\n\nexport const lengthZero = 0 as any as Length;\n\nexport function lengthIsZero(length: Length): boolean {\n\treturn length as any as number === 0;\n}\n\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\n\nexport function toLength(lineCount: number, columnCount: number): Length {\n\t// llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n\t//       line count (26 bits)    column count (26 bits)\n\n\t// If there is no overflow (all values/sums below 2^26 = 67108864),\n\t// we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n\n\treturn (lineCount * factor + columnCount) as any as Length;\n}\n\nexport function lengthToObj(length: Length): TextLength {\n\tconst l = length as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst columnCount = l - lineCount * factor;\n\treturn new TextLength(lineCount, columnCount);\n}\n\nexport function lengthGetLineCount(length: Length): number {\n\treturn Math.floor(length as any as number / factor);\n}\n\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length: Length): number {\n\treturn length as any as number;\n}\n\n\n// [10 lines, 5 cols] + [ 0 lines, 3 cols] = [10 lines, 8 cols]\n// [10 lines, 5 cols] + [20 lines, 3 cols] = [30 lines, 3 cols]\nexport function lengthAdd(length1: Length, length2: Length): Length;\nexport function lengthAdd(l1: any, l2: any): Length {\n\tlet r = l1 + l2;\n\tif (l2 >= factor) { r = r - (l1 % factor); }\n\treturn r;\n}\n\nexport function sumLengths<T>(items: readonly T[], lengthFn: (item: T) => Length): Length {\n\treturn items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\n\nexport function lengthEquals(length1: Length, length2: Length): boolean {\n\treturn length1 === length2;\n}\n\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1: Length, length2: Length): Length {\n\tconst l1 = length1 as any as number;\n\tconst l2 = length2 as any as number;\n\n\tconst diff = l2 - l1;\n\tif (diff <= 0) {\n\t\t// line-count of length1 is higher than line-count of length2\n\t\t// or they are equal and column-count of length1 is higher than column-count of length2\n\t\treturn lengthZero;\n\t}\n\n\tconst lineCount1 = Math.floor(l1 / factor);\n\tconst lineCount2 = Math.floor(l2 / factor);\n\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\tif (lineCount1 === lineCount2) {\n\t\tconst colCount1 = l1 - lineCount1 * factor;\n\t\treturn toLength(0, colCount2 - colCount1);\n\t} else {\n\t\treturn toLength(lineCount2 - lineCount1, colCount2);\n\t}\n}\n\nexport function lengthLessThan(length1: Length, length2: Length): boolean {\n\t// First, compare line counts, then column counts.\n\treturn (length1 as any as number) < (length2 as any as number);\n}\n\nexport function lengthLessThanEqual(length1: Length, length2: Length): boolean {\n\treturn (length1 as any as number) <= (length2 as any as number);\n}\n\nexport function lengthGreaterThanEqual(length1: Length, length2: Length): boolean {\n\treturn (length1 as any as number) >= (length2 as any as number);\n}\n\nexport function positionToLength(position: Position): Length {\n\treturn toLength(position.lineNumber - 1, position.column - 1);\n}\n\nexport function lengthsToRange(lengthStart: Length, lengthEnd: Length): Range {\n\tconst l = lengthStart as any as number;\n\tconst lineCount = Math.floor(l / factor);\n\tconst colCount = l - lineCount * factor;\n\n\tconst l2 = lengthEnd as any as number;\n\tconst lineCount2 = Math.floor(l2 / factor);\n\tconst colCount2 = l2 - lineCount2 * factor;\n\n\treturn new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\n\nexport function lengthOfString(str: string): Length {\n\tconst lines = splitLines(str);\n\treturn toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 607, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../../../core/range.js';\nimport { Length, lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nimport { TextLength } from '../../../core/text/textLength.js';\nimport { IModelContentChange } from '../../mirrorTextModel.js';\n\nexport class TextEditInfo {\n\tpublic static fromModelContentChanges(changes: IModelContentChange[]): TextEditInfo[] {\n\t\t// Must be sorted in ascending order\n\t\tconst edits = changes.map(c => {\n\t\t\tconst range = Range.lift(c.range);\n\t\t\treturn new TextEditInfo(\n\t\t\t\tpositionToLength(range.getStartPosition()),\n\t\t\t\tpositionToLength(range.getEndPosition()),\n\t\t\t\tlengthOfString(c.text)\n\t\t\t);\n\t\t}).reverse();\n\t\treturn edits;\n\t}\n\n\tconstructor(\n\t\tpublic readonly startOffset: Length,\n\t\tpublic readonly endOffset: Length,\n\t\tpublic readonly newLength: Length\n\t) {\n\t}\n\n\ttoString(): string {\n\t\treturn `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n\t}\n}\n\nexport class BeforeEditPositionMapper {\n\tprivate nextEditIdx = 0;\n\tprivate deltaOldToNewLineCount = 0;\n\tprivate deltaOldToNewColumnCount = 0;\n\tprivate deltaLineIdxInOld = -1;\n\tprivate readonly edits: readonly TextEditInfoCache[];\n\n\t/**\n\t * @param edits Must be sorted by offset in ascending order.\n\t*/\n\tconstructor(\n\t\tedits: readonly TextEditInfo[],\n\t) {\n\t\tthis.edits = edits.map(edit => TextEditInfoCache.from(edit));\n\t}\n\n\t/**\n\t * @param offset Must be equal to or greater than the last offset this method has been called with.\n\t*/\n\tgetOffsetBeforeChange(offset: Length): Length {\n\t\tthis.adjustNextEdit(offset);\n\t\treturn this.translateCurToOld(offset);\n\t}\n\n\t/**\n\t * @param offset Must be equal to or greater than the last offset this method has been called with.\n\t * Returns null if there is no edit anymore.\n\t*/\n\tgetDistanceToNextChange(offset: Length): Length | null {\n\t\tthis.adjustNextEdit(offset);\n\n\t\tconst nextEdit = this.edits[this.nextEditIdx];\n\t\tconst nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n\t\tif (nextChangeOffset === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn lengthDiffNonNegative(offset, nextChangeOffset);\n\t}\n\n\tprivate translateOldToCur(oldOffsetObj: TextLength): Length {\n\t\tif (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n\t\t\treturn toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n\t\t} else {\n\t\t\treturn toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n\t\t}\n\t}\n\n\tprivate translateCurToOld(newOffset: Length): Length {\n\t\tconst offsetObj = lengthToObj(newOffset);\n\t\tif (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n\t\t\treturn toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n\t\t} else {\n\t\t\treturn toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n\t\t}\n\t}\n\n\tprivate adjustNextEdit(offset: Length) {\n\t\twhile (this.nextEditIdx < this.edits.length) {\n\t\t\tconst nextEdit = this.edits[this.nextEditIdx];\n\n\t\t\t// After applying the edit, what is its end offset (considering all previous edits)?\n\t\t\tconst nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n\n\t\t\tif (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n\t\t\t\t// We are after the edit, skip it\n\t\t\t\tthis.nextEditIdx++;\n\n\t\t\t\tconst nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n\n\t\t\t\t// Before applying the edit, what is its end offset (considering all previous edits)?\n\t\t\t\tconst nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n\n\t\t\t\tconst lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n\t\t\t\tthis.deltaOldToNewLineCount += lineDelta;\n\n\t\t\t\tconst previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n\t\t\t\tconst columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n\t\t\t\tthis.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n\t\t\t\tthis.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n\t\t\t} else {\n\t\t\t\t// We are in or before the edit.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass TextEditInfoCache {\n\tstatic from(edit: TextEditInfo): TextEditInfoCache {\n\t\treturn new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n\t}\n\n\tpublic readonly endOffsetBeforeObj: TextLength;\n\tpublic readonly endOffsetAfterObj: TextLength;\n\tpublic readonly offsetObj: TextLength;\n\n\tconstructor(\n\t\tstartOffset: Length,\n\t\tendOffset: Length,\n\t\ttextLength: Length,\n\t) {\n\t\tthis.endOffsetBeforeObj = lengthToObj(endOffset);\n\t\tthis.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n\t\tthis.offsetObj = lengthToObj(startOffset);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../../../core/range.js';\nimport { Length, lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nimport { TextLength } from '../../../core/text/textLength.js';\nimport { IModelContentChange } from '../../mirrorTextModel.js';\n\nexport class TextEditInfo {\n\tpublic static fromModelContentChanges(changes: IModelContentChange[]): TextEditInfo[] {\n\t\t// Must be sorted in ascending order\n\t\tconst edits = changes.map(c => {\n\t\t\tconst range = Range.lift(c.range);\n\t\t\treturn new TextEditInfo(\n\t\t\t\tpositionToLength(range.getStartPosition()),\n\t\t\t\tpositionToLength(range.getEndPosition()),\n\t\t\t\tlengthOfString(c.text)\n\t\t\t);\n\t\t}).reverse();\n\t\treturn edits;\n\t}\n\n\tconstructor(\n\t\tpublic readonly startOffset: Length,\n\t\tpublic readonly endOffset: Length,\n\t\tpublic readonly newLength: Length\n\t) {\n\t}\n\n\ttoString(): string {\n\t\treturn `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n\t}\n}\n\nexport class BeforeEditPositionMapper {\n\tprivate nextEditIdx = 0;\n\tprivate deltaOldToNewLineCount = 0;\n\tprivate deltaOldToNewColumnCount = 0;\n\tprivate deltaLineIdxInOld = -1;\n\tprivate readonly edits: readonly TextEditInfoCache[];\n\n\t/**\n\t * @param edits Must be sorted by offset in ascending order.\n\t*/\n\tconstructor(\n\t\tedits: readonly TextEditInfo[],\n\t) {\n\t\tthis.edits = edits.map(edit => TextEditInfoCache.from(edit));\n\t}\n\n\t/**\n\t * @param offset Must be equal to or greater than the last offset this method has been called with.\n\t*/\n\tgetOffsetBeforeChange(offset: Length): Length {\n\t\tthis.adjustNextEdit(offset);\n\t\treturn this.translateCurToOld(offset);\n\t}\n\n\t/**\n\t * @param offset Must be equal to or greater than the last offset this method has been called with.\n\t * Returns null if there is no edit anymore.\n\t*/\n\tgetDistanceToNextChange(offset: Length): Length | null {\n\t\tthis.adjustNextEdit(offset);\n\n\t\tconst nextEdit = this.edits[this.nextEditIdx];\n\t\tconst nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n\t\tif (nextChangeOffset === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn lengthDiffNonNegative(offset, nextChangeOffset);\n\t}\n\n\tprivate translateOldToCur(oldOffsetObj: TextLength): Length {\n\t\tif (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n\t\t\treturn toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n\t\t} else {\n\t\t\treturn toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n\t\t}\n\t}\n\n\tprivate translateCurToOld(newOffset: Length): Length {\n\t\tconst offsetObj = lengthToObj(newOffset);\n\t\tif (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n\t\t\treturn toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n\t\t} else {\n\t\t\treturn toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n\t\t}\n\t}\n\n\tprivate adjustNextEdit(offset: Length) {\n\t\twhile (this.nextEditIdx < this.edits.length) {\n\t\t\tconst nextEdit = this.edits[this.nextEditIdx];\n\n\t\t\t// After applying the edit, what is its end offset (considering all previous edits)?\n\t\t\tconst nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n\n\t\t\tif (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n\t\t\t\t// We are after the edit, skip it\n\t\t\t\tthis.nextEditIdx++;\n\n\t\t\t\tconst nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n\n\t\t\t\t// Before applying the edit, what is its end offset (considering all previous edits)?\n\t\t\t\tconst nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n\n\t\t\t\tconst lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n\t\t\t\tthis.deltaOldToNewLineCount += lineDelta;\n\n\t\t\t\tconst previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n\t\t\t\tconst columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n\t\t\t\tthis.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n\t\t\t\tthis.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n\t\t\t} else {\n\t\t\t\t// We are in or before the edit.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass TextEditInfoCache {\n\tstatic from(edit: TextEditInfo): TextEditInfoCache {\n\t\treturn new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n\t}\n\n\tpublic readonly endOffsetBeforeObj: TextLength;\n\tpublic readonly endOffsetAfterObj: TextLength;\n\tpublic readonly offsetObj: TextLength;\n\n\tconstructor(\n\t\tstartOffset: Length,\n\t\tendOffset: Length,\n\t\ttextLength: Length,\n\t) {\n\t\tthis.endOffsetBeforeObj = lengthToObj(endOffset);\n\t\tthis.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n\t\tthis.offsetObj = lengthToObj(startOffset);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 718, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst emptyArr: number[] = [];\n\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet<T> {\n\tprivate static cache = new Array<SmallImmutableSet<any>>(129);\n\n\tprivate static create<T>(items: number, additionalItems: readonly number[]): SmallImmutableSet<T> {\n\t\tif (items <= 128 && additionalItems.length === 0) {\n\t\t\t// We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n\t\t\tlet cached = SmallImmutableSet.cache[items];\n\t\t\tif (!cached) {\n\t\t\t\tcached = new SmallImmutableSet(items, additionalItems);\n\t\t\t\tSmallImmutableSet.cache[items] = cached;\n\t\t\t}\n\t\t\treturn cached;\n\t\t}\n\n\t\treturn new SmallImmutableSet(items, additionalItems);\n\t}\n\n\tprivate static empty = SmallImmutableSet.create<any>(0, emptyArr);\n\tpublic static getEmpty<T>(): SmallImmutableSet<T> {\n\t\treturn this.empty;\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly items: number,\n\t\tprivate readonly additionalItems: readonly number[]\n\t) {\n\t}\n\n\tpublic add(value: T, keyProvider: IDenseKeyProvider<T>): SmallImmutableSet<T> {\n\t\tconst key = keyProvider.getKey(value);\n\t\tlet idx = key >> 5; // divided by 32\n\t\tif (idx === 0) {\n\t\t\t// fast path\n\t\t\tconst newItem = (1 << key) | this.items;\n\t\t\tif (newItem === this.items) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn SmallImmutableSet.create(newItem, this.additionalItems);\n\t\t}\n\t\tidx--;\n\n\t\tconst newItems = this.additionalItems.slice(0);\n\t\twhile (newItems.length < idx) {\n\t\t\tnewItems.push(0);\n\t\t}\n\t\tnewItems[idx] |= 1 << (key & 31);\n\n\t\treturn SmallImmutableSet.create(this.items, newItems);\n\t}\n\n\tpublic merge(other: SmallImmutableSet<T>): SmallImmutableSet<T> {\n\t\tconst merged = this.items | other.items;\n\n\t\tif (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n\t\t\t// fast path\n\t\t\tif (merged === this.items) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (merged === other.items) {\n\t\t\t\treturn other;\n\t\t\t}\n\t\t\treturn SmallImmutableSet.create(merged, emptyArr);\n\t\t}\n\n\t\t// This can be optimized, but it's not a common case\n\t\tconst newItems: number[] = [];\n\t\tfor (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n\t\t\tconst item1 = this.additionalItems[i] || 0;\n\t\t\tconst item2 = other.additionalItems[i] || 0;\n\t\t\tnewItems.push(item1 | item2);\n\t\t}\n\n\t\treturn SmallImmutableSet.create(merged, newItems);\n\t}\n\n\tpublic intersects(other: SmallImmutableSet<T>): boolean {\n\t\tif ((this.items & other.items) !== 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfor (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n\t\t\tif ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nexport interface IDenseKeyProvider<T> {\n\tgetKey(value: T): number;\n}\n\nexport const identityKeyProvider: IDenseKeyProvider<number> = {\n\tgetKey(value: number) {\n\t\treturn value;\n\t}\n};\n\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider<T> {\n\tprivate readonly items = new Map<T, number>();\n\n\tgetKey(value: T): number {\n\t\tlet existing = this.items.get(value);\n\t\tif (existing === undefined) {\n\t\t\texisting = this.items.size;\n\t\t\tthis.items.set(value, existing);\n\t\t}\n\t\treturn existing;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst emptyArr: number[] = [];\n\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet<T> {\n\tprivate static cache = new Array<SmallImmutableSet<any>>(129);\n\n\tprivate static create<T>(items: number, additionalItems: readonly number[]): SmallImmutableSet<T> {\n\t\tif (items <= 128 && additionalItems.length === 0) {\n\t\t\t// We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n\t\t\tlet cached = SmallImmutableSet.cache[items];\n\t\t\tif (!cached) {\n\t\t\t\tcached = new SmallImmutableSet(items, additionalItems);\n\t\t\t\tSmallImmutableSet.cache[items] = cached;\n\t\t\t}\n\t\t\treturn cached;\n\t\t}\n\n\t\treturn new SmallImmutableSet(items, additionalItems);\n\t}\n\n\tprivate static empty = SmallImmutableSet.create<any>(0, emptyArr);\n\tpublic static getEmpty<T>(): SmallImmutableSet<T> {\n\t\treturn this.empty;\n\t}\n\n\tprivate constructor(\n\t\tprivate readonly items: number,\n\t\tprivate readonly additionalItems: readonly number[]\n\t) {\n\t}\n\n\tpublic add(value: T, keyProvider: IDenseKeyProvider<T>): SmallImmutableSet<T> {\n\t\tconst key = keyProvider.getKey(value);\n\t\tlet idx = key >> 5; // divided by 32\n\t\tif (idx === 0) {\n\t\t\t// fast path\n\t\t\tconst newItem = (1 << key) | this.items;\n\t\t\tif (newItem === this.items) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn SmallImmutableSet.create(newItem, this.additionalItems);\n\t\t}\n\t\tidx--;\n\n\t\tconst newItems = this.additionalItems.slice(0);\n\t\twhile (newItems.length < idx) {\n\t\t\tnewItems.push(0);\n\t\t}\n\t\tnewItems[idx] |= 1 << (key & 31);\n\n\t\treturn SmallImmutableSet.create(this.items, newItems);\n\t}\n\n\tpublic merge(other: SmallImmutableSet<T>): SmallImmutableSet<T> {\n\t\tconst merged = this.items | other.items;\n\n\t\tif (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n\t\t\t// fast path\n\t\t\tif (merged === this.items) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (merged === other.items) {\n\t\t\t\treturn other;\n\t\t\t}\n\t\t\treturn SmallImmutableSet.create(merged, emptyArr);\n\t\t}\n\n\t\t// This can be optimized, but it's not a common case\n\t\tconst newItems: number[] = [];\n\t\tfor (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n\t\t\tconst item1 = this.additionalItems[i] || 0;\n\t\t\tconst item2 = other.additionalItems[i] || 0;\n\t\t\tnewItems.push(item1 | item2);\n\t\t}\n\n\t\treturn SmallImmutableSet.create(merged, newItems);\n\t}\n\n\tpublic intersects(other: SmallImmutableSet<T>): boolean {\n\t\tif ((this.items & other.items) !== 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfor (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n\t\t\tif ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nexport interface IDenseKeyProvider<T> {\n\tgetKey(value: T): number;\n}\n\nexport const identityKeyProvider: IDenseKeyProvider<number> = {\n\tgetKey(value: number) {\n\t\treturn value;\n\t}\n};\n\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider<T> {\n\tprivate readonly items = new Map<T, number>();\n\n\tgetKey(value: T): number {\n\t\tlet existing = this.items.get(value);\n\t\tif (existing === undefined) {\n\t\t\texisting = this.items.size;\n\t\t\tthis.items.set(value, existing);\n\t\t}\n\t\treturn existing;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 826, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { BracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\nimport { ITextModel } from '../../../model.js';\nimport { Length, lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { OpeningBracketId } from './tokenizer.js';\n\nexport const enum AstNodeKind {\n\tText = 0,\n\tBracket = 1,\n\tPair = 2,\n\tUnexpectedClosingBracket = 3,\n\tList = 4,\n}\n\nexport type AstNode = PairAstNode | ListAstNode | BracketAstNode | InvalidBracketAstNode | TextAstNode;\n\n/**\n * The base implementation for all AST nodes.\n*/\nabstract class BaseAstNode {\n\tpublic abstract readonly kind: AstNodeKind;\n\n\tpublic abstract readonly childrenLength: number;\n\n\t/**\n\t * Might return null even if {@link idx} is smaller than {@link BaseAstNode.childrenLength}.\n\t*/\n\tpublic abstract getChild(idx: number): AstNode | null;\n\n\t/**\n\t * Try to avoid using this property, as implementations might need to allocate the resulting array.\n\t*/\n\tpublic abstract readonly children: readonly AstNode[];\n\n\t/**\n\t * Represents the set of all (potentially) missing opening bracket ids in this node.\n\t * E.g. in `{ ] ) }` that set is {`[`, `(` }.\n\t*/\n\tpublic abstract readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;\n\n\t/**\n\t * In case of a list, determines the height of the (2,3) tree.\n\t*/\n\tpublic abstract readonly listHeight: number;\n\n\tprotected _length: Length;\n\n\t/**\n\t * The length of the entire node, which should equal the sum of lengths of all children.\n\t*/\n\tpublic get length(): Length {\n\t\treturn this._length;\n\t}\n\n\tpublic constructor(length: Length) {\n\t\tthis._length = length;\n\t}\n\n\t/**\n\t * @param openBracketIds The set of all opening brackets that have not yet been closed.\n\t */\n\tpublic abstract canBeReused(\n\t\topenBracketIds: SmallImmutableSet<OpeningBracketId>\n\t): boolean;\n\n\t/**\n\t * Creates a deep clone.\n\t */\n\tpublic abstract deepClone(): AstNode;\n\n\tpublic abstract computeMinIndentation(offset: Length, textModel: ITextModel): number;\n}\n\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n\tpublic static create(\n\t\topeningBracket: BracketAstNode,\n\t\tchild: AstNode | null,\n\t\tclosingBracket: BracketAstNode | null\n\t) {\n\t\tlet length = openingBracket.length;\n\t\tif (child) {\n\t\t\tlength = lengthAdd(length, child.length);\n\t\t}\n\t\tif (closingBracket) {\n\t\t\tlength = lengthAdd(length, closingBracket.length);\n\t\t}\n\t\treturn new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n\t}\n\n\tpublic get kind(): AstNodeKind.Pair {\n\t\treturn AstNodeKind.Pair;\n\t}\n\tpublic get listHeight() {\n\t\treturn 0;\n\t}\n\tpublic get childrenLength(): number {\n\t\treturn 3;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\tswitch (idx) {\n\t\t\tcase 0: return this.openingBracket;\n\t\t\tcase 1: return this.child;\n\t\t\tcase 2: return this.closingBracket;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\n\t/**\n\t * Avoid using this property, it allocates an array!\n\t*/\n\tpublic get children() {\n\t\tconst result: AstNode[] = [];\n\t\tresult.push(this.openingBracket);\n\t\tif (this.child) {\n\t\t\tresult.push(this.child);\n\t\t}\n\t\tif (this.closingBracket) {\n\t\t\tresult.push(this.closingBracket);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate constructor(\n\t\tlength: Length,\n\t\tpublic readonly openingBracket: BracketAstNode,\n\t\tpublic readonly child: AstNode | null,\n\t\tpublic readonly closingBracket: BracketAstNode | null,\n\t\tpublic readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tpublic canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\tif (this.closingBracket === null) {\n\t\t\t// Unclosed pair ast nodes only\n\t\t\t// end at the end of the document\n\t\t\t// or when a parent node is closed.\n\n\t\t\t// This could be improved:\n\t\t\t// Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic deepClone(): PairAstNode {\n\t\treturn new PairAstNode(\n\t\t\tthis.length,\n\t\t\tthis.openingBracket.deepClone(),\n\t\t\tthis.child && this.child.deepClone(),\n\t\t\tthis.closingBracket && this.closingBracket.deepClone(),\n\t\t\tthis.missingOpeningBracketIds\n\t\t);\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n\t}\n}\n\nexport abstract class ListAstNode extends BaseAstNode {\n\t/**\n\t * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n\t*/\n\tpublic static create23(item1: AstNode, item2: AstNode, item3: AstNode | null, immutable: boolean = false): ListAstNode {\n\t\tlet length = item1.length;\n\t\tlet missingBracketIds = item1.missingOpeningBracketIds;\n\n\t\tif (item1.listHeight !== item2.listHeight) {\n\t\t\tthrow new Error('Invalid list heights');\n\t\t}\n\n\t\tlength = lengthAdd(length, item2.length);\n\t\tmissingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n\n\t\tif (item3) {\n\t\t\tif (item1.listHeight !== item3.listHeight) {\n\t\t\t\tthrow new Error('Invalid list heights');\n\t\t\t}\n\t\t\tlength = lengthAdd(length, item3.length);\n\t\t\tmissingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n\t\t}\n\t\treturn immutable\n\t\t\t? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n\t\t\t: new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n\t}\n\n\tpublic static getEmpty() {\n\t\treturn new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n\t}\n\n\tpublic get kind(): AstNodeKind.List {\n\t\treturn AstNodeKind.List;\n\t}\n\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn this._missingOpeningBracketIds;\n\t}\n\n\tprivate cachedMinIndentation: number = -1;\n\n\t/**\n\t * Use ListAstNode.create.\n\t*/\n\tconstructor(\n\t\tlength: Length,\n\t\tpublic readonly listHeight: number,\n\t\tprivate _missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tprotected throwIfImmutable(): void {\n\t\t// NOOP\n\t}\n\n\tprotected abstract setChild(idx: number, child: AstNode): void;\n\n\tpublic makeLastElementMutable(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst childCount = this.childrenLength;\n\t\tif (childCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst lastChild = this.getChild(childCount - 1)!;\n\t\tconst mutable = lastChild.kind === AstNodeKind.List ? lastChild.toMutable() : lastChild;\n\t\tif (lastChild !== mutable) {\n\t\t\tthis.setChild(childCount - 1, mutable);\n\t\t}\n\t\treturn mutable;\n\t}\n\n\tpublic makeFirstElementMutable(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst childCount = this.childrenLength;\n\t\tif (childCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst firstChild = this.getChild(0)!;\n\t\tconst mutable = firstChild.kind === AstNodeKind.List ? firstChild.toMutable() : firstChild;\n\t\tif (firstChild !== mutable) {\n\t\t\tthis.setChild(0, mutable);\n\t\t}\n\t\treturn mutable;\n\t}\n\n\tpublic canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>): boolean {\n\t\tif (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.childrenLength === 0) {\n\t\t\t// Don't reuse empty lists.\n\t\t\treturn false;\n\t\t}\n\n\t\tlet lastChild: ListAstNode = this;\n\t\twhile (lastChild.kind === AstNodeKind.List) {\n\t\t\tconst lastLength = lastChild.childrenLength;\n\t\t\tif (lastLength === 0) {\n\t\t\t\t// Empty lists should never be contained in other lists.\n\t\t\t\tthrow new BugIndicatingError();\n\t\t\t}\n\t\t\tlastChild = lastChild.getChild(lastLength - 1) as ListAstNode;\n\t\t}\n\n\t\treturn lastChild.canBeReused(openBracketIds);\n\t}\n\n\tpublic handleChildrenChanged(): void {\n\t\tthis.throwIfImmutable();\n\n\t\tconst count = this.childrenLength;\n\n\t\tlet length = this.getChild(0)!.length;\n\t\tlet unopenedBrackets = this.getChild(0)!.missingOpeningBracketIds;\n\n\t\tfor (let i = 1; i < count; i++) {\n\t\t\tconst child = this.getChild(i)!;\n\t\t\tlength = lengthAdd(length, child.length);\n\t\t\tunopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n\t\t}\n\n\t\tthis._length = length;\n\t\tthis._missingOpeningBracketIds = unopenedBrackets;\n\t\tthis.cachedMinIndentation = -1;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\tif (this.cachedMinIndentation !== -1) {\n\t\t\treturn this.cachedMinIndentation;\n\t\t}\n\n\t\tlet minIndentation = Number.MAX_SAFE_INTEGER;\n\t\tlet childOffset = offset;\n\t\tfor (let i = 0; i < this.childrenLength; i++) {\n\t\t\tconst child = this.getChild(i);\n\t\t\tif (child) {\n\t\t\t\tminIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n\t\t\t\tchildOffset = lengthAdd(childOffset, child.length);\n\t\t\t}\n\t\t}\n\n\t\tthis.cachedMinIndentation = minIndentation;\n\t\treturn minIndentation;\n\t}\n\n\t/**\n\t * Creates a shallow clone that is mutable, or itself if it is already mutable.\n\t */\n\tpublic abstract toMutable(): ListAstNode;\n\n\tpublic abstract appendChildOfSameHeight(node: AstNode): void;\n\tpublic abstract unappendChild(): AstNode | undefined;\n\tpublic abstract prependChildOfSameHeight(node: AstNode): void;\n\tpublic abstract unprependChild(): AstNode | undefined;\n}\n\nclass TwoThreeListAstNode extends ListAstNode {\n\tpublic get childrenLength(): number {\n\t\treturn this._item3 !== null ? 3 : 2;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\tswitch (idx) {\n\t\t\tcase 0: return this._item1;\n\t\t\tcase 1: return this._item2;\n\t\t\tcase 2: return this._item3;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\tprotected setChild(idx: number, node: AstNode): void {\n\t\tswitch (idx) {\n\t\t\tcase 0: this._item1 = node; return;\n\t\t\tcase 1: this._item2 = node; return;\n\t\t\tcase 2: this._item3 = node; return;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\n\tpublic get children(): readonly AstNode[] {\n\t\treturn this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n\t}\n\n\tpublic get item1(): AstNode {\n\t\treturn this._item1;\n\t}\n\tpublic get item2(): AstNode {\n\t\treturn this._item2;\n\t}\n\tpublic get item3(): AstNode | null {\n\t\treturn this._item3;\n\t}\n\n\tpublic constructor(\n\t\tlength: Length,\n\t\tlistHeight: number,\n\t\tprivate _item1: AstNode,\n\t\tprivate _item2: AstNode,\n\t\tprivate _item3: AstNode | null,\n\t\tmissingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length, listHeight, missingOpeningBracketIds);\n\t}\n\n\tpublic deepClone(): ListAstNode {\n\t\treturn new TwoThreeListAstNode(\n\t\t\tthis.length,\n\t\t\tthis.listHeight,\n\t\t\tthis._item1.deepClone(),\n\t\t\tthis._item2.deepClone(),\n\t\t\tthis._item3 ? this._item3.deepClone() : null,\n\t\t\tthis.missingOpeningBracketIds\n\t\t);\n\t}\n\n\tpublic appendChildOfSameHeight(node: AstNode): void {\n\t\tif (this._item3) {\n\t\t\tthrow new Error('Cannot append to a full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tthis._item3 = node;\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unappendChild(): AstNode | undefined {\n\t\tif (!this._item3) {\n\t\t\tthrow new Error('Cannot remove from a non-full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tconst result = this._item3;\n\t\tthis._item3 = null;\n\t\tthis.handleChildrenChanged();\n\t\treturn result;\n\t}\n\n\tpublic prependChildOfSameHeight(node: AstNode): void {\n\t\tif (this._item3) {\n\t\t\tthrow new Error('Cannot prepend to a full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tthis._item3 = this._item2;\n\t\tthis._item2 = this._item1;\n\t\tthis._item1 = node;\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unprependChild(): AstNode | undefined {\n\t\tif (!this._item3) {\n\t\t\tthrow new Error('Cannot remove from a non-full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tconst result = this._item1;\n\t\tthis._item1 = this._item2;\n\t\tthis._item2 = this._item3;\n\t\tthis._item3 = null;\n\n\t\tthis.handleChildrenChanged();\n\t\treturn result;\n\t}\n\n\toverride toMutable(): ListAstNode {\n\t\treturn this;\n\t}\n}\n\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n\toverride toMutable(): ListAstNode {\n\t\treturn new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n\t}\n\n\tprotected override throwIfImmutable(): void {\n\t\tthrow new Error('this instance is immutable');\n\t}\n}\n\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n\tget childrenLength(): number {\n\t\treturn this._children.length;\n\t}\n\tgetChild(idx: number): AstNode | null {\n\t\treturn this._children[idx];\n\t}\n\tprotected setChild(idx: number, child: AstNode): void {\n\t\tthis._children[idx] = child;\n\t}\n\tget children(): readonly AstNode[] {\n\t\treturn this._children;\n\t}\n\n\tconstructor(\n\t\tlength: Length,\n\t\tlistHeight: number,\n\t\tprivate readonly _children: AstNode[],\n\t\tmissingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length, listHeight, missingOpeningBracketIds);\n\t}\n\n\tdeepClone(): ListAstNode {\n\t\tconst children = new Array<AstNode>(this._children.length);\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tchildren[i] = this._children[i].deepClone();\n\t\t}\n\t\treturn new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n\t}\n\n\tpublic appendChildOfSameHeight(node: AstNode): void {\n\t\tthis.throwIfImmutable();\n\t\tthis._children.push(node);\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unappendChild(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst item = this._children.pop();\n\t\tthis.handleChildrenChanged();\n\t\treturn item;\n\t}\n\n\tpublic prependChildOfSameHeight(node: AstNode): void {\n\t\tthis.throwIfImmutable();\n\t\tthis._children.unshift(node);\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unprependChild(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst item = this._children.shift();\n\t\tthis.handleChildrenChanged();\n\t\treturn item;\n\t}\n\n\tpublic override toMutable(): ListAstNode {\n\t\treturn this;\n\t}\n}\n\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n\toverride toMutable(): ListAstNode {\n\t\treturn new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n\t}\n\n\tprotected override throwIfImmutable(): void {\n\t\tthrow new Error('this instance is immutable');\n\t}\n}\n\nconst emptyArray: readonly AstNode[] = [];\n\nabstract class ImmutableLeafAstNode extends BaseAstNode {\n\tpublic get listHeight() {\n\t\treturn 0;\n\t}\n\tpublic get childrenLength(): number {\n\t\treturn 0;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\treturn null;\n\t}\n\tpublic get children(): readonly AstNode[] {\n\t\treturn emptyArray;\n\t}\n\tpublic deepClone(): this & AstNode {\n\t\treturn this as this & AstNode;\n\t}\n}\n\nexport class TextAstNode extends ImmutableLeafAstNode {\n\tpublic get kind(): AstNodeKind.Text {\n\t\treturn AstNodeKind.Text;\n\t}\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn SmallImmutableSet.getEmpty();\n\t}\n\n\tpublic canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\treturn true;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\tconst start = lengthToObj(offset);\n\t\t// Text ast nodes don't have partial indentation (ensured by the tokenizer).\n\t\t// Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n\t\tconst startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n\t\tconst endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n\n\t\tlet result = Number.MAX_SAFE_INTEGER;\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\t\tconst lineContent = textModel.getLineContent(lineNumber);\n\t\t\tif (firstNonWsColumn === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize)!;\n\t\t\tresult = Math.min(result, visibleColumn);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport class BracketAstNode extends ImmutableLeafAstNode {\n\tpublic static create(\n\t\tlength: Length,\n\t\tbracketInfo: BracketKind,\n\t\tbracketIds: SmallImmutableSet<OpeningBracketId>\n\t): BracketAstNode {\n\t\tconst node = new BracketAstNode(length, bracketInfo, bracketIds);\n\t\treturn node;\n\t}\n\n\tpublic get kind(): AstNodeKind.Bracket {\n\t\treturn AstNodeKind.Bracket;\n\t}\n\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn SmallImmutableSet.getEmpty();\n\t}\n\n\tprivate constructor(\n\t\tlength: Length,\n\t\tpublic readonly bracketInfo: BracketKind,\n\t\t/**\n\t\t * In case of a opening bracket, this is the id of the opening bracket.\n\t\t * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n\t\t*/\n\t\tpublic readonly bracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tpublic get text() {\n\t\treturn this.bracketInfo.bracketText;\n\t}\n\n\tpublic get languageId() {\n\t\treturn this.bracketInfo.languageId;\n\t}\n\n\tpublic canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\t// These nodes could be reused,\n\t\t// but not in a general way.\n\t\t// Their parent may be reused.\n\t\treturn false;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n}\n\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n\tpublic get kind(): AstNodeKind.UnexpectedClosingBracket {\n\t\treturn AstNodeKind.UnexpectedClosingBracket;\n\t}\n\n\tpublic readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;\n\n\tpublic constructor(closingBrackets: SmallImmutableSet<OpeningBracketId>, length: Length) {\n\t\tsuper(length);\n\t\tthis.missingOpeningBracketIds = closingBrackets;\n\t}\n\n\tpublic canBeReused(openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\treturn !openedBracketIds.intersects(this.missingOpeningBracketIds);\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { BracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\nimport { ITextModel } from '../../../model.js';\nimport { Length, lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { OpeningBracketId } from './tokenizer.js';\n\nexport const enum AstNodeKind {\n\tText = 0,\n\tBracket = 1,\n\tPair = 2,\n\tUnexpectedClosingBracket = 3,\n\tList = 4,\n}\n\nexport type AstNode = PairAstNode | ListAstNode | BracketAstNode | InvalidBracketAstNode | TextAstNode;\n\n/**\n * The base implementation for all AST nodes.\n*/\nabstract class BaseAstNode {\n\tpublic abstract readonly kind: AstNodeKind;\n\n\tpublic abstract readonly childrenLength: number;\n\n\t/**\n\t * Might return null even if {@link idx} is smaller than {@link BaseAstNode.childrenLength}.\n\t*/\n\tpublic abstract getChild(idx: number): AstNode | null;\n\n\t/**\n\t * Try to avoid using this property, as implementations might need to allocate the resulting array.\n\t*/\n\tpublic abstract readonly children: readonly AstNode[];\n\n\t/**\n\t * Represents the set of all (potentially) missing opening bracket ids in this node.\n\t * E.g. in `{ ] ) }` that set is {`[`, `(` }.\n\t*/\n\tpublic abstract readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;\n\n\t/**\n\t * In case of a list, determines the height of the (2,3) tree.\n\t*/\n\tpublic abstract readonly listHeight: number;\n\n\tprotected _length: Length;\n\n\t/**\n\t * The length of the entire node, which should equal the sum of lengths of all children.\n\t*/\n\tpublic get length(): Length {\n\t\treturn this._length;\n\t}\n\n\tpublic constructor(length: Length) {\n\t\tthis._length = length;\n\t}\n\n\t/**\n\t * @param openBracketIds The set of all opening brackets that have not yet been closed.\n\t */\n\tpublic abstract canBeReused(\n\t\topenBracketIds: SmallImmutableSet<OpeningBracketId>\n\t): boolean;\n\n\t/**\n\t * Creates a deep clone.\n\t */\n\tpublic abstract deepClone(): AstNode;\n\n\tpublic abstract computeMinIndentation(offset: Length, textModel: ITextModel): number;\n}\n\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n\tpublic static create(\n\t\topeningBracket: BracketAstNode,\n\t\tchild: AstNode | null,\n\t\tclosingBracket: BracketAstNode | null\n\t) {\n\t\tlet length = openingBracket.length;\n\t\tif (child) {\n\t\t\tlength = lengthAdd(length, child.length);\n\t\t}\n\t\tif (closingBracket) {\n\t\t\tlength = lengthAdd(length, closingBracket.length);\n\t\t}\n\t\treturn new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n\t}\n\n\tpublic get kind(): AstNodeKind.Pair {\n\t\treturn AstNodeKind.Pair;\n\t}\n\tpublic get listHeight() {\n\t\treturn 0;\n\t}\n\tpublic get childrenLength(): number {\n\t\treturn 3;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\tswitch (idx) {\n\t\t\tcase 0: return this.openingBracket;\n\t\t\tcase 1: return this.child;\n\t\t\tcase 2: return this.closingBracket;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\n\t/**\n\t * Avoid using this property, it allocates an array!\n\t*/\n\tpublic get children() {\n\t\tconst result: AstNode[] = [];\n\t\tresult.push(this.openingBracket);\n\t\tif (this.child) {\n\t\t\tresult.push(this.child);\n\t\t}\n\t\tif (this.closingBracket) {\n\t\t\tresult.push(this.closingBracket);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate constructor(\n\t\tlength: Length,\n\t\tpublic readonly openingBracket: BracketAstNode,\n\t\tpublic readonly child: AstNode | null,\n\t\tpublic readonly closingBracket: BracketAstNode | null,\n\t\tpublic readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tpublic canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\tif (this.closingBracket === null) {\n\t\t\t// Unclosed pair ast nodes only\n\t\t\t// end at the end of the document\n\t\t\t// or when a parent node is closed.\n\n\t\t\t// This could be improved:\n\t\t\t// Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic deepClone(): PairAstNode {\n\t\treturn new PairAstNode(\n\t\t\tthis.length,\n\t\t\tthis.openingBracket.deepClone(),\n\t\t\tthis.child && this.child.deepClone(),\n\t\t\tthis.closingBracket && this.closingBracket.deepClone(),\n\t\t\tthis.missingOpeningBracketIds\n\t\t);\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n\t}\n}\n\nexport abstract class ListAstNode extends BaseAstNode {\n\t/**\n\t * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n\t*/\n\tpublic static create23(item1: AstNode, item2: AstNode, item3: AstNode | null, immutable: boolean = false): ListAstNode {\n\t\tlet length = item1.length;\n\t\tlet missingBracketIds = item1.missingOpeningBracketIds;\n\n\t\tif (item1.listHeight !== item2.listHeight) {\n\t\t\tthrow new Error('Invalid list heights');\n\t\t}\n\n\t\tlength = lengthAdd(length, item2.length);\n\t\tmissingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n\n\t\tif (item3) {\n\t\t\tif (item1.listHeight !== item3.listHeight) {\n\t\t\t\tthrow new Error('Invalid list heights');\n\t\t\t}\n\t\t\tlength = lengthAdd(length, item3.length);\n\t\t\tmissingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n\t\t}\n\t\treturn immutable\n\t\t\t? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n\t\t\t: new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n\t}\n\n\tpublic static getEmpty() {\n\t\treturn new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n\t}\n\n\tpublic get kind(): AstNodeKind.List {\n\t\treturn AstNodeKind.List;\n\t}\n\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn this._missingOpeningBracketIds;\n\t}\n\n\tprivate cachedMinIndentation: number = -1;\n\n\t/**\n\t * Use ListAstNode.create.\n\t*/\n\tconstructor(\n\t\tlength: Length,\n\t\tpublic readonly listHeight: number,\n\t\tprivate _missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tprotected throwIfImmutable(): void {\n\t\t// NOOP\n\t}\n\n\tprotected abstract setChild(idx: number, child: AstNode): void;\n\n\tpublic makeLastElementMutable(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst childCount = this.childrenLength;\n\t\tif (childCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst lastChild = this.getChild(childCount - 1)!;\n\t\tconst mutable = lastChild.kind === AstNodeKind.List ? lastChild.toMutable() : lastChild;\n\t\tif (lastChild !== mutable) {\n\t\t\tthis.setChild(childCount - 1, mutable);\n\t\t}\n\t\treturn mutable;\n\t}\n\n\tpublic makeFirstElementMutable(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst childCount = this.childrenLength;\n\t\tif (childCount === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst firstChild = this.getChild(0)!;\n\t\tconst mutable = firstChild.kind === AstNodeKind.List ? firstChild.toMutable() : firstChild;\n\t\tif (firstChild !== mutable) {\n\t\t\tthis.setChild(0, mutable);\n\t\t}\n\t\treturn mutable;\n\t}\n\n\tpublic canBeReused(openBracketIds: SmallImmutableSet<OpeningBracketId>): boolean {\n\t\tif (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.childrenLength === 0) {\n\t\t\t// Don't reuse empty lists.\n\t\t\treturn false;\n\t\t}\n\n\t\tlet lastChild: ListAstNode = this;\n\t\twhile (lastChild.kind === AstNodeKind.List) {\n\t\t\tconst lastLength = lastChild.childrenLength;\n\t\t\tif (lastLength === 0) {\n\t\t\t\t// Empty lists should never be contained in other lists.\n\t\t\t\tthrow new BugIndicatingError();\n\t\t\t}\n\t\t\tlastChild = lastChild.getChild(lastLength - 1) as ListAstNode;\n\t\t}\n\n\t\treturn lastChild.canBeReused(openBracketIds);\n\t}\n\n\tpublic handleChildrenChanged(): void {\n\t\tthis.throwIfImmutable();\n\n\t\tconst count = this.childrenLength;\n\n\t\tlet length = this.getChild(0)!.length;\n\t\tlet unopenedBrackets = this.getChild(0)!.missingOpeningBracketIds;\n\n\t\tfor (let i = 1; i < count; i++) {\n\t\t\tconst child = this.getChild(i)!;\n\t\t\tlength = lengthAdd(length, child.length);\n\t\t\tunopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n\t\t}\n\n\t\tthis._length = length;\n\t\tthis._missingOpeningBracketIds = unopenedBrackets;\n\t\tthis.cachedMinIndentation = -1;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\tif (this.cachedMinIndentation !== -1) {\n\t\t\treturn this.cachedMinIndentation;\n\t\t}\n\n\t\tlet minIndentation = Number.MAX_SAFE_INTEGER;\n\t\tlet childOffset = offset;\n\t\tfor (let i = 0; i < this.childrenLength; i++) {\n\t\t\tconst child = this.getChild(i);\n\t\t\tif (child) {\n\t\t\t\tminIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n\t\t\t\tchildOffset = lengthAdd(childOffset, child.length);\n\t\t\t}\n\t\t}\n\n\t\tthis.cachedMinIndentation = minIndentation;\n\t\treturn minIndentation;\n\t}\n\n\t/**\n\t * Creates a shallow clone that is mutable, or itself if it is already mutable.\n\t */\n\tpublic abstract toMutable(): ListAstNode;\n\n\tpublic abstract appendChildOfSameHeight(node: AstNode): void;\n\tpublic abstract unappendChild(): AstNode | undefined;\n\tpublic abstract prependChildOfSameHeight(node: AstNode): void;\n\tpublic abstract unprependChild(): AstNode | undefined;\n}\n\nclass TwoThreeListAstNode extends ListAstNode {\n\tpublic get childrenLength(): number {\n\t\treturn this._item3 !== null ? 3 : 2;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\tswitch (idx) {\n\t\t\tcase 0: return this._item1;\n\t\t\tcase 1: return this._item2;\n\t\t\tcase 2: return this._item3;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\tprotected setChild(idx: number, node: AstNode): void {\n\t\tswitch (idx) {\n\t\t\tcase 0: this._item1 = node; return;\n\t\t\tcase 1: this._item2 = node; return;\n\t\t\tcase 2: this._item3 = node; return;\n\t\t}\n\t\tthrow new Error('Invalid child index');\n\t}\n\n\tpublic get children(): readonly AstNode[] {\n\t\treturn this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n\t}\n\n\tpublic get item1(): AstNode {\n\t\treturn this._item1;\n\t}\n\tpublic get item2(): AstNode {\n\t\treturn this._item2;\n\t}\n\tpublic get item3(): AstNode | null {\n\t\treturn this._item3;\n\t}\n\n\tpublic constructor(\n\t\tlength: Length,\n\t\tlistHeight: number,\n\t\tprivate _item1: AstNode,\n\t\tprivate _item2: AstNode,\n\t\tprivate _item3: AstNode | null,\n\t\tmissingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length, listHeight, missingOpeningBracketIds);\n\t}\n\n\tpublic deepClone(): ListAstNode {\n\t\treturn new TwoThreeListAstNode(\n\t\t\tthis.length,\n\t\t\tthis.listHeight,\n\t\t\tthis._item1.deepClone(),\n\t\t\tthis._item2.deepClone(),\n\t\t\tthis._item3 ? this._item3.deepClone() : null,\n\t\t\tthis.missingOpeningBracketIds\n\t\t);\n\t}\n\n\tpublic appendChildOfSameHeight(node: AstNode): void {\n\t\tif (this._item3) {\n\t\t\tthrow new Error('Cannot append to a full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tthis._item3 = node;\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unappendChild(): AstNode | undefined {\n\t\tif (!this._item3) {\n\t\t\tthrow new Error('Cannot remove from a non-full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tconst result = this._item3;\n\t\tthis._item3 = null;\n\t\tthis.handleChildrenChanged();\n\t\treturn result;\n\t}\n\n\tpublic prependChildOfSameHeight(node: AstNode): void {\n\t\tif (this._item3) {\n\t\t\tthrow new Error('Cannot prepend to a full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tthis._item3 = this._item2;\n\t\tthis._item2 = this._item1;\n\t\tthis._item1 = node;\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unprependChild(): AstNode | undefined {\n\t\tif (!this._item3) {\n\t\t\tthrow new Error('Cannot remove from a non-full (2,3) tree node');\n\t\t}\n\t\tthis.throwIfImmutable();\n\t\tconst result = this._item1;\n\t\tthis._item1 = this._item2;\n\t\tthis._item2 = this._item3;\n\t\tthis._item3 = null;\n\n\t\tthis.handleChildrenChanged();\n\t\treturn result;\n\t}\n\n\toverride toMutable(): ListAstNode {\n\t\treturn this;\n\t}\n}\n\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n\toverride toMutable(): ListAstNode {\n\t\treturn new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n\t}\n\n\tprotected override throwIfImmutable(): void {\n\t\tthrow new Error('this instance is immutable');\n\t}\n}\n\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n\tget childrenLength(): number {\n\t\treturn this._children.length;\n\t}\n\tgetChild(idx: number): AstNode | null {\n\t\treturn this._children[idx];\n\t}\n\tprotected setChild(idx: number, child: AstNode): void {\n\t\tthis._children[idx] = child;\n\t}\n\tget children(): readonly AstNode[] {\n\t\treturn this._children;\n\t}\n\n\tconstructor(\n\t\tlength: Length,\n\t\tlistHeight: number,\n\t\tprivate readonly _children: AstNode[],\n\t\tmissingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length, listHeight, missingOpeningBracketIds);\n\t}\n\n\tdeepClone(): ListAstNode {\n\t\tconst children = new Array<AstNode>(this._children.length);\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tchildren[i] = this._children[i].deepClone();\n\t\t}\n\t\treturn new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n\t}\n\n\tpublic appendChildOfSameHeight(node: AstNode): void {\n\t\tthis.throwIfImmutable();\n\t\tthis._children.push(node);\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unappendChild(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst item = this._children.pop();\n\t\tthis.handleChildrenChanged();\n\t\treturn item;\n\t}\n\n\tpublic prependChildOfSameHeight(node: AstNode): void {\n\t\tthis.throwIfImmutable();\n\t\tthis._children.unshift(node);\n\t\tthis.handleChildrenChanged();\n\t}\n\n\tpublic unprependChild(): AstNode | undefined {\n\t\tthis.throwIfImmutable();\n\t\tconst item = this._children.shift();\n\t\tthis.handleChildrenChanged();\n\t\treturn item;\n\t}\n\n\tpublic override toMutable(): ListAstNode {\n\t\treturn this;\n\t}\n}\n\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n\toverride toMutable(): ListAstNode {\n\t\treturn new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n\t}\n\n\tprotected override throwIfImmutable(): void {\n\t\tthrow new Error('this instance is immutable');\n\t}\n}\n\nconst emptyArray: readonly AstNode[] = [];\n\nabstract class ImmutableLeafAstNode extends BaseAstNode {\n\tpublic get listHeight() {\n\t\treturn 0;\n\t}\n\tpublic get childrenLength(): number {\n\t\treturn 0;\n\t}\n\tpublic getChild(idx: number): AstNode | null {\n\t\treturn null;\n\t}\n\tpublic get children(): readonly AstNode[] {\n\t\treturn emptyArray;\n\t}\n\tpublic deepClone(): this & AstNode {\n\t\treturn this as this & AstNode;\n\t}\n}\n\nexport class TextAstNode extends ImmutableLeafAstNode {\n\tpublic get kind(): AstNodeKind.Text {\n\t\treturn AstNodeKind.Text;\n\t}\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn SmallImmutableSet.getEmpty();\n\t}\n\n\tpublic canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\treturn true;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\tconst start = lengthToObj(offset);\n\t\t// Text ast nodes don't have partial indentation (ensured by the tokenizer).\n\t\t// Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n\t\tconst startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n\t\tconst endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n\n\t\tlet result = Number.MAX_SAFE_INTEGER;\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\t\tconst lineContent = textModel.getLineContent(lineNumber);\n\t\t\tif (firstNonWsColumn === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize)!;\n\t\t\tresult = Math.min(result, visibleColumn);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport class BracketAstNode extends ImmutableLeafAstNode {\n\tpublic static create(\n\t\tlength: Length,\n\t\tbracketInfo: BracketKind,\n\t\tbracketIds: SmallImmutableSet<OpeningBracketId>\n\t): BracketAstNode {\n\t\tconst node = new BracketAstNode(length, bracketInfo, bracketIds);\n\t\treturn node;\n\t}\n\n\tpublic get kind(): AstNodeKind.Bracket {\n\t\treturn AstNodeKind.Bracket;\n\t}\n\n\tpublic get missingOpeningBracketIds(): SmallImmutableSet<OpeningBracketId> {\n\t\treturn SmallImmutableSet.getEmpty();\n\t}\n\n\tprivate constructor(\n\t\tlength: Length,\n\t\tpublic readonly bracketInfo: BracketKind,\n\t\t/**\n\t\t * In case of a opening bracket, this is the id of the opening bracket.\n\t\t * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n\t\t*/\n\t\tpublic readonly bracketIds: SmallImmutableSet<OpeningBracketId>\n\t) {\n\t\tsuper(length);\n\t}\n\n\tpublic get text() {\n\t\treturn this.bracketInfo.bracketText;\n\t}\n\n\tpublic get languageId() {\n\t\treturn this.bracketInfo.languageId;\n\t}\n\n\tpublic canBeReused(_openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\t// These nodes could be reused,\n\t\t// but not in a general way.\n\t\t// Their parent may be reused.\n\t\treturn false;\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n}\n\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n\tpublic get kind(): AstNodeKind.UnexpectedClosingBracket {\n\t\treturn AstNodeKind.UnexpectedClosingBracket;\n\t}\n\n\tpublic readonly missingOpeningBracketIds: SmallImmutableSet<OpeningBracketId>;\n\n\tpublic constructor(closingBrackets: SmallImmutableSet<OpeningBracketId>, length: Length) {\n\t\tsuper(length);\n\t\tthis.missingOpeningBracketIds = closingBrackets;\n\t}\n\n\tpublic canBeReused(openedBracketIds: SmallImmutableSet<OpeningBracketId>) {\n\t\treturn !openedBracketIds.intersects(this.missingOpeningBracketIds);\n\t}\n\n\tpublic computeMinIndentation(offset: Length, textModel: ITextModel): number {\n\t\treturn Number.MAX_SAFE_INTEGER;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1326, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { StandardTokenType, TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { IViewLineTokens } from '../../../tokens/lineTokens.js';\nimport { BracketAstNode, TextAstNode } from './ast.js';\nimport { BracketTokens, LanguageAgnosticBracketTokens } from './brackets.js';\nimport { Length, lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n\nexport interface Tokenizer {\n\treadonly offset: Length;\n\n\tread(): Token | null;\n\tpeek(): Token | null;\n\tskip(length: Length): void;\n}\n\nexport const enum TokenKind {\n\tText = 0,\n\tOpeningBracket = 1,\n\tClosingBracket = 2,\n}\n\nexport type OpeningBracketId = number;\n\nexport class Token {\n\tconstructor(\n\t\treadonly length: Length,\n\t\treadonly kind: TokenKind,\n\t\t/**\n\t\t * If this token is an opening bracket, this is the id of the opening bracket.\n\t\t * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n\t\t * Otherwise, it is -1.\n\t\t */\n\t\treadonly bracketId: OpeningBracketId,\n\t\t/**\n\t\t * If this token is an opening bracket, this just contains `bracketId`.\n\t\t * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n\t\t * Otherwise, it is empty.\n\t\t */\n\t\treadonly bracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\treadonly astNode: BracketAstNode | TextAstNode | undefined,\n\t) { }\n}\n\nexport interface ITokenizerSource {\n\tgetLineCount(): number;\n\tgetLineLength(lineNumber: number): number;\n\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t};\n}\n\nexport class TextBufferTokenizer implements Tokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tprivate readonly reader;\n\n\tconstructor(\n\t\tprivate readonly textModel: ITokenizerSource,\n\t\tprivate readonly bracketTokens: LanguageAgnosticBracketTokens\n\t) {\n\t\tthis.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n\t\tthis._offset = lengthZero;\n\t\tthis.didPeek = false;\n\t\tthis.peeked = null;\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate _offset: Length;\n\n\tget offset() {\n\t\treturn this._offset;\n\t}\n\n\tget length() {\n\t\treturn toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n\t}\n\n\tskip(length: Length): void {\n\t\tthis.didPeek = false;\n\t\tthis._offset = lengthAdd(this._offset, length);\n\t\tconst obj = lengthToObj(this._offset);\n\t\tthis.reader.setPosition(obj.lineCount, obj.columnCount);\n\t}\n\n\tprivate didPeek;\n\tprivate peeked: Token | null;\n\n\tread(): Token | null {\n\t\tlet token: Token | null;\n\t\tif (this.peeked) {\n\t\t\tthis.didPeek = false;\n\t\t\ttoken = this.peeked;\n\t\t} else {\n\t\t\ttoken = this.reader.read();\n\t\t}\n\t\tif (token) {\n\t\t\tthis._offset = lengthAdd(this._offset, token.length);\n\t\t}\n\t\treturn token;\n\t}\n\n\tpeek(): Token | null {\n\t\tif (!this.didPeek) {\n\t\t\tthis.peeked = this.reader.read();\n\t\t\tthis.didPeek = true;\n\t\t}\n\t\treturn this.peeked;\n\t}\n}\n\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tconstructor(private readonly textModel: ITokenizerSource, private readonly bracketTokens: LanguageAgnosticBracketTokens) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate lineIdx = 0;\n\tprivate line: string | null = null;\n\tprivate lineCharOffset = 0;\n\tprivate lineTokens: IViewLineTokens | null = null;\n\tprivate lineTokenOffset = 0;\n\n\tpublic setPosition(lineIdx: number, column: number): void {\n\t\t// We must not jump into a token!\n\t\tif (lineIdx === this.lineIdx) {\n\t\t\tthis.lineCharOffset = column;\n\t\t\tif (this.line !== null) {\n\t\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens!.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.lineIdx = lineIdx;\n\t\t\tthis.lineCharOffset = column;\n\t\t\tthis.line = null;\n\t\t}\n\t\tthis.peekedToken = null;\n\t}\n\n\t/** Must be a zero line token. The end of the document cannot be peeked. */\n\tprivate peekedToken: Token | null = null;\n\n\tpublic read(): Token | null {\n\t\tif (this.peekedToken) {\n\t\t\tconst token = this.peekedToken;\n\t\t\tthis.peekedToken = null;\n\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n\t\t\treturn token;\n\t\t}\n\n\t\tif (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n\t\t\t// We are after the end\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.line === null) {\n\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t}\n\n\t\tconst startLineIdx = this.lineIdx;\n\t\tconst startLineCharOffset = this.lineCharOffset;\n\n\t\t// limits the length of text tokens.\n\t\t// If text tokens get too long, incremental updates will be slow\n\t\tlet lengthHeuristic = 0;\n\t\twhile (true) {\n\t\t\tconst lineTokens = this.lineTokens!;\n\t\t\tconst tokenCount = lineTokens.getCount();\n\n\t\t\tlet peekedBracketToken: Token | null = null;\n\n\t\t\tif (this.lineTokenOffset < tokenCount) {\n\t\t\t\tconst tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n\t\t\t\twhile (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n\t\t\t\t\t// Skip tokens that are identical.\n\t\t\t\t\t// Sometimes, (bracket) identifiers are split up into multiple tokens.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t}\n\n\t\t\t\tconst isOther = TokenMetadata.getTokenType(tokenMetadata) === StandardTokenType.Other;\n\t\t\t\tconst containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n\n\t\t\t\tconst endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n\t\t\t\t// Is there a bracket token next? Only consume text.\n\t\t\t\tif (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n\t\t\t\t\tconst languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n\t\t\t\t\tconst text = this.line.substring(this.lineCharOffset, endOffset);\n\n\t\t\t\t\tconst brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n\t\t\t\t\tconst regexp = brackets.regExpGlobal;\n\t\t\t\t\tif (regexp) {\n\t\t\t\t\t\tregexp.lastIndex = 0;\n\t\t\t\t\t\tconst match = regexp.exec(text);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tpeekedBracketToken = brackets.getToken(match[0])!;\n\t\t\t\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t\t\t\t// Consume leading text of the token\n\t\t\t\t\t\t\t\tthis.lineCharOffset += match.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlengthHeuristic += endOffset - this.lineCharOffset;\n\n\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t// Don't skip the entire token, as a single token could contain multiple brackets.\n\n\t\t\t\t\tif (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n\t\t\t\t\t\t// There is text before the bracket\n\t\t\t\t\t\tthis.peekedToken = peekedBracketToken;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Consume the peeked token\n\t\t\t\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n\t\t\t\t\t\treturn peekedBracketToken;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Skip the entire token, as the token contains no brackets at all.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t\tthis.lineCharOffset = endOffset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.lineIdx === this.textBufferLineCount - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.lineIdx++;\n\t\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\t\tthis.lineTokenOffset = 0;\n\t\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\t\tthis.lineCharOffset = 0;\n\n\t\t\t\tlengthHeuristic += 33; // max 1000/33 = 30 lines\n\t\t\t\t// This limits the amount of work to recompute min-indentation\n\n\t\t\t\tif (lengthHeuristic > 1000) {\n\t\t\t\t\t// only break (automatically) at the end of line.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lengthHeuristic > 1500) {\n\t\t\t\t// Eventually break regardless of the line length so that\n\t\t\t\t// very long lines do not cause bad performance.\n\t\t\t\t// This effective limits max indentation to 500, as\n\t\t\t\t// indentation is not computed across multiple text nodes.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n\t\t// unless the line is too long.\n\t\t// Thus, the min indentation of the document is the minimum min indentation of every text node.\n\t\tconst length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n\t\treturn new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t}\n}\n\nexport class FastTokenizer implements Tokenizer {\n\tprivate _offset: Length = lengthZero;\n\tprivate readonly tokens: readonly Token[];\n\tprivate idx = 0;\n\n\tconstructor(private readonly text: string, brackets: BracketTokens) {\n\t\tconst regExpStr = brackets.getRegExpStr();\n\t\tconst regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n\n\t\tconst tokens: Token[] = [];\n\n\t\tlet match: RegExpExecArray | null;\n\t\tlet curLineCount = 0;\n\t\tlet lastLineBreakOffset = 0;\n\n\t\tlet lastTokenEndOffset = 0;\n\t\tlet lastTokenEndLine = 0;\n\n\t\tconst smallTextTokens0Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens0Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(0, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(0, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst smallTextTokens1Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens1Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(1, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(1, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tregexp.lastIndex = 0;\n\t\t\t// If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n\t\t\twhile ((match = regexp.exec(text)) !== null) {\n\t\t\t\tconst curOffset = match.index;\n\t\t\t\tconst value = match[0];\n\t\t\t\tif (value === '\\n') {\n\t\t\t\t\tcurLineCount++;\n\t\t\t\t\tlastLineBreakOffset = curOffset + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastTokenEndOffset !== curOffset) {\n\t\t\t\t\t\tlet token: Token;\n\t\t\t\t\t\tif (lastTokenEndLine === curLineCount) {\n\t\t\t\t\t\t\tconst colCount = curOffset - lastTokenEndOffset;\n\t\t\t\t\t\t\tif (colCount < smallTextTokens0Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens0Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(0, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst lineCount = curLineCount - lastTokenEndLine;\n\t\t\t\t\t\t\tconst colCount = curOffset - lastLineBreakOffset;\n\t\t\t\t\t\t\tif (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens1Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(lineCount, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\n\t\t\t\t\t// value is matched by regexp, so the token must exist\n\t\t\t\t\ttokens.push(brackets.getToken(value)!);\n\n\t\t\t\t\tlastTokenEndOffset = curOffset + value.length;\n\t\t\t\t\tlastTokenEndLine = curLineCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst offset = text.length;\n\n\t\tif (lastTokenEndOffset !== offset) {\n\t\t\tconst length = (lastTokenEndLine === curLineCount)\n\t\t\t\t? toLength(0, offset - lastTokenEndOffset)\n\t\t\t\t: toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n\t\t\ttokens.push(new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n\t\t}\n\n\t\tthis.length = toLength(curLineCount, offset - lastLineBreakOffset);\n\t\tthis.tokens = tokens;\n\t}\n\n\tget offset(): Length {\n\t\treturn this._offset;\n\t}\n\n\treadonly length: Length;\n\n\tread(): Token | null {\n\t\treturn this.tokens[this.idx++] || null;\n\t}\n\n\tpeek(): Token | null {\n\t\treturn this.tokens[this.idx] || null;\n\t}\n\n\tskip(length: Length): void {\n\t\tthrow new NotSupportedError();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { StandardTokenType, TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { IViewLineTokens } from '../../../tokens/lineTokens.js';\nimport { BracketAstNode, TextAstNode } from './ast.js';\nimport { BracketTokens, LanguageAgnosticBracketTokens } from './brackets.js';\nimport { Length, lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n\nexport interface Tokenizer {\n\treadonly offset: Length;\n\n\tread(): Token | null;\n\tpeek(): Token | null;\n\tskip(length: Length): void;\n}\n\nexport const enum TokenKind {\n\tText = 0,\n\tOpeningBracket = 1,\n\tClosingBracket = 2,\n}\n\nexport type OpeningBracketId = number;\n\nexport class Token {\n\tconstructor(\n\t\treadonly length: Length,\n\t\treadonly kind: TokenKind,\n\t\t/**\n\t\t * If this token is an opening bracket, this is the id of the opening bracket.\n\t\t * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n\t\t * Otherwise, it is -1.\n\t\t */\n\t\treadonly bracketId: OpeningBracketId,\n\t\t/**\n\t\t * If this token is an opening bracket, this just contains `bracketId`.\n\t\t * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n\t\t * Otherwise, it is empty.\n\t\t */\n\t\treadonly bracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\treadonly astNode: BracketAstNode | TextAstNode | undefined,\n\t) { }\n}\n\nexport interface ITokenizerSource {\n\tgetLineCount(): number;\n\tgetLineLength(lineNumber: number): number;\n\n\ttokenization: {\n\t\tgetLineTokens(lineNumber: number): IViewLineTokens;\n\t};\n}\n\nexport class TextBufferTokenizer implements Tokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tprivate readonly reader;\n\n\tconstructor(\n\t\tprivate readonly textModel: ITokenizerSource,\n\t\tprivate readonly bracketTokens: LanguageAgnosticBracketTokens\n\t) {\n\t\tthis.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n\t\tthis._offset = lengthZero;\n\t\tthis.didPeek = false;\n\t\tthis.peeked = null;\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate _offset: Length;\n\n\tget offset() {\n\t\treturn this._offset;\n\t}\n\n\tget length() {\n\t\treturn toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n\t}\n\n\tskip(length: Length): void {\n\t\tthis.didPeek = false;\n\t\tthis._offset = lengthAdd(this._offset, length);\n\t\tconst obj = lengthToObj(this._offset);\n\t\tthis.reader.setPosition(obj.lineCount, obj.columnCount);\n\t}\n\n\tprivate didPeek;\n\tprivate peeked: Token | null;\n\n\tread(): Token | null {\n\t\tlet token: Token | null;\n\t\tif (this.peeked) {\n\t\t\tthis.didPeek = false;\n\t\t\ttoken = this.peeked;\n\t\t} else {\n\t\t\ttoken = this.reader.read();\n\t\t}\n\t\tif (token) {\n\t\t\tthis._offset = lengthAdd(this._offset, token.length);\n\t\t}\n\t\treturn token;\n\t}\n\n\tpeek(): Token | null {\n\t\tif (!this.didPeek) {\n\t\t\tthis.peeked = this.reader.read();\n\t\t\tthis.didPeek = true;\n\t\t}\n\t\treturn this.peeked;\n\t}\n}\n\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n\tprivate readonly textBufferLineCount: number;\n\tprivate readonly textBufferLastLineLength: number;\n\n\tconstructor(private readonly textModel: ITokenizerSource, private readonly bracketTokens: LanguageAgnosticBracketTokens) {\n\t\tthis.textBufferLineCount = textModel.getLineCount();\n\t\tthis.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n\t}\n\n\tprivate lineIdx = 0;\n\tprivate line: string | null = null;\n\tprivate lineCharOffset = 0;\n\tprivate lineTokens: IViewLineTokens | null = null;\n\tprivate lineTokenOffset = 0;\n\n\tpublic setPosition(lineIdx: number, column: number): void {\n\t\t// We must not jump into a token!\n\t\tif (lineIdx === this.lineIdx) {\n\t\t\tthis.lineCharOffset = column;\n\t\t\tif (this.line !== null) {\n\t\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens!.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.lineIdx = lineIdx;\n\t\t\tthis.lineCharOffset = column;\n\t\t\tthis.line = null;\n\t\t}\n\t\tthis.peekedToken = null;\n\t}\n\n\t/** Must be a zero line token. The end of the document cannot be peeked. */\n\tprivate peekedToken: Token | null = null;\n\n\tpublic read(): Token | null {\n\t\tif (this.peekedToken) {\n\t\t\tconst token = this.peekedToken;\n\t\t\tthis.peekedToken = null;\n\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n\t\t\treturn token;\n\t\t}\n\n\t\tif (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n\t\t\t// We are after the end\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.line === null) {\n\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\tthis.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n\t\t}\n\n\t\tconst startLineIdx = this.lineIdx;\n\t\tconst startLineCharOffset = this.lineCharOffset;\n\n\t\t// limits the length of text tokens.\n\t\t// If text tokens get too long, incremental updates will be slow\n\t\tlet lengthHeuristic = 0;\n\t\twhile (true) {\n\t\t\tconst lineTokens = this.lineTokens!;\n\t\t\tconst tokenCount = lineTokens.getCount();\n\n\t\t\tlet peekedBracketToken: Token | null = null;\n\n\t\t\tif (this.lineTokenOffset < tokenCount) {\n\t\t\t\tconst tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n\t\t\t\twhile (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n\t\t\t\t\t// Skip tokens that are identical.\n\t\t\t\t\t// Sometimes, (bracket) identifiers are split up into multiple tokens.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t}\n\n\t\t\t\tconst isOther = TokenMetadata.getTokenType(tokenMetadata) === StandardTokenType.Other;\n\t\t\t\tconst containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n\n\t\t\t\tconst endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n\t\t\t\t// Is there a bracket token next? Only consume text.\n\t\t\t\tif (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n\t\t\t\t\tconst languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n\t\t\t\t\tconst text = this.line.substring(this.lineCharOffset, endOffset);\n\n\t\t\t\t\tconst brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n\t\t\t\t\tconst regexp = brackets.regExpGlobal;\n\t\t\t\t\tif (regexp) {\n\t\t\t\t\t\tregexp.lastIndex = 0;\n\t\t\t\t\t\tconst match = regexp.exec(text);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tpeekedBracketToken = brackets.getToken(match[0])!;\n\t\t\t\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t\t\t\t// Consume leading text of the token\n\t\t\t\t\t\t\t\tthis.lineCharOffset += match.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlengthHeuristic += endOffset - this.lineCharOffset;\n\n\t\t\t\tif (peekedBracketToken) {\n\t\t\t\t\t// Don't skip the entire token, as a single token could contain multiple brackets.\n\n\t\t\t\t\tif (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n\t\t\t\t\t\t// There is text before the bracket\n\t\t\t\t\t\tthis.peekedToken = peekedBracketToken;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Consume the peeked token\n\t\t\t\t\t\tthis.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n\t\t\t\t\t\treturn peekedBracketToken;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Skip the entire token, as the token contains no brackets at all.\n\t\t\t\t\tthis.lineTokenOffset++;\n\t\t\t\t\tthis.lineCharOffset = endOffset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.lineIdx === this.textBufferLineCount - 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis.lineIdx++;\n\t\t\t\tthis.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n\t\t\t\tthis.lineTokenOffset = 0;\n\t\t\t\tthis.line = this.lineTokens.getLineContent();\n\t\t\t\tthis.lineCharOffset = 0;\n\n\t\t\t\tlengthHeuristic += 33; // max 1000/33 = 30 lines\n\t\t\t\t// This limits the amount of work to recompute min-indentation\n\n\t\t\t\tif (lengthHeuristic > 1000) {\n\t\t\t\t\t// only break (automatically) at the end of line.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lengthHeuristic > 1500) {\n\t\t\t\t// Eventually break regardless of the line length so that\n\t\t\t\t// very long lines do not cause bad performance.\n\t\t\t\t// This effective limits max indentation to 500, as\n\t\t\t\t// indentation is not computed across multiple text nodes.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n\t\t// unless the line is too long.\n\t\t// Thus, the min indentation of the document is the minimum min indentation of every text node.\n\t\tconst length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n\t\treturn new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t}\n}\n\nexport class FastTokenizer implements Tokenizer {\n\tprivate _offset: Length = lengthZero;\n\tprivate readonly tokens: readonly Token[];\n\tprivate idx = 0;\n\n\tconstructor(private readonly text: string, brackets: BracketTokens) {\n\t\tconst regExpStr = brackets.getRegExpStr();\n\t\tconst regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n\n\t\tconst tokens: Token[] = [];\n\n\t\tlet match: RegExpExecArray | null;\n\t\tlet curLineCount = 0;\n\t\tlet lastLineBreakOffset = 0;\n\n\t\tlet lastTokenEndOffset = 0;\n\t\tlet lastTokenEndLine = 0;\n\n\t\tconst smallTextTokens0Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens0Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(0, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(0, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst smallTextTokens1Line: Token[] = [];\n\t\tfor (let i = 0; i < 60; i++) {\n\t\t\tsmallTextTokens1Line.push(\n\t\t\t\tnew Token(\n\t\t\t\t\ttoLength(1, i), TokenKind.Text, -1, SmallImmutableSet.getEmpty(),\n\t\t\t\t\tnew TextAstNode(toLength(1, i))\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tregexp.lastIndex = 0;\n\t\t\t// If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n\t\t\twhile ((match = regexp.exec(text)) !== null) {\n\t\t\t\tconst curOffset = match.index;\n\t\t\t\tconst value = match[0];\n\t\t\t\tif (value === '\\n') {\n\t\t\t\t\tcurLineCount++;\n\t\t\t\t\tlastLineBreakOffset = curOffset + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastTokenEndOffset !== curOffset) {\n\t\t\t\t\t\tlet token: Token;\n\t\t\t\t\t\tif (lastTokenEndLine === curLineCount) {\n\t\t\t\t\t\t\tconst colCount = curOffset - lastTokenEndOffset;\n\t\t\t\t\t\t\tif (colCount < smallTextTokens0Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens0Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(0, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst lineCount = curLineCount - lastTokenEndLine;\n\t\t\t\t\t\t\tconst colCount = curOffset - lastLineBreakOffset;\n\t\t\t\t\t\t\tif (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n\t\t\t\t\t\t\t\ttoken = smallTextTokens1Line[colCount];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst length = toLength(lineCount, colCount);\n\t\t\t\t\t\t\t\ttoken = new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttokens.push(token);\n\t\t\t\t\t}\n\n\t\t\t\t\t// value is matched by regexp, so the token must exist\n\t\t\t\t\ttokens.push(brackets.getToken(value)!);\n\n\t\t\t\t\tlastTokenEndOffset = curOffset + value.length;\n\t\t\t\t\tlastTokenEndLine = curLineCount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst offset = text.length;\n\n\t\tif (lastTokenEndOffset !== offset) {\n\t\t\tconst length = (lastTokenEndLine === curLineCount)\n\t\t\t\t? toLength(0, offset - lastTokenEndOffset)\n\t\t\t\t: toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n\t\t\ttokens.push(new Token(length, TokenKind.Text, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n\t\t}\n\n\t\tthis.length = toLength(curLineCount, offset - lastLineBreakOffset);\n\t\tthis.tokens = tokens;\n\t}\n\n\tget offset(): Length {\n\t\treturn this._offset;\n\t}\n\n\treadonly length: Length;\n\n\tread(): Token | null {\n\t\treturn this.tokens[this.idx++] || null;\n\t}\n\n\tpeek(): Token | null {\n\t\treturn this.tokens[this.idx] || null;\n\t}\n\n\tskip(length: Length): void {\n\t\tthrow new NotSupportedError();\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1618, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { ResolvedLanguageConfiguration } from '../../../languages/languageConfigurationRegistry.js';\nimport { BracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { DenseKeyProvider, identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { OpeningBracketId, Token, TokenKind } from './tokenizer.js';\n\nexport class BracketTokens {\n\tstatic createFromLanguage(configuration: ResolvedLanguageConfiguration, denseKeyProvider: DenseKeyProvider<string>): BracketTokens {\n\t\tfunction getId(bracketInfo: BracketKind): OpeningBracketId {\n\t\t\treturn denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n\t\t}\n\n\t\tconst map = new Map<string, Token>();\n\t\tfor (const openingBracket of configuration.bracketsNew.openingBrackets) {\n\t\t\tconst length = toLength(0, openingBracket.bracketText.length);\n\t\t\tconst openingTextId = getId(openingBracket);\n\t\t\tconst bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n\t\t\tmap.set(openingBracket.bracketText, new Token(\n\t\t\t\tlength,\n\t\t\t\tTokenKind.OpeningBracket,\n\t\t\t\topeningTextId,\n\t\t\t\tbracketIds,\n\t\t\t\tBracketAstNode.create(length, openingBracket, bracketIds)\n\t\t\t));\n\t\t}\n\n\t\tfor (const closingBracket of configuration.bracketsNew.closingBrackets) {\n\t\t\tconst length = toLength(0, closingBracket.bracketText.length);\n\t\t\tlet bracketIds = SmallImmutableSet.getEmpty();\n\t\t\tconst closingBrackets = closingBracket.getOpeningBrackets();\n\t\t\tfor (const bracket of closingBrackets) {\n\t\t\t\tbracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n\t\t\t}\n\t\t\tmap.set(closingBracket.bracketText, new Token(\n\t\t\t\tlength,\n\t\t\t\tTokenKind.ClosingBracket,\n\t\t\t\tgetId(closingBrackets[0]),\n\t\t\t\tbracketIds,\n\t\t\t\tBracketAstNode.create(length, closingBracket, bracketIds)\n\t\t\t));\n\t\t}\n\n\t\treturn new BracketTokens(map);\n\t}\n\n\tprivate hasRegExp = false;\n\tprivate _regExpGlobal: RegExp | null = null;\n\n\tconstructor(\n\t\tprivate readonly map: Map<string, Token>\n\t) { }\n\n\tgetRegExpStr(): string | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst keys = [...this.map.keys()];\n\t\t\tkeys.sort();\n\t\t\tkeys.reverse();\n\t\t\treturn keys.map(k => prepareBracketForRegExp(k)).join('|');\n\t\t}\n\t}\n\n\t/**\n\t * Returns null if there is no such regexp (because there are no brackets).\n\t*/\n\tget regExpGlobal(): RegExp | null {\n\t\tif (!this.hasRegExp) {\n\t\t\tconst regExpStr = this.getRegExpStr();\n\t\t\tthis._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n\t\t\tthis.hasRegExp = true;\n\t\t}\n\t\treturn this._regExpGlobal;\n\t}\n\n\tgetToken(value: string): Token | undefined {\n\t\treturn this.map.get(value.toLowerCase());\n\t}\n\n\tfindClosingTokenText(openingBracketIds: SmallImmutableSet<OpeningBracketId>): string | undefined {\n\t\tfor (const [closingText, info] of this.map) {\n\t\t\tif (info.kind === TokenKind.ClosingBracket && info.bracketIds.intersects(openingBracketIds)) {\n\t\t\t\treturn closingText;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.map.size === 0;\n\t}\n}\n\nfunction prepareBracketForRegExp(str: string): string {\n\tlet escaped = escapeRegExpCharacters(str);\n\t// These bracket pair delimiters start or end with letters\n\t// see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n\tif (/^[\\w ]+/.test(str)) {\n\t\tescaped = `\\\\b${escaped}`;\n\t}\n\tif (/[\\w ]+$/.test(str)) {\n\t\tescaped = `${escaped}\\\\b`;\n\t}\n\treturn escaped;\n}\n\nexport class LanguageAgnosticBracketTokens {\n\tprivate readonly languageIdToBracketTokens = new Map<string, BracketTokens>();\n\n\tconstructor(\n\t\tprivate readonly denseKeyProvider: DenseKeyProvider<string>,\n\t\tprivate readonly getLanguageConfiguration: (languageId: string) => ResolvedLanguageConfiguration,\n\t) {\n\t}\n\n\tpublic didLanguageChange(languageId: string): boolean {\n\t\t// Report a change whenever the language configuration updates.\n\t\treturn this.languageIdToBracketTokens.has(languageId);\n\t}\n\n\tgetSingleLanguageBracketTokens(languageId: string): BracketTokens {\n\t\tlet singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n\t\tif (!singleLanguageBracketTokens) {\n\t\t\tsingleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n\t\t\tthis.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n\t\t}\n\t\treturn singleLanguageBracketTokens;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { ResolvedLanguageConfiguration } from '../../../languages/languageConfigurationRegistry.js';\nimport { BracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { DenseKeyProvider, identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { OpeningBracketId, Token, TokenKind } from './tokenizer.js';\n\nexport class BracketTokens {\n\tstatic createFromLanguage(configuration: ResolvedLanguageConfiguration, denseKeyProvider: DenseKeyProvider<string>): BracketTokens {\n\t\tfunction getId(bracketInfo: BracketKind): OpeningBracketId {\n\t\t\treturn denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n\t\t}\n\n\t\tconst map = new Map<string, Token>();\n\t\tfor (const openingBracket of configuration.bracketsNew.openingBrackets) {\n\t\t\tconst length = toLength(0, openingBracket.bracketText.length);\n\t\t\tconst openingTextId = getId(openingBracket);\n\t\t\tconst bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n\t\t\tmap.set(openingBracket.bracketText, new Token(\n\t\t\t\tlength,\n\t\t\t\tTokenKind.OpeningBracket,\n\t\t\t\topeningTextId,\n\t\t\t\tbracketIds,\n\t\t\t\tBracketAstNode.create(length, openingBracket, bracketIds)\n\t\t\t));\n\t\t}\n\n\t\tfor (const closingBracket of configuration.bracketsNew.closingBrackets) {\n\t\t\tconst length = toLength(0, closingBracket.bracketText.length);\n\t\t\tlet bracketIds = SmallImmutableSet.getEmpty();\n\t\t\tconst closingBrackets = closingBracket.getOpeningBrackets();\n\t\t\tfor (const bracket of closingBrackets) {\n\t\t\t\tbracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n\t\t\t}\n\t\t\tmap.set(closingBracket.bracketText, new Token(\n\t\t\t\tlength,\n\t\t\t\tTokenKind.ClosingBracket,\n\t\t\t\tgetId(closingBrackets[0]),\n\t\t\t\tbracketIds,\n\t\t\t\tBracketAstNode.create(length, closingBracket, bracketIds)\n\t\t\t));\n\t\t}\n\n\t\treturn new BracketTokens(map);\n\t}\n\n\tprivate hasRegExp = false;\n\tprivate _regExpGlobal: RegExp | null = null;\n\n\tconstructor(\n\t\tprivate readonly map: Map<string, Token>\n\t) { }\n\n\tgetRegExpStr(): string | null {\n\t\tif (this.isEmpty) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tconst keys = [...this.map.keys()];\n\t\t\tkeys.sort();\n\t\t\tkeys.reverse();\n\t\t\treturn keys.map(k => prepareBracketForRegExp(k)).join('|');\n\t\t}\n\t}\n\n\t/**\n\t * Returns null if there is no such regexp (because there are no brackets).\n\t*/\n\tget regExpGlobal(): RegExp | null {\n\t\tif (!this.hasRegExp) {\n\t\t\tconst regExpStr = this.getRegExpStr();\n\t\t\tthis._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n\t\t\tthis.hasRegExp = true;\n\t\t}\n\t\treturn this._regExpGlobal;\n\t}\n\n\tgetToken(value: string): Token | undefined {\n\t\treturn this.map.get(value.toLowerCase());\n\t}\n\n\tfindClosingTokenText(openingBracketIds: SmallImmutableSet<OpeningBracketId>): string | undefined {\n\t\tfor (const [closingText, info] of this.map) {\n\t\t\tif (info.kind === TokenKind.ClosingBracket && info.bracketIds.intersects(openingBracketIds)) {\n\t\t\t\treturn closingText;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.map.size === 0;\n\t}\n}\n\nfunction prepareBracketForRegExp(str: string): string {\n\tlet escaped = escapeRegExpCharacters(str);\n\t// These bracket pair delimiters start or end with letters\n\t// see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n\tif (/^[\\w ]+/.test(str)) {\n\t\tescaped = `\\\\b${escaped}`;\n\t}\n\tif (/[\\w ]+$/.test(str)) {\n\t\tescaped = `${escaped}\\\\b`;\n\t}\n\treturn escaped;\n}\n\nexport class LanguageAgnosticBracketTokens {\n\tprivate readonly languageIdToBracketTokens = new Map<string, BracketTokens>();\n\n\tconstructor(\n\t\tprivate readonly denseKeyProvider: DenseKeyProvider<string>,\n\t\tprivate readonly getLanguageConfiguration: (languageId: string) => ResolvedLanguageConfiguration,\n\t) {\n\t}\n\n\tpublic didLanguageChange(languageId: string): boolean {\n\t\t// Report a change whenever the language configuration updates.\n\t\treturn this.languageIdToBracketTokens.has(languageId);\n\t}\n\n\tgetSingleLanguageBracketTokens(languageId: string): BracketTokens {\n\t\tlet singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n\t\tif (!singleLanguageBracketTokens) {\n\t\t\tsingleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n\t\t\tthis.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n\t\t}\n\t\treturn singleLanguageBracketTokens;\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;AAChG,OAAO,EAAE,sBAAsB,EAAE,MAAM,uCAAuC,CAAC;AAG/E,OAAO,EAAE,cAAc,EAAE,MAAM,UAAU,CAAC;AAC1C,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAC;AACvC,OAAO,EAAoB,mBAAmB,EAAE,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;AAClG,OAAO,EAAoB,KAAK,EAAa,MAAM,gBAAgB,CAAC;;;;;;AAE9D,MAAO,aAAa;IACzB,MAAM,CAAC,kBAAkB,CAAC,aAA4C,EAAE,gBAA0C,EAAA;QACjH,SAAS,KAAK,CAAC,WAAwB;YACtC,OAAO,gBAAgB,CAAC,MAAM,CAAC,GAA+B,OAA5B,IAAuC,OAA5B,CAAC,UAAU,EAAA,OAA6B,CAAE,CAAC,CAAC,gBAAf,WAAW;QACtF,CAAC;QAED,MAAM,GAAG,GAAG,IAAI,GAAG,EAAiB,CAAC;QACrC,KAAK,MAAM,cAAc,IAAI,aAAa,CAAC,WAAW,CAAC,eAAe,CAAE,CAAC;YACxE,MAAM,MAAM,GAAG,wPAAQ,EAAC,CAAC,EAAE,cAAc,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YAC9D,MAAM,aAAa,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC;YAC5C,MAAM,UAAU,GAAG,wQAAiB,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,aAAa,EAAE,0QAAmB,CAAC,CAAC;YACxF,GAAG,CAAC,GAAG,CAAC,cAAc,CAAC,WAAW,EAAE,IAAI,oPAAK,CAC5C,MAAM,EAAA,EAAA,4BAAA,KAEN,aAAa,EACb,UAAU,EACV,uPAAc,CAAC,MAAM,CAAC,MAAM,EAAE,cAAc,EAAE,UAAU,CAAC,CACzD,CAAC,CAAC;QACJ,CAAC;QAED,KAAK,MAAM,cAAc,IAAI,aAAa,CAAC,WAAW,CAAC,eAAe,CAAE,CAAC;YACxE,MAAM,MAAM,GAAG,wPAAQ,EAAC,CAAC,EAAE,cAAc,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YAC9D,IAAI,UAAU,GAAG,wQAAiB,CAAC,QAAQ,EAAE,CAAC;YAC9C,MAAM,eAAe,GAAG,cAAc,CAAC,kBAAkB,EAAE,CAAC;YAC5D,KAAK,MAAM,OAAO,IAAI,eAAe,CAAE,CAAC;gBACvC,UAAU,GAAG,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,0QAAmB,CAAC,CAAC;YAClE,CAAC;YACD,GAAG,CAAC,GAAG,CAAC,cAAc,CAAC,WAAW,EAAE,IAAI,oPAAK,CAC5C,MAAM,EAAA,EAAA,4BAAA,KAEN,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,EACzB,UAAU,EACV,uPAAc,CAAC,MAAM,CAAC,MAAM,EAAE,cAAc,EAAE,UAAU,CAAC,CACzD,CAAC,CAAC;QACJ,CAAC;QAED,OAAO,IAAI,aAAa,CAAC,GAAG,CAAC,CAAC;IAC/B,CAAC;IASD,YAAY,GAAA;QACX,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;YAClB,OAAO,IAAI,CAAC;QACb,CAAC,MAAM,CAAC;YACP,MAAM,IAAI,GAAG,CAAC;mBAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;aAAC,CAAC;YAClC,IAAI,CAAC,IAAI,EAAE,CAAC;YACZ,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,CAAC,GAAG,EAAC,CAAC,CAAC,EAAE,AAAC,uBAAuB,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC5D,CAAC;IACF,CAAC;IAED;;MAEE,CACF,IAAI,YAAY,GAAA;QACf,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;YACrB,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;YACtC,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;YACpE,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACvB,CAAC;QACD,OAAO,IAAI,CAAC,aAAa,CAAC;IAC3B,CAAC;IAED,QAAQ,CAAC,KAAa,EAAA;QACrB,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;IAC1C,CAAC;IAED,oBAAoB,CAAC,iBAAsD,EAAA;QAC1E,KAAK,MAAM,CAAC,WAAW,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,CAAE,CAAC;YAC5C,IAAI,IAAI,CAAC,IAAI,KAAA,EAAA,4BAAA,EAA6B,KAAI,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,iBAAiB,CAAC,EAAE,CAAC;gBAC7F,OAAO,WAAW,CAAC;YACpB,CAAC;QACF,CAAC;QACD,OAAO,SAAS,CAAC;IAClB,CAAC;IAED,IAAI,OAAO,GAAA;QACV,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,CAAC;IAC5B,CAAC;IA1CD,YACkB,GAAuB,CAAA;QAAvB,IAAA,CAAA,GAAG,GAAH,GAAG,CAAoB;QAJjC,IAAA,CAAA,SAAS,GAAG,KAAK,CAAC;QAClB,IAAA,CAAA,aAAa,GAAkB,IAAI,CAAC;IAIxC,CAAC;CAyCL;AAED,SAAS,uBAAuB,CAAC,GAAW;IAC3C,IAAI,OAAO,OAAG,uMAAsB,EAAC,GAAG,CAAC,CAAC;IAC1C,0DAA0D;IAC1D,0GAA0G;IAC1G,IAAI,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACzB,OAAO,GAAG,MAAa,CAAE,CAAC,KAAV,OAAO;IACxB,CAAC;IACD,IAAI,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACzB,OAAO,GAAG,GAAU,OAAP,OAAO,EAAA,IAAK,CAAC;IAC3B,CAAC;IACD,OAAO,OAAO,CAAC;AAChB,CAAC;AAEK,MAAO,6BAA6B;IASlC,iBAAiB,CAAC,UAAkB,EAAA;QAC1C,+DAA+D;QAC/D,OAAO,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IACvD,CAAC;IAED,8BAA8B,CAAC,UAAkB,EAAA;QAChD,IAAI,2BAA2B,GAAG,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QACjF,IAAI,CAAC,2BAA2B,EAAE,CAAC;YAClC,2BAA2B,GAAG,aAAa,CAAC,kBAAkB,CAAC,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;YACjI,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,UAAU,EAAE,2BAA2B,CAAC,CAAC;QAC7E,CAAC;QACD,OAAO,2BAA2B,CAAC;IACpC,CAAC;IAlBD,YACkB,gBAA0C,EAC1C,wBAA+E,CAAA;QAD/E,IAAA,CAAA,gBAAgB,GAAhB,gBAAgB,CAA0B;QAC1C,IAAA,CAAA,wBAAwB,GAAxB,wBAAwB,CAAuD;QAJhF,IAAA,CAAA,yBAAyB,GAAG,IAAI,GAAG,EAAyB,CAAC;IAM9E,CAAC;CAeD","debugId":null}},
    {"offset": {"line": 1737, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, ListAstNode } from './ast.js';\n\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items: AstNode[]): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet i = 0;\n\t/**\n\t * Reads nodes of same height and concatenates them to a single node.\n\t*/\n\tfunction readNode(): AstNode | null {\n\t\tif (i >= items.length) {\n\t\t\treturn null;\n\t\t}\n\t\tconst start = i;\n\t\tconst height = items[start].listHeight;\n\n\t\ti++;\n\t\twhile (i < items.length && items[i].listHeight === height) {\n\t\t\ti++;\n\t\t}\n\n\t\tif (i - start >= 2) {\n\t\t\treturn concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n\t\t} else {\n\t\t\treturn items[start];\n\t\t}\n\t}\n\n\t// The items might not have the same height.\n\t// We merge all items by using a binary concat operator.\n\tlet first = readNode()!; // There must be a first item\n\tlet second = readNode();\n\tif (!second) {\n\t\treturn first;\n\t}\n\n\tfor (let item = readNode(); item; item = readNode()) {\n\t\t// Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n\t\tif (heightDiff(first, second) <= heightDiff(second, item)) {\n\t\t\tfirst = concat(first, second);\n\t\t\tsecond = item;\n\t\t} else {\n\t\t\tsecond = concat(second, item);\n\t\t}\n\t}\n\n\tconst result = concat(first, second);\n\treturn result;\n}\n\nexport function concat23TreesOfSameHeight(items: AstNode[], createImmutableLists: boolean = false): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet length = items.length;\n\t// All trees have same height, just create parent nodes.\n\twhile (length > 3) {\n\t\tconst newLength = length >> 1;\n\t\tfor (let i = 0; i < newLength; i++) {\n\t\t\tconst j = i << 1;\n\t\t\titems[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n\t\t}\n\t\tlength = newLength;\n\t}\n\treturn ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\n\nfunction heightDiff(node1: AstNode, node2: AstNode): number {\n\treturn Math.abs(node1.listHeight - node2.listHeight);\n}\n\nfunction concat(node1: AstNode, node2: AstNode): AstNode {\n\tif (node1.listHeight === node2.listHeight) {\n\t\treturn ListAstNode.create23(node1, node2, null, false);\n\t}\n\telse if (node1.listHeight > node2.listHeight) {\n\t\t// node1 is the tree we want to insert into\n\t\treturn append(node1 as ListAstNode, node2);\n\t} else {\n\t\treturn prepend(node2 as ListAstNode, node1);\n\t}\n}\n\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\tlet nodeToAppendOfCorrectHeight: AstNode | undefined;\n\twhile (true) {\n\t\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\t\tif (nodeToAppend.listHeight === curNode.listHeight) {\n\t\t\tnodeToAppendOfCorrectHeight = nodeToAppend;\n\t\t\tbreak;\n\t\t}\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenLength <= 3\n\t\tcurNode = curNode.makeLastElementMutable()!;\n\t}\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToAppendOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild()!, nodeToAppendOfCorrectHeight, null, false);\n\t\t\t} else {\n\t\t\t\tparent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToAppendOfCorrectHeight) {\n\t\treturn ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\twhile (nodeToAppend.listHeight !== curNode.listHeight) {\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenFast.length <= 3\n\t\tcurNode = curNode.makeFirstElementMutable()!;\n\t}\n\tlet nodeToPrependOfCorrectHeight: AstNode | undefined = nodeToAppend;\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToPrependOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild()!, null, false);\n\t\t\t} else {\n\t\t\t\tparent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n\t\t\t\tnodeToPrependOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToPrependOfCorrectHeight) {\n\t\treturn ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, ListAstNode } from './ast.js';\n\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items: AstNode[]): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet i = 0;\n\t/**\n\t * Reads nodes of same height and concatenates them to a single node.\n\t*/\n\tfunction readNode(): AstNode | null {\n\t\tif (i >= items.length) {\n\t\t\treturn null;\n\t\t}\n\t\tconst start = i;\n\t\tconst height = items[start].listHeight;\n\n\t\ti++;\n\t\twhile (i < items.length && items[i].listHeight === height) {\n\t\t\ti++;\n\t\t}\n\n\t\tif (i - start >= 2) {\n\t\t\treturn concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n\t\t} else {\n\t\t\treturn items[start];\n\t\t}\n\t}\n\n\t// The items might not have the same height.\n\t// We merge all items by using a binary concat operator.\n\tlet first = readNode()!; // There must be a first item\n\tlet second = readNode();\n\tif (!second) {\n\t\treturn first;\n\t}\n\n\tfor (let item = readNode(); item; item = readNode()) {\n\t\t// Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n\t\tif (heightDiff(first, second) <= heightDiff(second, item)) {\n\t\t\tfirst = concat(first, second);\n\t\t\tsecond = item;\n\t\t} else {\n\t\t\tsecond = concat(second, item);\n\t\t}\n\t}\n\n\tconst result = concat(first, second);\n\treturn result;\n}\n\nexport function concat23TreesOfSameHeight(items: AstNode[], createImmutableLists: boolean = false): AstNode | null {\n\tif (items.length === 0) {\n\t\treturn null;\n\t}\n\tif (items.length === 1) {\n\t\treturn items[0];\n\t}\n\n\tlet length = items.length;\n\t// All trees have same height, just create parent nodes.\n\twhile (length > 3) {\n\t\tconst newLength = length >> 1;\n\t\tfor (let i = 0; i < newLength; i++) {\n\t\t\tconst j = i << 1;\n\t\t\titems[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n\t\t}\n\t\tlength = newLength;\n\t}\n\treturn ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\n\nfunction heightDiff(node1: AstNode, node2: AstNode): number {\n\treturn Math.abs(node1.listHeight - node2.listHeight);\n}\n\nfunction concat(node1: AstNode, node2: AstNode): AstNode {\n\tif (node1.listHeight === node2.listHeight) {\n\t\treturn ListAstNode.create23(node1, node2, null, false);\n\t}\n\telse if (node1.listHeight > node2.listHeight) {\n\t\t// node1 is the tree we want to insert into\n\t\treturn append(node1 as ListAstNode, node2);\n\t} else {\n\t\treturn prepend(node2 as ListAstNode, node1);\n\t}\n}\n\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\tlet nodeToAppendOfCorrectHeight: AstNode | undefined;\n\twhile (true) {\n\t\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\t\tif (nodeToAppend.listHeight === curNode.listHeight) {\n\t\t\tnodeToAppendOfCorrectHeight = nodeToAppend;\n\t\t\tbreak;\n\t\t}\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenLength <= 3\n\t\tcurNode = curNode.makeLastElementMutable()!;\n\t}\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToAppendOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild()!, nodeToAppendOfCorrectHeight, null, false);\n\t\t\t} else {\n\t\t\t\tparent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToAppendOfCorrectHeight) {\n\t\treturn ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list: ListAstNode, nodeToAppend: AstNode): AstNode {\n\tlist = list.toMutable() as ListAstNode;\n\tlet curNode: AstNode = list;\n\tconst parents: ListAstNode[] = [];\n\t// assert nodeToInsert.listHeight <= curNode.listHeight\n\twhile (nodeToAppend.listHeight !== curNode.listHeight) {\n\t\t// assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n\t\tif (curNode.kind !== AstNodeKind.List) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenFast.length <= 3\n\t\tcurNode = curNode.makeFirstElementMutable()!;\n\t}\n\tlet nodeToPrependOfCorrectHeight: AstNode | undefined = nodeToAppend;\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToPrependOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.childrenLength >= 3) {\n\t\t\t\t// assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild()!, null, false);\n\t\t\t} else {\n\t\t\t\tparent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n\t\t\t\tnodeToPrependOfCorrectHeight = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tparent.handleChildrenChanged();\n\t\t}\n\t}\n\tif (nodeToPrependOfCorrectHeight) {\n\t\treturn ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n\t} else {\n\t\treturn list;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1918, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode } from './ast.js';\nimport { lengthAdd, lengthZero, Length, lengthLessThan } from './length.js';\n\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n\tprivate readonly nextNodes: AstNode[];\n\tprivate readonly offsets: Length[];\n\tprivate readonly idxs: number[];\n\tprivate lastOffset: Length = lengthZero;\n\n\tconstructor(node: AstNode) {\n\t\tthis.nextNodes = [node];\n\t\tthis.offsets = [lengthZero];\n\t\tthis.idxs = [];\n\t}\n\n\t/**\n\t * Returns the longest node at `offset` that satisfies the predicate.\n\t * @param offset must be greater than or equal to the last offset this method has been called with!\n\t*/\n\treadLongestNodeAt(offset: Length, predicate: (node: AstNode) => boolean): AstNode | undefined {\n\t\tif (lengthLessThan(offset, this.lastOffset)) {\n\t\t\tthrow new Error('Invalid offset');\n\t\t}\n\t\tthis.lastOffset = offset;\n\n\t\t// Find the longest node of all those that are closest to the current offset.\n\t\twhile (true) {\n\t\t\tconst curNode = lastOrUndefined(this.nextNodes);\n\n\t\t\tif (!curNode) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst curNodeOffset = lastOrUndefined(this.offsets)!;\n\n\t\t\tif (lengthLessThan(offset, curNodeOffset)) {\n\t\t\t\t// The next best node is not here yet.\n\t\t\t\t// The reader must advance before a cached node is hit.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (lengthLessThan(curNodeOffset, offset)) {\n\t\t\t\t// The reader is ahead of the current node.\n\t\t\t\tif (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n\t\t\t\t\t// The reader is after the end of the current node.\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t} else {\n\t\t\t\t\t// The reader is somewhere in the current node.\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\t\t\t// Go to the first child and repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We don't have children\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// readerOffsetBeforeChange === curNodeOffset\n\t\t\t\tif (predicate(curNode)) {\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\treturn curNode;\n\t\t\t\t} else {\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\t// look for shorter node\n\t\t\t\t\tif (nextChildIdx === -1) {\n\t\t\t\t\t\t// There is no shorter node.\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Descend into first child & repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Navigates to the longest node that continues after the current node.\n\tprivate nextNodeAfterCurrent(): void {\n\t\twhile (true) {\n\t\t\tconst currentOffset = lastOrUndefined(this.offsets);\n\t\t\tconst currentNode = lastOrUndefined(this.nextNodes);\n\t\t\tthis.nextNodes.pop();\n\t\t\tthis.offsets.pop();\n\n\t\t\tif (this.idxs.length === 0) {\n\t\t\t\t// We just popped the root node, there is no next node.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Parent is not undefined, because idxs is not empty\n\t\t\tconst parent = lastOrUndefined(this.nextNodes)!;\n\t\t\tconst nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n\n\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\tthis.nextNodes.push(parent.getChild(nextChildIdx)!);\n\t\t\t\tthis.offsets.push(lengthAdd(currentOffset!, currentNode!.length));\n\t\t\t\tthis.idxs[this.idxs.length - 1] = nextChildIdx;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tthis.idxs.pop();\n\t\t\t}\n\t\t\t// We fully consumed the parent.\n\t\t\t// Current node is now parent, so call nextNodeAfterCurrent again\n\t\t}\n\t}\n}\n\nfunction getNextChildIdx(node: AstNode, curIdx: number = -1): number | -1 {\n\twhile (true) {\n\t\tcurIdx++;\n\t\tif (curIdx >= node.childrenLength) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (node.getChild(curIdx)) {\n\t\t\treturn curIdx;\n\t\t}\n\t}\n}\n\nfunction lastOrUndefined<T>(arr: readonly T[]): T | undefined {\n\treturn arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode } from './ast.js';\nimport { lengthAdd, lengthZero, Length, lengthLessThan } from './length.js';\n\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n\tprivate readonly nextNodes: AstNode[];\n\tprivate readonly offsets: Length[];\n\tprivate readonly idxs: number[];\n\tprivate lastOffset: Length = lengthZero;\n\n\tconstructor(node: AstNode) {\n\t\tthis.nextNodes = [node];\n\t\tthis.offsets = [lengthZero];\n\t\tthis.idxs = [];\n\t}\n\n\t/**\n\t * Returns the longest node at `offset` that satisfies the predicate.\n\t * @param offset must be greater than or equal to the last offset this method has been called with!\n\t*/\n\treadLongestNodeAt(offset: Length, predicate: (node: AstNode) => boolean): AstNode | undefined {\n\t\tif (lengthLessThan(offset, this.lastOffset)) {\n\t\t\tthrow new Error('Invalid offset');\n\t\t}\n\t\tthis.lastOffset = offset;\n\n\t\t// Find the longest node of all those that are closest to the current offset.\n\t\twhile (true) {\n\t\t\tconst curNode = lastOrUndefined(this.nextNodes);\n\n\t\t\tif (!curNode) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst curNodeOffset = lastOrUndefined(this.offsets)!;\n\n\t\t\tif (lengthLessThan(offset, curNodeOffset)) {\n\t\t\t\t// The next best node is not here yet.\n\t\t\t\t// The reader must advance before a cached node is hit.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (lengthLessThan(curNodeOffset, offset)) {\n\t\t\t\t// The reader is ahead of the current node.\n\t\t\t\tif (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n\t\t\t\t\t// The reader is after the end of the current node.\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t} else {\n\t\t\t\t\t// The reader is somewhere in the current node.\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\t\t\t// Go to the first child and repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// We don't have children\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// readerOffsetBeforeChange === curNodeOffset\n\t\t\t\tif (predicate(curNode)) {\n\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\treturn curNode;\n\t\t\t\t} else {\n\t\t\t\t\tconst nextChildIdx = getNextChildIdx(curNode);\n\t\t\t\t\t// look for shorter node\n\t\t\t\t\tif (nextChildIdx === -1) {\n\t\t\t\t\t\t// There is no shorter node.\n\t\t\t\t\t\tthis.nextNodeAfterCurrent();\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Descend into first child & repeat.\n\t\t\t\t\t\tthis.nextNodes.push(curNode.getChild(nextChildIdx)!);\n\t\t\t\t\t\tthis.offsets.push(curNodeOffset);\n\t\t\t\t\t\tthis.idxs.push(nextChildIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Navigates to the longest node that continues after the current node.\n\tprivate nextNodeAfterCurrent(): void {\n\t\twhile (true) {\n\t\t\tconst currentOffset = lastOrUndefined(this.offsets);\n\t\t\tconst currentNode = lastOrUndefined(this.nextNodes);\n\t\t\tthis.nextNodes.pop();\n\t\t\tthis.offsets.pop();\n\n\t\t\tif (this.idxs.length === 0) {\n\t\t\t\t// We just popped the root node, there is no next node.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Parent is not undefined, because idxs is not empty\n\t\t\tconst parent = lastOrUndefined(this.nextNodes)!;\n\t\t\tconst nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n\n\t\t\tif (nextChildIdx !== -1) {\n\t\t\t\tthis.nextNodes.push(parent.getChild(nextChildIdx)!);\n\t\t\t\tthis.offsets.push(lengthAdd(currentOffset!, currentNode!.length));\n\t\t\t\tthis.idxs[this.idxs.length - 1] = nextChildIdx;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tthis.idxs.pop();\n\t\t\t}\n\t\t\t// We fully consumed the parent.\n\t\t\t// Current node is now parent, so call nextNodeAfterCurrent again\n\t\t}\n\t}\n}\n\nfunction getNextChildIdx(node: AstNode, curIdx: number = -1): number | -1 {\n\twhile (true) {\n\t\tcurIdx++;\n\t\tif (curIdx >= node.childrenLength) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (node.getChild(curIdx)) {\n\t\t\treturn curIdx;\n\t\t}\n\t}\n}\n\nfunction lastOrUndefined<T>(arr: readonly T[]): T | undefined {\n\treturn arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2043, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, BracketAstNode, InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper, TextEditInfo } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\nimport { OpeningBracketId, Tokenizer, TokenKind } from './tokenizer.js';\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer: Tokenizer, edits: TextEditInfo[], oldNode: AstNode | undefined, createImmutableLists: boolean): AstNode {\n\tconst parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n\treturn parser.parseDocument();\n}\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n\tprivate readonly oldNodeReader?: NodeReader;\n\tprivate readonly positionMapper: BeforeEditPositionMapper;\n\tprivate _itemsConstructed: number = 0;\n\tprivate _itemsFromCache: number = 0;\n\n\tconstructor(\n\t\tprivate readonly tokenizer: Tokenizer,\n\t\tedits: TextEditInfo[],\n\t\toldNode: AstNode | undefined,\n\t\tprivate readonly createImmutableLists: boolean,\n\t) {\n\t\tif (oldNode && createImmutableLists) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\n\t\tthis.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n\t\tthis.positionMapper = new BeforeEditPositionMapper(edits);\n\t}\n\n\tparseDocument(): AstNode {\n\t\tthis._itemsConstructed = 0;\n\t\tthis._itemsFromCache = 0;\n\n\t\tlet result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n\t\tif (!result) {\n\t\t\tresult = ListAstNode.getEmpty();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate parseList(\n\t\topenedBracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\tlevel: number,\n\t): AstNode | null {\n\t\tconst items: AstNode[] = [];\n\n\t\twhile (true) {\n\t\t\tlet child = this.tryReadChildFromCache(openedBracketIds);\n\n\t\t\tif (!child) {\n\t\t\t\tconst token = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\t!token ||\n\t\t\t\t\t(token.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t\ttoken.bracketIds.intersects(openedBracketIds))\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchild = this.parseChild(openedBracketIds, level + 1);\n\t\t\t}\n\n\t\t\tif (child.kind === AstNodeKind.List && child.childrenLength === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titems.push(child);\n\t\t}\n\n\t\t// When there is no oldNodeReader, all items are created from scratch and must have the same height.\n\t\tconst result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n\t\treturn result;\n\t}\n\n\tprivate tryReadChildFromCache(openedBracketIds: SmallImmutableSet<number>): AstNode | undefined {\n\t\tif (this.oldNodeReader) {\n\t\t\tconst maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n\t\t\tif (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n\t\t\t\tconst cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n\t\t\t\t\t// The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n\t\t\t\t\t// If there is no edit anymore, we can re-use the node in any case.\n\t\t\t\t\tif (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n\t\t\t\t\t\t// Either the node contains edited text or touches edited text.\n\t\t\t\t\t\t// In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tconst canBeReused = curNode.canBeReused(openedBracketIds);\n\t\t\t\t\treturn canBeReused;\n\t\t\t\t});\n\n\t\t\t\tif (cachedNode) {\n\t\t\t\t\tthis._itemsFromCache++;\n\t\t\t\t\tthis.tokenizer.skip(cachedNode.length);\n\t\t\t\t\treturn cachedNode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate parseChild(\n\t\topenedBracketIds: SmallImmutableSet<number>,\n\t\tlevel: number,\n\t): AstNode {\n\t\tthis._itemsConstructed++;\n\n\t\tconst token = this.tokenizer.read()!;\n\n\t\tswitch (token.kind) {\n\t\t\tcase TokenKind.ClosingBracket:\n\t\t\t\treturn new InvalidBracketAstNode(token.bracketIds, token.length);\n\n\t\t\tcase TokenKind.Text:\n\t\t\t\treturn token.astNode as TextAstNode;\n\n\t\t\tcase TokenKind.OpeningBracket: {\n\t\t\t\tif (level > 300) {\n\t\t\t\t\t// To prevent stack overflows\n\t\t\t\t\treturn new TextAstNode(token.length);\n\t\t\t\t}\n\n\t\t\t\tconst set = openedBracketIds.merge(token.bracketIds);\n\t\t\t\tconst child = this.parseList(set, level + 1);\n\n\t\t\t\tconst nextToken = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\tnextToken &&\n\t\t\t\t\tnextToken.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t(nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))\n\t\t\t\t) {\n\t\t\t\t\tthis.tokenizer.read();\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnextToken.astNode as BracketAstNode\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnull\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('unexpected');\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AstNode, AstNodeKind, BracketAstNode, InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper, TextEditInfo } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\nimport { OpeningBracketId, Tokenizer, TokenKind } from './tokenizer.js';\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer: Tokenizer, edits: TextEditInfo[], oldNode: AstNode | undefined, createImmutableLists: boolean): AstNode {\n\tconst parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n\treturn parser.parseDocument();\n}\n\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n\tprivate readonly oldNodeReader?: NodeReader;\n\tprivate readonly positionMapper: BeforeEditPositionMapper;\n\tprivate _itemsConstructed: number = 0;\n\tprivate _itemsFromCache: number = 0;\n\n\tconstructor(\n\t\tprivate readonly tokenizer: Tokenizer,\n\t\tedits: TextEditInfo[],\n\t\toldNode: AstNode | undefined,\n\t\tprivate readonly createImmutableLists: boolean,\n\t) {\n\t\tif (oldNode && createImmutableLists) {\n\t\t\tthrow new Error('Not supported');\n\t\t}\n\n\t\tthis.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n\t\tthis.positionMapper = new BeforeEditPositionMapper(edits);\n\t}\n\n\tparseDocument(): AstNode {\n\t\tthis._itemsConstructed = 0;\n\t\tthis._itemsFromCache = 0;\n\n\t\tlet result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n\t\tif (!result) {\n\t\t\tresult = ListAstNode.getEmpty();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate parseList(\n\t\topenedBracketIds: SmallImmutableSet<OpeningBracketId>,\n\t\tlevel: number,\n\t): AstNode | null {\n\t\tconst items: AstNode[] = [];\n\n\t\twhile (true) {\n\t\t\tlet child = this.tryReadChildFromCache(openedBracketIds);\n\n\t\t\tif (!child) {\n\t\t\t\tconst token = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\t!token ||\n\t\t\t\t\t(token.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t\ttoken.bracketIds.intersects(openedBracketIds))\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchild = this.parseChild(openedBracketIds, level + 1);\n\t\t\t}\n\n\t\t\tif (child.kind === AstNodeKind.List && child.childrenLength === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titems.push(child);\n\t\t}\n\n\t\t// When there is no oldNodeReader, all items are created from scratch and must have the same height.\n\t\tconst result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n\t\treturn result;\n\t}\n\n\tprivate tryReadChildFromCache(openedBracketIds: SmallImmutableSet<number>): AstNode | undefined {\n\t\tif (this.oldNodeReader) {\n\t\t\tconst maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n\t\t\tif (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n\t\t\t\tconst cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n\t\t\t\t\t// The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n\t\t\t\t\t// If there is no edit anymore, we can re-use the node in any case.\n\t\t\t\t\tif (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n\t\t\t\t\t\t// Either the node contains edited text or touches edited text.\n\t\t\t\t\t\t// In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tconst canBeReused = curNode.canBeReused(openedBracketIds);\n\t\t\t\t\treturn canBeReused;\n\t\t\t\t});\n\n\t\t\t\tif (cachedNode) {\n\t\t\t\t\tthis._itemsFromCache++;\n\t\t\t\t\tthis.tokenizer.skip(cachedNode.length);\n\t\t\t\t\treturn cachedNode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate parseChild(\n\t\topenedBracketIds: SmallImmutableSet<number>,\n\t\tlevel: number,\n\t): AstNode {\n\t\tthis._itemsConstructed++;\n\n\t\tconst token = this.tokenizer.read()!;\n\n\t\tswitch (token.kind) {\n\t\t\tcase TokenKind.ClosingBracket:\n\t\t\t\treturn new InvalidBracketAstNode(token.bracketIds, token.length);\n\n\t\t\tcase TokenKind.Text:\n\t\t\t\treturn token.astNode as TextAstNode;\n\n\t\t\tcase TokenKind.OpeningBracket: {\n\t\t\t\tif (level > 300) {\n\t\t\t\t\t// To prevent stack overflows\n\t\t\t\t\treturn new TextAstNode(token.length);\n\t\t\t\t}\n\n\t\t\t\tconst set = openedBracketIds.merge(token.bracketIds);\n\t\t\t\tconst child = this.parseList(set, level + 1);\n\n\t\t\t\tconst nextToken = this.tokenizer.peek();\n\t\t\t\tif (\n\t\t\t\t\tnextToken &&\n\t\t\t\t\tnextToken.kind === TokenKind.ClosingBracket &&\n\t\t\t\t\t(nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))\n\t\t\t\t) {\n\t\t\t\t\tthis.tokenizer.read();\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnextToken.astNode as BracketAstNode\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn PairAstNode.create(\n\t\t\t\t\t\ttoken.astNode as BracketAstNode,\n\t\t\t\t\t\tchild,\n\t\t\t\t\t\tnull\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('unexpected');\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2166, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { Length, lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\n\nexport function combineTextEditInfos(textEditInfoFirst: TextEditInfo[], textEditInfoSecond: TextEditInfo[]): TextEditInfo[] {\n\tif (textEditInfoFirst.length === 0) {\n\t\treturn textEditInfoSecond;\n\t}\n\tif (textEditInfoSecond.length === 0) {\n\t\treturn textEditInfoFirst;\n\t}\n\n\t// s0: State before any edits\n\tconst s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n\t// s1: State after first edit, but before second edit\n\tconst s1ToS2Map = toLengthMapping(textEditInfoSecond) as (LengthMapping | { lengthBefore: undefined; lengthAfter: undefined; modified: false })[];\n\ts1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n\t// s2: State after both edits\n\n\tlet curItem: LengthMapping | undefined = s0ToS1Map.dequeue();\n\n\t/**\n\t * @param s1Length Use undefined for length \"infinity\"\n\t */\n\tfunction nextS0ToS1MapWithS1LengthOf(s1Length: Length | undefined): LengthMapping[] {\n\t\tif (s1Length === undefined) {\n\t\t\tconst arr = s0ToS1Map.takeWhile(v => true) || [];\n\t\t\tif (curItem) {\n\t\t\t\tarr.unshift(curItem);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tconst result: LengthMapping[] = [];\n\t\twhile (curItem && !lengthIsZero(s1Length)) {\n\t\t\tconst [item, remainingItem] = curItem.splitAt(s1Length);\n\t\t\tresult.push(item);\n\t\t\ts1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n\t\t\tcurItem = remainingItem ?? s0ToS1Map.dequeue();\n\t\t}\n\t\tif (!lengthIsZero(s1Length)) {\n\t\t\tresult.push(new LengthMapping(false, s1Length, s1Length));\n\t\t}\n\t\treturn result;\n\t}\n\n\tconst result: TextEditInfo[] = [];\n\n\tfunction pushEdit(startOffset: Length, endOffset: Length, newLength: Length): void {\n\t\tif (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n\t\t\tconst lastResult = result[result.length - 1];\n\t\t\tresult[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n\t\t} else {\n\t\t\tresult.push({ startOffset, endOffset, newLength });\n\t\t}\n\t}\n\n\tlet s0offset = lengthZero;\n\tfor (const s1ToS2 of s1ToS2Map) {\n\t\tconst s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n\t\tif (s1ToS2.modified) {\n\t\t\tconst s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n\t\t\tconst s0EndOffset = lengthAdd(s0offset, s0Length);\n\t\t\tpushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n\t\t\ts0offset = s0EndOffset;\n\t\t} else {\n\t\t\tfor (const s1 of s0ToS1Map) {\n\t\t\t\tconst s0startOffset = s0offset;\n\t\t\t\ts0offset = lengthAdd(s0offset, s1.lengthBefore);\n\t\t\t\tif (s1.modified) {\n\t\t\t\t\tpushEdit(s0startOffset, s0offset, s1.lengthAfter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LengthMapping {\n\tconstructor(\n\t\t/**\n\t\t * If false, length before and length after equal.\n\t\t */\n\t\tpublic readonly modified: boolean,\n\t\tpublic readonly lengthBefore: Length,\n\t\tpublic readonly lengthAfter: Length,\n\t) {\n\t}\n\n\tsplitAt(lengthAfter: Length): [LengthMapping, LengthMapping | undefined] {\n\t\tconst remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n\t\tif (lengthEquals(remainingLengthAfter, lengthZero)) {\n\t\t\treturn [this, undefined];\n\t\t} else if (this.modified) {\n\t\t\treturn [\n\t\t\t\tnew LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n\t\t\t\tnew LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n\t\t\t];\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tnew LengthMapping(this.modified, lengthAfter, lengthAfter),\n\t\t\t\tnew LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n\t\t\t];\n\t\t}\n\t}\n\n\ttoString(): string {\n\t\treturn `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n\t}\n}\n\nfunction toLengthMapping(textEditInfos: TextEditInfo[]): LengthMapping[] {\n\tconst result: LengthMapping[] = [];\n\tlet lastOffset = lengthZero;\n\tfor (const textEditInfo of textEditInfos) {\n\t\tconst spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n\t\tif (!lengthIsZero(spaceLength)) {\n\t\t\tresult.push(new LengthMapping(false, spaceLength, spaceLength));\n\t\t}\n\n\t\tconst lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n\t\tresult.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n\t\tlastOffset = textEditInfo.endOffset;\n\t}\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { Length, lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\n\nexport function combineTextEditInfos(textEditInfoFirst: TextEditInfo[], textEditInfoSecond: TextEditInfo[]): TextEditInfo[] {\n\tif (textEditInfoFirst.length === 0) {\n\t\treturn textEditInfoSecond;\n\t}\n\tif (textEditInfoSecond.length === 0) {\n\t\treturn textEditInfoFirst;\n\t}\n\n\t// s0: State before any edits\n\tconst s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n\t// s1: State after first edit, but before second edit\n\tconst s1ToS2Map = toLengthMapping(textEditInfoSecond) as (LengthMapping | { lengthBefore: undefined; lengthAfter: undefined; modified: false })[];\n\ts1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n\t// s2: State after both edits\n\n\tlet curItem: LengthMapping | undefined = s0ToS1Map.dequeue();\n\n\t/**\n\t * @param s1Length Use undefined for length \"infinity\"\n\t */\n\tfunction nextS0ToS1MapWithS1LengthOf(s1Length: Length | undefined): LengthMapping[] {\n\t\tif (s1Length === undefined) {\n\t\t\tconst arr = s0ToS1Map.takeWhile(v => true) || [];\n\t\t\tif (curItem) {\n\t\t\t\tarr.unshift(curItem);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tconst result: LengthMapping[] = [];\n\t\twhile (curItem && !lengthIsZero(s1Length)) {\n\t\t\tconst [item, remainingItem] = curItem.splitAt(s1Length);\n\t\t\tresult.push(item);\n\t\t\ts1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n\t\t\tcurItem = remainingItem ?? s0ToS1Map.dequeue();\n\t\t}\n\t\tif (!lengthIsZero(s1Length)) {\n\t\t\tresult.push(new LengthMapping(false, s1Length, s1Length));\n\t\t}\n\t\treturn result;\n\t}\n\n\tconst result: TextEditInfo[] = [];\n\n\tfunction pushEdit(startOffset: Length, endOffset: Length, newLength: Length): void {\n\t\tif (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n\t\t\tconst lastResult = result[result.length - 1];\n\t\t\tresult[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n\t\t} else {\n\t\t\tresult.push({ startOffset, endOffset, newLength });\n\t\t}\n\t}\n\n\tlet s0offset = lengthZero;\n\tfor (const s1ToS2 of s1ToS2Map) {\n\t\tconst s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n\t\tif (s1ToS2.modified) {\n\t\t\tconst s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n\t\t\tconst s0EndOffset = lengthAdd(s0offset, s0Length);\n\t\t\tpushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n\t\t\ts0offset = s0EndOffset;\n\t\t} else {\n\t\t\tfor (const s1 of s0ToS1Map) {\n\t\t\t\tconst s0startOffset = s0offset;\n\t\t\t\ts0offset = lengthAdd(s0offset, s1.lengthBefore);\n\t\t\t\tif (s1.modified) {\n\t\t\t\t\tpushEdit(s0startOffset, s0offset, s1.lengthAfter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LengthMapping {\n\tconstructor(\n\t\t/**\n\t\t * If false, length before and length after equal.\n\t\t */\n\t\tpublic readonly modified: boolean,\n\t\tpublic readonly lengthBefore: Length,\n\t\tpublic readonly lengthAfter: Length,\n\t) {\n\t}\n\n\tsplitAt(lengthAfter: Length): [LengthMapping, LengthMapping | undefined] {\n\t\tconst remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n\t\tif (lengthEquals(remainingLengthAfter, lengthZero)) {\n\t\t\treturn [this, undefined];\n\t\t} else if (this.modified) {\n\t\t\treturn [\n\t\t\t\tnew LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n\t\t\t\tnew LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n\t\t\t];\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tnew LengthMapping(this.modified, lengthAfter, lengthAfter),\n\t\t\t\tnew LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n\t\t\t];\n\t\t}\n\t}\n\n\ttoString(): string {\n\t\treturn `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n\t}\n}\n\nfunction toLengthMapping(textEditInfos: TextEditInfo[]): LengthMapping[] {\n\tconst result: LengthMapping[] = [];\n\tlet lastOffset = lengthZero;\n\tfor (const textEditInfo of textEditInfos) {\n\t\tconst spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n\t\tif (!lengthIsZero(spaceLength)) {\n\t\t\tresult.push(new LengthMapping(false, spaceLength, spaceLength));\n\t\t}\n\n\t\tconst lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n\t\tresult.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n\t\tlastOffset = textEditInfo.endOffset;\n\t}\n\treturn result;\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,UAAU,EAAE,MAAM,sCAAsC,CAAC;AAClE,OAAO,EAAE,YAAY,EAAE,MAAM,+BAA+B,CAAC;AAC7D,OAAO,EAAU,SAAS,EAAE,qBAAqB,EAAE,YAAY,EAAE,YAAY,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,aAAa,CAAC;;;;AAElI,SAAU,oBAAoB,CAAC,iBAAiC,EAAE,kBAAkC;IACzG,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACpC,OAAO,kBAAkB,CAAC;IAC3B,CAAC;IACD,IAAI,kBAAkB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACrC,OAAO,iBAAiB,CAAC;IAC1B,CAAC;IAED,6BAA6B;IAC7B,MAAM,SAAS,GAAG,IAAI,0LAAU,CAAC,eAAe,CAAC,iBAAiB,CAAC,CAAC,CAAC;IACrE,qDAAqD;IACrD,MAAM,SAAS,GAAG,eAAe,CAAC,kBAAkB,CAA6F,CAAC;IAClJ,SAAS,CAAC,IAAI,CAAC;QAAE,QAAQ,EAAE,KAAK;QAAE,YAAY,EAAE,SAAS;QAAE,WAAW,EAAE,SAAS;IAAA,CAAE,CAAC,CAAC,CAAC,kCAAkC;IACxH,6BAA6B;IAE7B,IAAI,OAAO,GAA8B,SAAS,CAAC,OAAO,EAAE,CAAC;IAE7D;;OAEG,CACH,SAAS,2BAA2B,CAAC,QAA4B;QAChE,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;YAC5B,MAAM,GAAG,GAAG,SAAS,CAAC,SAAS,EAAC,CAAC,CAAC,EAAE,AAAC,IAAI,CAAC,IAAI,EAAE,CAAC;YACjD,IAAI,OAAO,EAAE,CAAC;gBACb,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YACtB,CAAC;YACD,OAAO,GAAG,CAAC;QACZ,CAAC;QAED,MAAM,MAAM,GAAoB,EAAE,CAAC;QACnC,MAAO,OAAO,IAAI,KAAC,wPAAY,EAAC,QAAQ,CAAC,CAAE,CAAC;YAC3C,MAAM,CAAC,IAAI,EAAE,aAAa,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YACxD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAClB,QAAQ,OAAG,iQAAqB,EAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;YAC7D,OAAO,wDAAG,aAAa,GAAI,SAAS,CAAC,OAAO,EAAE,CAAC;QAChD,CAAC;QACD,IAAI,KAAC,wPAAY,EAAC,QAAQ,CAAC,EAAE,CAAC;YAC7B,MAAM,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC3D,CAAC;QACD,OAAO,MAAM,CAAC;IACf,CAAC;IAED,MAAM,MAAM,GAAmB,EAAE,CAAC;IAElC,SAAS,QAAQ,CAAC,WAAmB,EAAE,SAAiB,EAAE,SAAiB;QAC1E,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,QAAI,wPAAY,EAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,SAAS,EAAE,WAAW,CAAC,EAAE,CAAC;YACzF,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YAC7C,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,0QAAY,CAAC,UAAU,CAAC,WAAW,EAAE,SAAS,MAAE,qPAAS,EAAC,UAAU,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAC7H,CAAC,MAAM,CAAC;YACP,MAAM,CAAC,IAAI,CAAC;gBAAE,WAAW;gBAAE,SAAS;gBAAE,SAAS;YAAA,CAAE,CAAC,CAAC;QACpD,CAAC;IACF,CAAC;IAED,IAAI,QAAQ,GAAG,sPAAU,CAAC;IAC1B,KAAK,MAAM,MAAM,IAAI,SAAS,CAAE,CAAC;QAChC,MAAM,SAAS,GAAG,2BAA2B,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;QACnE,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;YACrB,MAAM,QAAQ,OAAG,sPAAU,EAAC,SAAS,GAAE,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,YAAY,CAAC,CAAC;YAC5D,MAAM,WAAW,OAAG,qPAAS,EAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;YAClD,QAAQ,CAAC,QAAQ,EAAE,WAAW,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;YACpD,QAAQ,GAAG,WAAW,CAAC;QACxB,CAAC,MAAM,CAAC;YACP,KAAK,MAAM,EAAE,IAAI,SAAS,CAAE,CAAC;gBAC5B,MAAM,aAAa,GAAG,QAAQ,CAAC;gBAC/B,QAAQ,OAAG,qPAAS,EAAC,QAAQ,EAAE,EAAE,CAAC,YAAY,CAAC,CAAC;gBAChD,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC;oBACjB,QAAQ,CAAC,aAAa,EAAE,QAAQ,EAAE,EAAE,CAAC,WAAW,CAAC,CAAC;gBACnD,CAAC;YACF,CAAC;QACF,CAAC;IACF,CAAC;IAED,OAAO,MAAM,CAAC;AACf,CAAC;AAED,MAAM,aAAa;IAWlB,OAAO,CAAC,WAAmB,EAAA;QAC1B,MAAM,oBAAoB,OAAG,iQAAqB,EAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;QAClF,QAAI,wPAAY,EAAC,oBAAoB,EAAE,sPAAU,CAAC,EAAE,CAAC;YACpD,OAAO;gBAAC,IAAI;gBAAE,SAAS;aAAC,CAAC;QAC1B,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC1B,OAAO;gBACN,IAAI,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,YAAY,EAAE,WAAW,CAAC;gBAChE,IAAI,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,sPAAU,EAAE,oBAAoB,CAAC;aAClE,CAAC;QACH,CAAC,MAAM,CAAC;YACP,OAAO;gBACN,IAAI,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,EAAE,WAAW,CAAC;gBAC1D,IAAI,aAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,oBAAoB,EAAE,oBAAoB,CAAC;aAC5E,CAAC;QACH,CAAC;IACF,CAAC;IAED,QAAQ,GAAA;QACP,OAAO,GAAgC,OAA7B,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAA,uQAAe,EAAC,IAAI,CAAC,YAAY,CAAC,EAAA,QAAoC,CAAE,CAAC,SAAhC,uPAAW,EAAC,IAAI,CAAC,WAAW,CAAC;IAC1G,CAAC;IA7BD,YACC;;OAEG,CACa,QAAiB,EACjB,YAAoB,EACpB,WAAmB,CAAA;QAFnB,IAAA,CAAA,QAAQ,GAAR,QAAQ,CAAS;QACjB,IAAA,CAAA,YAAY,GAAZ,YAAY,CAAQ;QACpB,IAAA,CAAA,WAAW,GAAX,WAAW,CAAQ;IAEpC,CAAC;CAsBD;AAED,SAAS,eAAe,CAAC,aAA6B;IACrD,MAAM,MAAM,GAAoB,EAAE,CAAC;IACnC,IAAI,UAAU,GAAG,sPAAU,CAAC;IAC5B,KAAK,MAAM,YAAY,IAAI,aAAa,CAAE,CAAC;QAC1C,MAAM,WAAW,OAAG,iQAAqB,EAAC,UAAU,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;QAChF,IAAI,KAAC,wPAAY,EAAC,WAAW,CAAC,EAAE,CAAC;YAChC,MAAM,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC,KAAK,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,CAAC;QACjE,CAAC;QAED,MAAM,YAAY,OAAG,iQAAqB,EAAC,YAAY,CAAC,WAAW,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC;QAC7F,MAAM,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC,IAAI,EAAE,YAAY,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;QAC3E,UAAU,GAAG,YAAY,CAAC,SAAS,CAAC;IACrC,CAAC;IACD,OAAO,MAAM,CAAC;AACf,CAAC","debugId":null}},
    {"offset": {"line": 2301, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { ITextModel } from '../../../model.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo, IFoundBracket } from '../../../textModelBracketPairs.js';\nimport { TextModel } from '../../textModel.js';\nimport { IModelContentChangedEvent, IModelTokensChangedEvent } from '../../../textModelEvents.js';\nimport { ResolvedLanguageConfiguration } from '../../../languages/languageConfigurationRegistry.js';\nimport { AstNode, AstNodeKind } from './ast.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { Length, lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { BackgroundTokenizationState } from '../../../tokenizationTextModelPart.js';\nimport { Position } from '../../../core/position.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nimport { ClosingBracketKind, OpeningBracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\n\nexport class BracketPairsTree extends Disposable {\n\tprivate readonly didChangeEmitter;\n\n\t/*\n\t\tThere are two trees:\n\t\t* The initial tree that has no token information and is used for performant initial bracket colorization.\n\t\t* The tree that used token information to detect bracket pairs.\n\n\t\tTo prevent flickering, we only switch from the initial tree to tree with token information\n\t\twhen tokenization completes.\n\t\tSince the text can be edited while background tokenization is in progress, we need to update both trees.\n\t*/\n\tprivate initialAstWithoutTokens: AstNode | undefined;\n\tprivate astWithTokens: AstNode | undefined;\n\n\tprivate readonly denseKeyProvider;\n\tprivate readonly brackets;\n\n\tpublic didLanguageChange(languageId: string): boolean {\n\t\treturn this.brackets.didLanguageChange(languageId);\n\t}\n\n\tpublic readonly onDidChange;\n\tprivate queuedTextEditsForInitialAstWithoutTokens: TextEditInfo[];\n\tprivate queuedTextEdits: TextEditInfo[];\n\n\tpublic constructor(\n\t\tprivate readonly textModel: TextModel,\n\t\tprivate readonly getLanguageConfiguration: (languageId: string) => ResolvedLanguageConfiguration\n\t) {\n\t\tsuper();\n\t\tthis.didChangeEmitter = new Emitter<void>();\n\t\tthis.denseKeyProvider = new DenseKeyProvider<string>();\n\t\tthis.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n\t\tthis.onDidChange = this.didChangeEmitter.event;\n\t\tthis.queuedTextEditsForInitialAstWithoutTokens = [];\n\t\tthis.queuedTextEdits = [];\n\n\t\tif (!textModel.tokenization.hasTokens) {\n\t\t\tconst brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n\t\t\tconst tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n\t\t\tthis.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n\t\t\tthis.astWithTokens = this.initialAstWithoutTokens;\n\t\t} else if (textModel.tokenization.backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\t// Skip the initial ast, as there is no flickering.\n\t\t\t// Directly create the tree with token information.\n\t\t\tthis.initialAstWithoutTokens = undefined;\n\t\t\tthis.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n\t\t} else {\n\t\t\t// We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n\t\t\tthis.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n\t\t\tthis.astWithTokens = this.initialAstWithoutTokens;\n\t\t}\n\t}\n\n\t//#region TextModel events\n\n\tpublic handleDidChangeBackgroundTokenizationState(): void {\n\t\tif (this.textModel.tokenization.backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\tconst wasUndefined = this.initialAstWithoutTokens === undefined;\n\t\t\t// Clear the initial tree as we can use the tree with token information now.\n\t\t\tthis.initialAstWithoutTokens = undefined;\n\t\t\tif (!wasUndefined) {\n\t\t\t\tthis.didChangeEmitter.fire();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleDidChangeTokens({ ranges }: IModelTokensChangedEvent): void {\n\t\tconst edits = ranges.map(r =>\n\t\t\tnew TextEditInfo(\n\t\t\t\ttoLength(r.fromLineNumber - 1, 0),\n\t\t\t\ttoLength(r.toLineNumber, 0),\n\t\t\t\ttoLength(r.toLineNumber - r.fromLineNumber + 1, 0)\n\t\t\t)\n\t\t);\n\n\t\tthis.handleEdits(edits, true);\n\n\t\tif (!this.initialAstWithoutTokens) {\n\t\t\tthis.didChangeEmitter.fire();\n\t\t}\n\t}\n\n\tpublic handleContentChanged(change: IModelContentChangedEvent) {\n\t\tconst edits = TextEditInfo.fromModelContentChanges(change.changes);\n\t\tthis.handleEdits(edits, false);\n\t}\n\n\tprivate handleEdits(edits: TextEditInfo[], tokenChange: boolean): void {\n\t\t// Lazily queue the edits and only apply them when the tree is accessed.\n\t\tconst result = combineTextEditInfos(this.queuedTextEdits, edits);\n\n\t\tthis.queuedTextEdits = result;\n\t\tif (this.initialAstWithoutTokens && !tokenChange) {\n\t\t\tthis.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n\t\t}\n\t}\n\n\t//#endregion\n\n\tprivate flushQueue() {\n\t\tif (this.queuedTextEdits.length > 0) {\n\t\t\tthis.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n\t\t\tthis.queuedTextEdits = [];\n\t\t}\n\t\tif (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n\t\t\tif (this.initialAstWithoutTokens) {\n\t\t\t\tthis.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n\t\t\t}\n\t\t\tthis.queuedTextEditsForInitialAstWithoutTokens = [];\n\t\t}\n\t}\n\n\t/**\n\t * @pure (only if isPure = true)\n\t*/\n\tprivate parseDocumentFromTextBuffer(edits: TextEditInfo[], previousAst: AstNode | undefined, immutable: boolean): AstNode {\n\t\t// Is much faster if `isPure = false`.\n\t\tconst isPure = false;\n\t\tconst previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n\t\tconst tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n\t\tconst result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n\t\treturn result;\n\t}\n\n\tpublic getBracketsInRange(range: Range, onlyColorizedBrackets: boolean): CallbackIterable<BracketInfo> {\n\t\tthis.flushQueue();\n\n\t\tconst startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n\t\tconst endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n\t\treturn new CallbackIterable(cb => {\n\t\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\t\tcollectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n\t\t});\n\t}\n\n\tpublic getBracketPairsInRange(range: Range, includeMinIndentation: boolean): CallbackIterable<BracketPairWithMinIndentationInfo> {\n\t\tthis.flushQueue();\n\n\t\tconst startLength = positionToLength(range.getStartPosition());\n\t\tconst endLength = positionToLength(range.getEndPosition());\n\n\t\treturn new CallbackIterable(cb => {\n\t\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\t\tconst context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n\t\t\tcollectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n\t\t});\n\t}\n\n\tpublic getFirstBracketAfter(position: Position): IFoundBracket | null {\n\t\tthis.flushQueue();\n\n\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\treturn getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n\t}\n\n\tpublic getFirstBracketBefore(position: Position): IFoundBracket | null {\n\t\tthis.flushQueue();\n\n\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\treturn getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n\t}\n}\n\nfunction getFirstBracketBefore(node: AstNode, nodeOffsetStart: Length, nodeOffsetEnd: Length, position: Length): IFoundBracket | null {\n\tif (node.kind === AstNodeKind.List || node.kind === AstNodeKind.Pair) {\n\t\tconst lengths: { nodeOffsetStart: Length; nodeOffsetEnd: Length }[] = [];\n\t\tfor (const child of node.children) {\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tlengths.push({ nodeOffsetStart, nodeOffsetEnd });\n\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t}\n\t\tfor (let i = lengths.length - 1; i >= 0; i--) {\n\t\t\tconst { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n\t\t\tif (lengthLessThan(nodeOffsetStart, position)) {\n\t\t\t\tconst result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.Bracket) {\n\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\treturn {\n\t\t\tbracketInfo: node.bracketInfo,\n\t\t\trange\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction getFirstBracketAfter(node: AstNode, nodeOffsetStart: Length, nodeOffsetEnd: Length, position: Length): IFoundBracket | null {\n\tif (node.kind === AstNodeKind.List || node.kind === AstNodeKind.Pair) {\n\t\tfor (const child of node.children) {\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tif (lengthLessThan(position, nodeOffsetEnd)) {\n\t\t\t\tconst result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t}\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.Bracket) {\n\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\treturn {\n\t\t\tbracketInfo: node.bracketInfo,\n\t\t\trange\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction collectBrackets(\n\tnode: AstNode,\n\tnodeOffsetStart: Length,\n\tnodeOffsetEnd: Length,\n\tstartOffset: Length,\n\tendOffset: Length,\n\tpush: (item: BracketInfo) => boolean,\n\tlevel: number,\n\tnestingLevelOfEqualBracketType: number,\n\tlevelPerBracketType: Map<string, number>,\n\tonlyColorizedBrackets: boolean,\n\tparentPairIsIncomplete: boolean = false,\n): boolean {\n\tif (level > 200) {\n\t\treturn true;\n\t}\n\n\twhileLoop:\n\twhile (true) {\n\t\tswitch (node.kind) {\n\t\t\tcase AstNodeKind.List: {\n\t\t\t\tconst childCount = node.childrenLength;\n\t\t\t\tfor (let i = 0; i < childCount; i++) {\n\t\t\t\t\tconst child = node.getChild(i);\n\t\t\t\t\tif (!child) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n\t\t\t\t\t\tif (childEndsAfterEnd) {\n\t\t\t\t\t\t\t// No child after this child in the requested window, don't recurse\n\t\t\t\t\t\t\tnode = child;\n\t\t\t\t\t\t\tcontinue whileLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n\t\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase AstNodeKind.Pair: {\n\t\t\t\tconst colorize = !onlyColorizedBrackets || !node.closingBracket || (node.closingBracket.bracketInfo as ClosingBracketKind).closesColorized(node.openingBracket.bracketInfo as OpeningBracketKind);\n\n\t\t\t\tlet levelPerBracket = 0;\n\t\t\t\tif (levelPerBracketType) {\n\t\t\t\t\tlet existing = levelPerBracketType.get(node.openingBracket.text);\n\t\t\t\t\tif (existing === undefined) {\n\t\t\t\t\t\texisting = 0;\n\t\t\t\t\t}\n\t\t\t\t\tlevelPerBracket = existing;\n\t\t\t\t\tif (colorize) {\n\t\t\t\t\t\texisting++;\n\t\t\t\t\t\tlevelPerBracketType.set(node.openingBracket.text, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst childCount = node.childrenLength;\n\t\t\t\tfor (let i = 0; i < childCount; i++) {\n\t\t\t\t\tconst child = node.getChild(i);\n\t\t\t\t\tif (!child) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n\t\t\t\t\t\tif (childEndsAfterEnd && child.kind !== AstNodeKind.Bracket) {\n\t\t\t\t\t\t\t// No child after this child in the requested window, don't recurse\n\t\t\t\t\t\t\t// Don't do this for brackets because of unclosed/unopened brackets\n\t\t\t\t\t\t\tnode = child;\n\t\t\t\t\t\t\tif (colorize) {\n\t\t\t\t\t\t\t\tlevel++;\n\t\t\t\t\t\t\t\tnestingLevelOfEqualBracketType = levelPerBracket + 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnestingLevelOfEqualBracketType = levelPerBracket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue whileLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (colorize || child.kind !== AstNodeKind.Bracket || !node.closingBracket) {\n\t\t\t\t\t\t\tconst shouldContinue = collectBrackets(\n\t\t\t\t\t\t\t\tchild,\n\t\t\t\t\t\t\t\tnodeOffsetStart,\n\t\t\t\t\t\t\t\tnodeOffsetEnd,\n\t\t\t\t\t\t\t\tstartOffset,\n\t\t\t\t\t\t\t\tendOffset,\n\t\t\t\t\t\t\t\tpush,\n\t\t\t\t\t\t\t\tcolorize ? level + 1 : level,\n\t\t\t\t\t\t\t\tcolorize ? levelPerBracket + 1 : levelPerBracket,\n\t\t\t\t\t\t\t\tlevelPerBracketType,\n\t\t\t\t\t\t\t\tonlyColorizedBrackets,\n\t\t\t\t\t\t\t\t!node.closingBracket,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t\t\t}\n\n\t\t\t\tlevelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase AstNodeKind.UnexpectedClosingBracket: {\n\t\t\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\t\t\treturn push(new BracketInfo(range, level - 1, 0, true));\n\t\t\t}\n\t\t\tcase AstNodeKind.Bracket: {\n\t\t\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\t\t\treturn push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n\t\t\t}\n\t\t\tcase AstNodeKind.Text:\n\t\t\t\treturn true;\n\t\t}\n\t}\n}\n\nclass CollectBracketPairsContext {\n\tconstructor(\n\t\tpublic readonly push: (item: BracketPairWithMinIndentationInfo) => boolean,\n\t\tpublic readonly includeMinIndentation: boolean,\n\t\tpublic readonly textModel: ITextModel,\n\t) {\n\t}\n}\n\nfunction collectBracketPairs(\n\tnode: AstNode,\n\tnodeOffsetStart: Length,\n\tnodeOffsetEnd: Length,\n\tstartOffset: Length,\n\tendOffset: Length,\n\tcontext: CollectBracketPairsContext,\n\tlevel: number,\n\tlevelPerBracketType: Map<string, number>\n): boolean {\n\tif (level > 200) {\n\t\treturn true;\n\t}\n\n\tlet shouldContinue = true;\n\n\tif (node.kind === AstNodeKind.Pair) {\n\t\tlet levelPerBracket = 0;\n\t\tif (levelPerBracketType) {\n\t\t\tlet existing = levelPerBracketType.get(node.openingBracket.text);\n\t\t\tif (existing === undefined) {\n\t\t\t\texisting = 0;\n\t\t\t}\n\t\t\tlevelPerBracket = existing;\n\t\t\texisting++;\n\t\t\tlevelPerBracketType.set(node.openingBracket.text, existing);\n\t\t}\n\n\t\tconst openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n\t\tlet minIndentation = -1;\n\t\tif (context.includeMinIndentation) {\n\t\t\tminIndentation = node.computeMinIndentation(\n\t\t\t\tnodeOffsetStart,\n\t\t\t\tcontext.textModel\n\t\t\t);\n\t\t}\n\n\t\tshouldContinue = context.push(\n\t\t\tnew BracketPairWithMinIndentationInfo(\n\t\t\t\tlengthsToRange(nodeOffsetStart, nodeOffsetEnd),\n\t\t\t\tlengthsToRange(nodeOffsetStart, openingBracketEnd),\n\t\t\t\tnode.closingBracket\n\t\t\t\t\t? lengthsToRange(\n\t\t\t\t\t\tlengthAdd(openingBracketEnd, node.child?.length || lengthZero),\n\t\t\t\t\t\tnodeOffsetEnd\n\t\t\t\t\t)\n\t\t\t\t\t: undefined,\n\t\t\t\tlevel,\n\t\t\t\tlevelPerBracket,\n\t\t\t\tnode,\n\t\t\t\tminIndentation\n\t\t\t)\n\t\t);\n\n\t\tnodeOffsetStart = openingBracketEnd;\n\t\tif (shouldContinue && node.child) {\n\t\t\tconst child = node.child;\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tif (\n\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t) {\n\t\t\t\tshouldContinue = collectBracketPairs(\n\t\t\t\t\tchild,\n\t\t\t\t\tnodeOffsetStart,\n\t\t\t\t\tnodeOffsetEnd,\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tendOffset,\n\t\t\t\t\tcontext,\n\t\t\t\t\tlevel + 1,\n\t\t\t\t\tlevelPerBracketType\n\t\t\t\t);\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlevelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n\t} else {\n\t\tlet curOffset = nodeOffsetStart;\n\t\tfor (const child of node.children) {\n\t\t\tconst childOffset = curOffset;\n\t\t\tcurOffset = lengthAdd(curOffset, child.length);\n\n\t\t\tif (\n\t\t\t\tlengthLessThanEqual(childOffset, endOffset) &&\n\t\t\t\tlengthLessThanEqual(startOffset, curOffset)\n\t\t\t) {\n\t\t\t\tshouldContinue = collectBracketPairs(\n\t\t\t\t\tchild,\n\t\t\t\t\tchildOffset,\n\t\t\t\t\tcurOffset,\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tendOffset,\n\t\t\t\t\tcontext,\n\t\t\t\t\tlevel,\n\t\t\t\t\tlevelPerBracketType\n\t\t\t\t);\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { ITextModel } from '../../../model.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo, IFoundBracket } from '../../../textModelBracketPairs.js';\nimport { TextModel } from '../../textModel.js';\nimport { IModelContentChangedEvent, IModelTokensChangedEvent } from '../../../textModelEvents.js';\nimport { ResolvedLanguageConfiguration } from '../../../languages/languageConfigurationRegistry.js';\nimport { AstNode, AstNodeKind } from './ast.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { Length, lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { BackgroundTokenizationState } from '../../../tokenizationTextModelPart.js';\nimport { Position } from '../../../core/position.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nimport { ClosingBracketKind, OpeningBracketKind } from '../../../languages/supports/languageBracketsConfiguration.js';\n\nexport class BracketPairsTree extends Disposable {\n\tprivate readonly didChangeEmitter;\n\n\t/*\n\t\tThere are two trees:\n\t\t* The initial tree that has no token information and is used for performant initial bracket colorization.\n\t\t* The tree that used token information to detect bracket pairs.\n\n\t\tTo prevent flickering, we only switch from the initial tree to tree with token information\n\t\twhen tokenization completes.\n\t\tSince the text can be edited while background tokenization is in progress, we need to update both trees.\n\t*/\n\tprivate initialAstWithoutTokens: AstNode | undefined;\n\tprivate astWithTokens: AstNode | undefined;\n\n\tprivate readonly denseKeyProvider;\n\tprivate readonly brackets;\n\n\tpublic didLanguageChange(languageId: string): boolean {\n\t\treturn this.brackets.didLanguageChange(languageId);\n\t}\n\n\tpublic readonly onDidChange;\n\tprivate queuedTextEditsForInitialAstWithoutTokens: TextEditInfo[];\n\tprivate queuedTextEdits: TextEditInfo[];\n\n\tpublic constructor(\n\t\tprivate readonly textModel: TextModel,\n\t\tprivate readonly getLanguageConfiguration: (languageId: string) => ResolvedLanguageConfiguration\n\t) {\n\t\tsuper();\n\t\tthis.didChangeEmitter = new Emitter<void>();\n\t\tthis.denseKeyProvider = new DenseKeyProvider<string>();\n\t\tthis.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n\t\tthis.onDidChange = this.didChangeEmitter.event;\n\t\tthis.queuedTextEditsForInitialAstWithoutTokens = [];\n\t\tthis.queuedTextEdits = [];\n\n\t\tif (!textModel.tokenization.hasTokens) {\n\t\t\tconst brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n\t\t\tconst tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n\t\t\tthis.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n\t\t\tthis.astWithTokens = this.initialAstWithoutTokens;\n\t\t} else if (textModel.tokenization.backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\t// Skip the initial ast, as there is no flickering.\n\t\t\t// Directly create the tree with token information.\n\t\t\tthis.initialAstWithoutTokens = undefined;\n\t\t\tthis.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n\t\t} else {\n\t\t\t// We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n\t\t\tthis.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n\t\t\tthis.astWithTokens = this.initialAstWithoutTokens;\n\t\t}\n\t}\n\n\t//#region TextModel events\n\n\tpublic handleDidChangeBackgroundTokenizationState(): void {\n\t\tif (this.textModel.tokenization.backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\tconst wasUndefined = this.initialAstWithoutTokens === undefined;\n\t\t\t// Clear the initial tree as we can use the tree with token information now.\n\t\t\tthis.initialAstWithoutTokens = undefined;\n\t\t\tif (!wasUndefined) {\n\t\t\t\tthis.didChangeEmitter.fire();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleDidChangeTokens({ ranges }: IModelTokensChangedEvent): void {\n\t\tconst edits = ranges.map(r =>\n\t\t\tnew TextEditInfo(\n\t\t\t\ttoLength(r.fromLineNumber - 1, 0),\n\t\t\t\ttoLength(r.toLineNumber, 0),\n\t\t\t\ttoLength(r.toLineNumber - r.fromLineNumber + 1, 0)\n\t\t\t)\n\t\t);\n\n\t\tthis.handleEdits(edits, true);\n\n\t\tif (!this.initialAstWithoutTokens) {\n\t\t\tthis.didChangeEmitter.fire();\n\t\t}\n\t}\n\n\tpublic handleContentChanged(change: IModelContentChangedEvent) {\n\t\tconst edits = TextEditInfo.fromModelContentChanges(change.changes);\n\t\tthis.handleEdits(edits, false);\n\t}\n\n\tprivate handleEdits(edits: TextEditInfo[], tokenChange: boolean): void {\n\t\t// Lazily queue the edits and only apply them when the tree is accessed.\n\t\tconst result = combineTextEditInfos(this.queuedTextEdits, edits);\n\n\t\tthis.queuedTextEdits = result;\n\t\tif (this.initialAstWithoutTokens && !tokenChange) {\n\t\t\tthis.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n\t\t}\n\t}\n\n\t//#endregion\n\n\tprivate flushQueue() {\n\t\tif (this.queuedTextEdits.length > 0) {\n\t\t\tthis.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n\t\t\tthis.queuedTextEdits = [];\n\t\t}\n\t\tif (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n\t\t\tif (this.initialAstWithoutTokens) {\n\t\t\t\tthis.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n\t\t\t}\n\t\t\tthis.queuedTextEditsForInitialAstWithoutTokens = [];\n\t\t}\n\t}\n\n\t/**\n\t * @pure (only if isPure = true)\n\t*/\n\tprivate parseDocumentFromTextBuffer(edits: TextEditInfo[], previousAst: AstNode | undefined, immutable: boolean): AstNode {\n\t\t// Is much faster if `isPure = false`.\n\t\tconst isPure = false;\n\t\tconst previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n\t\tconst tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n\t\tconst result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n\t\treturn result;\n\t}\n\n\tpublic getBracketsInRange(range: Range, onlyColorizedBrackets: boolean): CallbackIterable<BracketInfo> {\n\t\tthis.flushQueue();\n\n\t\tconst startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n\t\tconst endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n\t\treturn new CallbackIterable(cb => {\n\t\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\t\tcollectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n\t\t});\n\t}\n\n\tpublic getBracketPairsInRange(range: Range, includeMinIndentation: boolean): CallbackIterable<BracketPairWithMinIndentationInfo> {\n\t\tthis.flushQueue();\n\n\t\tconst startLength = positionToLength(range.getStartPosition());\n\t\tconst endLength = positionToLength(range.getEndPosition());\n\n\t\treturn new CallbackIterable(cb => {\n\t\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\t\tconst context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n\t\t\tcollectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n\t\t});\n\t}\n\n\tpublic getFirstBracketAfter(position: Position): IFoundBracket | null {\n\t\tthis.flushQueue();\n\n\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\treturn getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n\t}\n\n\tpublic getFirstBracketBefore(position: Position): IFoundBracket | null {\n\t\tthis.flushQueue();\n\n\t\tconst node = this.initialAstWithoutTokens || this.astWithTokens!;\n\t\treturn getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n\t}\n}\n\nfunction getFirstBracketBefore(node: AstNode, nodeOffsetStart: Length, nodeOffsetEnd: Length, position: Length): IFoundBracket | null {\n\tif (node.kind === AstNodeKind.List || node.kind === AstNodeKind.Pair) {\n\t\tconst lengths: { nodeOffsetStart: Length; nodeOffsetEnd: Length }[] = [];\n\t\tfor (const child of node.children) {\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tlengths.push({ nodeOffsetStart, nodeOffsetEnd });\n\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t}\n\t\tfor (let i = lengths.length - 1; i >= 0; i--) {\n\t\t\tconst { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n\t\t\tif (lengthLessThan(nodeOffsetStart, position)) {\n\t\t\t\tconst result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.Bracket) {\n\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\treturn {\n\t\t\tbracketInfo: node.bracketInfo,\n\t\t\trange\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction getFirstBracketAfter(node: AstNode, nodeOffsetStart: Length, nodeOffsetEnd: Length, position: Length): IFoundBracket | null {\n\tif (node.kind === AstNodeKind.List || node.kind === AstNodeKind.Pair) {\n\t\tfor (const child of node.children) {\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tif (lengthLessThan(position, nodeOffsetEnd)) {\n\t\t\t\tconst result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t}\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\treturn null;\n\t} else if (node.kind === AstNodeKind.Bracket) {\n\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\treturn {\n\t\t\tbracketInfo: node.bracketInfo,\n\t\t\trange\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction collectBrackets(\n\tnode: AstNode,\n\tnodeOffsetStart: Length,\n\tnodeOffsetEnd: Length,\n\tstartOffset: Length,\n\tendOffset: Length,\n\tpush: (item: BracketInfo) => boolean,\n\tlevel: number,\n\tnestingLevelOfEqualBracketType: number,\n\tlevelPerBracketType: Map<string, number>,\n\tonlyColorizedBrackets: boolean,\n\tparentPairIsIncomplete: boolean = false,\n): boolean {\n\tif (level > 200) {\n\t\treturn true;\n\t}\n\n\twhileLoop:\n\twhile (true) {\n\t\tswitch (node.kind) {\n\t\t\tcase AstNodeKind.List: {\n\t\t\t\tconst childCount = node.childrenLength;\n\t\t\t\tfor (let i = 0; i < childCount; i++) {\n\t\t\t\t\tconst child = node.getChild(i);\n\t\t\t\t\tif (!child) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n\t\t\t\t\t\tif (childEndsAfterEnd) {\n\t\t\t\t\t\t\t// No child after this child in the requested window, don't recurse\n\t\t\t\t\t\t\tnode = child;\n\t\t\t\t\t\t\tcontinue whileLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n\t\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase AstNodeKind.Pair: {\n\t\t\t\tconst colorize = !onlyColorizedBrackets || !node.closingBracket || (node.closingBracket.bracketInfo as ClosingBracketKind).closesColorized(node.openingBracket.bracketInfo as OpeningBracketKind);\n\n\t\t\t\tlet levelPerBracket = 0;\n\t\t\t\tif (levelPerBracketType) {\n\t\t\t\t\tlet existing = levelPerBracketType.get(node.openingBracket.text);\n\t\t\t\t\tif (existing === undefined) {\n\t\t\t\t\t\texisting = 0;\n\t\t\t\t\t}\n\t\t\t\t\tlevelPerBracket = existing;\n\t\t\t\t\tif (colorize) {\n\t\t\t\t\t\texisting++;\n\t\t\t\t\t\tlevelPerBracketType.set(node.openingBracket.text, existing);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst childCount = node.childrenLength;\n\t\t\t\tfor (let i = 0; i < childCount; i++) {\n\t\t\t\t\tconst child = node.getChild(i);\n\t\t\t\t\tif (!child) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n\t\t\t\t\t\tif (childEndsAfterEnd && child.kind !== AstNodeKind.Bracket) {\n\t\t\t\t\t\t\t// No child after this child in the requested window, don't recurse\n\t\t\t\t\t\t\t// Don't do this for brackets because of unclosed/unopened brackets\n\t\t\t\t\t\t\tnode = child;\n\t\t\t\t\t\t\tif (colorize) {\n\t\t\t\t\t\t\t\tlevel++;\n\t\t\t\t\t\t\t\tnestingLevelOfEqualBracketType = levelPerBracket + 1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnestingLevelOfEqualBracketType = levelPerBracket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue whileLoop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (colorize || child.kind !== AstNodeKind.Bracket || !node.closingBracket) {\n\t\t\t\t\t\t\tconst shouldContinue = collectBrackets(\n\t\t\t\t\t\t\t\tchild,\n\t\t\t\t\t\t\t\tnodeOffsetStart,\n\t\t\t\t\t\t\t\tnodeOffsetEnd,\n\t\t\t\t\t\t\t\tstartOffset,\n\t\t\t\t\t\t\t\tendOffset,\n\t\t\t\t\t\t\t\tpush,\n\t\t\t\t\t\t\t\tcolorize ? level + 1 : level,\n\t\t\t\t\t\t\t\tcolorize ? levelPerBracket + 1 : levelPerBracket,\n\t\t\t\t\t\t\t\tlevelPerBracketType,\n\t\t\t\t\t\t\t\tonlyColorizedBrackets,\n\t\t\t\t\t\t\t\t!node.closingBracket,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnodeOffsetStart = nodeOffsetEnd;\n\t\t\t\t}\n\n\t\t\t\tlevelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase AstNodeKind.UnexpectedClosingBracket: {\n\t\t\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\t\t\treturn push(new BracketInfo(range, level - 1, 0, true));\n\t\t\t}\n\t\t\tcase AstNodeKind.Bracket: {\n\t\t\t\tconst range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n\t\t\t\treturn push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n\t\t\t}\n\t\t\tcase AstNodeKind.Text:\n\t\t\t\treturn true;\n\t\t}\n\t}\n}\n\nclass CollectBracketPairsContext {\n\tconstructor(\n\t\tpublic readonly push: (item: BracketPairWithMinIndentationInfo) => boolean,\n\t\tpublic readonly includeMinIndentation: boolean,\n\t\tpublic readonly textModel: ITextModel,\n\t) {\n\t}\n}\n\nfunction collectBracketPairs(\n\tnode: AstNode,\n\tnodeOffsetStart: Length,\n\tnodeOffsetEnd: Length,\n\tstartOffset: Length,\n\tendOffset: Length,\n\tcontext: CollectBracketPairsContext,\n\tlevel: number,\n\tlevelPerBracketType: Map<string, number>\n): boolean {\n\tif (level > 200) {\n\t\treturn true;\n\t}\n\n\tlet shouldContinue = true;\n\n\tif (node.kind === AstNodeKind.Pair) {\n\t\tlet levelPerBracket = 0;\n\t\tif (levelPerBracketType) {\n\t\t\tlet existing = levelPerBracketType.get(node.openingBracket.text);\n\t\t\tif (existing === undefined) {\n\t\t\t\texisting = 0;\n\t\t\t}\n\t\t\tlevelPerBracket = existing;\n\t\t\texisting++;\n\t\t\tlevelPerBracketType.set(node.openingBracket.text, existing);\n\t\t}\n\n\t\tconst openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n\t\tlet minIndentation = -1;\n\t\tif (context.includeMinIndentation) {\n\t\t\tminIndentation = node.computeMinIndentation(\n\t\t\t\tnodeOffsetStart,\n\t\t\t\tcontext.textModel\n\t\t\t);\n\t\t}\n\n\t\tshouldContinue = context.push(\n\t\t\tnew BracketPairWithMinIndentationInfo(\n\t\t\t\tlengthsToRange(nodeOffsetStart, nodeOffsetEnd),\n\t\t\t\tlengthsToRange(nodeOffsetStart, openingBracketEnd),\n\t\t\t\tnode.closingBracket\n\t\t\t\t\t? lengthsToRange(\n\t\t\t\t\t\tlengthAdd(openingBracketEnd, node.child?.length || lengthZero),\n\t\t\t\t\t\tnodeOffsetEnd\n\t\t\t\t\t)\n\t\t\t\t\t: undefined,\n\t\t\t\tlevel,\n\t\t\t\tlevelPerBracket,\n\t\t\t\tnode,\n\t\t\t\tminIndentation\n\t\t\t)\n\t\t);\n\n\t\tnodeOffsetStart = openingBracketEnd;\n\t\tif (shouldContinue && node.child) {\n\t\t\tconst child = node.child;\n\t\t\tnodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n\t\t\tif (\n\t\t\t\tlengthLessThanEqual(nodeOffsetStart, endOffset) &&\n\t\t\t\tlengthGreaterThanEqual(nodeOffsetEnd, startOffset)\n\t\t\t) {\n\t\t\t\tshouldContinue = collectBracketPairs(\n\t\t\t\t\tchild,\n\t\t\t\t\tnodeOffsetStart,\n\t\t\t\t\tnodeOffsetEnd,\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tendOffset,\n\t\t\t\t\tcontext,\n\t\t\t\t\tlevel + 1,\n\t\t\t\t\tlevelPerBracketType\n\t\t\t\t);\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlevelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n\t} else {\n\t\tlet curOffset = nodeOffsetStart;\n\t\tfor (const child of node.children) {\n\t\t\tconst childOffset = curOffset;\n\t\t\tcurOffset = lengthAdd(curOffset, child.length);\n\n\t\t\tif (\n\t\t\t\tlengthLessThanEqual(childOffset, endOffset) &&\n\t\t\t\tlengthLessThanEqual(startOffset, curOffset)\n\t\t\t) {\n\t\t\t\tshouldContinue = collectBracketPairs(\n\t\t\t\t\tchild,\n\t\t\t\t\tchildOffset,\n\t\t\t\t\tcurOffset,\n\t\t\t\t\tstartOffset,\n\t\t\t\t\tendOffset,\n\t\t\t\t\tcontext,\n\t\t\t\t\tlevel,\n\t\t\t\t\tlevelPerBracketType\n\t\t\t\t);\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn shouldContinue;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2656, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable, IReference, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IPosition, Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ILanguageConfigurationService, LanguageConfigurationServiceChangeEvent } from '../../languages/languageConfigurationRegistry.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { LanguageBracketsConfiguration } from '../../languages/supports/languageBracketsConfiguration.js';\nimport { BracketsUtils, RichEditBracket, RichEditBrackets } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nimport { TextModel } from '../textModel.js';\nimport { BracketInfo, BracketPairInfo, BracketPairWithMinIndentationInfo, IBracketPairsTextModelPart, IFoundBracket } from '../../textModelBracketPairs.js';\nimport { IModelContentChangedEvent, IModelLanguageChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent } from '../../textModelEvents.js';\nimport { LineTokens } from '../../tokens/lineTokens.js';\n\nexport class BracketPairsTextModelPart extends Disposable implements IBracketPairsTextModelPart {\n\tprivate readonly bracketPairsTree = this._register(new MutableDisposable<IReference<BracketPairsTree>>());\n\n\tprivate readonly onDidChangeEmitter = new Emitter<void>();\n\tpublic readonly onDidChange = this.onDidChangeEmitter.event;\n\n\tprivate get canBuildAST() {\n\t\tconst maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n\t\treturn this.textModel.getValueLength() <= maxSupportedDocumentLength;\n\t}\n\n\tprivate bracketsRequested = false;\n\n\tpublic constructor(\n\t\tprivate readonly textModel: TextModel,\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tsuper();\n\t}\n\n\t//#region TextModel events\n\n\tpublic handleLanguageConfigurationServiceChange(e: LanguageConfigurationServiceChangeEvent): void {\n\t\tif (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n\t\t\tthis.bracketPairsTree.clear();\n\t\t\tthis.updateBracketPairsTree();\n\t\t}\n\t}\n\n\tpublic handleDidChangeOptions(e: IModelOptionsChangedEvent): void {\n\t\tthis.bracketPairsTree.clear();\n\t\tthis.updateBracketPairsTree();\n\t}\n\n\tpublic handleDidChangeLanguage(e: IModelLanguageChangedEvent): void {\n\t\tthis.bracketPairsTree.clear();\n\t\tthis.updateBracketPairsTree();\n\t}\n\n\tpublic handleDidChangeContent(change: IModelContentChangedEvent) {\n\t\tthis.bracketPairsTree.value?.object.handleContentChanged(change);\n\t}\n\n\tpublic handleDidChangeBackgroundTokenizationState(): void {\n\t\tthis.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n\t}\n\n\tpublic handleDidChangeTokens(e: IModelTokensChangedEvent): void {\n\t\tthis.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n\t}\n\n\t//#endregion\n\n\tprivate updateBracketPairsTree() {\n\t\tif (this.bracketsRequested && this.canBuildAST) {\n\t\t\tif (!this.bracketPairsTree.value) {\n\t\t\t\tconst store = new DisposableStore();\n\n\t\t\t\tthis.bracketPairsTree.value = createDisposableRef(\n\t\t\t\t\tstore.add(\n\t\t\t\t\t\tnew BracketPairsTree(this.textModel, (languageId) => {\n\t\t\t\t\t\t\treturn this.languageConfigurationService.getLanguageConfiguration(languageId);\n\t\t\t\t\t\t})\n\t\t\t\t\t),\n\t\t\t\t\tstore\n\t\t\t\t);\n\t\t\t\tstore.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n\t\t\t\tthis.onDidChangeEmitter.fire();\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.bracketPairsTree.value) {\n\t\t\t\tthis.bracketPairsTree.clear();\n\t\t\t\t// Important: Don't call fire if there was no change!\n\t\t\t\tthis.onDidChangeEmitter.fire();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all bracket pairs that intersect the given range.\n\t * The result is sorted by the start position.\n\t*/\n\tpublic getBracketPairsInRange(range: Range): CallbackIterable<BracketPairInfo> {\n\t\tthis.bracketsRequested = true;\n\t\tthis.updateBracketPairsTree();\n\t\treturn this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n\t}\n\n\tpublic getBracketPairsInRangeWithMinIndentation(range: Range): CallbackIterable<BracketPairWithMinIndentationInfo> {\n\t\tthis.bracketsRequested = true;\n\t\tthis.updateBracketPairsTree();\n\t\treturn this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n\t}\n\n\tpublic getBracketsInRange(range: Range, onlyColorizedBrackets: boolean = false): CallbackIterable<BracketInfo> {\n\t\tthis.bracketsRequested = true;\n\t\tthis.updateBracketPairsTree();\n\t\treturn this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n\t}\n\n\tpublic findMatchingBracketUp(_bracket: string, _position: IPosition, maxDuration?: number): Range | null {\n\t\tconst position = this.textModel.validatePosition(_position);\n\t\tconst languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n\n\t\tif (this.canBuildAST) {\n\t\t\tconst closingBracketInfo = this.languageConfigurationService\n\t\t\t\t.getLanguageConfiguration(languageId)\n\t\t\t\t.bracketsNew.getClosingBracketInfo(_bracket);\n\n\t\t\tif (!closingBracketInfo) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) =>\n\t\t\t\tclosingBracketInfo.closes(b.openingBracketInfo)\n\t\t\t);\n\n\t\t\tif (bracketPair) {\n\t\t\t\treturn bracketPair.openingBracketRange;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// Fallback to old bracket matching code:\n\t\t\tconst bracket = _bracket.toLowerCase();\n\n\t\t\tconst bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\n\t\t\tif (!bracketsSupport) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst data = bracketsSupport.textIsBracket[bracket];\n\n\t\t\tif (!data) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n\t\t}\n\t}\n\n\tpublic matchBracket(position: IPosition, maxDuration?: number): [Range, Range] | null {\n\t\tif (this.canBuildAST) {\n\t\t\tconst bracketPair =\n\t\t\t\tthis.getBracketPairsInRange(\n\t\t\t\t\tRange.fromPositions(position, position)\n\t\t\t\t).filter(\n\t\t\t\t\t(item) =>\n\t\t\t\t\t\titem.closingBracketRange !== undefined &&\n\t\t\t\t\t\t(item.openingBracketRange.containsPosition(position) ||\n\t\t\t\t\t\t\titem.closingBracketRange.containsPosition(position))\n\t\t\t\t).findLastMaxBy(\n\t\t\t\t\tcompareBy(\n\t\t\t\t\t\t(item) =>\n\t\t\t\t\t\t\titem.openingBracketRange.containsPosition(position)\n\t\t\t\t\t\t\t\t? item.openingBracketRange\n\t\t\t\t\t\t\t\t: item.closingBracketRange,\n\t\t\t\t\t\tRange.compareRangesUsingStarts\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tif (bracketPair) {\n\t\t\t\treturn [bracketPair.openingBracketRange, bracketPair.closingBracketRange!];\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// Fallback to old bracket matching code:\n\t\t\tconst continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n\t\t\treturn this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n\t\t}\n\t}\n\n\tprivate _establishBracketSearchOffsets(position: Position, lineTokens: LineTokens, modeBrackets: RichEditBrackets, tokenIndex: number) {\n\t\tconst tokenCount = lineTokens.getCount();\n\t\tconst currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t// limit search to not go before `maxBracketLength`\n\t\tlet searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n\t\tfor (let i = tokenIndex - 1; i >= 0; i--) {\n\t\t\tconst tokenEndOffset = lineTokens.getEndOffset(i);\n\t\t\tif (tokenEndOffset <= searchStartOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n\t\t\t\tsearchStartOffset = tokenEndOffset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// limit search to not go after `maxBracketLength`\n\t\tlet searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n\t\tfor (let i = tokenIndex + 1; i < tokenCount; i++) {\n\t\t\tconst tokenStartOffset = lineTokens.getStartOffset(i);\n\t\t\tif (tokenStartOffset >= searchEndOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n\t\t\t\tsearchEndOffset = tokenStartOffset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn { searchStartOffset, searchEndOffset };\n\t}\n\n\tprivate _matchBracket(position: Position, continueSearchPredicate: ContinueBracketSearchPredicate): [Range, Range] | null {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\tif (tokenIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n\n\t\t// check that the token is not to be ignored\n\t\tif (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n\n\t\t\tlet { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n\n\t\t\t// it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n\t\t\t// `bestResult` will contain the most right-side result\n\t\t\tlet bestResult: [Range, Range] | null = null;\n\t\t\twhile (true) {\n\t\t\t\tconst foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (!foundBracket) {\n\t\t\t\t\t// there are no more brackets in this text\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// check that we didn't hit a bracket too far away from position\n\t\t\t\tif (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n\t\t\t\t\tconst foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n\t\t\t\t\tconst r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tif (r instanceof BracketSearchCanceled) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbestResult = r;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchStartOffset = foundBracket.endColumn - 1;\n\t\t\t}\n\n\t\t\tif (bestResult) {\n\t\t\t\treturn bestResult;\n\t\t\t}\n\t\t}\n\n\t\t// If position is in between two tokens, try also looking in the previous token\n\t\tif (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n\t\t\tconst prevTokenIndex = tokenIndex - 1;\n\t\t\tconst prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n\n\t\t\t// check that previous token is not to be ignored\n\t\t\tif (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n\n\t\t\t\tconst { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n\n\t\t\t\tconst foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n\t\t\t\t// check that we didn't hit a bracket too far away from position\n\t\t\t\tif (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n\t\t\t\t\tconst foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n\t\t\t\t\tconst r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tif (r instanceof BracketSearchCanceled) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _matchFoundBracket(foundBracket: Range, data: RichEditBracket, isOpen: boolean, continueSearchPredicate: ContinueBracketSearchPredicate): [Range, Range] | null | BracketSearchCanceled {\n\t\tif (!data) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matched = (\n\t\t\tisOpen\n\t\t\t\t? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n\t\t\t\t: this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate)\n\t\t);\n\n\t\tif (!matched) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (matched instanceof BracketSearchCanceled) {\n\t\t\treturn matched;\n\t\t}\n\n\t\treturn [foundBracket, matched];\n\t}\n\n\tprivate _findMatchingBracketUp(bracket: RichEditBracket, position: Position, continueSearchPredicate: ContinueBracketSearchPredicate): Range | null | BracketSearchCanceled {\n\t\t// console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n\n\t\tconst languageId = bracket.languageId;\n\t\tconst reversedBracketRegex = bracket.reversedRegex;\n\t\tlet count = -1;\n\n\t\tlet totalCallCount = 0;\n\t\tconst searchPrevMatchingBracketInRange = (lineNumber: number, lineText: string, searchStartOffset: number, searchEndOffset: number): Range | null | BracketSearchCanceled => {\n\t\t\twhile (true) {\n\t\t\t\tif (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n\t\t\t\t\treturn BracketSearchCanceled.INSTANCE;\n\t\t\t\t}\n\t\t\t\tconst r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (!r) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\t\t\t\tif (bracket.isOpen(hitText)) {\n\t\t\t\t\tcount++;\n\t\t\t\t} else if (bracket.isClose(hitText)) {\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\n\t\t\t\tif (count === 0) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\n\t\t\t\tsearchEndOffset = r.startColumn - 1;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tfor (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = tokenCount - 1;\n\t\t\tlet searchStartOffset = lineText.length;\n\t\t\tlet searchEndOffset = lineText.length;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex >= 0; tokenIndex--) {\n\t\t\t\tconst searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchStartOffset\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _findMatchingBracketDown(bracket: RichEditBracket, position: Position, continueSearchPredicate: ContinueBracketSearchPredicate): Range | null | BracketSearchCanceled {\n\t\t// console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n\n\t\tconst languageId = bracket.languageId;\n\t\tconst bracketRegex = bracket.forwardRegex;\n\t\tlet count = 1;\n\n\t\tlet totalCallCount = 0;\n\t\tconst searchNextMatchingBracketInRange = (lineNumber: number, lineText: string, searchStartOffset: number, searchEndOffset: number): Range | null | BracketSearchCanceled => {\n\t\t\twhile (true) {\n\t\t\t\tif (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n\t\t\t\t\treturn BracketSearchCanceled.INSTANCE;\n\t\t\t\t}\n\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (!r) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\t\t\t\tif (bracket.isOpen(hitText)) {\n\t\t\t\t\tcount++;\n\t\t\t\t} else if (bracket.isClose(hitText)) {\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\n\t\t\t\tif (count === 0) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\n\t\t\t\tsearchStartOffset = r.endColumn - 1;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst lineCount = this.textModel.getLineCount();\n\t\tfor (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = 0;\n\t\t\tlet searchStartOffset = 0;\n\t\t\tlet searchEndOffset = 0;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\t\tconst searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchEndOffset\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic findPrevBracket(_position: IPosition): IFoundBracket | null {\n\t\tconst position = this.textModel.validatePosition(_position);\n\n\t\tif (this.canBuildAST) {\n\t\t\tthis.bracketsRequested = true;\n\t\t\tthis.updateBracketPairsTree();\n\t\t\treturn this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n\t\t}\n\n\t\tlet languageId: string | null = null;\n\t\tlet modeBrackets: RichEditBrackets | null = null;\n\t\tlet bracketConfig: LanguageBracketsConfiguration | null = null;\n\t\tfor (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = tokenCount - 1;\n\t\t\tlet searchStartOffset = lineText.length;\n\t\t\tlet searchEndOffset = lineText.length;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tbracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex >= 0; tokenIndex--) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\t// language id change!\n\t\t\t\t\tif (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevSearchInToken = false;\n\t\t\t\t\t}\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tbracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\t\t\t}\n\n\t\t\t\tconst searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchStartOffset\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic findNextBracket(_position: IPosition): IFoundBracket | null {\n\t\tconst position = this.textModel.validatePosition(_position);\n\n\t\tif (this.canBuildAST) {\n\t\t\tthis.bracketsRequested = true;\n\t\t\tthis.updateBracketPairsTree();\n\t\t\treturn this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n\t\t}\n\n\t\tconst lineCount = this.textModel.getLineCount();\n\n\t\tlet languageId: string | null = null;\n\t\tlet modeBrackets: RichEditBrackets | null = null;\n\t\tlet bracketConfig: LanguageBracketsConfiguration | null = null;\n\t\tfor (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = 0;\n\t\t\tlet searchStartOffset = 0;\n\t\t\tlet searchEndOffset = 0;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tbracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\t// language id change!\n\t\t\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevSearchInToken = false;\n\t\t\t\t\t}\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tbracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\t\t\t}\n\n\t\t\t\tconst searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchEndOffset\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic findEnclosingBrackets(_position: IPosition, maxDuration?: number): [Range, Range] | null {\n\t\tconst position = this.textModel.validatePosition(_position);\n\n\t\tif (this.canBuildAST) {\n\t\t\tconst range = Range.fromPositions(position);\n\t\t\tconst bracketPair =\n\t\t\t\tthis.getBracketPairsInRange(Range.fromPositions(position, position)).findLast(\n\t\t\t\t\t(item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range)\n\t\t\t\t);\n\t\t\tif (bracketPair) {\n\t\t\t\treturn [bracketPair.openingBracketRange, bracketPair.closingBracketRange!];\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tconst continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n\t\tconst lineCount = this.textModel.getLineCount();\n\t\tconst savedCounts = new Map<string, number[]>();\n\n\t\tlet counts: number[] = [];\n\t\tconst resetCounts = (languageId: string, modeBrackets: RichEditBrackets | null) => {\n\t\t\tif (!savedCounts.has(languageId)) {\n\t\t\t\tconst tmp = [];\n\t\t\t\tfor (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n\t\t\t\t\ttmp[i] = 0;\n\t\t\t\t}\n\t\t\t\tsavedCounts.set(languageId, tmp);\n\t\t\t}\n\t\t\tcounts = savedCounts.get(languageId)!;\n\t\t};\n\n\t\tlet totalCallCount = 0;\n\t\tconst searchInRange = (modeBrackets: RichEditBrackets, lineNumber: number, lineText: string, searchStartOffset: number, searchEndOffset: number): [Range, Range] | null | BracketSearchCanceled => {\n\t\t\twhile (true) {\n\t\t\t\tif (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n\t\t\t\t\treturn BracketSearchCanceled.INSTANCE;\n\t\t\t\t}\n\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (!r) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\t\t\t\tconst bracket = modeBrackets.textIsBracket[hitText];\n\t\t\t\tif (bracket) {\n\t\t\t\t\tif (bracket.isOpen(hitText)) {\n\t\t\t\t\t\tcounts[bracket.index]++;\n\t\t\t\t\t} else if (bracket.isClose(hitText)) {\n\t\t\t\t\t\tcounts[bracket.index]--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (counts[bracket.index] === -1) {\n\t\t\t\t\t\treturn this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchStartOffset = r.endColumn - 1;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\tlet languageId: string | null = null;\n\t\tlet modeBrackets: RichEditBrackets | null = null;\n\t\tfor (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = 0;\n\t\t\tlet searchStartOffset = 0;\n\t\t\tlet searchEndOffset = 0;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tresetCounts(languageId, modeBrackets);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\t// language id change!\n\t\t\t\t\tif (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn stripBracketSearchCanceled(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevSearchInToken = false;\n\t\t\t\t\t}\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tresetCounts(languageId, modeBrackets);\n\t\t\t\t}\n\n\t\t\t\tconst searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchEndOffset\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn stripBracketSearchCanceled(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn stripBracketSearchCanceled(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _toFoundBracket(bracketConfig: LanguageBracketsConfiguration, r: Range): IFoundBracket | null {\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet text = this.textModel.getValueInRange(r);\n\t\ttext = text.toLowerCase();\n\n\t\tconst bracketInfo = bracketConfig.getBracketInfo(text);\n\t\tif (!bracketInfo) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\trange: r,\n\t\t\tbracketInfo\n\t\t};\n\t}\n}\n\nfunction createDisposableRef<T>(object: T, disposable?: IDisposable): IReference<T> {\n\treturn {\n\t\tobject,\n\t\tdispose: () => disposable?.dispose(),\n\t};\n}\n\ntype ContinueBracketSearchPredicate = (() => boolean);\n\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration: number | undefined): ContinueBracketSearchPredicate {\n\tif (typeof maxDuration === 'undefined') {\n\t\treturn () => true;\n\t} else {\n\t\tconst startTime = Date.now();\n\t\treturn () => {\n\t\t\treturn (Date.now() - startTime <= maxDuration);\n\t\t};\n\t}\n}\n\nclass BracketSearchCanceled {\n\tpublic static INSTANCE = new BracketSearchCanceled();\n\t_searchCanceledBrand = undefined;\n\tprivate constructor() { }\n}\n\nfunction stripBracketSearchCanceled<T>(result: T | null | BracketSearchCanceled): T | null {\n\tif (result instanceof BracketSearchCanceled) {\n\t\treturn null;\n\t}\n\treturn result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, IDisposable, IReference, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { IPosition, Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ILanguageConfigurationService, LanguageConfigurationServiceChangeEvent } from '../../languages/languageConfigurationRegistry.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { LanguageBracketsConfiguration } from '../../languages/supports/languageBracketsConfiguration.js';\nimport { BracketsUtils, RichEditBracket, RichEditBrackets } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nimport { TextModel } from '../textModel.js';\nimport { BracketInfo, BracketPairInfo, BracketPairWithMinIndentationInfo, IBracketPairsTextModelPart, IFoundBracket } from '../../textModelBracketPairs.js';\nimport { IModelContentChangedEvent, IModelLanguageChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent } from '../../textModelEvents.js';\nimport { LineTokens } from '../../tokens/lineTokens.js';\n\nexport class BracketPairsTextModelPart extends Disposable implements IBracketPairsTextModelPart {\n\tprivate readonly bracketPairsTree = this._register(new MutableDisposable<IReference<BracketPairsTree>>());\n\n\tprivate readonly onDidChangeEmitter = new Emitter<void>();\n\tpublic readonly onDidChange = this.onDidChangeEmitter.event;\n\n\tprivate get canBuildAST() {\n\t\tconst maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n\t\treturn this.textModel.getValueLength() <= maxSupportedDocumentLength;\n\t}\n\n\tprivate bracketsRequested = false;\n\n\tpublic constructor(\n\t\tprivate readonly textModel: TextModel,\n\t\tprivate readonly languageConfigurationService: ILanguageConfigurationService\n\t) {\n\t\tsuper();\n\t}\n\n\t//#region TextModel events\n\n\tpublic handleLanguageConfigurationServiceChange(e: LanguageConfigurationServiceChangeEvent): void {\n\t\tif (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n\t\t\tthis.bracketPairsTree.clear();\n\t\t\tthis.updateBracketPairsTree();\n\t\t}\n\t}\n\n\tpublic handleDidChangeOptions(e: IModelOptionsChangedEvent): void {\n\t\tthis.bracketPairsTree.clear();\n\t\tthis.updateBracketPairsTree();\n\t}\n\n\tpublic handleDidChangeLanguage(e: IModelLanguageChangedEvent): void {\n\t\tthis.bracketPairsTree.clear();\n\t\tthis.updateBracketPairsTree();\n\t}\n\n\tpublic handleDidChangeContent(change: IModelContentChangedEvent) {\n\t\tthis.bracketPairsTree.value?.object.handleContentChanged(change);\n\t}\n\n\tpublic handleDidChangeBackgroundTokenizationState(): void {\n\t\tthis.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n\t}\n\n\tpublic handleDidChangeTokens(e: IModelTokensChangedEvent): void {\n\t\tthis.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n\t}\n\n\t//#endregion\n\n\tprivate updateBracketPairsTree() {\n\t\tif (this.bracketsRequested && this.canBuildAST) {\n\t\t\tif (!this.bracketPairsTree.value) {\n\t\t\t\tconst store = new DisposableStore();\n\n\t\t\t\tthis.bracketPairsTree.value = createDisposableRef(\n\t\t\t\t\tstore.add(\n\t\t\t\t\t\tnew BracketPairsTree(this.textModel, (languageId) => {\n\t\t\t\t\t\t\treturn this.languageConfigurationService.getLanguageConfiguration(languageId);\n\t\t\t\t\t\t})\n\t\t\t\t\t),\n\t\t\t\t\tstore\n\t\t\t\t);\n\t\t\t\tstore.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n\t\t\t\tthis.onDidChangeEmitter.fire();\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.bracketPairsTree.value) {\n\t\t\t\tthis.bracketPairsTree.clear();\n\t\t\t\t// Important: Don't call fire if there was no change!\n\t\t\t\tthis.onDidChangeEmitter.fire();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all bracket pairs that intersect the given range.\n\t * The result is sorted by the start position.\n\t*/\n\tpublic getBracketPairsInRange(range: Range): CallbackIterable<BracketPairInfo> {\n\t\tthis.bracketsRequested = true;\n\t\tthis.updateBracketPairsTree();\n\t\treturn this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n\t}\n\n\tpublic getBracketPairsInRangeWithMinIndentation(range: Range): CallbackIterable<BracketPairWithMinIndentationInfo> {\n\t\tthis.bracketsRequested = true;\n\t\tthis.updateBracketPairsTree();\n\t\treturn this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n\t}\n\n\tpublic getBracketsInRange(range: Range, onlyColorizedBrackets: boolean = false): CallbackIterable<BracketInfo> {\n\t\tthis.bracketsRequested = true;\n\t\tthis.updateBracketPairsTree();\n\t\treturn this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n\t}\n\n\tpublic findMatchingBracketUp(_bracket: string, _position: IPosition, maxDuration?: number): Range | null {\n\t\tconst position = this.textModel.validatePosition(_position);\n\t\tconst languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n\n\t\tif (this.canBuildAST) {\n\t\t\tconst closingBracketInfo = this.languageConfigurationService\n\t\t\t\t.getLanguageConfiguration(languageId)\n\t\t\t\t.bracketsNew.getClosingBracketInfo(_bracket);\n\n\t\t\tif (!closingBracketInfo) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) =>\n\t\t\t\tclosingBracketInfo.closes(b.openingBracketInfo)\n\t\t\t);\n\n\t\t\tif (bracketPair) {\n\t\t\t\treturn bracketPair.openingBracketRange;\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// Fallback to old bracket matching code:\n\t\t\tconst bracket = _bracket.toLowerCase();\n\n\t\t\tconst bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\n\t\t\tif (!bracketsSupport) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst data = bracketsSupport.textIsBracket[bracket];\n\n\t\t\tif (!data) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n\t\t}\n\t}\n\n\tpublic matchBracket(position: IPosition, maxDuration?: number): [Range, Range] | null {\n\t\tif (this.canBuildAST) {\n\t\t\tconst bracketPair =\n\t\t\t\tthis.getBracketPairsInRange(\n\t\t\t\t\tRange.fromPositions(position, position)\n\t\t\t\t).filter(\n\t\t\t\t\t(item) =>\n\t\t\t\t\t\titem.closingBracketRange !== undefined &&\n\t\t\t\t\t\t(item.openingBracketRange.containsPosition(position) ||\n\t\t\t\t\t\t\titem.closingBracketRange.containsPosition(position))\n\t\t\t\t).findLastMaxBy(\n\t\t\t\t\tcompareBy(\n\t\t\t\t\t\t(item) =>\n\t\t\t\t\t\t\titem.openingBracketRange.containsPosition(position)\n\t\t\t\t\t\t\t\t? item.openingBracketRange\n\t\t\t\t\t\t\t\t: item.closingBracketRange,\n\t\t\t\t\t\tRange.compareRangesUsingStarts\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tif (bracketPair) {\n\t\t\t\treturn [bracketPair.openingBracketRange, bracketPair.closingBracketRange!];\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\t// Fallback to old bracket matching code:\n\t\t\tconst continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n\t\t\treturn this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n\t\t}\n\t}\n\n\tprivate _establishBracketSearchOffsets(position: Position, lineTokens: LineTokens, modeBrackets: RichEditBrackets, tokenIndex: number) {\n\t\tconst tokenCount = lineTokens.getCount();\n\t\tconst currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t// limit search to not go before `maxBracketLength`\n\t\tlet searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n\t\tfor (let i = tokenIndex - 1; i >= 0; i--) {\n\t\t\tconst tokenEndOffset = lineTokens.getEndOffset(i);\n\t\t\tif (tokenEndOffset <= searchStartOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n\t\t\t\tsearchStartOffset = tokenEndOffset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// limit search to not go after `maxBracketLength`\n\t\tlet searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n\t\tfor (let i = tokenIndex + 1; i < tokenCount; i++) {\n\t\t\tconst tokenStartOffset = lineTokens.getStartOffset(i);\n\t\t\tif (tokenStartOffset >= searchEndOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n\t\t\t\tsearchEndOffset = tokenStartOffset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn { searchStartOffset, searchEndOffset };\n\t}\n\n\tprivate _matchBracket(position: Position, continueSearchPredicate: ContinueBracketSearchPredicate): [Range, Range] | null {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\tif (tokenIndex < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n\n\t\t// check that the token is not to be ignored\n\t\tif (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n\n\t\t\tlet { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n\n\t\t\t// it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n\t\t\t// `bestResult` will contain the most right-side result\n\t\t\tlet bestResult: [Range, Range] | null = null;\n\t\t\twhile (true) {\n\t\t\t\tconst foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (!foundBracket) {\n\t\t\t\t\t// there are no more brackets in this text\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// check that we didn't hit a bracket too far away from position\n\t\t\t\tif (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n\t\t\t\t\tconst foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n\t\t\t\t\tconst r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tif (r instanceof BracketSearchCanceled) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbestResult = r;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchStartOffset = foundBracket.endColumn - 1;\n\t\t\t}\n\n\t\t\tif (bestResult) {\n\t\t\t\treturn bestResult;\n\t\t\t}\n\t\t}\n\n\t\t// If position is in between two tokens, try also looking in the previous token\n\t\tif (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n\t\t\tconst prevTokenIndex = tokenIndex - 1;\n\t\t\tconst prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n\n\t\t\t// check that previous token is not to be ignored\n\t\t\tif (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n\n\t\t\t\tconst { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n\n\t\t\t\tconst foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n\t\t\t\t// check that we didn't hit a bracket too far away from position\n\t\t\t\tif (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n\t\t\t\t\tconst foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n\t\t\t\t\tconst r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tif (r instanceof BracketSearchCanceled) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _matchFoundBracket(foundBracket: Range, data: RichEditBracket, isOpen: boolean, continueSearchPredicate: ContinueBracketSearchPredicate): [Range, Range] | null | BracketSearchCanceled {\n\t\tif (!data) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst matched = (\n\t\t\tisOpen\n\t\t\t\t? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n\t\t\t\t: this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate)\n\t\t);\n\n\t\tif (!matched) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (matched instanceof BracketSearchCanceled) {\n\t\t\treturn matched;\n\t\t}\n\n\t\treturn [foundBracket, matched];\n\t}\n\n\tprivate _findMatchingBracketUp(bracket: RichEditBracket, position: Position, continueSearchPredicate: ContinueBracketSearchPredicate): Range | null | BracketSearchCanceled {\n\t\t// console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n\n\t\tconst languageId = bracket.languageId;\n\t\tconst reversedBracketRegex = bracket.reversedRegex;\n\t\tlet count = -1;\n\n\t\tlet totalCallCount = 0;\n\t\tconst searchPrevMatchingBracketInRange = (lineNumber: number, lineText: string, searchStartOffset: number, searchEndOffset: number): Range | null | BracketSearchCanceled => {\n\t\t\twhile (true) {\n\t\t\t\tif (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n\t\t\t\t\treturn BracketSearchCanceled.INSTANCE;\n\t\t\t\t}\n\t\t\t\tconst r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (!r) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\t\t\t\tif (bracket.isOpen(hitText)) {\n\t\t\t\t\tcount++;\n\t\t\t\t} else if (bracket.isClose(hitText)) {\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\n\t\t\t\tif (count === 0) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\n\t\t\t\tsearchEndOffset = r.startColumn - 1;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tfor (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = tokenCount - 1;\n\t\t\tlet searchStartOffset = lineText.length;\n\t\t\tlet searchEndOffset = lineText.length;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex >= 0; tokenIndex--) {\n\t\t\t\tconst searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchStartOffset\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _findMatchingBracketDown(bracket: RichEditBracket, position: Position, continueSearchPredicate: ContinueBracketSearchPredicate): Range | null | BracketSearchCanceled {\n\t\t// console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n\n\t\tconst languageId = bracket.languageId;\n\t\tconst bracketRegex = bracket.forwardRegex;\n\t\tlet count = 1;\n\n\t\tlet totalCallCount = 0;\n\t\tconst searchNextMatchingBracketInRange = (lineNumber: number, lineText: string, searchStartOffset: number, searchEndOffset: number): Range | null | BracketSearchCanceled => {\n\t\t\twhile (true) {\n\t\t\t\tif (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n\t\t\t\t\treturn BracketSearchCanceled.INSTANCE;\n\t\t\t\t}\n\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (!r) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\t\t\t\tif (bracket.isOpen(hitText)) {\n\t\t\t\t\tcount++;\n\t\t\t\t} else if (bracket.isClose(hitText)) {\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\n\t\t\t\tif (count === 0) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\n\t\t\t\tsearchStartOffset = r.endColumn - 1;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst lineCount = this.textModel.getLineCount();\n\t\tfor (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = 0;\n\t\t\tlet searchStartOffset = 0;\n\t\t\tlet searchEndOffset = 0;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\t\tconst searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchEndOffset\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic findPrevBracket(_position: IPosition): IFoundBracket | null {\n\t\tconst position = this.textModel.validatePosition(_position);\n\n\t\tif (this.canBuildAST) {\n\t\t\tthis.bracketsRequested = true;\n\t\t\tthis.updateBracketPairsTree();\n\t\t\treturn this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n\t\t}\n\n\t\tlet languageId: string | null = null;\n\t\tlet modeBrackets: RichEditBrackets | null = null;\n\t\tlet bracketConfig: LanguageBracketsConfiguration | null = null;\n\t\tfor (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = tokenCount - 1;\n\t\t\tlet searchStartOffset = lineText.length;\n\t\t\tlet searchEndOffset = lineText.length;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tbracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex >= 0; tokenIndex--) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\t// language id change!\n\t\t\t\t\tif (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevSearchInToken = false;\n\t\t\t\t\t}\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tbracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\t\t\t}\n\n\t\t\t\tconst searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchStartOffset\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic findNextBracket(_position: IPosition): IFoundBracket | null {\n\t\tconst position = this.textModel.validatePosition(_position);\n\n\t\tif (this.canBuildAST) {\n\t\t\tthis.bracketsRequested = true;\n\t\t\tthis.updateBracketPairsTree();\n\t\t\treturn this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n\t\t}\n\n\t\tconst lineCount = this.textModel.getLineCount();\n\n\t\tlet languageId: string | null = null;\n\t\tlet modeBrackets: RichEditBrackets | null = null;\n\t\tlet bracketConfig: LanguageBracketsConfiguration | null = null;\n\t\tfor (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = 0;\n\t\t\tlet searchStartOffset = 0;\n\t\t\tlet searchEndOffset = 0;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tbracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\t// language id change!\n\t\t\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevSearchInToken = false;\n\t\t\t\t\t}\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tbracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n\t\t\t\t}\n\n\t\t\t\tconst searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchEndOffset\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn this._toFoundBracket(bracketConfig, r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic findEnclosingBrackets(_position: IPosition, maxDuration?: number): [Range, Range] | null {\n\t\tconst position = this.textModel.validatePosition(_position);\n\n\t\tif (this.canBuildAST) {\n\t\t\tconst range = Range.fromPositions(position);\n\t\t\tconst bracketPair =\n\t\t\t\tthis.getBracketPairsInRange(Range.fromPositions(position, position)).findLast(\n\t\t\t\t\t(item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range)\n\t\t\t\t);\n\t\t\tif (bracketPair) {\n\t\t\t\treturn [bracketPair.openingBracketRange, bracketPair.closingBracketRange!];\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tconst continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n\t\tconst lineCount = this.textModel.getLineCount();\n\t\tconst savedCounts = new Map<string, number[]>();\n\n\t\tlet counts: number[] = [];\n\t\tconst resetCounts = (languageId: string, modeBrackets: RichEditBrackets | null) => {\n\t\t\tif (!savedCounts.has(languageId)) {\n\t\t\t\tconst tmp = [];\n\t\t\t\tfor (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n\t\t\t\t\ttmp[i] = 0;\n\t\t\t\t}\n\t\t\t\tsavedCounts.set(languageId, tmp);\n\t\t\t}\n\t\t\tcounts = savedCounts.get(languageId)!;\n\t\t};\n\n\t\tlet totalCallCount = 0;\n\t\tconst searchInRange = (modeBrackets: RichEditBrackets, lineNumber: number, lineText: string, searchStartOffset: number, searchEndOffset: number): [Range, Range] | null | BracketSearchCanceled => {\n\t\t\twhile (true) {\n\t\t\t\tif (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n\t\t\t\t\treturn BracketSearchCanceled.INSTANCE;\n\t\t\t\t}\n\t\t\t\tconst r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (!r) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\t\t\t\tconst bracket = modeBrackets.textIsBracket[hitText];\n\t\t\t\tif (bracket) {\n\t\t\t\t\tif (bracket.isOpen(hitText)) {\n\t\t\t\t\t\tcounts[bracket.index]++;\n\t\t\t\t\t} else if (bracket.isClose(hitText)) {\n\t\t\t\t\t\tcounts[bracket.index]--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (counts[bracket.index] === -1) {\n\t\t\t\t\t\treturn this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsearchStartOffset = r.endColumn - 1;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\tlet languageId: string | null = null;\n\t\tlet modeBrackets: RichEditBrackets | null = null;\n\t\tfor (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n\t\t\tconst tokenCount = lineTokens.getCount();\n\t\t\tconst lineText = this.textModel.getLineContent(lineNumber);\n\n\t\t\tlet tokenIndex = 0;\n\t\t\tlet searchStartOffset = 0;\n\t\t\tlet searchEndOffset = 0;\n\t\t\tif (lineNumber === position.lineNumber) {\n\t\t\t\ttokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\t\t\tsearchStartOffset = position.column - 1;\n\t\t\t\tsearchEndOffset = position.column - 1;\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tresetCounts(languageId, modeBrackets);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet prevSearchInToken = true;\n\t\t\tfor (; tokenIndex < tokenCount; tokenIndex++) {\n\t\t\t\tconst tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t\t\tif (languageId !== tokenLanguageId) {\n\t\t\t\t\t// language id change!\n\t\t\t\t\tif (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn stripBracketSearchCanceled(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprevSearchInToken = false;\n\t\t\t\t\t}\n\t\t\t\t\tlanguageId = tokenLanguageId;\n\t\t\t\t\tmodeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n\t\t\t\t\tresetCounts(languageId, modeBrackets);\n\t\t\t\t}\n\n\t\t\t\tconst searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n\t\t\t\tif (searchInToken) {\n\t\t\t\t\t// this token should be searched\n\t\t\t\t\tif (prevSearchInToken) {\n\t\t\t\t\t\t// the previous token should be searched, simply extend searchEndOffset\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the previous token should not be searched\n\t\t\t\t\t\tsearchStartOffset = lineTokens.getStartOffset(tokenIndex);\n\t\t\t\t\t\tsearchEndOffset = lineTokens.getEndOffset(tokenIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// this token should not be searched\n\t\t\t\t\tif (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\t\t\tconst r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\treturn stripBracketSearchCanceled(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevSearchInToken = searchInToken;\n\t\t\t}\n\n\t\t\tif (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n\t\t\t\tconst r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn stripBracketSearchCanceled(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _toFoundBracket(bracketConfig: LanguageBracketsConfiguration, r: Range): IFoundBracket | null {\n\t\tif (!r) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet text = this.textModel.getValueInRange(r);\n\t\ttext = text.toLowerCase();\n\n\t\tconst bracketInfo = bracketConfig.getBracketInfo(text);\n\t\tif (!bracketInfo) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\trange: r,\n\t\t\tbracketInfo\n\t\t};\n\t}\n}\n\nfunction createDisposableRef<T>(object: T, disposable?: IDisposable): IReference<T> {\n\treturn {\n\t\tobject,\n\t\tdispose: () => disposable?.dispose(),\n\t};\n}\n\ntype ContinueBracketSearchPredicate = (() => boolean);\n\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration: number | undefined): ContinueBracketSearchPredicate {\n\tif (typeof maxDuration === 'undefined') {\n\t\treturn () => true;\n\t} else {\n\t\tconst startTime = Date.now();\n\t\treturn () => {\n\t\t\treturn (Date.now() - startTime <= maxDuration);\n\t\t};\n\t}\n}\n\nclass BracketSearchCanceled {\n\tpublic static INSTANCE = new BracketSearchCanceled();\n\t_searchCanceledBrand = undefined;\n\tprivate constructor() { }\n}\n\nfunction stripBracketSearchCanceled<T>(result: T | null | BracketSearchCanceled): T | null {\n\tif (result instanceof BracketSearchCanceled) {\n\t\treturn null;\n\t}\n\treturn result;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3379, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Color } from '../../../../base/common/color.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { BracketPairColorizationOptions, IModelDecoration } from '../../model.js';\nimport { BracketInfo } from '../../textModelBracketPairs.js';\nimport { DecorationProvider } from '../decorationProvider.js';\nimport { TextModel } from '../textModel.js';\nimport {\n\teditorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { IModelOptionsChangedEvent } from '../../textModelEvents.js';\n\nexport class ColorizedBracketPairsDecorationProvider extends Disposable implements DecorationProvider {\n\tprivate colorizationOptions: BracketPairColorizationOptions;\n\tprivate readonly colorProvider = new ColorProvider();\n\n\tprivate readonly onDidChangeEmitter = new Emitter<void>();\n\tpublic readonly onDidChange = this.onDidChangeEmitter.event;\n\n\tconstructor(private readonly textModel: TextModel) {\n\t\tsuper();\n\n\t\tthis.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n\n\t\tthis._register(textModel.bracketPairs.onDidChange(e => {\n\t\t\tthis.onDidChangeEmitter.fire();\n\t\t}));\n\t}\n\n\t//#region TextModel events\n\n\tpublic handleDidChangeOptions(e: IModelOptionsChangedEvent): void {\n\t\tthis.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n\t}\n\n\t//#endregion\n\n\tgetDecorationsInRange(range: Range, ownerId?: number, filterOutValidation?: boolean, onlyMinimapDecorations?: boolean): IModelDecoration[] {\n\t\tif (onlyMinimapDecorations) {\n\t\t\t// Bracket pair colorization decorations are not rendered in the minimap\n\t\t\treturn [];\n\t\t}\n\t\tif (ownerId === undefined) {\n\t\t\treturn [];\n\t\t}\n\t\tif (!this.colorizationOptions.enabled) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result = this.textModel.bracketPairs.getBracketsInRange(range, true).map<IModelDecoration>(bracket => ({\n\t\t\tid: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n\t\t\toptions: {\n\t\t\t\tdescription: 'BracketPairColorization',\n\t\t\t\tinlineClassName: this.colorProvider.getInlineClassName(\n\t\t\t\t\tbracket,\n\t\t\t\t\tthis.colorizationOptions.independentColorPoolPerBracketType\n\t\t\t\t),\n\t\t\t},\n\t\t\townerId: 0,\n\t\t\trange: bracket.range,\n\t\t})).toArray();\n\n\t\treturn result;\n\t}\n\n\tgetAllDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[] {\n\t\tif (ownerId === undefined) {\n\t\t\treturn [];\n\t\t}\n\t\tif (!this.colorizationOptions.enabled) {\n\t\t\treturn [];\n\t\t}\n\t\treturn this.getDecorationsInRange(\n\t\t\tnew Range(1, 1, this.textModel.getLineCount(), 1),\n\t\t\townerId,\n\t\t\tfilterOutValidation\n\t\t);\n\t}\n}\n\nclass ColorProvider {\n\tpublic readonly unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n\n\tgetInlineClassName(bracket: BracketInfo, independentColorPoolPerBracketType: boolean): string {\n\t\tif (bracket.isInvalid) {\n\t\t\treturn this.unexpectedClosingBracketClassName;\n\t\t}\n\t\treturn this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n\t}\n\n\tgetInlineClassNameOfLevel(level: number): string {\n\t\t// To support a dynamic amount of colors up to 6 colors,\n\t\t// we use a number that is a lcm of all numbers from 1 to 6.\n\t\treturn `bracket-highlighting-${level % 30}`;\n\t}\n}\n\nregisterThemingParticipant((theme, collector) => {\n\tconst colors = [\n\t\teditorBracketHighlightingForeground1,\n\t\teditorBracketHighlightingForeground2,\n\t\teditorBracketHighlightingForeground3,\n\t\teditorBracketHighlightingForeground4,\n\t\teditorBracketHighlightingForeground5,\n\t\teditorBracketHighlightingForeground6\n\t];\n\tconst colorProvider = new ColorProvider();\n\n\tcollector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n\n\tconst colorValues = colors\n\t\t.map(c => theme.getColor(c))\n\t\t.filter((c): c is Color => !!c)\n\t\t.filter(c => !c.isTransparent());\n\n\tfor (let level = 0; level < 30; level++) {\n\t\tconst color = colorValues[level % colorValues.length];\n\t\tcollector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n\t}\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Color } from '../../../../base/common/color.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { BracketPairColorizationOptions, IModelDecoration } from '../../model.js';\nimport { BracketInfo } from '../../textModelBracketPairs.js';\nimport { DecorationProvider } from '../decorationProvider.js';\nimport { TextModel } from '../textModel.js';\nimport {\n\teditorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { IModelOptionsChangedEvent } from '../../textModelEvents.js';\n\nexport class ColorizedBracketPairsDecorationProvider extends Disposable implements DecorationProvider {\n\tprivate colorizationOptions: BracketPairColorizationOptions;\n\tprivate readonly colorProvider = new ColorProvider();\n\n\tprivate readonly onDidChangeEmitter = new Emitter<void>();\n\tpublic readonly onDidChange = this.onDidChangeEmitter.event;\n\n\tconstructor(private readonly textModel: TextModel) {\n\t\tsuper();\n\n\t\tthis.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n\n\t\tthis._register(textModel.bracketPairs.onDidChange(e => {\n\t\t\tthis.onDidChangeEmitter.fire();\n\t\t}));\n\t}\n\n\t//#region TextModel events\n\n\tpublic handleDidChangeOptions(e: IModelOptionsChangedEvent): void {\n\t\tthis.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n\t}\n\n\t//#endregion\n\n\tgetDecorationsInRange(range: Range, ownerId?: number, filterOutValidation?: boolean, onlyMinimapDecorations?: boolean): IModelDecoration[] {\n\t\tif (onlyMinimapDecorations) {\n\t\t\t// Bracket pair colorization decorations are not rendered in the minimap\n\t\t\treturn [];\n\t\t}\n\t\tif (ownerId === undefined) {\n\t\t\treturn [];\n\t\t}\n\t\tif (!this.colorizationOptions.enabled) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst result = this.textModel.bracketPairs.getBracketsInRange(range, true).map<IModelDecoration>(bracket => ({\n\t\t\tid: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n\t\t\toptions: {\n\t\t\t\tdescription: 'BracketPairColorization',\n\t\t\t\tinlineClassName: this.colorProvider.getInlineClassName(\n\t\t\t\t\tbracket,\n\t\t\t\t\tthis.colorizationOptions.independentColorPoolPerBracketType\n\t\t\t\t),\n\t\t\t},\n\t\t\townerId: 0,\n\t\t\trange: bracket.range,\n\t\t})).toArray();\n\n\t\treturn result;\n\t}\n\n\tgetAllDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[] {\n\t\tif (ownerId === undefined) {\n\t\t\treturn [];\n\t\t}\n\t\tif (!this.colorizationOptions.enabled) {\n\t\t\treturn [];\n\t\t}\n\t\treturn this.getDecorationsInRange(\n\t\t\tnew Range(1, 1, this.textModel.getLineCount(), 1),\n\t\t\townerId,\n\t\t\tfilterOutValidation\n\t\t);\n\t}\n}\n\nclass ColorProvider {\n\tpublic readonly unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n\n\tgetInlineClassName(bracket: BracketInfo, independentColorPoolPerBracketType: boolean): string {\n\t\tif (bracket.isInvalid) {\n\t\t\treturn this.unexpectedClosingBracketClassName;\n\t\t}\n\t\treturn this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n\t}\n\n\tgetInlineClassNameOfLevel(level: number): string {\n\t\t// To support a dynamic amount of colors up to 6 colors,\n\t\t// we use a number that is a lcm of all numbers from 1 to 6.\n\t\treturn `bracket-highlighting-${level % 30}`;\n\t}\n}\n\nregisterThemingParticipant((theme, collector) => {\n\tconst colors = [\n\t\teditorBracketHighlightingForeground1,\n\t\teditorBracketHighlightingForeground2,\n\t\teditorBracketHighlightingForeground3,\n\t\teditorBracketHighlightingForeground4,\n\t\teditorBracketHighlightingForeground5,\n\t\teditorBracketHighlightingForeground6\n\t];\n\tconst colorProvider = new ColorProvider();\n\n\tcollector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n\n\tconst colorValues = colors\n\t\t.map(c => theme.getColor(c))\n\t\t.filter((c): c is Color => !!c)\n\t\t.filter(c => !c.isTransparent());\n\n\tfor (let level = 0; level < 30; level++) {\n\t\tconst color = colorValues[level % colorValues.length];\n\t\tcollector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n\t}\n});\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3482, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/editStack.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { EndOfLineSequence, ICursorStateComputer, IValidEditOperation, ITextModel } from '../model.js';\nimport { TextModel } from './textModel.js';\nimport { IUndoRedoService, IResourceUndoRedoElement, UndoRedoElementType, IWorkspaceUndoRedoElement, UndoRedoGroup } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { IDisposable } from '../../../base/common/lifecycle.js';\nimport { basename } from '../../../base/common/resources.js';\nimport { ISingleEditOperation } from '../core/editOperation.js';\nimport { EditSources, TextModelEditSource } from '../textModelEditSource.js';\n\nfunction uriGetComparisonKey(resource: URI): string {\n\treturn resource.toString();\n}\n\nexport class SingleModelEditStackData {\n\n\tpublic static create(model: ITextModel, beforeCursorState: Selection[] | null): SingleModelEditStackData {\n\t\tconst alternativeVersionId = model.getAlternativeVersionId();\n\t\tconst eol = getModelEOL(model);\n\t\treturn new SingleModelEditStackData(\n\t\t\talternativeVersionId,\n\t\t\talternativeVersionId,\n\t\t\teol,\n\t\t\teol,\n\t\t\tbeforeCursorState,\n\t\t\tbeforeCursorState,\n\t\t\t[]\n\t\t);\n\t}\n\n\tconstructor(\n\t\tpublic readonly beforeVersionId: number,\n\t\tpublic afterVersionId: number,\n\t\tpublic readonly beforeEOL: EndOfLineSequence,\n\t\tpublic afterEOL: EndOfLineSequence,\n\t\tpublic readonly beforeCursorState: Selection[] | null,\n\t\tpublic afterCursorState: Selection[] | null,\n\t\tpublic changes: TextChange[]\n\t) { }\n\n\tpublic append(model: ITextModel, textChanges: TextChange[], afterEOL: EndOfLineSequence, afterVersionId: number, afterCursorState: Selection[] | null): void {\n\t\tif (textChanges.length > 0) {\n\t\t\tthis.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n\t\t}\n\t\tthis.afterEOL = afterEOL;\n\t\tthis.afterVersionId = afterVersionId;\n\t\tthis.afterCursorState = afterCursorState;\n\t}\n\n\tprivate static _writeSelectionsSize(selections: Selection[] | null): number {\n\t\treturn 4 + 4 * 4 * (selections ? selections.length : 0);\n\t}\n\n\tprivate static _writeSelections(b: Uint8Array, selections: Selection[] | null, offset: number): number {\n\t\tbuffer.writeUInt32BE(b, (selections ? selections.length : 0), offset); offset += 4;\n\t\tif (selections) {\n\t\t\tfor (const selection of selections) {\n\t\t\t\tbuffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset); offset += 4;\n\t\t\t\tbuffer.writeUInt32BE(b, selection.selectionStartColumn, offset); offset += 4;\n\t\t\t\tbuffer.writeUInt32BE(b, selection.positionLineNumber, offset); offset += 4;\n\t\t\t\tbuffer.writeUInt32BE(b, selection.positionColumn, offset); offset += 4;\n\t\t\t}\n\t\t}\n\t\treturn offset;\n\t}\n\n\tprivate static _readSelections(b: Uint8Array, offset: number, dest: Selection[]): number {\n\t\tconst count = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst selectionStartLineNumber = buffer.readUInt32BE(b, offset); offset += 4;\n\t\t\tconst selectionStartColumn = buffer.readUInt32BE(b, offset); offset += 4;\n\t\t\tconst positionLineNumber = buffer.readUInt32BE(b, offset); offset += 4;\n\t\t\tconst positionColumn = buffer.readUInt32BE(b, offset); offset += 4;\n\t\t\tdest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n\t\t}\n\t\treturn offset;\n\t}\n\n\tpublic serialize(): ArrayBuffer {\n\t\tlet necessarySize = (\n\t\t\t+ 4 // beforeVersionId\n\t\t\t+ 4 // afterVersionId\n\t\t\t+ 1 // beforeEOL\n\t\t\t+ 1 // afterEOL\n\t\t\t+ SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n\t\t\t+ SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n\t\t\t+ 4 // change count\n\t\t);\n\t\tfor (const change of this.changes) {\n\t\t\tnecessarySize += change.writeSize();\n\t\t}\n\n\t\tconst b = new Uint8Array(necessarySize);\n\t\tlet offset = 0;\n\t\tbuffer.writeUInt32BE(b, this.beforeVersionId, offset); offset += 4;\n\t\tbuffer.writeUInt32BE(b, this.afterVersionId, offset); offset += 4;\n\t\tbuffer.writeUInt8(b, this.beforeEOL, offset); offset += 1;\n\t\tbuffer.writeUInt8(b, this.afterEOL, offset); offset += 1;\n\t\toffset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n\t\toffset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n\t\tbuffer.writeUInt32BE(b, this.changes.length, offset); offset += 4;\n\t\tfor (const change of this.changes) {\n\t\t\toffset = change.write(b, offset);\n\t\t}\n\t\treturn b.buffer;\n\t}\n\n\tpublic static deserialize(source: ArrayBuffer): SingleModelEditStackData {\n\t\tconst b = new Uint8Array(source);\n\t\tlet offset = 0;\n\t\tconst beforeVersionId = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst afterVersionId = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst beforeEOL = buffer.readUInt8(b, offset); offset += 1;\n\t\tconst afterEOL = buffer.readUInt8(b, offset); offset += 1;\n\t\tconst beforeCursorState: Selection[] = [];\n\t\toffset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n\t\tconst afterCursorState: Selection[] = [];\n\t\toffset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n\t\tconst changeCount = buffer.readUInt32BE(b, offset); offset += 4;\n\t\tconst changes: TextChange[] = [];\n\t\tfor (let i = 0; i < changeCount; i++) {\n\t\t\toffset = TextChange.read(b, offset, changes);\n\t\t}\n\t\treturn new SingleModelEditStackData(\n\t\t\tbeforeVersionId,\n\t\t\tafterVersionId,\n\t\t\tbeforeEOL,\n\t\t\tafterEOL,\n\t\t\tbeforeCursorState,\n\t\t\tafterCursorState,\n\t\t\tchanges\n\t\t);\n\t}\n}\n\nexport interface IUndoRedoDelegate {\n\tprepareUndoRedo(element: MultiModelEditStackElement): Promise<IDisposable> | IDisposable | void;\n}\n\nexport class SingleModelEditStackElement implements IResourceUndoRedoElement {\n\n\tpublic model: ITextModel | URI;\n\tprivate _data: SingleModelEditStackData | ArrayBuffer;\n\n\tpublic get type(): UndoRedoElementType.Resource {\n\t\treturn UndoRedoElementType.Resource;\n\t}\n\n\tpublic get resource(): URI {\n\t\tif (URI.isUri(this.model)) {\n\t\t\treturn this.model;\n\t\t}\n\t\treturn this.model.uri;\n\t}\n\n\tconstructor(\n\t\tpublic readonly label: string,\n\t\tpublic readonly code: string,\n\t\tmodel: ITextModel,\n\t\tbeforeCursorState: Selection[] | null\n\t) {\n\t\tthis.model = model;\n\t\tthis._data = SingleModelEditStackData.create(model, beforeCursorState);\n\t}\n\n\tpublic toString(): string {\n\t\tconst data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n\t\treturn data.changes.map(change => change.toString()).join(', ');\n\t}\n\n\tpublic matchesResource(resource: URI): boolean {\n\t\tconst uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n\t\treturn (uri.toString() === resource.toString());\n\t}\n\n\tpublic setModel(model: ITextModel | URI): void {\n\t\tthis.model = model;\n\t}\n\n\tpublic canAppend(model: ITextModel): boolean {\n\t\treturn (this.model === model && this._data instanceof SingleModelEditStackData);\n\t}\n\n\tpublic append(model: ITextModel, textChanges: TextChange[], afterEOL: EndOfLineSequence, afterVersionId: number, afterCursorState: Selection[] | null): void {\n\t\tif (this._data instanceof SingleModelEditStackData) {\n\t\t\tthis._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n\t\t}\n\t}\n\n\tpublic close(): void {\n\t\tif (this._data instanceof SingleModelEditStackData) {\n\t\t\tthis._data = this._data.serialize();\n\t\t}\n\t}\n\n\tpublic open(): void {\n\t\tif (!(this._data instanceof SingleModelEditStackData)) {\n\t\t\tthis._data = SingleModelEditStackData.deserialize(this._data);\n\t\t}\n\t}\n\n\tpublic undo(): void {\n\t\tif (URI.isUri(this.model)) {\n\t\t\t// don't have a model\n\t\t\tthrow new Error(`Invalid SingleModelEditStackElement`);\n\t\t}\n\t\tif (this._data instanceof SingleModelEditStackData) {\n\t\t\tthis._data = this._data.serialize();\n\t\t}\n\t\tconst data = SingleModelEditStackData.deserialize(this._data);\n\t\tthis.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n\t}\n\n\tpublic redo(): void {\n\t\tif (URI.isUri(this.model)) {\n\t\t\t// don't have a model\n\t\t\tthrow new Error(`Invalid SingleModelEditStackElement`);\n\t\t}\n\t\tif (this._data instanceof SingleModelEditStackData) {\n\t\t\tthis._data = this._data.serialize();\n\t\t}\n\t\tconst data = SingleModelEditStackData.deserialize(this._data);\n\t\tthis.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n\t}\n\n\tpublic heapSize(): number {\n\t\tif (this._data instanceof SingleModelEditStackData) {\n\t\t\tthis._data = this._data.serialize();\n\t\t}\n\t\treturn this._data.byteLength + 168/*heap overhead*/;\n\t}\n}\n\nexport class MultiModelEditStackElement implements IWorkspaceUndoRedoElement {\n\n\tpublic readonly type = UndoRedoElementType.Workspace;\n\tprivate _isOpen: boolean;\n\n\tprivate readonly _editStackElementsArr: SingleModelEditStackElement[];\n\tprivate readonly _editStackElementsMap: Map<string, SingleModelEditStackElement>;\n\n\tprivate _delegate: IUndoRedoDelegate | null;\n\n\tpublic get resources(): readonly URI[] {\n\t\treturn this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n\t}\n\n\tconstructor(\n\t\tpublic readonly label: string,\n\t\tpublic readonly code: string,\n\t\teditStackElements: SingleModelEditStackElement[]\n\t) {\n\t\tthis._isOpen = true;\n\t\tthis._editStackElementsArr = editStackElements.slice(0);\n\t\tthis._editStackElementsMap = new Map<string, SingleModelEditStackElement>();\n\t\tfor (const editStackElement of this._editStackElementsArr) {\n\t\t\tconst key = uriGetComparisonKey(editStackElement.resource);\n\t\t\tthis._editStackElementsMap.set(key, editStackElement);\n\t\t}\n\t\tthis._delegate = null;\n\t}\n\n\tpublic prepareUndoRedo(): Promise<IDisposable> | IDisposable | void {\n\t\tif (this._delegate) {\n\t\t\treturn this._delegate.prepareUndoRedo(this);\n\t\t}\n\t}\n\n\tpublic matchesResource(resource: URI): boolean {\n\t\tconst key = uriGetComparisonKey(resource);\n\t\treturn (this._editStackElementsMap.has(key));\n\t}\n\n\tpublic setModel(model: ITextModel | URI): void {\n\t\tconst key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n\t\tif (this._editStackElementsMap.has(key)) {\n\t\t\tthis._editStackElementsMap.get(key)!.setModel(model);\n\t\t}\n\t}\n\n\tpublic canAppend(model: ITextModel): boolean {\n\t\tif (!this._isOpen) {\n\t\t\treturn false;\n\t\t}\n\t\tconst key = uriGetComparisonKey(model.uri);\n\t\tif (this._editStackElementsMap.has(key)) {\n\t\t\tconst editStackElement = this._editStackElementsMap.get(key)!;\n\t\t\treturn editStackElement.canAppend(model);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic append(model: ITextModel, textChanges: TextChange[], afterEOL: EndOfLineSequence, afterVersionId: number, afterCursorState: Selection[] | null): void {\n\t\tconst key = uriGetComparisonKey(model.uri);\n\t\tconst editStackElement = this._editStackElementsMap.get(key)!;\n\t\teditStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n\t}\n\n\tpublic close(): void {\n\t\tthis._isOpen = false;\n\t}\n\n\tpublic open(): void {\n\t\t// cannot reopen\n\t}\n\n\tpublic undo(): void {\n\t\tthis._isOpen = false;\n\n\t\tfor (const editStackElement of this._editStackElementsArr) {\n\t\t\teditStackElement.undo();\n\t\t}\n\t}\n\n\tpublic redo(): void {\n\t\tfor (const editStackElement of this._editStackElementsArr) {\n\t\t\teditStackElement.redo();\n\t\t}\n\t}\n\n\tpublic heapSize(resource: URI): number {\n\t\tconst key = uriGetComparisonKey(resource);\n\t\tif (this._editStackElementsMap.has(key)) {\n\t\t\tconst editStackElement = this._editStackElementsMap.get(key)!;\n\t\t\treturn editStackElement.heapSize();\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic split(): IResourceUndoRedoElement[] {\n\t\treturn this._editStackElementsArr;\n\t}\n\n\tpublic toString(): string {\n\t\tconst result: string[] = [];\n\t\tfor (const editStackElement of this._editStackElementsArr) {\n\t\t\tresult.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n\t\t}\n\t\treturn `{${result.join(', ')}}`;\n\t}\n}\n\nexport type EditStackElement = SingleModelEditStackElement | MultiModelEditStackElement;\n\nfunction getModelEOL(model: ITextModel): EndOfLineSequence {\n\tconst eol = model.getEOL();\n\tif (eol === '\\n') {\n\t\treturn EndOfLineSequence.LF;\n\t} else {\n\t\treturn EndOfLineSequence.CRLF;\n\t}\n}\n\nexport function isEditStackElement(element: IResourceUndoRedoElement | IWorkspaceUndoRedoElement | null): element is EditStackElement {\n\tif (!element) {\n\t\treturn false;\n\t}\n\treturn ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\n\nexport class EditStack {\n\n\tprivate readonly _model: TextModel;\n\tprivate readonly _undoRedoService: IUndoRedoService;\n\n\tconstructor(model: TextModel, undoRedoService: IUndoRedoService) {\n\t\tthis._model = model;\n\t\tthis._undoRedoService = undoRedoService;\n\t}\n\n\tpublic pushStackElement(): void {\n\t\tconst lastElement = this._undoRedoService.getLastElement(this._model.uri);\n\t\tif (isEditStackElement(lastElement)) {\n\t\t\tlastElement.close();\n\t\t}\n\t}\n\n\tpublic popStackElement(): void {\n\t\tconst lastElement = this._undoRedoService.getLastElement(this._model.uri);\n\t\tif (isEditStackElement(lastElement)) {\n\t\t\tlastElement.open();\n\t\t}\n\t}\n\n\tpublic clear(): void {\n\t\tthis._undoRedoService.removeElements(this._model.uri);\n\t}\n\n\tprivate _getOrCreateEditStackElement(beforeCursorState: Selection[] | null, group: UndoRedoGroup | undefined): EditStackElement {\n\t\tconst lastElement = this._undoRedoService.getLastElement(this._model.uri);\n\t\tif (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n\t\t\treturn lastElement;\n\t\t}\n\t\tconst newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n\t\tthis._undoRedoService.pushElement(newElement, group);\n\t\treturn newElement;\n\t}\n\n\tpublic pushEOL(eol: EndOfLineSequence): void {\n\t\tconst editStackElement = this._getOrCreateEditStackElement(null, undefined);\n\t\tthis._model.setEOL(eol);\n\t\teditStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n\t}\n\n\tpublic pushEditOperation(beforeCursorState: Selection[] | null, editOperations: ISingleEditOperation[], cursorStateComputer: ICursorStateComputer | null, group?: UndoRedoGroup, reason: TextModelEditSource = EditSources.unknown({ name: 'pushEditOperation' })): Selection[] | null {\n\t\tconst editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n\t\tconst inverseEditOperations = this._model.applyEdits(editOperations, true, reason);\n\t\tconst afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n\t\tconst textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n\t\ttextChanges.sort((a, b) => {\n\t\t\tif (a.textChange.oldPosition === b.textChange.oldPosition) {\n\t\t\t\treturn a.index - b.index;\n\t\t\t}\n\t\t\treturn a.textChange.oldPosition - b.textChange.oldPosition;\n\t\t});\n\t\teditStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n\t\treturn afterCursorState;\n\t}\n\n\tprivate static _computeCursorState(cursorStateComputer: ICursorStateComputer | null, inverseEditOperations: IValidEditOperation[]): Selection[] | null {\n\t\ttry {\n\t\t\treturn cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t\treturn null;\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3867, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/indentationGuesser.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/indentationGuesser.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { ITextBuffer } from '../model.js';\n\nclass SpacesDiffResult {\n\tpublic spacesDiff: number = 0;\n\tpublic looksLikeAlignment: boolean = false;\n}\n\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a: string, aLength: number, b: string, bLength: number, result: SpacesDiffResult): void {\n\n\tresult.spacesDiff = 0;\n\tresult.looksLikeAlignment = false;\n\n\t// This can go both ways (e.g.):\n\t//  - a: \"\\t\"\n\t//  - b: \"\\t    \"\n\t//  => This should count 1 tab and 4 spaces\n\n\tlet i: number;\n\n\tfor (i = 0; i < aLength && i < bLength; i++) {\n\t\tconst aCharCode = a.charCodeAt(i);\n\t\tconst bCharCode = b.charCodeAt(i);\n\n\t\tif (aCharCode !== bCharCode) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlet aSpacesCnt = 0, aTabsCount = 0;\n\tfor (let j = i; j < aLength; j++) {\n\t\tconst aCharCode = a.charCodeAt(j);\n\t\tif (aCharCode === CharCode.Space) {\n\t\t\taSpacesCnt++;\n\t\t} else {\n\t\t\taTabsCount++;\n\t\t}\n\t}\n\n\tlet bSpacesCnt = 0, bTabsCount = 0;\n\tfor (let j = i; j < bLength; j++) {\n\t\tconst bCharCode = b.charCodeAt(j);\n\t\tif (bCharCode === CharCode.Space) {\n\t\t\tbSpacesCnt++;\n\t\t} else {\n\t\t\tbTabsCount++;\n\t\t}\n\t}\n\n\tif (aSpacesCnt > 0 && aTabsCount > 0) {\n\t\treturn;\n\t}\n\tif (bSpacesCnt > 0 && bTabsCount > 0) {\n\t\treturn;\n\t}\n\n\tconst tabsDiff = Math.abs(aTabsCount - bTabsCount);\n\tconst spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n\n\tif (tabsDiff === 0) {\n\t\t// check if the indentation difference might be caused by alignment reasons\n\t\t// sometime folks like to align their code, but this should not be used as a hint\n\t\tresult.spacesDiff = spacesDiff;\n\n\t\tif (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n\t\t\tif (b.charCodeAt(bSpacesCnt) !== CharCode.Space && a.charCodeAt(bSpacesCnt - 1) === CharCode.Space) {\n\t\t\t\tif (a.charCodeAt(a.length - 1) === CharCode.Comma) {\n\t\t\t\t\t// This looks like an alignment desire: e.g.\n\t\t\t\t\t// const a = b + c,\n\t\t\t\t\t//       d = b - c;\n\t\t\t\t\tresult.looksLikeAlignment = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif (spacesDiff % tabsDiff === 0) {\n\t\tresult.spacesDiff = spacesDiff / tabsDiff;\n\t\treturn;\n\t}\n}\n\n/**\n * Result for a guessIndentation\n */\nexport interface IGuessedIndentation {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces: boolean;\n}\n\nexport function guessIndentation(source: ITextBuffer, defaultTabSize: number, defaultInsertSpaces: boolean): IGuessedIndentation {\n\t// Look at most at the first 10k lines\n\tconst linesCount = Math.min(source.getLineCount(), 10000);\n\n\tlet linesIndentedWithTabsCount = 0;\t\t\t\t// number of lines that contain at least one tab in indentation\n\tlet linesIndentedWithSpacesCount = 0;\t\t\t// number of lines that contain only spaces in indentation\n\n\tlet previousLineText = '';\t\t\t\t\t\t// content of latest line that contained non-whitespace chars\n\tlet previousLineIndentation = 0;\t\t\t\t// index at which latest line contained the first non-whitespace char\n\n\tconst ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];\t// prefer even guesses for `tabSize`, limit to [2, 8].\n\tconst MAX_ALLOWED_TAB_SIZE_GUESS = 8;\t\t\t// max(ALLOWED_TAB_SIZE_GUESSES) = 8\n\n\tconst spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];\t\t// `tabSize` scores\n\tconst tmp = new SpacesDiffResult();\n\n\tfor (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n\t\tconst currentLineLength = source.getLineLength(lineNumber);\n\t\tconst currentLineText = source.getLineContent(lineNumber);\n\n\t\t// if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n\t\t// checking charCode on chunks directly is cheaper.\n\t\tconst useCurrentLineText = (currentLineLength <= 65536);\n\n\t\tlet currentLineHasContent = false;\t\t\t// does `currentLineText` contain non-whitespace chars\n\t\tlet currentLineIndentation = 0;\t\t\t\t// index at which `currentLineText` contains the first non-whitespace char\n\t\tlet currentLineSpacesCount = 0;\t\t\t\t// count of spaces found in `currentLineText` indentation\n\t\tlet currentLineTabsCount = 0;\t\t\t\t// count of tabs found in `currentLineText` indentation\n\t\tfor (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n\t\t\tconst charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n\n\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\tcurrentLineTabsCount++;\n\t\t\t} else if (charCode === CharCode.Space) {\n\t\t\t\tcurrentLineSpacesCount++;\n\t\t\t} else {\n\t\t\t\t// Hit non whitespace character on this line\n\t\t\t\tcurrentLineHasContent = true;\n\t\t\t\tcurrentLineIndentation = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Ignore empty or only whitespace lines\n\t\tif (!currentLineHasContent) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (currentLineTabsCount > 0) {\n\t\t\tlinesIndentedWithTabsCount++;\n\t\t} else if (currentLineSpacesCount > 1) {\n\t\t\tlinesIndentedWithSpacesCount++;\n\t\t}\n\n\t\tspacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n\n\t\tif (tmp.looksLikeAlignment) {\n\t\t\t// if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n\t\t\t//\n\t\t\t// - item1\n\t\t\t//   - item2\n\t\t\t//\n\t\t\t// otherwise skip this line entirely\n\t\t\t//\n\t\t\t// const a = 1,\n\t\t\t//       b = 2;\n\n\t\t\tif (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tconst currentSpacesDiff = tmp.spacesDiff;\n\t\tif (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n\t\t\tspacesDiffCount[currentSpacesDiff]++;\n\t\t}\n\n\t\tpreviousLineText = currentLineText;\n\t\tpreviousLineIndentation = currentLineIndentation;\n\t}\n\n\tlet insertSpaces = defaultInsertSpaces;\n\tif (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n\t\tinsertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n\t}\n\n\tlet tabSize = defaultTabSize;\n\n\t// Guess tabSize only if inserting spaces...\n\tif (insertSpaces) {\n\t\tlet tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n\n\t\t// console.log(\"score threshold: \" + tabSizeScore);\n\n\t\tALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n\t\t\tconst possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n\t\t\tif (possibleTabSizeScore > tabSizeScore) {\n\t\t\t\ttabSizeScore = possibleTabSizeScore;\n\t\t\t\ttabSize = possibleTabSize;\n\t\t\t}\n\t\t});\n\n\t\t// Let a tabSize of 2 win even if it is not the maximum\n\t\t// (only in case 4 was guessed)\n\t\tif (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n\t\t\ttabSize = 2;\n\t\t}\n\t}\n\n\n\t// console.log('--------------------------');\n\t// console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n\t// console.log('spacesDiffCount: ' + spacesDiffCount);\n\t// console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n\n\treturn {\n\t\tinsertSpaces: insertSpaces,\n\t\ttabSize: tabSize\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { ITextBuffer } from '../model.js';\n\nclass SpacesDiffResult {\n\tpublic spacesDiff: number = 0;\n\tpublic looksLikeAlignment: boolean = false;\n}\n\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a: string, aLength: number, b: string, bLength: number, result: SpacesDiffResult): void {\n\n\tresult.spacesDiff = 0;\n\tresult.looksLikeAlignment = false;\n\n\t// This can go both ways (e.g.):\n\t//  - a: \"\\t\"\n\t//  - b: \"\\t    \"\n\t//  => This should count 1 tab and 4 spaces\n\n\tlet i: number;\n\n\tfor (i = 0; i < aLength && i < bLength; i++) {\n\t\tconst aCharCode = a.charCodeAt(i);\n\t\tconst bCharCode = b.charCodeAt(i);\n\n\t\tif (aCharCode !== bCharCode) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlet aSpacesCnt = 0, aTabsCount = 0;\n\tfor (let j = i; j < aLength; j++) {\n\t\tconst aCharCode = a.charCodeAt(j);\n\t\tif (aCharCode === CharCode.Space) {\n\t\t\taSpacesCnt++;\n\t\t} else {\n\t\t\taTabsCount++;\n\t\t}\n\t}\n\n\tlet bSpacesCnt = 0, bTabsCount = 0;\n\tfor (let j = i; j < bLength; j++) {\n\t\tconst bCharCode = b.charCodeAt(j);\n\t\tif (bCharCode === CharCode.Space) {\n\t\t\tbSpacesCnt++;\n\t\t} else {\n\t\t\tbTabsCount++;\n\t\t}\n\t}\n\n\tif (aSpacesCnt > 0 && aTabsCount > 0) {\n\t\treturn;\n\t}\n\tif (bSpacesCnt > 0 && bTabsCount > 0) {\n\t\treturn;\n\t}\n\n\tconst tabsDiff = Math.abs(aTabsCount - bTabsCount);\n\tconst spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n\n\tif (tabsDiff === 0) {\n\t\t// check if the indentation difference might be caused by alignment reasons\n\t\t// sometime folks like to align their code, but this should not be used as a hint\n\t\tresult.spacesDiff = spacesDiff;\n\n\t\tif (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n\t\t\tif (b.charCodeAt(bSpacesCnt) !== CharCode.Space && a.charCodeAt(bSpacesCnt - 1) === CharCode.Space) {\n\t\t\t\tif (a.charCodeAt(a.length - 1) === CharCode.Comma) {\n\t\t\t\t\t// This looks like an alignment desire: e.g.\n\t\t\t\t\t// const a = b + c,\n\t\t\t\t\t//       d = b - c;\n\t\t\t\t\tresult.looksLikeAlignment = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif (spacesDiff % tabsDiff === 0) {\n\t\tresult.spacesDiff = spacesDiff / tabsDiff;\n\t\treturn;\n\t}\n}\n\n/**\n * Result for a guessIndentation\n */\nexport interface IGuessedIndentation {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces: boolean;\n}\n\nexport function guessIndentation(source: ITextBuffer, defaultTabSize: number, defaultInsertSpaces: boolean): IGuessedIndentation {\n\t// Look at most at the first 10k lines\n\tconst linesCount = Math.min(source.getLineCount(), 10000);\n\n\tlet linesIndentedWithTabsCount = 0;\t\t\t\t// number of lines that contain at least one tab in indentation\n\tlet linesIndentedWithSpacesCount = 0;\t\t\t// number of lines that contain only spaces in indentation\n\n\tlet previousLineText = '';\t\t\t\t\t\t// content of latest line that contained non-whitespace chars\n\tlet previousLineIndentation = 0;\t\t\t\t// index at which latest line contained the first non-whitespace char\n\n\tconst ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];\t// prefer even guesses for `tabSize`, limit to [2, 8].\n\tconst MAX_ALLOWED_TAB_SIZE_GUESS = 8;\t\t\t// max(ALLOWED_TAB_SIZE_GUESSES) = 8\n\n\tconst spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];\t\t// `tabSize` scores\n\tconst tmp = new SpacesDiffResult();\n\n\tfor (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n\t\tconst currentLineLength = source.getLineLength(lineNumber);\n\t\tconst currentLineText = source.getLineContent(lineNumber);\n\n\t\t// if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n\t\t// checking charCode on chunks directly is cheaper.\n\t\tconst useCurrentLineText = (currentLineLength <= 65536);\n\n\t\tlet currentLineHasContent = false;\t\t\t// does `currentLineText` contain non-whitespace chars\n\t\tlet currentLineIndentation = 0;\t\t\t\t// index at which `currentLineText` contains the first non-whitespace char\n\t\tlet currentLineSpacesCount = 0;\t\t\t\t// count of spaces found in `currentLineText` indentation\n\t\tlet currentLineTabsCount = 0;\t\t\t\t// count of tabs found in `currentLineText` indentation\n\t\tfor (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n\t\t\tconst charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n\n\t\t\tif (charCode === CharCode.Tab) {\n\t\t\t\tcurrentLineTabsCount++;\n\t\t\t} else if (charCode === CharCode.Space) {\n\t\t\t\tcurrentLineSpacesCount++;\n\t\t\t} else {\n\t\t\t\t// Hit non whitespace character on this line\n\t\t\t\tcurrentLineHasContent = true;\n\t\t\t\tcurrentLineIndentation = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Ignore empty or only whitespace lines\n\t\tif (!currentLineHasContent) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (currentLineTabsCount > 0) {\n\t\t\tlinesIndentedWithTabsCount++;\n\t\t} else if (currentLineSpacesCount > 1) {\n\t\t\tlinesIndentedWithSpacesCount++;\n\t\t}\n\n\t\tspacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n\n\t\tif (tmp.looksLikeAlignment) {\n\t\t\t// if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n\t\t\t//\n\t\t\t// - item1\n\t\t\t//   - item2\n\t\t\t//\n\t\t\t// otherwise skip this line entirely\n\t\t\t//\n\t\t\t// const a = 1,\n\t\t\t//       b = 2;\n\n\t\t\tif (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tconst currentSpacesDiff = tmp.spacesDiff;\n\t\tif (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n\t\t\tspacesDiffCount[currentSpacesDiff]++;\n\t\t}\n\n\t\tpreviousLineText = currentLineText;\n\t\tpreviousLineIndentation = currentLineIndentation;\n\t}\n\n\tlet insertSpaces = defaultInsertSpaces;\n\tif (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n\t\tinsertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n\t}\n\n\tlet tabSize = defaultTabSize;\n\n\t// Guess tabSize only if inserting spaces...\n\tif (insertSpaces) {\n\t\tlet tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n\n\t\t// console.log(\"score threshold: \" + tabSizeScore);\n\n\t\tALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n\t\t\tconst possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n\t\t\tif (possibleTabSizeScore > tabSizeScore) {\n\t\t\t\ttabSizeScore = possibleTabSizeScore;\n\t\t\t\ttabSize = possibleTabSize;\n\t\t\t}\n\t\t});\n\n\t\t// Let a tabSize of 2 win even if it is not the maximum\n\t\t// (only in case 4 was guessed)\n\t\tif (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n\t\t\ttabSize = 2;\n\t\t}\n\t}\n\n\n\t// console.log('--------------------------');\n\t// console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n\t// console.log('spacesDiffCount: ' + spacesDiffCount);\n\t// console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n\n\treturn {\n\t\tinsertSpaces: insertSpaces,\n\t\ttabSize: tabSize\n\t};\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4062, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/intervalTree.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/intervalTree.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../core/range.js';\nimport { TrackedRangeStickiness } from '../model.js';\nimport { ModelDecorationOptions } from './textModel.js';\n\n//\n// The red-black tree is based on the \"Introduction to Algorithms\" by Cormen, Leiserson and Rivest.\n//\n\nexport const enum ClassName {\n\tEditorHintDecoration = 'squiggly-hint',\n\tEditorInfoDecoration = 'squiggly-info',\n\tEditorWarningDecoration = 'squiggly-warning',\n\tEditorErrorDecoration = 'squiggly-error',\n\tEditorUnnecessaryDecoration = 'squiggly-unnecessary',\n\tEditorUnnecessaryInlineDecoration = 'squiggly-inline-unnecessary',\n\tEditorDeprecatedInlineDecoration = 'squiggly-inline-deprecated'\n}\n\nexport const enum NodeColor {\n\tBlack = 0,\n\tRed = 1,\n}\n\nconst enum Constants {\n\tColorMask = 0b00000001,\n\tColorMaskInverse = 0b11111110,\n\tColorOffset = 0,\n\n\tIsVisitedMask = 0b00000010,\n\tIsVisitedMaskInverse = 0b11111101,\n\tIsVisitedOffset = 1,\n\n\tIsForValidationMask = 0b00000100,\n\tIsForValidationMaskInverse = 0b11111011,\n\tIsForValidationOffset = 2,\n\n\tStickinessMask = 0b00011000,\n\tStickinessMaskInverse = 0b11100111,\n\tStickinessOffset = 3,\n\n\tCollapseOnReplaceEditMask = 0b00100000,\n\tCollapseOnReplaceEditMaskInverse = 0b11011111,\n\tCollapseOnReplaceEditOffset = 5,\n\n\tIsMarginMask = 0b01000000,\n\tIsMarginMaskInverse = 0b10111111,\n\tIsMarginOffset = 6,\n\n\tAffectsFontMask = 0b10000000,\n\tAffectsFontMaskInverse = 0b01111111,\n\tAffectsFontOffset = 7,\n\n\t/**\n\t * Due to how deletion works (in order to avoid always walking the right subtree of the deleted node),\n\t * the deltas for nodes can grow and shrink dramatically. It has been observed, in practice, that unless\n\t * the deltas are corrected, integer overflow will occur.\n\t *\n\t * The integer overflow occurs when 53 bits are used in the numbers, but we will try to avoid it as\n\t * a node's delta gets below a negative 30 bits number.\n\t *\n\t * MIN SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMIN_SAFE_DELTA = -(1 << 30),\n\t/**\n\t * MAX SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMAX_SAFE_DELTA = 1 << 30,\n}\n\nexport function getNodeColor(node: IntervalNode): NodeColor {\n\treturn ((node.metadata & Constants.ColorMask) >>> Constants.ColorOffset);\n}\nfunction setNodeColor(node: IntervalNode, color: NodeColor): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.ColorMaskInverse) | (color << Constants.ColorOffset)\n\t);\n}\nfunction getNodeIsVisited(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsVisitedMask) >>> Constants.IsVisitedOffset) === 1;\n}\nfunction setNodeIsVisited(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsVisitedMaskInverse) | ((value ? 1 : 0) << Constants.IsVisitedOffset)\n\t);\n}\nfunction getNodeIsForValidation(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsForValidationMask) >>> Constants.IsForValidationOffset) === 1;\n}\nfunction setNodeIsForValidation(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsForValidationMaskInverse) | ((value ? 1 : 0) << Constants.IsForValidationOffset)\n\t);\n}\nfunction getNodeIsInGlyphMargin(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsMarginMask) >>> Constants.IsMarginOffset) === 1;\n}\nfunction setNodeIsInGlyphMargin(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsMarginMaskInverse) | ((value ? 1 : 0) << Constants.IsMarginOffset)\n\t);\n}\nfunction getNodeAffectsFont(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.AffectsFontMask) >>> Constants.AffectsFontOffset) === 1;\n}\nfunction setNodeAffectsFont(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.AffectsFontMaskInverse) | ((value ? 1 : 0) << Constants.AffectsFontOffset)\n\t);\n}\nfunction getNodeStickiness(node: IntervalNode): TrackedRangeStickiness {\n\treturn ((node.metadata & Constants.StickinessMask) >>> Constants.StickinessOffset);\n}\nfunction _setNodeStickiness(node: IntervalNode, stickiness: TrackedRangeStickiness): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.StickinessMaskInverse) | (stickiness << Constants.StickinessOffset)\n\t);\n}\nfunction getCollapseOnReplaceEdit(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.CollapseOnReplaceEditMask) >>> Constants.CollapseOnReplaceEditOffset) === 1;\n}\nfunction setCollapseOnReplaceEdit(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.CollapseOnReplaceEditMaskInverse) | ((value ? 1 : 0) << Constants.CollapseOnReplaceEditOffset)\n\t);\n}\n\nexport class IntervalNode {\n\n\t/**\n\t * contains binary encoded information for color, visited, isForValidation and stickiness.\n\t */\n\tpublic metadata: number;\n\n\tpublic parent: IntervalNode;\n\tpublic left: IntervalNode;\n\tpublic right: IntervalNode;\n\n\tpublic start: number;\n\tpublic end: number;\n\tpublic delta: number;\n\tpublic maxEnd: number;\n\n\tpublic id: string;\n\tpublic ownerId: number;\n\tpublic options: ModelDecorationOptions;\n\n\tpublic cachedVersionId: number;\n\tpublic cachedAbsoluteStart: number;\n\tpublic cachedAbsoluteEnd: number;\n\tpublic range: Range | null;\n\n\tconstructor(id: string, start: number, end: number) {\n\t\tthis.metadata = 0;\n\n\t\tthis.parent = this;\n\t\tthis.left = this;\n\t\tthis.right = this;\n\t\tsetNodeColor(this, NodeColor.Red);\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\t// FORCE_OVERFLOWING_TEST: this.delta = start;\n\t\tthis.delta = 0;\n\t\tthis.maxEnd = end;\n\n\t\tthis.id = id;\n\t\tthis.ownerId = 0;\n\t\tthis.options = null!;\n\t\tsetNodeIsForValidation(this, false);\n\t\tsetNodeIsInGlyphMargin(this, false);\n\t\t_setNodeStickiness(this, TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);\n\t\tsetCollapseOnReplaceEdit(this, false);\n\t\tsetNodeAffectsFont(this, false);\n\n\t\tthis.cachedVersionId = 0;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = null;\n\n\t\tsetNodeIsVisited(this, false);\n\t}\n\n\tpublic reset(versionId: number, start: number, end: number, range: Range): void {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.maxEnd = end;\n\t\tthis.cachedVersionId = versionId;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = range;\n\t}\n\n\tpublic setOptions(options: ModelDecorationOptions) {\n\t\tthis.options = options;\n\t\tconst className = this.options.className;\n\t\tsetNodeIsForValidation(this, (\n\t\t\tclassName === ClassName.EditorErrorDecoration\n\t\t\t|| className === ClassName.EditorWarningDecoration\n\t\t\t|| className === ClassName.EditorInfoDecoration\n\t\t));\n\t\tsetNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n\t\t_setNodeStickiness(this, <number>this.options.stickiness);\n\t\tsetCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n\t\tsetNodeAffectsFont(this, this.options.affectsFont ?? false);\n\t}\n\n\tpublic setCachedOffsets(absoluteStart: number, absoluteEnd: number, cachedVersionId: number): void {\n\t\tif (this.cachedVersionId !== cachedVersionId) {\n\t\t\tthis.range = null;\n\t\t}\n\t\tthis.cachedVersionId = cachedVersionId;\n\t\tthis.cachedAbsoluteStart = absoluteStart;\n\t\tthis.cachedAbsoluteEnd = absoluteEnd;\n\t}\n\n\tpublic detach(): void {\n\t\tthis.parent = null!;\n\t\tthis.left = null!;\n\t\tthis.right = null!;\n\t}\n}\n\nexport const SENTINEL: IntervalNode = new IntervalNode(null!, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, NodeColor.Black);\n\nexport class IntervalTree {\n\n\tpublic root: IntervalNode;\n\tpublic requestNormalizeDelta: boolean;\n\n\tconstructor() {\n\t\tthis.root = SENTINEL;\n\t\tthis.requestNormalizeDelta = false;\n\t}\n\n\tpublic intervalSearch(start: number, end: number, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn intervalSearch(this, start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t}\n\n\tpublic search(filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn search(this, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesFromOwner(ownerId: number): IntervalNode[] {\n\t\treturn collectNodesFromOwner(this, ownerId);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesPostOrder(): IntervalNode[] {\n\t\treturn collectNodesPostOrder(this);\n\t}\n\n\tpublic insert(node: IntervalNode): void {\n\t\trbTreeInsert(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic delete(node: IntervalNode): void {\n\t\trbTreeDelete(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic resolveNode(node: IntervalNode, cachedVersionId: number): void {\n\t\tconst initialNode = node;\n\t\tlet delta = 0;\n\t\twhile (node !== this.root) {\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta += node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tconst nodeStart = initialNode.start + delta;\n\t\tconst nodeEnd = initialNode.end + delta;\n\t\tinitialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\t}\n\n\tpublic acceptReplace(offset: number, length: number, textLength: number, forceMoveMarkers: boolean): void {\n\t\t// Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n\n\t\t// (1) collect all nodes that are intersecting this edit as nodes of interest\n\t\tconst nodesOfInterest = searchForEditing(this, offset, offset + length);\n\n\t\t// (2) remove all nodes that are intersecting this edit\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\trbTreeDelete(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (3) edit all tree nodes except the nodes of interest\n\t\tnoOverlapReplace(this, offset, offset + length, textLength);\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (4) edit the nodes of interest and insert them back in the tree\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\tnode.start = node.cachedAbsoluteStart;\n\t\t\tnode.end = node.cachedAbsoluteEnd;\n\t\t\tnodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n\t\t\tnode.maxEnd = node.end;\n\t\t\trbTreeInsert(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tprivate _normalizeDeltaIfNecessary(): void {\n\t\tif (!this.requestNormalizeDelta) {\n\t\t\treturn;\n\t\t}\n\t\tthis.requestNormalizeDelta = false;\n\t\tnormalizeDelta(this);\n\t}\n}\n\n//#region Delta Normalization\nfunction normalizeDelta(T: IntervalTree): void {\n\tlet node = T.root;\n\tlet delta = 0;\n\twhile (node !== SENTINEL) {\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnode.start = delta + node.start;\n\t\tnode.end = delta + node.end;\n\t\tnode.delta = 0;\n\t\trecomputeMaxEnd(node);\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\t// going up from this node\n\t\tsetNodeIsVisited(node.left, false);\n\t\tsetNodeIsVisited(node.right, false);\n\t\tif (node === node.parent.right) {\n\t\t\tdelta -= node.parent.delta;\n\t\t}\n\t\tnode = node.parent;\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n//#endregion\n\n//#region Editing\n\nconst enum MarkerMoveSemantics {\n\tMarkerDefined = 0,\n\tForceMove = 1,\n\tForceStay = 2\n}\n\nfunction adjustMarkerBeforeColumn(markerOffset: number, markerStickToPreviousCharacter: boolean, checkOffset: number, moveSemantics: MarkerMoveSemantics): boolean {\n\tif (markerOffset < checkOffset) {\n\t\treturn true;\n\t}\n\tif (markerOffset > checkOffset) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceMove) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceStay) {\n\t\treturn true;\n\t}\n\treturn markerStickToPreviousCharacter;\n}\n\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node: IntervalNode, start: number, end: number, textLength: number, forceMoveMarkers: boolean): void {\n\tconst nodeStickiness = getNodeStickiness(node);\n\tconst startStickToPreviousCharacter = (\n\t\tnodeStickiness === TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t\t|| nodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore\n\t);\n\tconst endStickToPreviousCharacter = (\n\t\tnodeStickiness === TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n\t\t|| nodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore\n\t);\n\n\tconst deletingCnt = (end - start);\n\tconst insertingCnt = textLength;\n\tconst commonLength = Math.min(deletingCnt, insertingCnt);\n\n\tconst nodeStart = node.start;\n\tlet startDone = false;\n\n\tconst nodeEnd = node.end;\n\tlet endDone = false;\n\n\tif (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n\t\t// This edit encompasses the entire decoration range\n\t\t// and the decoration has asked to become collapsed\n\t\tnode.start = start;\n\t\tstartDone = true;\n\t\tnode.end = start;\n\t\tendDone = true;\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > 0 ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\tif (commonLength > 0 && !forceMoveMarkers) {\n\t\tconst moveSemantics = (deletingCnt > insertingCnt ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : MarkerMoveSemantics.MarkerDefined;\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n\t\t\tnode.start = start + insertingCnt;\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n\t\t\tnode.end = start + insertingCnt;\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t// Finish\n\tconst deltaColumn = (insertingCnt - deletingCnt);\n\tif (!startDone) {\n\t\tnode.start = Math.max(0, nodeStart + deltaColumn);\n\t}\n\tif (!endDone) {\n\t\tnode.end = Math.max(0, nodeEnd + deltaColumn);\n\t}\n\n\tif (node.start > node.end) {\n\t\tnode.end = node.start;\n\t}\n}\n\nfunction searchForEditing(T: IntervalTree, start: number, end: number): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\t\tif (nodeEnd >= start) {\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, 0);\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction noOverlapReplace(T: IntervalTree, start: number, end: number, textLength: number): void {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tconst editDelta = (textLength - (end - start));\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\trecomputeMaxEnd(node);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\tnode.start += editDelta;\n\t\t\tnode.end += editDelta;\n\t\t\tnode.delta += editDelta;\n\t\t\tif (node.delta < Constants.MIN_SAFE_DELTA || node.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\t\tT.requestNormalizeDelta = true;\n\t\t\t}\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n\n//#endregion\n\n//#region Searching\n\nfunction collectNodesFromOwner(T: IntervalTree, ownerId: number): IntervalNode[] {\n\tlet node = T.root;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tif (node.ownerId === ownerId) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction collectNodesPostOrder(T: IntervalTree): IntervalNode[] {\n\tlet node = T.root;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tresult[resultLen++] = node;\n\t\tsetNodeIsVisited(node, true);\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction search(T: IntervalTree, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tnodeEnd = delta + node.end;\n\n\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\tlet include = true;\n\t\tif (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (filterFontDecorations && getNodeAffectsFont(node)) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n\t\t\tinclude = false;\n\t\t}\n\n\t\tif (include) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < intervalStart) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > intervalEnd) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\n\t\tif (nodeEnd >= intervalStart) {\n\t\t\t// There is overlap\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\t\tlet include = true;\n\t\t\tif (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (filterFontDecorations && getNodeAffectsFont(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\n\t\t\tif (include) {\n\t\t\t\tresult[resultLen++] = node;\n\t\t\t}\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\n//#endregion\n\n//#region Insertion\nfunction rbTreeInsert(T: IntervalTree, newNode: IntervalNode): IntervalNode {\n\tif (T.root === SENTINEL) {\n\t\tnewNode.parent = SENTINEL;\n\t\tnewNode.left = SENTINEL;\n\t\tnewNode.right = SENTINEL;\n\t\tsetNodeColor(newNode, NodeColor.Black);\n\t\tT.root = newNode;\n\t\treturn T.root;\n\t}\n\n\ttreeInsert(T, newNode);\n\n\trecomputeMaxEndWalkToRoot(newNode.parent);\n\n\t// repair tree\n\tlet x = newNode;\n\twhile (x !== T.root && getNodeColor(x.parent) === NodeColor.Red) {\n\t\tif (x.parent === x.parent.parent.left) {\n\t\t\tconst y = x.parent.parent.right;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.right) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\tleftRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent.parent);\n\t\t\t}\n\t\t} else {\n\t\t\tconst y = x.parent.parent.left;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.left) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\trightRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent.parent);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(T.root, NodeColor.Black);\n\n\treturn newNode;\n}\n\nfunction treeInsert(T: IntervalTree, z: IntervalNode): void {\n\tlet delta: number = 0;\n\tlet x = T.root;\n\tconst zAbsoluteStart = z.start;\n\tconst zAbsoluteEnd = z.end;\n\twhile (true) {\n\t\tconst cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n\t\tif (cmp < 0) {\n\t\t\t// this node should be inserted to the left\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.left === SENTINEL) {\n\t\t\t\tz.start -= delta;\n\t\t\t\tz.end -= delta;\n\t\t\t\tz.maxEnd -= delta;\n\t\t\t\tx.left = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tx = x.left;\n\t\t\t}\n\t\t} else {\n\t\t\t// this node should be inserted to the right\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.right === SENTINEL) {\n\t\t\t\tz.start -= (delta + x.delta);\n\t\t\t\tz.end -= (delta + x.delta);\n\t\t\t\tz.maxEnd -= (delta + x.delta);\n\t\t\t\tx.right = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdelta += x.delta;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\t}\n\n\tz.parent = x;\n\tz.left = SENTINEL;\n\tz.right = SENTINEL;\n\tsetNodeColor(z, NodeColor.Red);\n}\n//#endregion\n\n//#region Deletion\nfunction rbTreeDelete(T: IntervalTree, z: IntervalNode): void {\n\n\tlet x: IntervalNode;\n\tlet y: IntervalNode;\n\n\t// RB-DELETE except we don't swap z and y in case c)\n\t// i.e. we always delete what's pointed at by z.\n\n\tif (z.left === SENTINEL) {\n\t\tx = z.right;\n\t\ty = z;\n\n\t\t// x's delta is no longer influenced by z's delta\n\t\tx.delta += z.delta;\n\t\tif (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t\tx.start += z.delta;\n\t\tx.end += z.delta;\n\n\t} else if (z.right === SENTINEL) {\n\t\tx = z.left;\n\t\ty = z;\n\n\t} else {\n\t\ty = leftest(z.right);\n\t\tx = y.right;\n\n\t\t// y's delta is no longer influenced by z's delta,\n\t\t// but we don't want to walk the entire right-hand-side subtree of x.\n\t\t// we therefore maintain z's delta in y, and adjust only x\n\t\tx.start += y.delta;\n\t\tx.end += y.delta;\n\t\tx.delta += y.delta;\n\t\tif (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\n\t\ty.start += z.delta;\n\t\ty.end += z.delta;\n\t\ty.delta = z.delta;\n\t\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t}\n\n\tif (y === T.root) {\n\t\tT.root = x;\n\t\tsetNodeColor(x, NodeColor.Black);\n\n\t\tz.detach();\n\t\tresetSentinel();\n\t\trecomputeMaxEnd(x);\n\t\tT.root.parent = SENTINEL;\n\t\treturn;\n\t}\n\n\tconst yWasRed = (getNodeColor(y) === NodeColor.Red);\n\n\tif (y === y.parent.left) {\n\t\ty.parent.left = x;\n\t} else {\n\t\ty.parent.right = x;\n\t}\n\n\tif (y === z) {\n\t\tx.parent = y.parent;\n\t} else {\n\n\t\tif (y.parent === z) {\n\t\t\tx.parent = y;\n\t\t} else {\n\t\t\tx.parent = y.parent;\n\t\t}\n\n\t\ty.left = z.left;\n\t\ty.right = z.right;\n\t\ty.parent = z.parent;\n\t\tsetNodeColor(y, getNodeColor(z));\n\n\t\tif (z === T.root) {\n\t\t\tT.root = y;\n\t\t} else {\n\t\t\tif (z === z.parent.left) {\n\t\t\t\tz.parent.left = y;\n\t\t\t} else {\n\t\t\t\tz.parent.right = y;\n\t\t\t}\n\t\t}\n\n\t\tif (y.left !== SENTINEL) {\n\t\t\ty.left.parent = y;\n\t\t}\n\t\tif (y.right !== SENTINEL) {\n\t\t\ty.right.parent = y;\n\t\t}\n\t}\n\n\tz.detach();\n\n\tif (yWasRed) {\n\t\trecomputeMaxEndWalkToRoot(x.parent);\n\t\tif (y !== z) {\n\t\t\trecomputeMaxEndWalkToRoot(y);\n\t\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t\t}\n\t\tresetSentinel();\n\t\treturn;\n\t}\n\n\trecomputeMaxEndWalkToRoot(x);\n\trecomputeMaxEndWalkToRoot(x.parent);\n\tif (y !== z) {\n\t\trecomputeMaxEndWalkToRoot(y);\n\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t}\n\n\t// RB-DELETE-FIXUP\n\tlet w: IntervalNode;\n\twhile (x !== T.root && getNodeColor(x) === NodeColor.Black) {\n\n\t\tif (x === x.parent.left) {\n\t\t\tw = x.parent.right;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tw = x.parent.right;\n\t\t\t}\n\n\t\t\tif (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\trightRotate(T, w);\n\t\t\t\t\tw = x.parent.right;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\n\t\t} else {\n\t\t\tw = x.parent.left;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tw = x.parent.left;\n\t\t\t}\n\n\t\t\tif (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.left) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\tleftRotate(T, w);\n\t\t\t\t\tw = x.parent.left;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(x, NodeColor.Black);\n\tresetSentinel();\n}\n\nfunction leftest(node: IntervalNode): IntervalNode {\n\twhile (node.left !== SENTINEL) {\n\t\tnode = node.left;\n\t}\n\treturn node;\n}\n\nfunction resetSentinel(): void {\n\tSENTINEL.parent = SENTINEL;\n\tSENTINEL.delta = 0; // optional\n\tSENTINEL.start = 0; // optional\n\tSENTINEL.end = 0; // optional\n}\n//#endregion\n\n//#region Rotations\nfunction leftRotate(T: IntervalTree, x: IntervalNode): void {\n\tconst y = x.right;\t\t\t\t// set y.\n\n\ty.delta += x.delta;\t\t\t\t// y's delta is no longer influenced by x's delta\n\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start += x.delta;\n\ty.end += x.delta;\n\n\tx.right = y.left;\t\t\t\t// turn y's left subtree into x's right subtree.\n\tif (y.left !== SENTINEL) {\n\t\ty.left.parent = x;\n\t}\n\ty.parent = x.parent;\t\t\t// link x's parent to y.\n\tif (x.parent === SENTINEL) {\n\t\tT.root = y;\n\t} else if (x === x.parent.left) {\n\t\tx.parent.left = y;\n\t} else {\n\t\tx.parent.right = y;\n\t}\n\n\ty.left = x;\t\t\t\t\t\t// put x on y's left.\n\tx.parent = y;\n\n\trecomputeMaxEnd(x);\n\trecomputeMaxEnd(y);\n}\n\nfunction rightRotate(T: IntervalTree, y: IntervalNode): void {\n\tconst x = y.left;\n\n\ty.delta -= x.delta;\n\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start -= x.delta;\n\ty.end -= x.delta;\n\n\ty.left = x.right;\n\tif (x.right !== SENTINEL) {\n\t\tx.right.parent = y;\n\t}\n\tx.parent = y.parent;\n\tif (y.parent === SENTINEL) {\n\t\tT.root = x;\n\t} else if (y === y.parent.right) {\n\t\ty.parent.right = x;\n\t} else {\n\t\ty.parent.left = x;\n\t}\n\n\tx.right = y;\n\ty.parent = x;\n\n\trecomputeMaxEnd(y);\n\trecomputeMaxEnd(x);\n}\n//#endregion\n\n//#region max end computation\n\nfunction computeMaxEnd(node: IntervalNode): number {\n\tlet maxEnd = node.end;\n\tif (node.left !== SENTINEL) {\n\t\tconst leftMaxEnd = node.left.maxEnd;\n\t\tif (leftMaxEnd > maxEnd) {\n\t\t\tmaxEnd = leftMaxEnd;\n\t\t}\n\t}\n\tif (node.right !== SENTINEL) {\n\t\tconst rightMaxEnd = node.right.maxEnd + node.delta;\n\t\tif (rightMaxEnd > maxEnd) {\n\t\t\tmaxEnd = rightMaxEnd;\n\t\t}\n\t}\n\treturn maxEnd;\n}\n\nexport function recomputeMaxEnd(node: IntervalNode): void {\n\tnode.maxEnd = computeMaxEnd(node);\n}\n\nfunction recomputeMaxEndWalkToRoot(node: IntervalNode): void {\n\twhile (node !== SENTINEL) {\n\n\t\tconst maxEnd = computeMaxEnd(node);\n\n\t\tif (node.maxEnd === maxEnd) {\n\t\t\t// no need to go further\n\t\t\treturn;\n\t\t}\n\n\t\tnode.maxEnd = maxEnd;\n\t\tnode = node.parent;\n\t}\n}\n\n//#endregion\n\n//#region utils\nexport function intervalCompare(aStart: number, aEnd: number, bStart: number, bEnd: number): number {\n\tif (aStart === bStart) {\n\t\treturn aEnd - bEnd;\n\t}\n\treturn aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../core/range.js';\nimport { TrackedRangeStickiness } from '../model.js';\nimport { ModelDecorationOptions } from './textModel.js';\n\n//\n// The red-black tree is based on the \"Introduction to Algorithms\" by Cormen, Leiserson and Rivest.\n//\n\nexport const enum ClassName {\n\tEditorHintDecoration = 'squiggly-hint',\n\tEditorInfoDecoration = 'squiggly-info',\n\tEditorWarningDecoration = 'squiggly-warning',\n\tEditorErrorDecoration = 'squiggly-error',\n\tEditorUnnecessaryDecoration = 'squiggly-unnecessary',\n\tEditorUnnecessaryInlineDecoration = 'squiggly-inline-unnecessary',\n\tEditorDeprecatedInlineDecoration = 'squiggly-inline-deprecated'\n}\n\nexport const enum NodeColor {\n\tBlack = 0,\n\tRed = 1,\n}\n\nconst enum Constants {\n\tColorMask = 0b00000001,\n\tColorMaskInverse = 0b11111110,\n\tColorOffset = 0,\n\n\tIsVisitedMask = 0b00000010,\n\tIsVisitedMaskInverse = 0b11111101,\n\tIsVisitedOffset = 1,\n\n\tIsForValidationMask = 0b00000100,\n\tIsForValidationMaskInverse = 0b11111011,\n\tIsForValidationOffset = 2,\n\n\tStickinessMask = 0b00011000,\n\tStickinessMaskInverse = 0b11100111,\n\tStickinessOffset = 3,\n\n\tCollapseOnReplaceEditMask = 0b00100000,\n\tCollapseOnReplaceEditMaskInverse = 0b11011111,\n\tCollapseOnReplaceEditOffset = 5,\n\n\tIsMarginMask = 0b01000000,\n\tIsMarginMaskInverse = 0b10111111,\n\tIsMarginOffset = 6,\n\n\tAffectsFontMask = 0b10000000,\n\tAffectsFontMaskInverse = 0b01111111,\n\tAffectsFontOffset = 7,\n\n\t/**\n\t * Due to how deletion works (in order to avoid always walking the right subtree of the deleted node),\n\t * the deltas for nodes can grow and shrink dramatically. It has been observed, in practice, that unless\n\t * the deltas are corrected, integer overflow will occur.\n\t *\n\t * The integer overflow occurs when 53 bits are used in the numbers, but we will try to avoid it as\n\t * a node's delta gets below a negative 30 bits number.\n\t *\n\t * MIN SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMIN_SAFE_DELTA = -(1 << 30),\n\t/**\n\t * MAX SMI (SMall Integer) as defined in v8.\n\t * one bit is lost for boxing/unboxing flag.\n\t * one bit is lost for sign flag.\n\t * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values\n\t */\n\tMAX_SAFE_DELTA = 1 << 30,\n}\n\nexport function getNodeColor(node: IntervalNode): NodeColor {\n\treturn ((node.metadata & Constants.ColorMask) >>> Constants.ColorOffset);\n}\nfunction setNodeColor(node: IntervalNode, color: NodeColor): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.ColorMaskInverse) | (color << Constants.ColorOffset)\n\t);\n}\nfunction getNodeIsVisited(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsVisitedMask) >>> Constants.IsVisitedOffset) === 1;\n}\nfunction setNodeIsVisited(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsVisitedMaskInverse) | ((value ? 1 : 0) << Constants.IsVisitedOffset)\n\t);\n}\nfunction getNodeIsForValidation(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsForValidationMask) >>> Constants.IsForValidationOffset) === 1;\n}\nfunction setNodeIsForValidation(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsForValidationMaskInverse) | ((value ? 1 : 0) << Constants.IsForValidationOffset)\n\t);\n}\nfunction getNodeIsInGlyphMargin(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.IsMarginMask) >>> Constants.IsMarginOffset) === 1;\n}\nfunction setNodeIsInGlyphMargin(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.IsMarginMaskInverse) | ((value ? 1 : 0) << Constants.IsMarginOffset)\n\t);\n}\nfunction getNodeAffectsFont(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.AffectsFontMask) >>> Constants.AffectsFontOffset) === 1;\n}\nfunction setNodeAffectsFont(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.AffectsFontMaskInverse) | ((value ? 1 : 0) << Constants.AffectsFontOffset)\n\t);\n}\nfunction getNodeStickiness(node: IntervalNode): TrackedRangeStickiness {\n\treturn ((node.metadata & Constants.StickinessMask) >>> Constants.StickinessOffset);\n}\nfunction _setNodeStickiness(node: IntervalNode, stickiness: TrackedRangeStickiness): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.StickinessMaskInverse) | (stickiness << Constants.StickinessOffset)\n\t);\n}\nfunction getCollapseOnReplaceEdit(node: IntervalNode): boolean {\n\treturn ((node.metadata & Constants.CollapseOnReplaceEditMask) >>> Constants.CollapseOnReplaceEditOffset) === 1;\n}\nfunction setCollapseOnReplaceEdit(node: IntervalNode, value: boolean): void {\n\tnode.metadata = (\n\t\t(node.metadata & Constants.CollapseOnReplaceEditMaskInverse) | ((value ? 1 : 0) << Constants.CollapseOnReplaceEditOffset)\n\t);\n}\n\nexport class IntervalNode {\n\n\t/**\n\t * contains binary encoded information for color, visited, isForValidation and stickiness.\n\t */\n\tpublic metadata: number;\n\n\tpublic parent: IntervalNode;\n\tpublic left: IntervalNode;\n\tpublic right: IntervalNode;\n\n\tpublic start: number;\n\tpublic end: number;\n\tpublic delta: number;\n\tpublic maxEnd: number;\n\n\tpublic id: string;\n\tpublic ownerId: number;\n\tpublic options: ModelDecorationOptions;\n\n\tpublic cachedVersionId: number;\n\tpublic cachedAbsoluteStart: number;\n\tpublic cachedAbsoluteEnd: number;\n\tpublic range: Range | null;\n\n\tconstructor(id: string, start: number, end: number) {\n\t\tthis.metadata = 0;\n\n\t\tthis.parent = this;\n\t\tthis.left = this;\n\t\tthis.right = this;\n\t\tsetNodeColor(this, NodeColor.Red);\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\t// FORCE_OVERFLOWING_TEST: this.delta = start;\n\t\tthis.delta = 0;\n\t\tthis.maxEnd = end;\n\n\t\tthis.id = id;\n\t\tthis.ownerId = 0;\n\t\tthis.options = null!;\n\t\tsetNodeIsForValidation(this, false);\n\t\tsetNodeIsInGlyphMargin(this, false);\n\t\t_setNodeStickiness(this, TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges);\n\t\tsetCollapseOnReplaceEdit(this, false);\n\t\tsetNodeAffectsFont(this, false);\n\n\t\tthis.cachedVersionId = 0;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = null;\n\n\t\tsetNodeIsVisited(this, false);\n\t}\n\n\tpublic reset(versionId: number, start: number, end: number, range: Range): void {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.maxEnd = end;\n\t\tthis.cachedVersionId = versionId;\n\t\tthis.cachedAbsoluteStart = start;\n\t\tthis.cachedAbsoluteEnd = end;\n\t\tthis.range = range;\n\t}\n\n\tpublic setOptions(options: ModelDecorationOptions) {\n\t\tthis.options = options;\n\t\tconst className = this.options.className;\n\t\tsetNodeIsForValidation(this, (\n\t\t\tclassName === ClassName.EditorErrorDecoration\n\t\t\t|| className === ClassName.EditorWarningDecoration\n\t\t\t|| className === ClassName.EditorInfoDecoration\n\t\t));\n\t\tsetNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n\t\t_setNodeStickiness(this, <number>this.options.stickiness);\n\t\tsetCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n\t\tsetNodeAffectsFont(this, this.options.affectsFont ?? false);\n\t}\n\n\tpublic setCachedOffsets(absoluteStart: number, absoluteEnd: number, cachedVersionId: number): void {\n\t\tif (this.cachedVersionId !== cachedVersionId) {\n\t\t\tthis.range = null;\n\t\t}\n\t\tthis.cachedVersionId = cachedVersionId;\n\t\tthis.cachedAbsoluteStart = absoluteStart;\n\t\tthis.cachedAbsoluteEnd = absoluteEnd;\n\t}\n\n\tpublic detach(): void {\n\t\tthis.parent = null!;\n\t\tthis.left = null!;\n\t\tthis.right = null!;\n\t}\n}\n\nexport const SENTINEL: IntervalNode = new IntervalNode(null!, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, NodeColor.Black);\n\nexport class IntervalTree {\n\n\tpublic root: IntervalNode;\n\tpublic requestNormalizeDelta: boolean;\n\n\tconstructor() {\n\t\tthis.root = SENTINEL;\n\t\tthis.requestNormalizeDelta = false;\n\t}\n\n\tpublic intervalSearch(start: number, end: number, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn intervalSearch(this, start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t}\n\n\tpublic search(filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tif (this.root === SENTINEL) {\n\t\t\treturn [];\n\t\t}\n\t\treturn search(this, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesFromOwner(ownerId: number): IntervalNode[] {\n\t\treturn collectNodesFromOwner(this, ownerId);\n\t}\n\n\t/**\n\t * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n\t */\n\tpublic collectNodesPostOrder(): IntervalNode[] {\n\t\treturn collectNodesPostOrder(this);\n\t}\n\n\tpublic insert(node: IntervalNode): void {\n\t\trbTreeInsert(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic delete(node: IntervalNode): void {\n\t\trbTreeDelete(this, node);\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tpublic resolveNode(node: IntervalNode, cachedVersionId: number): void {\n\t\tconst initialNode = node;\n\t\tlet delta = 0;\n\t\twhile (node !== this.root) {\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta += node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tconst nodeStart = initialNode.start + delta;\n\t\tconst nodeEnd = initialNode.end + delta;\n\t\tinitialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\t}\n\n\tpublic acceptReplace(offset: number, length: number, textLength: number, forceMoveMarkers: boolean): void {\n\t\t// Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n\n\t\t// (1) collect all nodes that are intersecting this edit as nodes of interest\n\t\tconst nodesOfInterest = searchForEditing(this, offset, offset + length);\n\n\t\t// (2) remove all nodes that are intersecting this edit\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\trbTreeDelete(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (3) edit all tree nodes except the nodes of interest\n\t\tnoOverlapReplace(this, offset, offset + length, textLength);\n\t\tthis._normalizeDeltaIfNecessary();\n\n\t\t// (4) edit the nodes of interest and insert them back in the tree\n\t\tfor (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n\t\t\tconst node = nodesOfInterest[i];\n\t\t\tnode.start = node.cachedAbsoluteStart;\n\t\t\tnode.end = node.cachedAbsoluteEnd;\n\t\t\tnodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n\t\t\tnode.maxEnd = node.end;\n\t\t\trbTreeInsert(this, node);\n\t\t}\n\t\tthis._normalizeDeltaIfNecessary();\n\t}\n\n\tprivate _normalizeDeltaIfNecessary(): void {\n\t\tif (!this.requestNormalizeDelta) {\n\t\t\treturn;\n\t\t}\n\t\tthis.requestNormalizeDelta = false;\n\t\tnormalizeDelta(this);\n\t}\n}\n\n//#region Delta Normalization\nfunction normalizeDelta(T: IntervalTree): void {\n\tlet node = T.root;\n\tlet delta = 0;\n\twhile (node !== SENTINEL) {\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnode.start = delta + node.start;\n\t\tnode.end = delta + node.end;\n\t\tnode.delta = 0;\n\t\trecomputeMaxEnd(node);\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\t// going up from this node\n\t\tsetNodeIsVisited(node.left, false);\n\t\tsetNodeIsVisited(node.right, false);\n\t\tif (node === node.parent.right) {\n\t\t\tdelta -= node.parent.delta;\n\t\t}\n\t\tnode = node.parent;\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n//#endregion\n\n//#region Editing\n\nconst enum MarkerMoveSemantics {\n\tMarkerDefined = 0,\n\tForceMove = 1,\n\tForceStay = 2\n}\n\nfunction adjustMarkerBeforeColumn(markerOffset: number, markerStickToPreviousCharacter: boolean, checkOffset: number, moveSemantics: MarkerMoveSemantics): boolean {\n\tif (markerOffset < checkOffset) {\n\t\treturn true;\n\t}\n\tif (markerOffset > checkOffset) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceMove) {\n\t\treturn false;\n\t}\n\tif (moveSemantics === MarkerMoveSemantics.ForceStay) {\n\t\treturn true;\n\t}\n\treturn markerStickToPreviousCharacter;\n}\n\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node: IntervalNode, start: number, end: number, textLength: number, forceMoveMarkers: boolean): void {\n\tconst nodeStickiness = getNodeStickiness(node);\n\tconst startStickToPreviousCharacter = (\n\t\tnodeStickiness === TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t\t|| nodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore\n\t);\n\tconst endStickToPreviousCharacter = (\n\t\tnodeStickiness === TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges\n\t\t|| nodeStickiness === TrackedRangeStickiness.GrowsOnlyWhenTypingBefore\n\t);\n\n\tconst deletingCnt = (end - start);\n\tconst insertingCnt = textLength;\n\tconst commonLength = Math.min(deletingCnt, insertingCnt);\n\n\tconst nodeStart = node.start;\n\tlet startDone = false;\n\n\tconst nodeEnd = node.end;\n\tlet endDone = false;\n\n\tif (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n\t\t// This edit encompasses the entire decoration range\n\t\t// and the decoration has asked to become collapsed\n\t\tnode.start = start;\n\t\tstartDone = true;\n\t\tnode.end = start;\n\t\tendDone = true;\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > 0 ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\tif (commonLength > 0 && !forceMoveMarkers) {\n\t\tconst moveSemantics = (deletingCnt > insertingCnt ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined);\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t{\n\t\tconst moveSemantics = forceMoveMarkers ? MarkerMoveSemantics.ForceMove : MarkerMoveSemantics.MarkerDefined;\n\t\tif (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n\t\t\tnode.start = start + insertingCnt;\n\t\t\tstartDone = true;\n\t\t}\n\t\tif (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n\t\t\tnode.end = start + insertingCnt;\n\t\t\tendDone = true;\n\t\t}\n\t}\n\n\t// Finish\n\tconst deltaColumn = (insertingCnt - deletingCnt);\n\tif (!startDone) {\n\t\tnode.start = Math.max(0, nodeStart + deltaColumn);\n\t}\n\tif (!endDone) {\n\t\tnode.end = Math.max(0, nodeEnd + deltaColumn);\n\t}\n\n\tif (node.start > node.end) {\n\t\tnode.end = node.start;\n\t}\n}\n\nfunction searchForEditing(T: IntervalTree, start: number, end: number): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\t\tif (nodeEnd >= start) {\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, 0);\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction noOverlapReplace(T: IntervalTree, start: number, end: number, textLength: number): void {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tconst editDelta = (textLength - (end - start));\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\trecomputeMaxEnd(node);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < start) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > end) {\n\t\t\tnode.start += editDelta;\n\t\t\tnode.end += editDelta;\n\t\t\tnode.delta += editDelta;\n\t\t\tif (node.delta < Constants.MIN_SAFE_DELTA || node.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\t\tT.requestNormalizeDelta = true;\n\t\t\t}\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n}\n\n//#endregion\n\n//#region Searching\n\nfunction collectNodesFromOwner(T: IntervalTree, ownerId: number): IntervalNode[] {\n\tlet node = T.root;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tif (node.ownerId === ownerId) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction collectNodesPostOrder(T: IntervalTree): IntervalNode[] {\n\tlet node = T.root;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tresult[resultLen++] = node;\n\t\tsetNodeIsVisited(node, true);\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction search(T: IntervalTree, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n\t\t\t// go left\n\t\t\tnode = node.left;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tnodeEnd = delta + node.end;\n\n\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\tlet include = true;\n\t\tif (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (filterFontDecorations && getNodeAffectsFont(node)) {\n\t\t\tinclude = false;\n\t\t}\n\t\tif (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n\t\t\tinclude = false;\n\t\t}\n\n\t\tif (include) {\n\t\t\tresult[resultLen++] = node;\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\nfunction intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t// https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n\t// Now, it is known that two intervals A and B overlap only when both\n\t// A.low <= B.high and A.high >= B.low. When searching the trees for\n\t// nodes overlapping with a given interval, you can immediately skip:\n\t//  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n\t//  b) all nodes that have their maximum 'high' value below the start of the given interval.\n\n\tlet node = T.root;\n\tlet delta = 0;\n\tlet nodeMaxEnd = 0;\n\tlet nodeStart = 0;\n\tlet nodeEnd = 0;\n\tconst result: IntervalNode[] = [];\n\tlet resultLen = 0;\n\twhile (node !== SENTINEL) {\n\t\tif (getNodeIsVisited(node)) {\n\t\t\t// going up from this node\n\t\t\tsetNodeIsVisited(node.left, false);\n\t\t\tsetNodeIsVisited(node.right, false);\n\t\t\tif (node === node.parent.right) {\n\t\t\t\tdelta -= node.parent.delta;\n\t\t\t}\n\t\t\tnode = node.parent;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!getNodeIsVisited(node.left)) {\n\t\t\t// first time seeing this node\n\t\t\tnodeMaxEnd = delta + node.maxEnd;\n\t\t\tif (nodeMaxEnd < intervalStart) {\n\t\t\t\t// cover case b) from above\n\t\t\t\t// there is no need to search this node or its children\n\t\t\t\tsetNodeIsVisited(node, true);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (node.left !== SENTINEL) {\n\t\t\t\t// go left\n\t\t\t\tnode = node.left;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// handle current node\n\t\tnodeStart = delta + node.start;\n\t\tif (nodeStart > intervalEnd) {\n\t\t\t// cover case a) from above\n\t\t\t// there is no need to search this node or its right subtree\n\t\t\tsetNodeIsVisited(node, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnodeEnd = delta + node.end;\n\n\t\tif (nodeEnd >= intervalStart) {\n\t\t\t// There is overlap\n\t\t\tnode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n\n\t\t\tlet include = true;\n\t\t\tif (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (filterOutValidation && getNodeIsForValidation(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (filterFontDecorations && getNodeAffectsFont(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\t\t\tif (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n\t\t\t\tinclude = false;\n\t\t\t}\n\n\t\t\tif (include) {\n\t\t\t\tresult[resultLen++] = node;\n\t\t\t}\n\t\t}\n\n\t\tsetNodeIsVisited(node, true);\n\n\t\tif (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n\t\t\t// go right\n\t\t\tdelta += node.delta;\n\t\t\tnode = node.right;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tsetNodeIsVisited(T.root, false);\n\n\treturn result;\n}\n\n//#endregion\n\n//#region Insertion\nfunction rbTreeInsert(T: IntervalTree, newNode: IntervalNode): IntervalNode {\n\tif (T.root === SENTINEL) {\n\t\tnewNode.parent = SENTINEL;\n\t\tnewNode.left = SENTINEL;\n\t\tnewNode.right = SENTINEL;\n\t\tsetNodeColor(newNode, NodeColor.Black);\n\t\tT.root = newNode;\n\t\treturn T.root;\n\t}\n\n\ttreeInsert(T, newNode);\n\n\trecomputeMaxEndWalkToRoot(newNode.parent);\n\n\t// repair tree\n\tlet x = newNode;\n\twhile (x !== T.root && getNodeColor(x.parent) === NodeColor.Red) {\n\t\tif (x.parent === x.parent.parent.left) {\n\t\t\tconst y = x.parent.parent.right;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.right) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\tleftRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent.parent);\n\t\t\t}\n\t\t} else {\n\t\t\tconst y = x.parent.parent.left;\n\n\t\t\tif (getNodeColor(y) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(y, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.left) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\trightRotate(T, x);\n\t\t\t\t}\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent.parent);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(T.root, NodeColor.Black);\n\n\treturn newNode;\n}\n\nfunction treeInsert(T: IntervalTree, z: IntervalNode): void {\n\tlet delta: number = 0;\n\tlet x = T.root;\n\tconst zAbsoluteStart = z.start;\n\tconst zAbsoluteEnd = z.end;\n\twhile (true) {\n\t\tconst cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n\t\tif (cmp < 0) {\n\t\t\t// this node should be inserted to the left\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.left === SENTINEL) {\n\t\t\t\tz.start -= delta;\n\t\t\t\tz.end -= delta;\n\t\t\t\tz.maxEnd -= delta;\n\t\t\t\tx.left = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tx = x.left;\n\t\t\t}\n\t\t} else {\n\t\t\t// this node should be inserted to the right\n\t\t\t// => it is not affected by the node's delta\n\t\t\tif (x.right === SENTINEL) {\n\t\t\t\tz.start -= (delta + x.delta);\n\t\t\t\tz.end -= (delta + x.delta);\n\t\t\t\tz.maxEnd -= (delta + x.delta);\n\t\t\t\tx.right = z;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdelta += x.delta;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\t}\n\n\tz.parent = x;\n\tz.left = SENTINEL;\n\tz.right = SENTINEL;\n\tsetNodeColor(z, NodeColor.Red);\n}\n//#endregion\n\n//#region Deletion\nfunction rbTreeDelete(T: IntervalTree, z: IntervalNode): void {\n\n\tlet x: IntervalNode;\n\tlet y: IntervalNode;\n\n\t// RB-DELETE except we don't swap z and y in case c)\n\t// i.e. we always delete what's pointed at by z.\n\n\tif (z.left === SENTINEL) {\n\t\tx = z.right;\n\t\ty = z;\n\n\t\t// x's delta is no longer influenced by z's delta\n\t\tx.delta += z.delta;\n\t\tif (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t\tx.start += z.delta;\n\t\tx.end += z.delta;\n\n\t} else if (z.right === SENTINEL) {\n\t\tx = z.left;\n\t\ty = z;\n\n\t} else {\n\t\ty = leftest(z.right);\n\t\tx = y.right;\n\n\t\t// y's delta is no longer influenced by z's delta,\n\t\t// but we don't want to walk the entire right-hand-side subtree of x.\n\t\t// we therefore maintain z's delta in y, and adjust only x\n\t\tx.start += y.delta;\n\t\tx.end += y.delta;\n\t\tx.delta += y.delta;\n\t\tif (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\n\t\ty.start += z.delta;\n\t\ty.end += z.delta;\n\t\ty.delta = z.delta;\n\t\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\t\tT.requestNormalizeDelta = true;\n\t\t}\n\t}\n\n\tif (y === T.root) {\n\t\tT.root = x;\n\t\tsetNodeColor(x, NodeColor.Black);\n\n\t\tz.detach();\n\t\tresetSentinel();\n\t\trecomputeMaxEnd(x);\n\t\tT.root.parent = SENTINEL;\n\t\treturn;\n\t}\n\n\tconst yWasRed = (getNodeColor(y) === NodeColor.Red);\n\n\tif (y === y.parent.left) {\n\t\ty.parent.left = x;\n\t} else {\n\t\ty.parent.right = x;\n\t}\n\n\tif (y === z) {\n\t\tx.parent = y.parent;\n\t} else {\n\n\t\tif (y.parent === z) {\n\t\t\tx.parent = y;\n\t\t} else {\n\t\t\tx.parent = y.parent;\n\t\t}\n\n\t\ty.left = z.left;\n\t\ty.right = z.right;\n\t\ty.parent = z.parent;\n\t\tsetNodeColor(y, getNodeColor(z));\n\n\t\tif (z === T.root) {\n\t\t\tT.root = y;\n\t\t} else {\n\t\t\tif (z === z.parent.left) {\n\t\t\t\tz.parent.left = y;\n\t\t\t} else {\n\t\t\t\tz.parent.right = y;\n\t\t\t}\n\t\t}\n\n\t\tif (y.left !== SENTINEL) {\n\t\t\ty.left.parent = y;\n\t\t}\n\t\tif (y.right !== SENTINEL) {\n\t\t\ty.right.parent = y;\n\t\t}\n\t}\n\n\tz.detach();\n\n\tif (yWasRed) {\n\t\trecomputeMaxEndWalkToRoot(x.parent);\n\t\tif (y !== z) {\n\t\t\trecomputeMaxEndWalkToRoot(y);\n\t\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t\t}\n\t\tresetSentinel();\n\t\treturn;\n\t}\n\n\trecomputeMaxEndWalkToRoot(x);\n\trecomputeMaxEndWalkToRoot(x.parent);\n\tif (y !== z) {\n\t\trecomputeMaxEndWalkToRoot(y);\n\t\trecomputeMaxEndWalkToRoot(y.parent);\n\t}\n\n\t// RB-DELETE-FIXUP\n\tlet w: IntervalNode;\n\twhile (x !== T.root && getNodeColor(x) === NodeColor.Black) {\n\n\t\tif (x === x.parent.left) {\n\t\t\tw = x.parent.right;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tw = x.parent.right;\n\t\t\t}\n\n\t\t\tif (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\trightRotate(T, w);\n\t\t\t\t\tw = x.parent.right;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\tleftRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\n\t\t} else {\n\t\t\tw = x.parent.left;\n\n\t\t\tif (getNodeColor(w) === NodeColor.Red) {\n\t\t\t\tsetNodeColor(w, NodeColor.Black);\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Red);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tw = x.parent.left;\n\t\t\t}\n\n\t\t\tif (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {\n\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\tx = x.parent;\n\n\t\t\t} else {\n\t\t\t\tif (getNodeColor(w.left) === NodeColor.Black) {\n\t\t\t\t\tsetNodeColor(w.right, NodeColor.Black);\n\t\t\t\t\tsetNodeColor(w, NodeColor.Red);\n\t\t\t\t\tleftRotate(T, w);\n\t\t\t\t\tw = x.parent.left;\n\t\t\t\t}\n\n\t\t\t\tsetNodeColor(w, getNodeColor(x.parent));\n\t\t\t\tsetNodeColor(x.parent, NodeColor.Black);\n\t\t\t\tsetNodeColor(w.left, NodeColor.Black);\n\t\t\t\trightRotate(T, x.parent);\n\t\t\t\tx = T.root;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNodeColor(x, NodeColor.Black);\n\tresetSentinel();\n}\n\nfunction leftest(node: IntervalNode): IntervalNode {\n\twhile (node.left !== SENTINEL) {\n\t\tnode = node.left;\n\t}\n\treturn node;\n}\n\nfunction resetSentinel(): void {\n\tSENTINEL.parent = SENTINEL;\n\tSENTINEL.delta = 0; // optional\n\tSENTINEL.start = 0; // optional\n\tSENTINEL.end = 0; // optional\n}\n//#endregion\n\n//#region Rotations\nfunction leftRotate(T: IntervalTree, x: IntervalNode): void {\n\tconst y = x.right;\t\t\t\t// set y.\n\n\ty.delta += x.delta;\t\t\t\t// y's delta is no longer influenced by x's delta\n\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start += x.delta;\n\ty.end += x.delta;\n\n\tx.right = y.left;\t\t\t\t// turn y's left subtree into x's right subtree.\n\tif (y.left !== SENTINEL) {\n\t\ty.left.parent = x;\n\t}\n\ty.parent = x.parent;\t\t\t// link x's parent to y.\n\tif (x.parent === SENTINEL) {\n\t\tT.root = y;\n\t} else if (x === x.parent.left) {\n\t\tx.parent.left = y;\n\t} else {\n\t\tx.parent.right = y;\n\t}\n\n\ty.left = x;\t\t\t\t\t\t// put x on y's left.\n\tx.parent = y;\n\n\trecomputeMaxEnd(x);\n\trecomputeMaxEnd(y);\n}\n\nfunction rightRotate(T: IntervalTree, y: IntervalNode): void {\n\tconst x = y.left;\n\n\ty.delta -= x.delta;\n\tif (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {\n\t\tT.requestNormalizeDelta = true;\n\t}\n\ty.start -= x.delta;\n\ty.end -= x.delta;\n\n\ty.left = x.right;\n\tif (x.right !== SENTINEL) {\n\t\tx.right.parent = y;\n\t}\n\tx.parent = y.parent;\n\tif (y.parent === SENTINEL) {\n\t\tT.root = x;\n\t} else if (y === y.parent.right) {\n\t\ty.parent.right = x;\n\t} else {\n\t\ty.parent.left = x;\n\t}\n\n\tx.right = y;\n\ty.parent = x;\n\n\trecomputeMaxEnd(y);\n\trecomputeMaxEnd(x);\n}\n//#endregion\n\n//#region max end computation\n\nfunction computeMaxEnd(node: IntervalNode): number {\n\tlet maxEnd = node.end;\n\tif (node.left !== SENTINEL) {\n\t\tconst leftMaxEnd = node.left.maxEnd;\n\t\tif (leftMaxEnd > maxEnd) {\n\t\t\tmaxEnd = leftMaxEnd;\n\t\t}\n\t}\n\tif (node.right !== SENTINEL) {\n\t\tconst rightMaxEnd = node.right.maxEnd + node.delta;\n\t\tif (rightMaxEnd > maxEnd) {\n\t\t\tmaxEnd = rightMaxEnd;\n\t\t}\n\t}\n\treturn maxEnd;\n}\n\nexport function recomputeMaxEnd(node: IntervalNode): void {\n\tnode.maxEnd = computeMaxEnd(node);\n}\n\nfunction recomputeMaxEndWalkToRoot(node: IntervalNode): void {\n\twhile (node !== SENTINEL) {\n\n\t\tconst maxEnd = computeMaxEnd(node);\n\n\t\tif (node.maxEnd === maxEnd) {\n\t\t\t// no need to go further\n\t\t\treturn;\n\t\t}\n\n\t\tnode.maxEnd = maxEnd;\n\t\tnode = node.parent;\n\t}\n}\n\n//#endregion\n\n//#region utils\nexport function intervalCompare(aStart: number, aEnd: number, bStart: number, bEnd: number): number {\n\tif (aStart === bStart) {\n\t\treturn aEnd - bEnd;\n\t}\n\treturn aStart - bStart;\n}\n//#endregion\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5050, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Piece, PieceTreeBase } from './pieceTreeBase.js';\n\nexport class TreeNode {\n\tparent: TreeNode;\n\tleft: TreeNode;\n\tright: TreeNode;\n\tcolor: NodeColor;\n\n\t// Piece\n\tpiece: Piece;\n\tsize_left: number; // size of the left subtree (not inorder)\n\tlf_left: number; // line feeds cnt in the left subtree (not in order)\n\n\tconstructor(piece: Piece, color: NodeColor) {\n\t\tthis.piece = piece;\n\t\tthis.color = color;\n\t\tthis.size_left = 0;\n\t\tthis.lf_left = 0;\n\t\tthis.parent = this;\n\t\tthis.left = this;\n\t\tthis.right = this;\n\t}\n\n\tpublic next(): TreeNode {\n\t\tif (this.right !== SENTINEL) {\n\t\t\treturn leftest(this.right);\n\t\t}\n\n\t\tlet node: TreeNode = this;\n\n\t\twhile (node.parent !== SENTINEL) {\n\t\t\tif (node.parent.left === node) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tif (node.parent === SENTINEL) {\n\t\t\treturn SENTINEL;\n\t\t} else {\n\t\t\treturn node.parent;\n\t\t}\n\t}\n\n\tpublic prev(): TreeNode {\n\t\tif (this.left !== SENTINEL) {\n\t\t\treturn righttest(this.left);\n\t\t}\n\n\t\tlet node: TreeNode = this;\n\n\t\twhile (node.parent !== SENTINEL) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tif (node.parent === SENTINEL) {\n\t\t\treturn SENTINEL;\n\t\t} else {\n\t\t\treturn node.parent;\n\t\t}\n\t}\n\n\tpublic detach(): void {\n\t\tthis.parent = null!;\n\t\tthis.left = null!;\n\t\tthis.right = null!;\n\t}\n}\n\nexport const enum NodeColor {\n\tBlack = 0,\n\tRed = 1,\n}\n\nexport const SENTINEL: TreeNode = new TreeNode(null!, NodeColor.Black);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = NodeColor.Black;\n\nexport function leftest(node: TreeNode): TreeNode {\n\twhile (node.left !== SENTINEL) {\n\t\tnode = node.left;\n\t}\n\treturn node;\n}\n\nexport function righttest(node: TreeNode): TreeNode {\n\twhile (node.right !== SENTINEL) {\n\t\tnode = node.right;\n\t}\n\treturn node;\n}\n\nfunction calculateSize(node: TreeNode): number {\n\tif (node === SENTINEL) {\n\t\treturn 0;\n\t}\n\n\treturn node.size_left + node.piece.length + calculateSize(node.right);\n}\n\nfunction calculateLF(node: TreeNode): number {\n\tif (node === SENTINEL) {\n\t\treturn 0;\n\t}\n\n\treturn node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\n\nfunction resetSentinel(): void {\n\tSENTINEL.parent = SENTINEL;\n}\n\nexport function leftRotate(tree: PieceTreeBase, x: TreeNode) {\n\tconst y = x.right;\n\n\t// fix size_left\n\ty.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n\ty.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\tx.right = y.left;\n\n\tif (y.left !== SENTINEL) {\n\t\ty.left.parent = x;\n\t}\n\ty.parent = x.parent;\n\tif (x.parent === SENTINEL) {\n\t\ttree.root = y;\n\t} else if (x.parent.left === x) {\n\t\tx.parent.left = y;\n\t} else {\n\t\tx.parent.right = y;\n\t}\n\ty.left = x;\n\tx.parent = y;\n}\n\nexport function rightRotate(tree: PieceTreeBase, y: TreeNode) {\n\tconst x = y.left;\n\ty.left = x.right;\n\tif (x.right !== SENTINEL) {\n\t\tx.right.parent = y;\n\t}\n\tx.parent = y.parent;\n\n\t// fix size_left\n\ty.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n\ty.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\n\tif (y.parent === SENTINEL) {\n\t\ttree.root = x;\n\t} else if (y === y.parent.right) {\n\t\ty.parent.right = x;\n\t} else {\n\t\ty.parent.left = x;\n\t}\n\n\tx.right = y;\n\ty.parent = x;\n}\n\nexport function rbDelete(tree: PieceTreeBase, z: TreeNode) {\n\tlet x: TreeNode;\n\tlet y: TreeNode;\n\n\tif (z.left === SENTINEL) {\n\t\ty = z;\n\t\tx = y.right;\n\t} else if (z.right === SENTINEL) {\n\t\ty = z;\n\t\tx = y.left;\n\t} else {\n\t\ty = leftest(z.right);\n\t\tx = y.right;\n\t}\n\n\tif (y === tree.root) {\n\t\ttree.root = x;\n\n\t\t// if x is null, we are removing the only node\n\t\tx.color = NodeColor.Black;\n\t\tz.detach();\n\t\tresetSentinel();\n\t\ttree.root.parent = SENTINEL;\n\n\t\treturn;\n\t}\n\n\tconst yWasRed = (y.color === NodeColor.Red);\n\n\tif (y === y.parent.left) {\n\t\ty.parent.left = x;\n\t} else {\n\t\ty.parent.right = x;\n\t}\n\n\tif (y === z) {\n\t\tx.parent = y.parent;\n\t\trecomputeTreeMetadata(tree, x);\n\t} else {\n\t\tif (y.parent === z) {\n\t\t\tx.parent = y;\n\t\t} else {\n\t\t\tx.parent = y.parent;\n\t\t}\n\n\t\t// as we make changes to x's hierarchy, update size_left of subtree first\n\t\trecomputeTreeMetadata(tree, x);\n\n\t\ty.left = z.left;\n\t\ty.right = z.right;\n\t\ty.parent = z.parent;\n\t\ty.color = z.color;\n\n\t\tif (z === tree.root) {\n\t\t\ttree.root = y;\n\t\t} else {\n\t\t\tif (z === z.parent.left) {\n\t\t\t\tz.parent.left = y;\n\t\t\t} else {\n\t\t\t\tz.parent.right = y;\n\t\t\t}\n\t\t}\n\n\t\tif (y.left !== SENTINEL) {\n\t\t\ty.left.parent = y;\n\t\t}\n\t\tif (y.right !== SENTINEL) {\n\t\t\ty.right.parent = y;\n\t\t}\n\t\t// update metadata\n\t\t// we replace z with y, so in this sub tree, the length change is z.item.length\n\t\ty.size_left = z.size_left;\n\t\ty.lf_left = z.lf_left;\n\t\trecomputeTreeMetadata(tree, y);\n\t}\n\n\tz.detach();\n\n\tif (x.parent.left === x) {\n\t\tconst newSizeLeft = calculateSize(x);\n\t\tconst newLFLeft = calculateLF(x);\n\t\tif (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n\t\t\tconst delta = newSizeLeft - x.parent.size_left;\n\t\t\tconst lf_delta = newLFLeft - x.parent.lf_left;\n\t\t\tx.parent.size_left = newSizeLeft;\n\t\t\tx.parent.lf_left = newLFLeft;\n\t\t\tupdateTreeMetadata(tree, x.parent, delta, lf_delta);\n\t\t}\n\t}\n\n\trecomputeTreeMetadata(tree, x.parent);\n\n\tif (yWasRed) {\n\t\tresetSentinel();\n\t\treturn;\n\t}\n\n\t// RB-DELETE-FIXUP\n\tlet w: TreeNode;\n\twhile (x !== tree.root && x.color === NodeColor.Black) {\n\t\tif (x === x.parent.left) {\n\t\t\tw = x.parent.right;\n\n\t\t\tif (w.color === NodeColor.Red) {\n\t\t\t\tw.color = NodeColor.Black;\n\t\t\t\tx.parent.color = NodeColor.Red;\n\t\t\t\tleftRotate(tree, x.parent);\n\t\t\t\tw = x.parent.right;\n\t\t\t}\n\n\t\t\tif (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (w.right.color === NodeColor.Black) {\n\t\t\t\t\tw.left.color = NodeColor.Black;\n\t\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\t\trightRotate(tree, w);\n\t\t\t\t\tw = x.parent.right;\n\t\t\t\t}\n\n\t\t\t\tw.color = x.parent.color;\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tw.right.color = NodeColor.Black;\n\t\t\t\tleftRotate(tree, x.parent);\n\t\t\t\tx = tree.root;\n\t\t\t}\n\t\t} else {\n\t\t\tw = x.parent.left;\n\n\t\t\tif (w.color === NodeColor.Red) {\n\t\t\t\tw.color = NodeColor.Black;\n\t\t\t\tx.parent.color = NodeColor.Red;\n\t\t\t\trightRotate(tree, x.parent);\n\t\t\t\tw = x.parent.left;\n\t\t\t}\n\n\t\t\tif (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\tx = x.parent;\n\n\t\t\t} else {\n\t\t\t\tif (w.left.color === NodeColor.Black) {\n\t\t\t\t\tw.right.color = NodeColor.Black;\n\t\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\t\tleftRotate(tree, w);\n\t\t\t\t\tw = x.parent.left;\n\t\t\t\t}\n\n\t\t\t\tw.color = x.parent.color;\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tw.left.color = NodeColor.Black;\n\t\t\t\trightRotate(tree, x.parent);\n\t\t\t\tx = tree.root;\n\t\t\t}\n\t\t}\n\t}\n\tx.color = NodeColor.Black;\n\tresetSentinel();\n}\n\nexport function fixInsert(tree: PieceTreeBase, x: TreeNode) {\n\trecomputeTreeMetadata(tree, x);\n\n\twhile (x !== tree.root && x.parent.color === NodeColor.Red) {\n\t\tif (x.parent === x.parent.parent.left) {\n\t\t\tconst y = x.parent.parent.right;\n\n\t\t\tif (y.color === NodeColor.Red) {\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\ty.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.right) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\tleftRotate(tree, x);\n\t\t\t\t}\n\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\trightRotate(tree, x.parent.parent);\n\t\t\t}\n\t\t} else {\n\t\t\tconst y = x.parent.parent.left;\n\n\t\t\tif (y.color === NodeColor.Red) {\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\ty.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.left) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\trightRotate(tree, x);\n\t\t\t\t}\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tleftRotate(tree, x.parent.parent);\n\t\t\t}\n\t\t}\n\t}\n\n\ttree.root.color = NodeColor.Black;\n}\n\nexport function updateTreeMetadata(tree: PieceTreeBase, x: TreeNode, delta: number, lineFeedCntDelta: number): void {\n\t// node length change or line feed count change\n\twhile (x !== tree.root && x !== SENTINEL) {\n\t\tif (x.parent.left === x) {\n\t\t\tx.parent.size_left += delta;\n\t\t\tx.parent.lf_left += lineFeedCntDelta;\n\t\t}\n\n\t\tx = x.parent;\n\t}\n}\n\nexport function recomputeTreeMetadata(tree: PieceTreeBase, x: TreeNode) {\n\tlet delta = 0;\n\tlet lf_delta = 0;\n\tif (x === tree.root) {\n\t\treturn;\n\t}\n\n\t// go upwards till the node whose left subtree is changed.\n\twhile (x !== tree.root && x === x.parent.right) {\n\t\tx = x.parent;\n\t}\n\n\tif (x === tree.root) {\n\t\t// well, it means we add a node to the end (inorder)\n\t\treturn;\n\t}\n\n\t// x is the node whose right subtree is changed.\n\tx = x.parent;\n\n\tdelta = calculateSize(x.left) - x.size_left;\n\tlf_delta = calculateLF(x.left) - x.lf_left;\n\tx.size_left += delta;\n\tx.lf_left += lf_delta;\n\n\n\t// go upwards till root. O(logN)\n\twhile (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n\t\tif (x.parent.left === x) {\n\t\t\tx.parent.size_left += delta;\n\t\t\tx.parent.lf_left += lf_delta;\n\t\t}\n\n\t\tx = x.parent;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Piece, PieceTreeBase } from './pieceTreeBase.js';\n\nexport class TreeNode {\n\tparent: TreeNode;\n\tleft: TreeNode;\n\tright: TreeNode;\n\tcolor: NodeColor;\n\n\t// Piece\n\tpiece: Piece;\n\tsize_left: number; // size of the left subtree (not inorder)\n\tlf_left: number; // line feeds cnt in the left subtree (not in order)\n\n\tconstructor(piece: Piece, color: NodeColor) {\n\t\tthis.piece = piece;\n\t\tthis.color = color;\n\t\tthis.size_left = 0;\n\t\tthis.lf_left = 0;\n\t\tthis.parent = this;\n\t\tthis.left = this;\n\t\tthis.right = this;\n\t}\n\n\tpublic next(): TreeNode {\n\t\tif (this.right !== SENTINEL) {\n\t\t\treturn leftest(this.right);\n\t\t}\n\n\t\tlet node: TreeNode = this;\n\n\t\twhile (node.parent !== SENTINEL) {\n\t\t\tif (node.parent.left === node) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tif (node.parent === SENTINEL) {\n\t\t\treturn SENTINEL;\n\t\t} else {\n\t\t\treturn node.parent;\n\t\t}\n\t}\n\n\tpublic prev(): TreeNode {\n\t\tif (this.left !== SENTINEL) {\n\t\t\treturn righttest(this.left);\n\t\t}\n\n\t\tlet node: TreeNode = this;\n\n\t\twhile (node.parent !== SENTINEL) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tif (node.parent === SENTINEL) {\n\t\t\treturn SENTINEL;\n\t\t} else {\n\t\t\treturn node.parent;\n\t\t}\n\t}\n\n\tpublic detach(): void {\n\t\tthis.parent = null!;\n\t\tthis.left = null!;\n\t\tthis.right = null!;\n\t}\n}\n\nexport const enum NodeColor {\n\tBlack = 0,\n\tRed = 1,\n}\n\nexport const SENTINEL: TreeNode = new TreeNode(null!, NodeColor.Black);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = NodeColor.Black;\n\nexport function leftest(node: TreeNode): TreeNode {\n\twhile (node.left !== SENTINEL) {\n\t\tnode = node.left;\n\t}\n\treturn node;\n}\n\nexport function righttest(node: TreeNode): TreeNode {\n\twhile (node.right !== SENTINEL) {\n\t\tnode = node.right;\n\t}\n\treturn node;\n}\n\nfunction calculateSize(node: TreeNode): number {\n\tif (node === SENTINEL) {\n\t\treturn 0;\n\t}\n\n\treturn node.size_left + node.piece.length + calculateSize(node.right);\n}\n\nfunction calculateLF(node: TreeNode): number {\n\tif (node === SENTINEL) {\n\t\treturn 0;\n\t}\n\n\treturn node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\n\nfunction resetSentinel(): void {\n\tSENTINEL.parent = SENTINEL;\n}\n\nexport function leftRotate(tree: PieceTreeBase, x: TreeNode) {\n\tconst y = x.right;\n\n\t// fix size_left\n\ty.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n\ty.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\tx.right = y.left;\n\n\tif (y.left !== SENTINEL) {\n\t\ty.left.parent = x;\n\t}\n\ty.parent = x.parent;\n\tif (x.parent === SENTINEL) {\n\t\ttree.root = y;\n\t} else if (x.parent.left === x) {\n\t\tx.parent.left = y;\n\t} else {\n\t\tx.parent.right = y;\n\t}\n\ty.left = x;\n\tx.parent = y;\n}\n\nexport function rightRotate(tree: PieceTreeBase, y: TreeNode) {\n\tconst x = y.left;\n\ty.left = x.right;\n\tif (x.right !== SENTINEL) {\n\t\tx.right.parent = y;\n\t}\n\tx.parent = y.parent;\n\n\t// fix size_left\n\ty.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n\ty.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n\n\tif (y.parent === SENTINEL) {\n\t\ttree.root = x;\n\t} else if (y === y.parent.right) {\n\t\ty.parent.right = x;\n\t} else {\n\t\ty.parent.left = x;\n\t}\n\n\tx.right = y;\n\ty.parent = x;\n}\n\nexport function rbDelete(tree: PieceTreeBase, z: TreeNode) {\n\tlet x: TreeNode;\n\tlet y: TreeNode;\n\n\tif (z.left === SENTINEL) {\n\t\ty = z;\n\t\tx = y.right;\n\t} else if (z.right === SENTINEL) {\n\t\ty = z;\n\t\tx = y.left;\n\t} else {\n\t\ty = leftest(z.right);\n\t\tx = y.right;\n\t}\n\n\tif (y === tree.root) {\n\t\ttree.root = x;\n\n\t\t// if x is null, we are removing the only node\n\t\tx.color = NodeColor.Black;\n\t\tz.detach();\n\t\tresetSentinel();\n\t\ttree.root.parent = SENTINEL;\n\n\t\treturn;\n\t}\n\n\tconst yWasRed = (y.color === NodeColor.Red);\n\n\tif (y === y.parent.left) {\n\t\ty.parent.left = x;\n\t} else {\n\t\ty.parent.right = x;\n\t}\n\n\tif (y === z) {\n\t\tx.parent = y.parent;\n\t\trecomputeTreeMetadata(tree, x);\n\t} else {\n\t\tif (y.parent === z) {\n\t\t\tx.parent = y;\n\t\t} else {\n\t\t\tx.parent = y.parent;\n\t\t}\n\n\t\t// as we make changes to x's hierarchy, update size_left of subtree first\n\t\trecomputeTreeMetadata(tree, x);\n\n\t\ty.left = z.left;\n\t\ty.right = z.right;\n\t\ty.parent = z.parent;\n\t\ty.color = z.color;\n\n\t\tif (z === tree.root) {\n\t\t\ttree.root = y;\n\t\t} else {\n\t\t\tif (z === z.parent.left) {\n\t\t\t\tz.parent.left = y;\n\t\t\t} else {\n\t\t\t\tz.parent.right = y;\n\t\t\t}\n\t\t}\n\n\t\tif (y.left !== SENTINEL) {\n\t\t\ty.left.parent = y;\n\t\t}\n\t\tif (y.right !== SENTINEL) {\n\t\t\ty.right.parent = y;\n\t\t}\n\t\t// update metadata\n\t\t// we replace z with y, so in this sub tree, the length change is z.item.length\n\t\ty.size_left = z.size_left;\n\t\ty.lf_left = z.lf_left;\n\t\trecomputeTreeMetadata(tree, y);\n\t}\n\n\tz.detach();\n\n\tif (x.parent.left === x) {\n\t\tconst newSizeLeft = calculateSize(x);\n\t\tconst newLFLeft = calculateLF(x);\n\t\tif (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n\t\t\tconst delta = newSizeLeft - x.parent.size_left;\n\t\t\tconst lf_delta = newLFLeft - x.parent.lf_left;\n\t\t\tx.parent.size_left = newSizeLeft;\n\t\t\tx.parent.lf_left = newLFLeft;\n\t\t\tupdateTreeMetadata(tree, x.parent, delta, lf_delta);\n\t\t}\n\t}\n\n\trecomputeTreeMetadata(tree, x.parent);\n\n\tif (yWasRed) {\n\t\tresetSentinel();\n\t\treturn;\n\t}\n\n\t// RB-DELETE-FIXUP\n\tlet w: TreeNode;\n\twhile (x !== tree.root && x.color === NodeColor.Black) {\n\t\tif (x === x.parent.left) {\n\t\t\tw = x.parent.right;\n\n\t\t\tif (w.color === NodeColor.Red) {\n\t\t\t\tw.color = NodeColor.Black;\n\t\t\t\tx.parent.color = NodeColor.Red;\n\t\t\t\tleftRotate(tree, x.parent);\n\t\t\t\tw = x.parent.right;\n\t\t\t}\n\n\t\t\tif (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\tx = x.parent;\n\t\t\t} else {\n\t\t\t\tif (w.right.color === NodeColor.Black) {\n\t\t\t\t\tw.left.color = NodeColor.Black;\n\t\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\t\trightRotate(tree, w);\n\t\t\t\t\tw = x.parent.right;\n\t\t\t\t}\n\n\t\t\t\tw.color = x.parent.color;\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tw.right.color = NodeColor.Black;\n\t\t\t\tleftRotate(tree, x.parent);\n\t\t\t\tx = tree.root;\n\t\t\t}\n\t\t} else {\n\t\t\tw = x.parent.left;\n\n\t\t\tif (w.color === NodeColor.Red) {\n\t\t\t\tw.color = NodeColor.Black;\n\t\t\t\tx.parent.color = NodeColor.Red;\n\t\t\t\trightRotate(tree, x.parent);\n\t\t\t\tw = x.parent.left;\n\t\t\t}\n\n\t\t\tif (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {\n\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\tx = x.parent;\n\n\t\t\t} else {\n\t\t\t\tif (w.left.color === NodeColor.Black) {\n\t\t\t\t\tw.right.color = NodeColor.Black;\n\t\t\t\t\tw.color = NodeColor.Red;\n\t\t\t\t\tleftRotate(tree, w);\n\t\t\t\t\tw = x.parent.left;\n\t\t\t\t}\n\n\t\t\t\tw.color = x.parent.color;\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tw.left.color = NodeColor.Black;\n\t\t\t\trightRotate(tree, x.parent);\n\t\t\t\tx = tree.root;\n\t\t\t}\n\t\t}\n\t}\n\tx.color = NodeColor.Black;\n\tresetSentinel();\n}\n\nexport function fixInsert(tree: PieceTreeBase, x: TreeNode) {\n\trecomputeTreeMetadata(tree, x);\n\n\twhile (x !== tree.root && x.parent.color === NodeColor.Red) {\n\t\tif (x.parent === x.parent.parent.left) {\n\t\t\tconst y = x.parent.parent.right;\n\n\t\t\tif (y.color === NodeColor.Red) {\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\ty.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.right) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\tleftRotate(tree, x);\n\t\t\t\t}\n\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\trightRotate(tree, x.parent.parent);\n\t\t\t}\n\t\t} else {\n\t\t\tconst y = x.parent.parent.left;\n\n\t\t\tif (y.color === NodeColor.Red) {\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\ty.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tx = x.parent.parent;\n\t\t\t} else {\n\t\t\t\tif (x === x.parent.left) {\n\t\t\t\t\tx = x.parent;\n\t\t\t\t\trightRotate(tree, x);\n\t\t\t\t}\n\t\t\t\tx.parent.color = NodeColor.Black;\n\t\t\t\tx.parent.parent.color = NodeColor.Red;\n\t\t\t\tleftRotate(tree, x.parent.parent);\n\t\t\t}\n\t\t}\n\t}\n\n\ttree.root.color = NodeColor.Black;\n}\n\nexport function updateTreeMetadata(tree: PieceTreeBase, x: TreeNode, delta: number, lineFeedCntDelta: number): void {\n\t// node length change or line feed count change\n\twhile (x !== tree.root && x !== SENTINEL) {\n\t\tif (x.parent.left === x) {\n\t\t\tx.parent.size_left += delta;\n\t\t\tx.parent.lf_left += lineFeedCntDelta;\n\t\t}\n\n\t\tx = x.parent;\n\t}\n}\n\nexport function recomputeTreeMetadata(tree: PieceTreeBase, x: TreeNode) {\n\tlet delta = 0;\n\tlet lf_delta = 0;\n\tif (x === tree.root) {\n\t\treturn;\n\t}\n\n\t// go upwards till the node whose left subtree is changed.\n\twhile (x !== tree.root && x === x.parent.right) {\n\t\tx = x.parent;\n\t}\n\n\tif (x === tree.root) {\n\t\t// well, it means we add a node to the end (inorder)\n\t\treturn;\n\t}\n\n\t// x is the node whose right subtree is changed.\n\tx = x.parent;\n\n\tdelta = calculateSize(x.left) - x.size_left;\n\tlf_delta = calculateLF(x.left) - x.lf_left;\n\tx.size_left += delta;\n\tx.lf_left += lf_delta;\n\n\n\t// go upwards till root. O(logN)\n\twhile (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n\t\tif (x.parent.left === x) {\n\t\t\tx.parent.size_left += delta;\n\t\t\tx.parent.lf_left += lf_delta;\n\t\t}\n\n\t\tx = x.parent;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5416, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/textModelSearch.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/textModelSearch.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { WordCharacterClass, WordCharacterClassifier, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { EndOfLinePreference, FindMatch, SearchData } from '../model.js';\nimport { TextModel } from './textModel.js';\n\nconst LIMIT_FIND_COUNT = 999;\n\nexport class SearchParams {\n\tpublic readonly searchString: string;\n\tpublic readonly isRegex: boolean;\n\tpublic readonly matchCase: boolean;\n\tpublic readonly wordSeparators: string | null;\n\n\tconstructor(searchString: string, isRegex: boolean, matchCase: boolean, wordSeparators: string | null) {\n\t\tthis.searchString = searchString;\n\t\tthis.isRegex = isRegex;\n\t\tthis.matchCase = matchCase;\n\t\tthis.wordSeparators = wordSeparators;\n\t}\n\n\tpublic parseSearchRequest(): SearchData | null {\n\t\tif (this.searchString === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try to create a RegExp out of the params\n\t\tlet multiline: boolean;\n\t\tif (this.isRegex) {\n\t\t\tmultiline = isMultilineRegexSource(this.searchString);\n\t\t} else {\n\t\t\tmultiline = (this.searchString.indexOf('\\n') >= 0);\n\t\t}\n\n\t\tlet regex: RegExp | null = null;\n\t\ttry {\n\t\t\tregex = strings.createRegExp(this.searchString, this.isRegex, {\n\t\t\t\tmatchCase: this.matchCase,\n\t\t\t\twholeWord: false,\n\t\t\t\tmultiline: multiline,\n\t\t\t\tglobal: true,\n\t\t\t\tunicode: true\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!regex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet canUseSimpleSearch = (!this.isRegex && !multiline);\n\t\tif (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n\t\t\t// casing might make a difference\n\t\t\tcanUseSimpleSearch = this.matchCase;\n\t\t}\n\n\t\treturn new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n\t}\n}\n\nexport function isMultilineRegexSource(searchString: string): boolean {\n\tif (!searchString || searchString.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = searchString.length; i < len; i++) {\n\t\tconst chCode = searchString.charCodeAt(i);\n\n\t\tif (chCode === CharCode.LineFeed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a \\\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextChCode = searchString.charCodeAt(i);\n\t\t\tif (nextChCode === CharCode.n || nextChCode === CharCode.r || nextChCode === CharCode.W) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function createFindMatch(range: Range, rawMatches: RegExpExecArray, captureMatches: boolean): FindMatch {\n\tif (!captureMatches) {\n\t\treturn new FindMatch(range, null);\n\t}\n\tconst matches: string[] = [];\n\tfor (let i = 0, len = rawMatches.length; i < len; i++) {\n\t\tmatches[i] = rawMatches[i];\n\t}\n\treturn new FindMatch(range, matches);\n}\n\nclass LineFeedCounter {\n\n\tprivate readonly _lineFeedsOffsets: number[];\n\n\tconstructor(text: string) {\n\t\tconst lineFeedsOffsets: number[] = [];\n\t\tlet lineFeedsOffsetsLen = 0;\n\t\tfor (let i = 0, textLen = text.length; i < textLen; i++) {\n\t\t\tif (text.charCodeAt(i) === CharCode.LineFeed) {\n\t\t\t\tlineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n\t\t\t}\n\t\t}\n\t\tthis._lineFeedsOffsets = lineFeedsOffsets;\n\t}\n\n\tpublic findLineFeedCountBeforeOffset(offset: number): number {\n\t\tconst lineFeedsOffsets = this._lineFeedsOffsets;\n\t\tlet min = 0;\n\t\tlet max = lineFeedsOffsets.length - 1;\n\n\t\tif (max === -1) {\n\t\t\t// no line feeds\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (offset <= lineFeedsOffsets[0]) {\n\t\t\t// before first line feed\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (min < max) {\n\t\t\tconst mid = min + ((max - min) / 2 >> 0);\n\n\t\t\tif (lineFeedsOffsets[mid] >= offset) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lineFeedsOffsets[mid + 1] >= offset) {\n\t\t\t\t\t// bingo!\n\t\t\t\t\tmin = mid;\n\t\t\t\t\tmax = mid;\n\t\t\t\t} else {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min + 1;\n\t}\n}\n\nexport class TextModelSearch {\n\n\tpublic static findMatches(model: TextModel, searchParams: SearchParams, searchRange: Range, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n\t\t}\n\t\treturn this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Multiline search always executes on the lines concatenated with \\n.\n\t * We must therefore compensate for the count of \\n in case the model is CRLF\n\t */\n\tprivate static _getMultilineMatchRange(model: TextModel, deltaOffset: number, text: string, lfCounter: LineFeedCounter | null, matchIndex: number, match0: string): Range {\n\t\tlet startOffset: number;\n\t\tlet lineFeedCountBeforeMatch = 0;\n\t\tif (lfCounter) {\n\t\t\tlineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n\t\t\tstartOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tstartOffset = deltaOffset + matchIndex;\n\t\t}\n\n\t\tlet endOffset: number;\n\t\tif (lfCounter) {\n\t\t\tconst lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n\t\t\tconst lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n\t\t\tendOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tendOffset = startOffset + match0.length;\n\t\t}\n\n\t\tconst startPosition = model.getPositionAt(startOffset);\n\t\tconst endPosition = model.getPositionAt(endOffset);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tprivate static _doFindMatchesMultiline(model: TextModel, searchRange: Range, searcher: Searcher, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(searchRange, EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\n\t\tconst result: FindMatch[] = [];\n\t\tlet counter = 0;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tresult[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\t\t\tif (counter >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _doFindMatchesLineByLine(model: TextModel, searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\n\t\t// Early case for a search range that starts & stops on the same line number\n\t\tif (searchRange.startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Collect results from first line\n\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\n\t\t// Collect results from middle lines\n\t\tfor (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n\t\t\tresultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\t// Collect results from last line\n\t\tif (resultLen < limitResultCount) {\n\t\t\tconst text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _findMatchesInLine(searchData: SearchData, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\tpublic static findNextMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindNextMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst searchTextStart = new Position(searchStart.lineNumber, 1);\n\t\tconst deltaOffset = model.getOffsetAt(searchTextStart);\n\t\tconst lineCount = model.getLineCount();\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\t\tsearcher.reset(searchStart.column - 1);\n\t\tconst m = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tthis._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\n\t\tif (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n\t\t\t// Try again from the top\n\t\t\treturn this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindNextMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber);\n\t\tconst r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (startLineNumber + i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findFirstMatchInLine(searcher: Searcher, text: string, lineNumber: number, fromColumn: number, captureMatches: boolean): FindMatch | null {\n\t\t// Set regex to search from column\n\t\tsearcher.reset(fromColumn - 1);\n\t\tconst m: RegExpExecArray | null = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tnew Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static findPreviousMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindPreviousMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\t\tif (matches.length > 0) {\n\t\t\treturn matches[matches.length - 1];\n\t\t}\n\n\t\tconst lineCount = model.getLineCount();\n\t\tif (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n\t\t\t// Try again with all content\n\t\t\treturn this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindPreviousMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\t\tconst r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findLastMatchInLine(searcher: Searcher, text: string, lineNumber: number, captureMatches: boolean): FindMatch | null {\n\t\tlet bestResult: FindMatch | null = null;\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tbestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n\t\t}\n\t\treturn bestResult;\n\t}\n}\n\nfunction leftIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex === 0) {\n\t\t// Match starts at start of string\n\t\treturn true;\n\t}\n\n\tconst charBefore = text.charCodeAt(matchStartIndex - 1);\n\tif (wordSeparators.get(charBefore) !== WordCharacterClass.Regular) {\n\t\t// The character before the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charBefore === CharCode.CarriageReturn || charBefore === CharCode.LineFeed) {\n\t\t// The character before the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst firstCharInMatch = text.charCodeAt(matchStartIndex);\n\t\tif (wordSeparators.get(firstCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The first character inside the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction rightIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex + matchLength === textLength) {\n\t\t// Match ends at end of string\n\t\treturn true;\n\t}\n\n\tconst charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\tif (wordSeparators.get(charAfter) !== WordCharacterClass.Regular) {\n\t\t// The character after the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charAfter === CharCode.CarriageReturn || charAfter === CharCode.LineFeed) {\n\t\t// The character after the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\t\tif (wordSeparators.get(lastCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The last character in the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function isValidMatch(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\treturn (\n\t\tleftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t\t&& rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t);\n}\n\nexport class Searcher {\n\tpublic readonly _wordSeparators: WordCharacterClassifier | null;\n\tprivate readonly _searchRegex: RegExp;\n\tprivate _prevMatchStartIndex: number;\n\tprivate _prevMatchLength: number;\n\n\tconstructor(wordSeparators: WordCharacterClassifier | null, searchRegex: RegExp,) {\n\t\tthis._wordSeparators = wordSeparators;\n\t\tthis._searchRegex = searchRegex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic reset(lastIndex: number): void {\n\t\tthis._searchRegex.lastIndex = lastIndex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic next(text: string): RegExpExecArray | null {\n\t\tconst textLength = text.length;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tdo {\n\t\t\tif (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n\t\t\t\t// Reached the end of the line\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tm = this._searchRegex.exec(text);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst matchStartIndex = m.index;\n\t\t\tconst matchLength = m[0].length;\n\t\t\tif (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n\t\t\t\tif (matchLength === 0) {\n\t\t\t\t\t// the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n\t\t\t\t\t// we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n\t\t\t\t\tif (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Exit early if the regex matches the same range twice\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._prevMatchStartIndex = matchStartIndex;\n\t\t\tthis._prevMatchLength = matchLength;\n\n\t\t\tif (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n\t\t\t\treturn m;\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { WordCharacterClass, WordCharacterClassifier, getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { EndOfLinePreference, FindMatch, SearchData } from '../model.js';\nimport { TextModel } from './textModel.js';\n\nconst LIMIT_FIND_COUNT = 999;\n\nexport class SearchParams {\n\tpublic readonly searchString: string;\n\tpublic readonly isRegex: boolean;\n\tpublic readonly matchCase: boolean;\n\tpublic readonly wordSeparators: string | null;\n\n\tconstructor(searchString: string, isRegex: boolean, matchCase: boolean, wordSeparators: string | null) {\n\t\tthis.searchString = searchString;\n\t\tthis.isRegex = isRegex;\n\t\tthis.matchCase = matchCase;\n\t\tthis.wordSeparators = wordSeparators;\n\t}\n\n\tpublic parseSearchRequest(): SearchData | null {\n\t\tif (this.searchString === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try to create a RegExp out of the params\n\t\tlet multiline: boolean;\n\t\tif (this.isRegex) {\n\t\t\tmultiline = isMultilineRegexSource(this.searchString);\n\t\t} else {\n\t\t\tmultiline = (this.searchString.indexOf('\\n') >= 0);\n\t\t}\n\n\t\tlet regex: RegExp | null = null;\n\t\ttry {\n\t\t\tregex = strings.createRegExp(this.searchString, this.isRegex, {\n\t\t\t\tmatchCase: this.matchCase,\n\t\t\t\twholeWord: false,\n\t\t\t\tmultiline: multiline,\n\t\t\t\tglobal: true,\n\t\t\t\tunicode: true\n\t\t\t});\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!regex) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet canUseSimpleSearch = (!this.isRegex && !multiline);\n\t\tif (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n\t\t\t// casing might make a difference\n\t\t\tcanUseSimpleSearch = this.matchCase;\n\t\t}\n\n\t\treturn new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n\t}\n}\n\nexport function isMultilineRegexSource(searchString: string): boolean {\n\tif (!searchString || searchString.length === 0) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = searchString.length; i < len; i++) {\n\t\tconst chCode = searchString.charCodeAt(i);\n\n\t\tif (chCode === CharCode.LineFeed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (chCode === CharCode.Backslash) {\n\n\t\t\t// move to next char\n\t\t\ti++;\n\n\t\t\tif (i >= len) {\n\t\t\t\t// string ends with a \\\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst nextChCode = searchString.charCodeAt(i);\n\t\t\tif (nextChCode === CharCode.n || nextChCode === CharCode.r || nextChCode === CharCode.W) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function createFindMatch(range: Range, rawMatches: RegExpExecArray, captureMatches: boolean): FindMatch {\n\tif (!captureMatches) {\n\t\treturn new FindMatch(range, null);\n\t}\n\tconst matches: string[] = [];\n\tfor (let i = 0, len = rawMatches.length; i < len; i++) {\n\t\tmatches[i] = rawMatches[i];\n\t}\n\treturn new FindMatch(range, matches);\n}\n\nclass LineFeedCounter {\n\n\tprivate readonly _lineFeedsOffsets: number[];\n\n\tconstructor(text: string) {\n\t\tconst lineFeedsOffsets: number[] = [];\n\t\tlet lineFeedsOffsetsLen = 0;\n\t\tfor (let i = 0, textLen = text.length; i < textLen; i++) {\n\t\t\tif (text.charCodeAt(i) === CharCode.LineFeed) {\n\t\t\t\tlineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n\t\t\t}\n\t\t}\n\t\tthis._lineFeedsOffsets = lineFeedsOffsets;\n\t}\n\n\tpublic findLineFeedCountBeforeOffset(offset: number): number {\n\t\tconst lineFeedsOffsets = this._lineFeedsOffsets;\n\t\tlet min = 0;\n\t\tlet max = lineFeedsOffsets.length - 1;\n\n\t\tif (max === -1) {\n\t\t\t// no line feeds\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (offset <= lineFeedsOffsets[0]) {\n\t\t\t// before first line feed\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (min < max) {\n\t\t\tconst mid = min + ((max - min) / 2 >> 0);\n\n\t\t\tif (lineFeedsOffsets[mid] >= offset) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tif (lineFeedsOffsets[mid + 1] >= offset) {\n\t\t\t\t\t// bingo!\n\t\t\t\t\tmin = mid;\n\t\t\t\t\tmax = mid;\n\t\t\t\t} else {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min + 1;\n\t}\n}\n\nexport class TextModelSearch {\n\n\tpublic static findMatches(model: TextModel, searchParams: SearchParams, searchRange: Range, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n\t\t}\n\t\treturn this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Multiline search always executes on the lines concatenated with \\n.\n\t * We must therefore compensate for the count of \\n in case the model is CRLF\n\t */\n\tprivate static _getMultilineMatchRange(model: TextModel, deltaOffset: number, text: string, lfCounter: LineFeedCounter | null, matchIndex: number, match0: string): Range {\n\t\tlet startOffset: number;\n\t\tlet lineFeedCountBeforeMatch = 0;\n\t\tif (lfCounter) {\n\t\t\tlineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n\t\t\tstartOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tstartOffset = deltaOffset + matchIndex;\n\t\t}\n\n\t\tlet endOffset: number;\n\t\tif (lfCounter) {\n\t\t\tconst lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n\t\t\tconst lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n\t\t\tendOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n\t\t} else {\n\t\t\tendOffset = startOffset + match0.length;\n\t\t}\n\n\t\tconst startPosition = model.getPositionAt(startOffset);\n\t\tconst endPosition = model.getPositionAt(endOffset);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tprivate static _doFindMatchesMultiline(model: TextModel, searchRange: Range, searcher: Searcher, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(searchRange, EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\n\t\tconst result: FindMatch[] = [];\n\t\tlet counter = 0;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tresult[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\t\t\tif (counter >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _doFindMatchesLineByLine(model: TextModel, searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\n\t\t// Early case for a search range that starts & stops on the same line number\n\t\tif (searchRange.startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\t// Collect results from first line\n\t\tconst text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n\n\t\t// Collect results from middle lines\n\t\tfor (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n\t\t\tresultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\t// Collect results from last line\n\t\tif (resultLen < limitResultCount) {\n\t\t\tconst text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _findMatchesInLine(searchData: SearchData, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\tpublic static findNextMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindNextMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst searchTextStart = new Position(searchStart.lineNumber, 1);\n\t\tconst deltaOffset = model.getOffsetAt(searchTextStart);\n\t\tconst lineCount = model.getLineCount();\n\t\t// We always execute multiline search over the lines joined with \\n\n\t\t// This makes it that \\n will match the EOL for both CRLF and LF models\n\t\t// We compensate for offset errors in `_getMultilineMatchRange`\n\t\tconst text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), EndOfLinePreference.LF);\n\t\tconst lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n\t\tsearcher.reset(searchStart.column - 1);\n\t\tconst m = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tthis._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\n\t\tif (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n\t\t\t// Try again from the top\n\t\t\treturn this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindNextMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber);\n\t\tconst r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (startLineNumber + i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findFirstMatchInLine(searcher: Searcher, text: string, lineNumber: number, fromColumn: number, captureMatches: boolean): FindMatch | null {\n\t\t// Set regex to search from column\n\t\tsearcher.reset(fromColumn - 1);\n\t\tconst m: RegExpExecArray | null = searcher.next(text);\n\t\tif (m) {\n\t\t\treturn createFindMatch(\n\t\t\t\tnew Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length),\n\t\t\t\tm,\n\t\t\t\tcaptureMatches\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static findPreviousMatch(model: TextModel, searchParams: SearchParams, searchStart: Position, captureMatches: boolean): FindMatch | null {\n\t\tconst searchData = searchParams.parseSearchRequest();\n\t\tif (!searchData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tif (searchData.regex.multiline) {\n\t\t\treturn this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n\t\t}\n\t\treturn this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n\t}\n\n\tprivate static _doFindPreviousMatchMultiline(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\t\tif (matches.length > 0) {\n\t\t\treturn matches[matches.length - 1];\n\t\t}\n\n\t\tconst lineCount = model.getLineCount();\n\t\tif (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n\t\t\t// Try again with all content\n\t\t\treturn this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _doFindPreviousMatchLineByLine(model: TextModel, searchStart: Position, searcher: Searcher, captureMatches: boolean): FindMatch | null {\n\t\tconst lineCount = model.getLineCount();\n\t\tconst startLineNumber = searchStart.lineNumber;\n\n\t\t// Look in first line\n\t\tconst text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\t\tconst r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tfor (let i = 1; i <= lineCount; i++) {\n\t\t\tconst lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n\t\t\tconst text = model.getLineContent(lineIndex + 1);\n\t\t\tconst r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _findLastMatchInLine(searcher: Searcher, text: string, lineNumber: number, captureMatches: boolean): FindMatch | null {\n\t\tlet bestResult: FindMatch | null = null;\n\t\tlet m: RegExpExecArray | null;\n\t\tsearcher.reset(0);\n\t\twhile ((m = searcher.next(text))) {\n\t\t\tbestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n\t\t}\n\t\treturn bestResult;\n\t}\n}\n\nfunction leftIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex === 0) {\n\t\t// Match starts at start of string\n\t\treturn true;\n\t}\n\n\tconst charBefore = text.charCodeAt(matchStartIndex - 1);\n\tif (wordSeparators.get(charBefore) !== WordCharacterClass.Regular) {\n\t\t// The character before the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charBefore === CharCode.CarriageReturn || charBefore === CharCode.LineFeed) {\n\t\t// The character before the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst firstCharInMatch = text.charCodeAt(matchStartIndex);\n\t\tif (wordSeparators.get(firstCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The first character inside the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction rightIsWordBounday(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\tif (matchStartIndex + matchLength === textLength) {\n\t\t// Match ends at end of string\n\t\treturn true;\n\t}\n\n\tconst charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\tif (wordSeparators.get(charAfter) !== WordCharacterClass.Regular) {\n\t\t// The character after the match is a word separator\n\t\treturn true;\n\t}\n\n\tif (charAfter === CharCode.CarriageReturn || charAfter === CharCode.LineFeed) {\n\t\t// The character after the match is line break or carriage return.\n\t\treturn true;\n\t}\n\n\tif (matchLength > 0) {\n\t\tconst lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\t\tif (wordSeparators.get(lastCharInMatch) !== WordCharacterClass.Regular) {\n\t\t\t// The last character in the match is a word separator\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport function isValidMatch(wordSeparators: WordCharacterClassifier, text: string, textLength: number, matchStartIndex: number, matchLength: number): boolean {\n\treturn (\n\t\tleftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t\t&& rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n\t);\n}\n\nexport class Searcher {\n\tpublic readonly _wordSeparators: WordCharacterClassifier | null;\n\tprivate readonly _searchRegex: RegExp;\n\tprivate _prevMatchStartIndex: number;\n\tprivate _prevMatchLength: number;\n\n\tconstructor(wordSeparators: WordCharacterClassifier | null, searchRegex: RegExp,) {\n\t\tthis._wordSeparators = wordSeparators;\n\t\tthis._searchRegex = searchRegex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic reset(lastIndex: number): void {\n\t\tthis._searchRegex.lastIndex = lastIndex;\n\t\tthis._prevMatchStartIndex = -1;\n\t\tthis._prevMatchLength = 0;\n\t}\n\n\tpublic next(text: string): RegExpExecArray | null {\n\t\tconst textLength = text.length;\n\n\t\tlet m: RegExpExecArray | null;\n\t\tdo {\n\t\t\tif (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n\t\t\t\t// Reached the end of the line\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tm = this._searchRegex.exec(text);\n\t\t\tif (!m) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst matchStartIndex = m.index;\n\t\t\tconst matchLength = m[0].length;\n\t\t\tif (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n\t\t\t\tif (matchLength === 0) {\n\t\t\t\t\t// the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n\t\t\t\t\t// we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n\t\t\t\t\tif (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._searchRegex.lastIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Exit early if the regex matches the same range twice\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis._prevMatchStartIndex = matchStartIndex;\n\t\t\tthis._prevMatchLength = matchLength;\n\n\t\t\tif (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n\t\t\t\treturn m;\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn null;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5880, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch, ITextSnapshot, SearchData } from '../../model.js';\nimport { NodeColor, SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\n\nfunction createUintArray(arr: number[]): Uint32Array | Uint16Array {\n\tlet r;\n\tif (arr[arr.length - 1] < 65536) {\n\t\tr = new Uint16Array(arr.length);\n\t} else {\n\t\tr = new Uint32Array(arr.length);\n\t}\n\tr.set(arr, 0);\n\treturn r;\n}\n\nclass LineStarts {\n\tconstructor(\n\t\tpublic readonly lineStarts: Uint32Array | Uint16Array | number[],\n\t\tpublic readonly cr: number,\n\t\tpublic readonly lf: number,\n\t\tpublic readonly crlf: number,\n\t\tpublic readonly isBasicASCII: boolean\n\t) { }\n}\n\nexport function createLineStartsFast(str: string, readonly: boolean = true): Uint32Array | Uint16Array | number[] {\n\tconst r: number[] = [0];\n\tlet rLength = 1;\n\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tr[rLength++] = i + 1;\n\t\t}\n\t}\n\tif (readonly) {\n\t\treturn createUintArray(r);\n\t} else {\n\t\treturn r;\n\t}\n}\n\nexport function createLineStarts(r: number[], str: string): LineStarts {\n\tr.length = 0;\n\tr[0] = 0;\n\tlet rLength = 1;\n\tlet cr = 0, lf = 0, crlf = 0;\n\tlet isBasicASCII = true;\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tcrlf++;\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\tcr++;\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tlf++;\n\t\t\tr[rLength++] = i + 1;\n\t\t} else {\n\t\t\tif (isBasicASCII) {\n\t\t\t\tif (chr !== CharCode.Tab && (chr < 32 || chr > 126)) {\n\t\t\t\t\tisBasicASCII = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n\tr.length = 0;\n\n\treturn result;\n}\n\ninterface NodePosition {\n\t/**\n\t * Piece Index\n\t */\n\tnode: TreeNode;\n\t/**\n\t * remainder in current piece.\n\t*/\n\tremainder: number;\n\t/**\n\t * node start offset in document.\n\t */\n\tnodeStartOffset: number;\n}\n\ninterface BufferCursor {\n\t/**\n\t * Line number in current buffer\n\t */\n\tline: number;\n\t/**\n\t * Column number in current buffer\n\t */\n\tcolumn: number;\n}\n\nexport class Piece {\n\treadonly bufferIndex: number;\n\treadonly start: BufferCursor;\n\treadonly end: BufferCursor;\n\treadonly length: number;\n\treadonly lineFeedCnt: number;\n\n\tconstructor(bufferIndex: number, start: BufferCursor, end: BufferCursor, lineFeedCnt: number, length: number) {\n\t\tthis.bufferIndex = bufferIndex;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.lineFeedCnt = lineFeedCnt;\n\t\tthis.length = length;\n\t}\n}\n\nexport class StringBuffer {\n\tbuffer: string;\n\tlineStarts: Uint32Array | Uint16Array | number[];\n\n\tconstructor(buffer: string, lineStarts: Uint32Array | Uint16Array | number[]) {\n\t\tthis.buffer = buffer;\n\t\tthis.lineStarts = lineStarts;\n\t}\n}\n\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot implements ITextSnapshot {\n\tprivate readonly _pieces: Piece[];\n\tprivate _index: number;\n\tprivate readonly _tree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\n\tconstructor(tree: PieceTreeBase, BOM: string) {\n\t\tthis._pieces = [];\n\t\tthis._tree = tree;\n\t\tthis._BOM = BOM;\n\t\tthis._index = 0;\n\t\tif (tree.root !== SENTINEL) {\n\t\t\ttree.iterate(tree.root, node => {\n\t\t\t\tif (node !== SENTINEL) {\n\t\t\t\t\tthis._pieces.push(node.piece);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\n\tread(): string | null {\n\t\tif (this._pieces.length === 0) {\n\t\t\tif (this._index === 0) {\n\t\t\t\tthis._index++;\n\t\t\t\treturn this._BOM;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._index > this._pieces.length - 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._index === 0) {\n\t\t\treturn this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n\t\t}\n\t\treturn this._tree.getPieceContent(this._pieces[this._index++]);\n\t}\n}\n\ninterface CacheEntry {\n\tnode: TreeNode;\n\tnodeStartOffset: number;\n\tnodeStartLineNumber?: number;\n}\n\nclass PieceTreeSearchCache {\n\tprivate readonly _limit: number;\n\tprivate _cache: CacheEntry[];\n\n\tconstructor(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis._cache = [];\n\t}\n\n\tpublic get(offset: number): CacheEntry | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n\t\t\t\treturn nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic get2(lineNumber: number): { node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number } | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n\t\t\t\treturn <{ node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number }>nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic set(nodePosition: CacheEntry) {\n\t\tif (this._cache.length >= this._limit) {\n\t\t\tthis._cache.shift();\n\t\t}\n\t\tthis._cache.push(nodePosition);\n\t}\n\n\tpublic validate(offset: number) {\n\t\tlet hasInvalidVal = false;\n\t\tconst tmp: Array<CacheEntry | null> = this._cache;\n\t\tfor (let i = 0; i < tmp.length; i++) {\n\t\t\tconst nodePos = tmp[i]!;\n\t\t\tif (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n\t\t\t\ttmp[i] = null;\n\t\t\t\thasInvalidVal = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInvalidVal) {\n\t\t\tconst newArr: CacheEntry[] = [];\n\t\t\tfor (const entry of tmp) {\n\t\t\t\tif (entry !== null) {\n\t\t\t\t\tnewArr.push(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._cache = newArr;\n\t\t}\n\t}\n}\n\nexport class PieceTreeBase {\n\troot!: TreeNode;\n\tprotected _buffers!: StringBuffer[]; // 0 is change buffer, others are readonly original buffer.\n\tprotected _lineCnt!: number;\n\tprotected _length!: number;\n\tprotected _EOL!: '\\r\\n' | '\\n';\n\tprotected _EOLLength!: number;\n\tprotected _EOLNormalized!: boolean;\n\tprivate _lastChangeBufferPos!: BufferCursor;\n\tprivate _searchCache!: PieceTreeSearchCache;\n\tprivate _lastVisitedLine!: { lineNumber: number; value: string };\n\n\tconstructor(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis.create(chunks, eol, eolNormalized);\n\t}\n\n\tcreate(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis._buffers = [\n\t\t\tnew StringBuffer('', [0])\n\t\t];\n\t\tthis._lastChangeBufferPos = { line: 0, column: 0 };\n\t\tthis.root = SENTINEL;\n\t\tthis._lineCnt = 1;\n\t\tthis._length = 0;\n\t\tthis._EOL = eol;\n\t\tthis._EOLLength = eol.length;\n\t\tthis._EOLNormalized = eolNormalized;\n\n\t\tlet lastNode: TreeNode | null = null;\n\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\tif (chunks[i].buffer.length > 0) {\n\t\t\t\tif (!chunks[i].lineStarts) {\n\t\t\t\t\tchunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n\t\t\t\t}\n\n\t\t\t\tconst piece = new Piece(\n\t\t\t\t\ti + 1,\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] },\n\t\t\t\t\tchunks[i].lineStarts.length - 1,\n\t\t\t\t\tchunks[i].buffer.length\n\t\t\t\t);\n\t\t\t\tthis._buffers.push(chunks[i]);\n\t\t\t\tlastNode = this.rbInsertRight(lastNode, piece);\n\t\t\t}\n\t\t}\n\n\t\tthis._searchCache = new PieceTreeSearchCache(1);\n\t\tthis._lastVisitedLine = { lineNumber: 0, value: '' };\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n') {\n\t\tconst averageBufferSize = AverageBufferSize;\n\t\tconst min = averageBufferSize - Math.floor(averageBufferSize / 3);\n\t\tconst max = min * 2;\n\n\t\tlet tempChunk = '';\n\t\tlet tempChunkLen = 0;\n\t\tconst chunks: StringBuffer[] = [];\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tif (tempChunkLen <= min || tempChunkLen + len < max) {\n\t\t\t\ttempChunk += str;\n\t\t\t\ttempChunkLen += len;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// flush anyways\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t\ttempChunk = str;\n\t\t\ttempChunkLen = len;\n\t\t\treturn true;\n\t\t});\n\n\t\tif (tempChunkLen > 0) {\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t}\n\n\t\tthis.create(chunks, eol, true);\n\t}\n\n\t// #region Buffer API\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._EOL;\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._EOL = newEOL;\n\t\tthis._EOLLength = this._EOL.length;\n\t\tthis.normalizeEOL(newEOL);\n\t}\n\n\tpublic createSnapshot(BOM: string): ITextSnapshot {\n\t\treturn new PieceTreeSnapshot(this, BOM);\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\tlet leftLen = 0; // inorder\n\n\t\tlet x = this.root;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n\t\t\t\tleftLen += x.size_left;\n\t\t\t\t// lineNumber >= 2\n\t\t\t\tconst accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\treturn leftLen += accumualtedValInCurrentIndex + column - 1;\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tleftLen += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn leftLen;\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tlet x = this.root;\n\t\tlet lfCnt = 0;\n\t\tconst originalOffset = offset;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left !== 0 && x.size_left >= offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tconst out = this.getIndexOf(x, offset - x.size_left);\n\n\t\t\t\tlfCnt += x.lf_left + out.index;\n\n\t\t\t\tif (out.index === 0) {\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t}\n\n\t\t\t\treturn new Position(lfCnt + 1, out.remainder + 1);\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n\t\t\t\tif (x.right === SENTINEL) {\n\t\t\t\t\t// last node\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - offset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t} else {\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(1, 1);\n\t}\n\n\tpublic getValueInRange(range: Range, eol?: string): string {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n\t\tconst endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n\n\t\tconst value = this.getValueInRange2(startPosition, endPosition);\n\t\tif (eol) {\n\t\t\tif (eol !== this._EOL || !this._EOLNormalized) {\n\t\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t}\n\n\t\t\tif (eol === this.getEOL() && this._EOLNormalized) {\n\t\t\t\tif (eol === '\\r\\n') {\n\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic getValueInRange2(startPosition: NodePosition, endPosition: NodePosition): string {\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tconst node = startPosition.node;\n\t\t\tconst buffer = this._buffers[node.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\t\treturn buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n\t\t}\n\n\t\tlet x = startPosition.node;\n\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\tlet ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\tif (x === endPosition.node) {\n\t\t\t\tret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\tconst lines: string[] = [];\n\t\tlet linesLength = 0;\n\t\tlet currentLine = '';\n\t\tlet danglingCR = false;\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst piece = node.piece;\n\t\t\tlet pieceLength = piece.length;\n\t\t\tif (pieceLength === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[piece.bufferIndex].buffer;\n\t\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\n\t\t\tconst pieceStartLine = piece.start.line;\n\t\t\tconst pieceEndLine = piece.end.line;\n\t\t\tlet pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n\n\t\t\tif (danglingCR) {\n\t\t\t\tif (buffer.charCodeAt(pieceStartOffset) === CharCode.LineFeed) {\n\t\t\t\t\t// pretend the \\n was in the previous piece..\n\t\t\t\t\tpieceStartOffset++;\n\t\t\t\t\tpieceLength--;\n\t\t\t\t}\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t\tcurrentLine = '';\n\t\t\t\tdanglingCR = false;\n\t\t\t\tif (pieceLength === 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pieceStartLine === pieceEndLine) {\n\t\t\t\t// this piece has no new lines\n\t\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === CharCode.CarriageReturn) {\n\t\t\t\t\tdanglingCR = true;\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// add the text before the first line start in this piece\n\t\t\tcurrentLine += (\n\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n\t\t\t\t\t: buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t);\n\t\t\tlines[linesLength++] = currentLine;\n\n\t\t\tfor (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n\t\t\t\tcurrentLine = (\n\t\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t\t? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n\t\t\t\t\t\t: buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t\t);\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t}\n\n\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === CharCode.CarriageReturn) {\n\t\t\t\tdanglingCR = true;\n\t\t\t\tif (piece.end.column === 0) {\n\t\t\t\t\t// The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n\t\t\t\t\tlinesLength--;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tif (danglingCR) {\n\t\t\tlines[linesLength++] = currentLine;\n\t\t\tcurrentLine = '';\n\t\t}\n\n\t\tlines[linesLength++] = currentLine;\n\t\treturn lines;\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._length;\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lineCnt;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tif (this._lastVisitedLine.lineNumber === lineNumber) {\n\t\t\treturn this._lastVisitedLine.value;\n\t\t}\n\n\t\tthis._lastVisitedLine.lineNumber = lineNumber;\n\n\t\tif (lineNumber === this._lineCnt) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n\t\t} else if (this._EOLNormalized) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n\t\t} else {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n\t\t}\n\n\t\treturn this._lastVisitedLine.value;\n\t}\n\n\tprivate _getCharCode(nodePos: NodePosition): number {\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the char we want to fetch is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n\t\t\treturn buffer.buffer.charCodeAt(startOffset);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\n\t\t\treturn buffer.buffer.charCodeAt(targetOffset);\n\t\t}\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\tconst nodePos = this.nodeAt2(lineNumber, index + 1);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tif (lineNumber === this.getLineCount()) {\n\t\t\tconst startOffset = this.getOffsetAt(lineNumber, 1);\n\t\t\treturn this.getLength() - startOffset;\n\t\t}\n\t\treturn this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\tconst nodePos = this.nodeAt(offset);\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the offset is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode || matchingNode === SENTINEL) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n\t\t\treturn buffer.buffer.substring(startOffset, startOffset + matchingNode.piece.length);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\t\t\tconst targetEnd = startOffset + nodePos.node.piece.length;\n\t\t\treturn buffer.buffer.substring(targetOffset, targetEnd);\n\t\t}\n\t}\n\n\tpublic findMatchesInNode(node: TreeNode, searcher: Searcher, startLineNumber: number, startColumn: number, startCursor: BufferCursor, endCursor: BufferCursor, searchData: SearchData, captureMatches: boolean, limitResultCount: number, resultLen: number, result: FindMatch[]) {\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\tconst start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n\t\tconst end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tconst ret: BufferCursor = { line: 0, column: 0 };\n\t\tlet searchText: string;\n\t\tlet offsetInBuffer: (offset: number) => number;\n\n\t\tif (searcher._wordSeparators) {\n\t\t\tsearchText = buffer.buffer.substring(start, end);\n\t\t\toffsetInBuffer = (offset: number) => offset + start;\n\t\t\tsearcher.reset(0);\n\t\t} else {\n\t\t\tsearchText = buffer.buffer;\n\t\t\toffsetInBuffer = (offset: number) => offset;\n\t\t\tsearcher.reset(start);\n\t\t}\n\n\t\tdo {\n\t\t\tm = searcher.next(searchText);\n\n\t\t\tif (m) {\n\t\t\t\tif (offsetInBuffer(m.index) >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tthis.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n\t\t\t\tconst lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n\t\t\t\tconst retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n\t\t\t\tconst retEndColumn = retStartColumn + m[0].length;\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n\t\t\t\tif (offsetInBuffer(m.index) + m[0].length >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn resultLen;\n\t}\n\n\tpublic findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tlet startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\t\tif (startPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\t\tif (endPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tlet start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\tconst end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tthis.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\t\treturn result;\n\t\t}\n\n\t\tlet startLineNumber = searchRange.startLineNumber;\n\n\t\tlet currentNode = startPosition.node;\n\t\twhile (currentNode !== endPosition.node) {\n\t\t\tconst lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n\t\t\tif (lineBreakCnt >= 1) {\n\t\t\t\t// last line break position\n\t\t\t\tconst lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n\t\t\t\tconst startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n\t\t\t\tconst nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n\t\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\t\t\tresultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tstartLineNumber += lineBreakCnt;\n\t\t\t}\n\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\t// search for the remaining content\n\t\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\n\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tstartLineNumber++;\n\t\t\tstartPosition = this.nodeAt2(startLineNumber, 1);\n\t\t\tcurrentNode = startPosition.node;\n\t\t\tstart = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\t}\n\n\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\tresultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\treturn result;\n\t}\n\n\tprivate _findMatchesInLine(searchData: SearchData, searcher: Searcher, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\t// #endregion\n\n\t// #region Piece Table\n\tpublic insert(offset: number, value: string, eolNormalized: boolean = false): void {\n\t\tthis._EOLNormalized = this._EOLNormalized && eolNormalized;\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (this.root !== SENTINEL) {\n\t\t\tconst { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n\t\t\tconst piece = node.piece;\n\t\t\tconst bufferIndex = piece.bufferIndex;\n\t\t\tconst insertPosInBuffer = this.positionInBuffer(node, remainder);\n\t\t\tif (node.piece.bufferIndex === 0 &&\n\t\t\t\tpiece.end.line === this._lastChangeBufferPos.line &&\n\t\t\t\tpiece.end.column === this._lastChangeBufferPos.column &&\n\t\t\t\t(nodeStartOffset + piece.length === offset) &&\n\t\t\t\tvalue.length < AverageBufferSize\n\t\t\t) {\n\t\t\t\t// changed buffer\n\t\t\t\tthis.appendToNode(node, value);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nodeStartOffset === offset) {\n\t\t\t\tthis.insertContentToNodeLeft(value, node);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t} else if (nodeStartOffset + node.piece.length > offset) {\n\t\t\t\t// we are inserting into the middle of a node.\n\t\t\t\tconst nodesToDel: TreeNode[] = [];\n\t\t\t\tlet newRightPiece = new Piece(\n\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\tinsertPosInBuffer,\n\t\t\t\t\tpiece.end,\n\t\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end),\n\t\t\t\t\tthis.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer)\n\t\t\t\t);\n\n\t\t\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\t\t\tconst headOfRight = this.nodeCharCodeAt(node, remainder);\n\n\t\t\t\t\tif (headOfRight === 10 /** \\n */) {\n\t\t\t\t\t\tconst newStart: BufferCursor = { line: newRightPiece.start.line + 1, column: 0 };\n\t\t\t\t\t\tnewRightPiece = new Piece(\n\t\t\t\t\t\t\tnewRightPiece.bufferIndex,\n\t\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\t\tnewRightPiece.end,\n\t\t\t\t\t\t\tthis.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end),\n\t\t\t\t\t\t\tnewRightPiece.length - 1\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tvalue += '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// reuse node for content before insertion point.\n\t\t\t\tif (this.shouldCheckCRLF() && this.startWithLF(value)) {\n\t\t\t\t\tconst tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\t\t\t\t\tif (tailOfLeft === 13 /** \\r */) {\n\t\t\t\t\t\tconst previousPos = this.positionInBuffer(node, remainder - 1);\n\t\t\t\t\t\tthis.deleteNodeTail(node, previousPos);\n\t\t\t\t\t\tvalue = '\\r' + value;\n\n\t\t\t\t\t\tif (node.piece.length === 0) {\n\t\t\t\t\t\t\tnodesToDel.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t}\n\n\t\t\t\tconst newPieces = this.createNewPieces(value);\n\t\t\t\tif (newRightPiece.length > 0) {\n\t\t\t\t\tthis.rbInsertRight(node, newRightPiece);\n\t\t\t\t}\n\n\t\t\t\tlet tmpNode = node;\n\t\t\t\tfor (let k = 0; k < newPieces.length; k++) {\n\t\t\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t\t\t}\n\t\t\t\tthis.deleteNodes(nodesToDel);\n\t\t\t} else {\n\t\t\t\tthis.insertContentToNodeRight(value, node);\n\t\t\t}\n\t\t} else {\n\t\t\t// insert new node\n\t\t\tconst pieces = this.createNewPieces(value);\n\t\t\tlet node = this.rbInsertLeft(null, pieces[0]);\n\n\t\t\tfor (let k = 1; k < pieces.length; k++) {\n\t\t\t\tnode = this.rbInsertRight(node, pieces[k]);\n\t\t\t}\n\t\t}\n\n\t\t// todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tpublic delete(offset: number, cnt: number): void {\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (cnt <= 0 || this.root === SENTINEL) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst startPosition = this.nodeAt(offset);\n\t\tconst endPosition = this.nodeAt(offset + cnt);\n\t\tconst startNode = startPosition.node;\n\t\tconst endNode = endPosition.node;\n\n\t\tif (startNode === endNode) {\n\t\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\t\tconst endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n\n\t\t\tif (startPosition.nodeStartOffset === offset) {\n\t\t\t\tif (cnt === startNode.piece.length) { // delete node\n\t\t\t\t\tconst next = startNode.next();\n\t\t\t\t\trbDelete(this, startNode);\n\t\t\t\t\tthis.validateCRLFWithPrevNode(next);\n\t\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.deleteNodeHead(startNode, endSplitPosInBuffer);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t\tthis.validateCRLFWithPrevNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n\t\t\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\t\t\tthis.validateCRLFWithNextNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// delete content in the middle, this node will be splitted to nodes\n\t\t\tthis.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n\t\t\tthis.computeBufferMetadata();\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodesToDel: TreeNode[] = [];\n\n\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\tthis._searchCache.validate(offset);\n\t\tif (startNode.piece.length === 0) {\n\t\t\tnodesToDel.push(startNode);\n\t\t}\n\n\t\t// update last touched node\n\t\tconst endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n\t\tthis.deleteNodeHead(endNode, endSplitPosInBuffer);\n\t\tif (endNode.piece.length === 0) {\n\t\t\tnodesToDel.push(endNode);\n\t\t}\n\n\t\t// delete nodes in between\n\t\tconst secondNode = startNode.next();\n\t\tfor (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n\t\t\tnodesToDel.push(node);\n\t\t}\n\n\t\tconst prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n\t\tthis.deleteNodes(nodesToDel);\n\t\tthis.validateCRLFWithNextNode(prev);\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tprivate insertContentToNodeLeft(value: string, node: TreeNode) {\n\t\t// we are inserting content to the beginning of node\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n\t\t\t// move `\\n` to new node.\n\n\t\t\tconst piece = node.piece;\n\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\tconst nPiece = new Piece(\n\t\t\t\tpiece.bufferIndex,\n\t\t\t\tnewStart,\n\t\t\t\tpiece.end,\n\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, newStart, piece.end),\n\t\t\t\tpiece.length - 1\n\t\t\t);\n\n\t\t\tnode.piece = nPiece;\n\n\t\t\tvalue += '\\n';\n\t\t\tupdateTreeMetadata(this, node, -1, -1);\n\n\t\t\tif (node.piece.length === 0) {\n\t\t\t\tnodesToDel.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tlet newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\t\tfor (let k = newPieces.length - 2; k >= 0; k--) {\n\t\t\tnewNode = this.rbInsertLeft(newNode, newPieces[k]);\n\t\t}\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t\tthis.deleteNodes(nodesToDel);\n\t}\n\n\tprivate insertContentToNodeRight(value: string, node: TreeNode) {\n\t\t// we are inserting to the right of this node.\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\t// move \\n to the new node.\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tconst newNode = this.rbInsertRight(node, newPieces[0]);\n\t\tlet tmpNode = newNode;\n\n\t\tfor (let k = 1; k < newPieces.length; k++) {\n\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t}\n\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate positionInBuffer(node: TreeNode, remainder: number): BufferCursor;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret: BufferCursor): null;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret?: BufferCursor): BufferCursor | null {\n\t\tconst piece = node.piece;\n\t\tconst bufferIndex = node.piece.bufferIndex;\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\n\t\tconst startOffset = lineStarts[piece.start.line] + piece.start.column;\n\n\t\tconst offset = startOffset + remainder;\n\n\t\t// binary search offset between startOffset and endOffset\n\t\tlet low = piece.start.line;\n\t\tlet high = piece.end.line;\n\n\t\tlet mid: number = 0;\n\t\tlet midStop: number = 0;\n\t\tlet midStart: number = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\t\t\tmidStart = lineStarts[mid];\n\n\t\t\tif (mid === high) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmidStop = lineStarts[mid + 1];\n\n\t\t\tif (offset < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (offset >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret.line = mid;\n\t\t\tret.column = offset - midStart;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tline: mid,\n\t\t\tcolumn: offset - midStart\n\t\t};\n\t}\n\n\tprivate getLineFeedCnt(bufferIndex: number, start: BufferCursor, end: BufferCursor): number {\n\t\t// we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n\t\t// now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n\t\tif (end.column === 0) {\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\tif (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst nextLineStartOffset = lineStarts[end.line + 1];\n\t\tconst endOffset = lineStarts[end.line] + end.column;\n\t\tif (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n\t\t\treturn end.line - start.line;\n\t\t}\n\t\t// endOffset + 1 === nextLineStartOffset\n\t\t// character at endOffset is \\n, so we check the character before first\n\t\t// if character at endOffset is \\r, end.column is 0 and we can't get here.\n\t\tconst previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\t\tconst buffer = this._buffers[bufferIndex].buffer;\n\n\t\tif (buffer.charCodeAt(previousCharOffset) === 13) {\n\t\t\treturn end.line - start.line + 1;\n\t\t} else {\n\t\t\treturn end.line - start.line;\n\t\t}\n\t}\n\n\tprivate offsetInBuffer(bufferIndex: number, cursor: BufferCursor): number {\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\treturn lineStarts[cursor.line] + cursor.column;\n\t}\n\n\tprivate deleteNodes(nodes: TreeNode[]): void {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\trbDelete(this, nodes[i]);\n\t\t}\n\t}\n\n\tprivate createNewPieces(text: string): Piece[] {\n\t\tif (text.length > AverageBufferSize) {\n\t\t\t// the content is large, operations like substring, charCode becomes slow\n\t\t\t// so here we split it into smaller chunks, just like what we did for CR/LF normalization\n\t\t\tconst newPieces: Piece[] = [];\n\t\t\twhile (text.length > AverageBufferSize) {\n\t\t\t\tconst lastChar = text.charCodeAt(AverageBufferSize - 1);\n\t\t\t\tlet splitText;\n\t\t\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize - 1);\n\t\t\t\t\ttext = text.substring(AverageBufferSize - 1);\n\t\t\t\t} else {\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize);\n\t\t\t\t\ttext = text.substring(AverageBufferSize);\n\t\t\t\t}\n\n\t\t\t\tconst lineStarts = createLineStartsFast(splitText);\n\t\t\t\tnewPieces.push(new Piece(\n\t\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\t\tlineStarts.length - 1,\n\t\t\t\t\tsplitText.length\n\t\t\t\t));\n\t\t\t\tthis._buffers.push(new StringBuffer(splitText, lineStarts));\n\t\t\t}\n\n\t\t\tconst lineStarts = createLineStartsFast(text);\n\t\t\tnewPieces.push(new Piece(\n\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t{ line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\tlineStarts.length - 1,\n\t\t\t\ttext.length\n\t\t\t));\n\t\t\tthis._buffers.push(new StringBuffer(text, lineStarts));\n\n\t\t\treturn newPieces;\n\t\t}\n\n\t\tlet startOffset = this._buffers[0].buffer.length;\n\t\tconst lineStarts = createLineStartsFast(text, false);\n\n\t\tlet start = this._lastChangeBufferPos;\n\t\tif (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n\t\t\t&& startOffset !== 0\n\t\t\t&& this.startWithLF(text)\n\t\t\t&& this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n\t\t) {\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n\t\t\tstart = this._lastChangeBufferPos;\n\n\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\tlineStarts[i] += startOffset + 1;\n\t\t\t}\n\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += '_' + text;\n\t\t\tstartOffset += 1;\n\t\t} else {\n\t\t\tif (startOffset !== 0) {\n\t\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\t\tlineStarts[i] += startOffset;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += text;\n\t\t}\n\n\t\tconst endOffset = this._buffers[0].buffer.length;\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n\t\tconst endPos = { line: endIndex, column: endColumn };\n\t\tconst newPiece = new Piece(\n\t\t\t0, /** todo@peng */\n\t\t\tstart,\n\t\t\tendPos,\n\t\t\tthis.getLineFeedCnt(0, start, endPos),\n\t\t\tendOffset - startOffset\n\t\t);\n\t\tthis._lastChangeBufferPos = endPos;\n\t\treturn [newPiece];\n\t}\n\n\tpublic getLineRawContent(lineNumber: number, endOffset: number = 0): string {\n\t\tlet x = this.root;\n\n\t\tlet ret = '';\n\t\tconst cache = this._searchCache.get2(lineNumber);\n\t\tif (cache) {\n\t\t\tx = cache.node;\n\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\tif (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t} else {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tlet nodeStartOffset = 0;\n\t\t\tconst originalLineNumber = lineNumber;\n\t\t\twhile (x !== SENTINEL) {\n\t\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\t\tx = x.left;\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\t\tthis._searchCache.set({\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tnodeStartOffset,\n\t\t\t\t\t\tnodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n\t\t\t\t\t});\n\n\t\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains end column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\tret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tprivate computeBufferMetadata() {\n\t\tlet x = this.root;\n\n\t\tlet lfCnt = 1;\n\t\tlet len = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\t\t\tlen += x.size_left + x.piece.length;\n\t\t\tx = x.right;\n\t\t}\n\n\t\tthis._lineCnt = lfCnt;\n\t\tthis._length = len;\n\t\tthis._searchCache.validate(this._length);\n\t}\n\n\t// #region node operations\n\tprivate getIndexOf(node: TreeNode, accumulatedValue: number): { index: number; remainder: number } {\n\t\tconst piece = node.piece;\n\t\tconst pos = this.positionInBuffer(node, accumulatedValue);\n\t\tconst lineCnt = pos.line - piece.start.line;\n\n\t\tif (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n\t\t\t// we are checking the end of this node, so a CRLF check is necessary.\n\t\t\tconst realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\t\t\tif (realLineCnt !== lineCnt) {\n\t\t\t\t// aha yes, CRLF\n\t\t\t\treturn { index: realLineCnt, remainder: 0 };\n\t\t\t}\n\t\t}\n\n\t\treturn { index: lineCnt, remainder: pos.column };\n\t}\n\n\tprivate getAccumulatedValue(node: TreeNode, index: number) {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst piece = node.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst expectedLineStartIndex = piece.start.line + index + 1;\n\t\tif (expectedLineStartIndex > piece.end.line) {\n\t\t\treturn lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n\t\t} else {\n\t\t\treturn lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n\t\t}\n\t}\n\n\tprivate deleteNodeTail(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\n\t\tconst newEnd = pos;\n\t\tconst newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = newEndOffset - originalEndOffset;\n\t\tconst newLength = piece.length + size_delta;\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate deleteNodeHead(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\n\t\tconst newStart = pos;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\tconst newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = originalStartOffset - newStartOffset;\n\t\tconst newLength = piece.length + size_delta;\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tpiece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate shrinkNode(node: TreeNode, start: BufferCursor, end: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalStartPos = piece.start;\n\t\tconst originalEndPos = piece.end;\n\n\t\t// old piece, originalStartPos, start\n\t\tconst oldLength = piece.length;\n\t\tconst oldLFCnt = piece.lineFeedCnt;\n\t\tconst newEnd = start;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\t\tconst newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n\n\t\t// new right piece, end, originalEndPos\n\t\tconst newPiece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tend,\n\t\t\toriginalEndPos,\n\t\t\tthis.getLineFeedCnt(piece.bufferIndex, end, originalEndPos),\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end)\n\t\t);\n\n\t\tconst newNode = this.rbInsertRight(node, newPiece);\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate appendToNode(node: TreeNode, value: string): void {\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n\t\tconst startOffset = this._buffers[0].buffer.length;\n\t\tthis._buffers[0].buffer += value;\n\t\tconst lineStarts = createLineStartsFast(value, false);\n\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\tlineStarts[i] += startOffset;\n\t\t}\n\t\tif (hitCRLF) {\n\t\t\tconst prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\t\t\t(<number[]>this._buffers[0].lineStarts).pop();\n\t\t\t// _lastChangeBufferPos is already wrong\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n\t\t}\n\n\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n\t\tconst newEnd = { line: endIndex, column: endColumn };\n\t\tconst newLength = node.piece.length + value.length;\n\t\tconst oldLineFeedCnt = node.piece.lineFeedCnt;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n\t\tconst lf_delta = newLineFeedCnt - oldLineFeedCnt;\n\n\t\tnode.piece = new Piece(\n\t\t\tnode.piece.bufferIndex,\n\t\t\tnode.piece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tthis._lastChangeBufferPos = newEnd;\n\t\tupdateTreeMetadata(this, node, value.length, lf_delta);\n\t}\n\n\tprivate nodeAt(offset: number): NodePosition {\n\t\tlet x = this.root;\n\t\tconst cache = this._searchCache.get(offset);\n\t\tif (cache) {\n\t\t\treturn {\n\t\t\t\tnode: cache.node,\n\t\t\t\tnodeStartOffset: cache.nodeStartOffset,\n\t\t\t\tremainder: offset - cache.nodeStartOffset\n\t\t\t};\n\t\t}\n\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left > offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\tconst ret = {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: offset - x.size_left,\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t\tthis._searchCache.set(ret);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeAt2(lineNumber: number, column: number): NodePosition {\n\t\tlet x = this.root;\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\tnodeStartOffset += x.size_left;\n\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tif (prevAccumualtedValue + column - 1 <= x.piece.length) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: prevAccumualtedValue + column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length - prevAccumualtedValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains position.column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (x.piece.length >= column - 1) {\n\t\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeCharCodeAt(node: TreeNode, offset: number): number {\n\t\tif (node.piece.lineFeedCnt < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n\t\treturn buffer.buffer.charCodeAt(newOffset);\n\t}\n\n\tprivate offsetOfNode(node: TreeNode): number {\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet pos = node.size_left;\n\t\twhile (node !== this.root) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tpos += node.parent.size_left + node.parent.piece.length;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// #endregion\n\n\t// #region CRLF\n\tprivate shouldCheckCRLF() {\n\t\treturn !(this._EOLNormalized && this._EOL === '\\n');\n\t}\n\n\tprivate startWithLF(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(0) === 10;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst piece = val.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst line = piece.start.line;\n\t\tconst startOffset = lineStarts[line] + piece.start.column;\n\t\tif (line === lineStarts.length - 1) {\n\t\t\t// last line, so there is no line feed at the end of this line\n\t\t\treturn false;\n\t\t}\n\t\tconst nextLineOffset = lineStarts[line + 1];\n\t\tif (nextLineOffset > startOffset + 1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n\t}\n\n\tprivate endWithCR(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(val.length - 1) === 13;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n\t}\n\n\tprivate validateCRLFWithPrevNode(nextNode: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n\t\t\tconst node = nextNode.prev();\n\t\t\tif (this.endWithCR(node)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate validateCRLFWithNextNode(node: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(node)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fixCRLF(prev: TreeNode, next: TreeNode) {\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\t// update node\n\t\tconst lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n\t\tlet newEnd: BufferCursor;\n\t\tif (prev.piece.end.column === 0) {\n\t\t\t// it means, last line ends with \\r, not \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n\t\t} else {\n\t\t\t// \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n\t\t}\n\n\t\tconst prevNewLength = prev.piece.length - 1;\n\t\tconst prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n\t\tprev.piece = new Piece(\n\t\t\tprev.piece.bufferIndex,\n\t\t\tprev.piece.start,\n\t\t\tnewEnd,\n\t\t\tprevNewLFCnt,\n\t\t\tprevNewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, prev, - 1, -1);\n\t\tif (prev.piece.length === 0) {\n\t\t\tnodesToDel.push(prev);\n\t\t}\n\n\t\t// update nextNode\n\t\tconst newStart: BufferCursor = { line: next.piece.start.line + 1, column: 0 };\n\t\tconst newLength = next.piece.length - 1;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n\t\tnext.piece = new Piece(\n\t\t\tnext.piece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tnext.piece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, next, - 1, -1);\n\t\tif (next.piece.length === 0) {\n\t\t\tnodesToDel.push(next);\n\t\t}\n\n\t\t// create new piece which contains \\r\\n\n\t\tconst pieces = this.createNewPieces('\\r\\n');\n\t\tthis.rbInsertRight(prev, pieces[0]);\n\t\t// delete empty nodes\n\n\t\tfor (let i = 0; i < nodesToDel.length; i++) {\n\t\t\trbDelete(this, nodesToDel[i]);\n\t\t}\n\t}\n\n\tprivate adjustCarriageReturnFromNext(value: string, node: TreeNode): boolean {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\t// move `\\n` forward\n\t\t\t\tvalue += '\\n';\n\n\t\t\t\tif (nextNode.piece.length === 1) {\n\t\t\t\t\trbDelete(this, nextNode);\n\t\t\t\t} else {\n\n\t\t\t\t\tconst piece = nextNode.piece;\n\t\t\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\t\t\tconst newLength = piece.length - 1;\n\t\t\t\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\t\t\t\tnextNode.piece = new Piece(\n\t\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\tpiece.end,\n\t\t\t\t\t\tnewLineFeedCnt,\n\t\t\t\t\t\tnewLength\n\t\t\t\t\t);\n\n\t\t\t\t\tupdateTreeMetadata(this, nextNode, -1, -1);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// #endregion\n\n\t// #endregion\n\n\t// #region Tree operations\n\titerate(node: TreeNode, callback: (node: TreeNode) => boolean): boolean {\n\t\tif (node === SENTINEL) {\n\t\t\treturn callback(SENTINEL);\n\t\t}\n\n\t\tconst leftRet = this.iterate(node.left, callback);\n\t\tif (!leftRet) {\n\t\t\treturn leftRet;\n\t\t}\n\n\t\treturn callback(node) && this.iterate(node.right, callback);\n\t}\n\n\tprivate getNodeContent(node: TreeNode) {\n\t\tif (node === SENTINEL) {\n\t\t\treturn '';\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst piece = node.piece;\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\tgetPieceContent(piece: Piece) {\n\t\tconst buffer = this._buffers[piece.bufferIndex];\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b    <----   a    b\n\t *                         /\n\t *                        z\n\t */\n\tprivate rbInsertRight(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tconst x = this.root;\n\t\tif (x === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.right === SENTINEL) {\n\t\t\tnode!.right = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst nextNode = leftest(node!.right);\n\t\t\tnextNode.left = z;\n\t\t\tz.parent = nextNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b     ---->   a    b\n\t *                       \\\n\t *                        z\n\t */\n\tprivate rbInsertLeft(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tif (this.root === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.left === SENTINEL) {\n\t\t\tnode!.left = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst prevNode = righttest(node!.left); // a\n\t\t\tprevNode.right = z;\n\t\t\tz.parent = prevNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\t// #endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch, ITextSnapshot, SearchData } from '../../model.js';\nimport { NodeColor, SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\n\nfunction createUintArray(arr: number[]): Uint32Array | Uint16Array {\n\tlet r;\n\tif (arr[arr.length - 1] < 65536) {\n\t\tr = new Uint16Array(arr.length);\n\t} else {\n\t\tr = new Uint32Array(arr.length);\n\t}\n\tr.set(arr, 0);\n\treturn r;\n}\n\nclass LineStarts {\n\tconstructor(\n\t\tpublic readonly lineStarts: Uint32Array | Uint16Array | number[],\n\t\tpublic readonly cr: number,\n\t\tpublic readonly lf: number,\n\t\tpublic readonly crlf: number,\n\t\tpublic readonly isBasicASCII: boolean\n\t) { }\n}\n\nexport function createLineStartsFast(str: string, readonly: boolean = true): Uint32Array | Uint16Array | number[] {\n\tconst r: number[] = [0];\n\tlet rLength = 1;\n\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tr[rLength++] = i + 1;\n\t\t}\n\t}\n\tif (readonly) {\n\t\treturn createUintArray(r);\n\t} else {\n\t\treturn r;\n\t}\n}\n\nexport function createLineStarts(r: number[], str: string): LineStarts {\n\tr.length = 0;\n\tr[0] = 0;\n\tlet rLength = 1;\n\tlet cr = 0, lf = 0, crlf = 0;\n\tlet isBasicASCII = true;\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tcrlf++;\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\tcr++;\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tlf++;\n\t\t\tr[rLength++] = i + 1;\n\t\t} else {\n\t\t\tif (isBasicASCII) {\n\t\t\t\tif (chr !== CharCode.Tab && (chr < 32 || chr > 126)) {\n\t\t\t\t\tisBasicASCII = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n\tr.length = 0;\n\n\treturn result;\n}\n\ninterface NodePosition {\n\t/**\n\t * Piece Index\n\t */\n\tnode: TreeNode;\n\t/**\n\t * remainder in current piece.\n\t*/\n\tremainder: number;\n\t/**\n\t * node start offset in document.\n\t */\n\tnodeStartOffset: number;\n}\n\ninterface BufferCursor {\n\t/**\n\t * Line number in current buffer\n\t */\n\tline: number;\n\t/**\n\t * Column number in current buffer\n\t */\n\tcolumn: number;\n}\n\nexport class Piece {\n\treadonly bufferIndex: number;\n\treadonly start: BufferCursor;\n\treadonly end: BufferCursor;\n\treadonly length: number;\n\treadonly lineFeedCnt: number;\n\n\tconstructor(bufferIndex: number, start: BufferCursor, end: BufferCursor, lineFeedCnt: number, length: number) {\n\t\tthis.bufferIndex = bufferIndex;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.lineFeedCnt = lineFeedCnt;\n\t\tthis.length = length;\n\t}\n}\n\nexport class StringBuffer {\n\tbuffer: string;\n\tlineStarts: Uint32Array | Uint16Array | number[];\n\n\tconstructor(buffer: string, lineStarts: Uint32Array | Uint16Array | number[]) {\n\t\tthis.buffer = buffer;\n\t\tthis.lineStarts = lineStarts;\n\t}\n}\n\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot implements ITextSnapshot {\n\tprivate readonly _pieces: Piece[];\n\tprivate _index: number;\n\tprivate readonly _tree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\n\tconstructor(tree: PieceTreeBase, BOM: string) {\n\t\tthis._pieces = [];\n\t\tthis._tree = tree;\n\t\tthis._BOM = BOM;\n\t\tthis._index = 0;\n\t\tif (tree.root !== SENTINEL) {\n\t\t\ttree.iterate(tree.root, node => {\n\t\t\t\tif (node !== SENTINEL) {\n\t\t\t\t\tthis._pieces.push(node.piece);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\n\tread(): string | null {\n\t\tif (this._pieces.length === 0) {\n\t\t\tif (this._index === 0) {\n\t\t\t\tthis._index++;\n\t\t\t\treturn this._BOM;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._index > this._pieces.length - 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._index === 0) {\n\t\t\treturn this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n\t\t}\n\t\treturn this._tree.getPieceContent(this._pieces[this._index++]);\n\t}\n}\n\ninterface CacheEntry {\n\tnode: TreeNode;\n\tnodeStartOffset: number;\n\tnodeStartLineNumber?: number;\n}\n\nclass PieceTreeSearchCache {\n\tprivate readonly _limit: number;\n\tprivate _cache: CacheEntry[];\n\n\tconstructor(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis._cache = [];\n\t}\n\n\tpublic get(offset: number): CacheEntry | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n\t\t\t\treturn nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic get2(lineNumber: number): { node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number } | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tconst nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n\t\t\t\treturn <{ node: TreeNode; nodeStartOffset: number; nodeStartLineNumber: number }>nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic set(nodePosition: CacheEntry) {\n\t\tif (this._cache.length >= this._limit) {\n\t\t\tthis._cache.shift();\n\t\t}\n\t\tthis._cache.push(nodePosition);\n\t}\n\n\tpublic validate(offset: number) {\n\t\tlet hasInvalidVal = false;\n\t\tconst tmp: Array<CacheEntry | null> = this._cache;\n\t\tfor (let i = 0; i < tmp.length; i++) {\n\t\t\tconst nodePos = tmp[i]!;\n\t\t\tif (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n\t\t\t\ttmp[i] = null;\n\t\t\t\thasInvalidVal = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInvalidVal) {\n\t\t\tconst newArr: CacheEntry[] = [];\n\t\t\tfor (const entry of tmp) {\n\t\t\t\tif (entry !== null) {\n\t\t\t\t\tnewArr.push(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._cache = newArr;\n\t\t}\n\t}\n}\n\nexport class PieceTreeBase {\n\troot!: TreeNode;\n\tprotected _buffers!: StringBuffer[]; // 0 is change buffer, others are readonly original buffer.\n\tprotected _lineCnt!: number;\n\tprotected _length!: number;\n\tprotected _EOL!: '\\r\\n' | '\\n';\n\tprotected _EOLLength!: number;\n\tprotected _EOLNormalized!: boolean;\n\tprivate _lastChangeBufferPos!: BufferCursor;\n\tprivate _searchCache!: PieceTreeSearchCache;\n\tprivate _lastVisitedLine!: { lineNumber: number; value: string };\n\n\tconstructor(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis.create(chunks, eol, eolNormalized);\n\t}\n\n\tcreate(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis._buffers = [\n\t\t\tnew StringBuffer('', [0])\n\t\t];\n\t\tthis._lastChangeBufferPos = { line: 0, column: 0 };\n\t\tthis.root = SENTINEL;\n\t\tthis._lineCnt = 1;\n\t\tthis._length = 0;\n\t\tthis._EOL = eol;\n\t\tthis._EOLLength = eol.length;\n\t\tthis._EOLNormalized = eolNormalized;\n\n\t\tlet lastNode: TreeNode | null = null;\n\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\tif (chunks[i].buffer.length > 0) {\n\t\t\t\tif (!chunks[i].lineStarts) {\n\t\t\t\t\tchunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n\t\t\t\t}\n\n\t\t\t\tconst piece = new Piece(\n\t\t\t\t\ti + 1,\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] },\n\t\t\t\t\tchunks[i].lineStarts.length - 1,\n\t\t\t\t\tchunks[i].buffer.length\n\t\t\t\t);\n\t\t\t\tthis._buffers.push(chunks[i]);\n\t\t\t\tlastNode = this.rbInsertRight(lastNode, piece);\n\t\t\t}\n\t\t}\n\n\t\tthis._searchCache = new PieceTreeSearchCache(1);\n\t\tthis._lastVisitedLine = { lineNumber: 0, value: '' };\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n') {\n\t\tconst averageBufferSize = AverageBufferSize;\n\t\tconst min = averageBufferSize - Math.floor(averageBufferSize / 3);\n\t\tconst max = min * 2;\n\n\t\tlet tempChunk = '';\n\t\tlet tempChunkLen = 0;\n\t\tconst chunks: StringBuffer[] = [];\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tconst str = this.getNodeContent(node);\n\t\t\tconst len = str.length;\n\t\t\tif (tempChunkLen <= min || tempChunkLen + len < max) {\n\t\t\t\ttempChunk += str;\n\t\t\t\ttempChunkLen += len;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// flush anyways\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t\ttempChunk = str;\n\t\t\ttempChunkLen = len;\n\t\t\treturn true;\n\t\t});\n\n\t\tif (tempChunkLen > 0) {\n\t\t\tconst text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t}\n\n\t\tthis.create(chunks, eol, true);\n\t}\n\n\t// #region Buffer API\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._EOL;\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._EOL = newEOL;\n\t\tthis._EOLLength = this._EOL.length;\n\t\tthis.normalizeEOL(newEOL);\n\t}\n\n\tpublic createSnapshot(BOM: string): ITextSnapshot {\n\t\treturn new PieceTreeSnapshot(this, BOM);\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\tlet leftLen = 0; // inorder\n\n\t\tlet x = this.root;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n\t\t\t\tleftLen += x.size_left;\n\t\t\t\t// lineNumber >= 2\n\t\t\t\tconst accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\treturn leftLen += accumualtedValInCurrentIndex + column - 1;\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tleftLen += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn leftLen;\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tlet x = this.root;\n\t\tlet lfCnt = 0;\n\t\tconst originalOffset = offset;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left !== 0 && x.size_left >= offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tconst out = this.getIndexOf(x, offset - x.size_left);\n\n\t\t\t\tlfCnt += x.lf_left + out.index;\n\n\t\t\t\tif (out.index === 0) {\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t}\n\n\t\t\t\treturn new Position(lfCnt + 1, out.remainder + 1);\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n\t\t\t\tif (x.right === SENTINEL) {\n\t\t\t\t\t// last node\n\t\t\t\t\tconst lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tconst column = originalOffset - offset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t} else {\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(1, 1);\n\t}\n\n\tpublic getValueInRange(range: Range, eol?: string): string {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n\t\tconst endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n\n\t\tconst value = this.getValueInRange2(startPosition, endPosition);\n\t\tif (eol) {\n\t\t\tif (eol !== this._EOL || !this._EOLNormalized) {\n\t\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t}\n\n\t\t\tif (eol === this.getEOL() && this._EOLNormalized) {\n\t\t\t\tif (eol === '\\r\\n') {\n\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic getValueInRange2(startPosition: NodePosition, endPosition: NodePosition): string {\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tconst node = startPosition.node;\n\t\t\tconst buffer = this._buffers[node.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\t\treturn buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n\t\t}\n\n\t\tlet x = startPosition.node;\n\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\tlet ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\tif (x === endPosition.node) {\n\t\t\t\tret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\tconst lines: string[] = [];\n\t\tlet linesLength = 0;\n\t\tlet currentLine = '';\n\t\tlet danglingCR = false;\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst piece = node.piece;\n\t\t\tlet pieceLength = piece.length;\n\t\t\tif (pieceLength === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[piece.bufferIndex].buffer;\n\t\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\n\t\t\tconst pieceStartLine = piece.start.line;\n\t\t\tconst pieceEndLine = piece.end.line;\n\t\t\tlet pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n\n\t\t\tif (danglingCR) {\n\t\t\t\tif (buffer.charCodeAt(pieceStartOffset) === CharCode.LineFeed) {\n\t\t\t\t\t// pretend the \\n was in the previous piece..\n\t\t\t\t\tpieceStartOffset++;\n\t\t\t\t\tpieceLength--;\n\t\t\t\t}\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t\tcurrentLine = '';\n\t\t\t\tdanglingCR = false;\n\t\t\t\tif (pieceLength === 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pieceStartLine === pieceEndLine) {\n\t\t\t\t// this piece has no new lines\n\t\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === CharCode.CarriageReturn) {\n\t\t\t\t\tdanglingCR = true;\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine += buffer.substr(pieceStartOffset, pieceLength);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// add the text before the first line start in this piece\n\t\t\tcurrentLine += (\n\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n\t\t\t\t\t: buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t);\n\t\t\tlines[linesLength++] = currentLine;\n\n\t\t\tfor (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n\t\t\t\tcurrentLine = (\n\t\t\t\t\tthis._EOLNormalized\n\t\t\t\t\t\t? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n\t\t\t\t\t\t: buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '')\n\t\t\t\t);\n\t\t\t\tlines[linesLength++] = currentLine;\n\t\t\t}\n\n\t\t\tif (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === CharCode.CarriageReturn) {\n\t\t\t\tdanglingCR = true;\n\t\t\t\tif (piece.end.column === 0) {\n\t\t\t\t\t// The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n\t\t\t\t\tlinesLength--;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\n\t\tif (danglingCR) {\n\t\t\tlines[linesLength++] = currentLine;\n\t\t\tcurrentLine = '';\n\t\t}\n\n\t\tlines[linesLength++] = currentLine;\n\t\treturn lines;\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._length;\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lineCnt;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tif (this._lastVisitedLine.lineNumber === lineNumber) {\n\t\t\treturn this._lastVisitedLine.value;\n\t\t}\n\n\t\tthis._lastVisitedLine.lineNumber = lineNumber;\n\n\t\tif (lineNumber === this._lineCnt) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n\t\t} else if (this._EOLNormalized) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n\t\t} else {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n\t\t}\n\n\t\treturn this._lastVisitedLine.value;\n\t}\n\n\tprivate _getCharCode(nodePos: NodePosition): number {\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the char we want to fetch is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n\t\t\treturn buffer.buffer.charCodeAt(startOffset);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\n\t\t\treturn buffer.buffer.charCodeAt(targetOffset);\n\t\t}\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\tconst nodePos = this.nodeAt2(lineNumber, index + 1);\n\t\treturn this._getCharCode(nodePos);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tif (lineNumber === this.getLineCount()) {\n\t\t\tconst startOffset = this.getOffsetAt(lineNumber, 1);\n\t\t\treturn this.getLength() - startOffset;\n\t\t}\n\t\treturn this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\tconst nodePos = this.nodeAt(offset);\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the offset is at the head of next node.\n\t\t\tconst matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode || matchingNode === SENTINEL) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tconst buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n\t\t\treturn buffer.buffer.substring(startOffset, startOffset + matchingNode.piece.length);\n\t\t} else {\n\t\t\tconst buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tconst startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\t\t\tconst targetOffset = startOffset + nodePos.remainder;\n\t\t\tconst targetEnd = startOffset + nodePos.node.piece.length;\n\t\t\treturn buffer.buffer.substring(targetOffset, targetEnd);\n\t\t}\n\t}\n\n\tpublic findMatchesInNode(node: TreeNode, searcher: Searcher, startLineNumber: number, startColumn: number, startCursor: BufferCursor, endCursor: BufferCursor, searchData: SearchData, captureMatches: boolean, limitResultCount: number, resultLen: number, result: FindMatch[]) {\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\tconst start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n\t\tconst end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tconst ret: BufferCursor = { line: 0, column: 0 };\n\t\tlet searchText: string;\n\t\tlet offsetInBuffer: (offset: number) => number;\n\n\t\tif (searcher._wordSeparators) {\n\t\t\tsearchText = buffer.buffer.substring(start, end);\n\t\t\toffsetInBuffer = (offset: number) => offset + start;\n\t\t\tsearcher.reset(0);\n\t\t} else {\n\t\t\tsearchText = buffer.buffer;\n\t\t\toffsetInBuffer = (offset: number) => offset;\n\t\t\tsearcher.reset(start);\n\t\t}\n\n\t\tdo {\n\t\t\tm = searcher.next(searchText);\n\n\t\t\tif (m) {\n\t\t\t\tif (offsetInBuffer(m.index) >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tthis.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n\t\t\t\tconst lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n\t\t\t\tconst retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n\t\t\t\tconst retEndColumn = retStartColumn + m[0].length;\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n\t\t\t\tif (offsetInBuffer(m.index) + m[0].length >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn resultLen;\n\t}\n\n\tpublic findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tlet startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\t\tif (startPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tconst endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\t\tif (endPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tlet start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\tconst end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tthis.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\t\treturn result;\n\t\t}\n\n\t\tlet startLineNumber = searchRange.startLineNumber;\n\n\t\tlet currentNode = startPosition.node;\n\t\twhile (currentNode !== endPosition.node) {\n\t\t\tconst lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n\t\t\tif (lineBreakCnt >= 1) {\n\t\t\t\t// last line break position\n\t\t\t\tconst lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n\t\t\t\tconst startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n\t\t\t\tconst nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n\t\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\t\t\tresultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tstartLineNumber += lineBreakCnt;\n\t\t\t}\n\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\t// search for the remaining content\n\t\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\n\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tstartLineNumber++;\n\t\t\tstartPosition = this.nodeAt2(startLineNumber, 1);\n\t\t\tcurrentNode = startPosition.node;\n\t\t\tstart = this.positionInBuffer(startPosition.node, startPosition.remainder);\n\t\t}\n\n\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\tconst startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\tresultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\treturn result;\n\t}\n\n\tprivate _findMatchesInLine(searchData: SearchData, searcher: Searcher, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\t// #endregion\n\n\t// #region Piece Table\n\tpublic insert(offset: number, value: string, eolNormalized: boolean = false): void {\n\t\tthis._EOLNormalized = this._EOLNormalized && eolNormalized;\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (this.root !== SENTINEL) {\n\t\t\tconst { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n\t\t\tconst piece = node.piece;\n\t\t\tconst bufferIndex = piece.bufferIndex;\n\t\t\tconst insertPosInBuffer = this.positionInBuffer(node, remainder);\n\t\t\tif (node.piece.bufferIndex === 0 &&\n\t\t\t\tpiece.end.line === this._lastChangeBufferPos.line &&\n\t\t\t\tpiece.end.column === this._lastChangeBufferPos.column &&\n\t\t\t\t(nodeStartOffset + piece.length === offset) &&\n\t\t\t\tvalue.length < AverageBufferSize\n\t\t\t) {\n\t\t\t\t// changed buffer\n\t\t\t\tthis.appendToNode(node, value);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nodeStartOffset === offset) {\n\t\t\t\tthis.insertContentToNodeLeft(value, node);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t} else if (nodeStartOffset + node.piece.length > offset) {\n\t\t\t\t// we are inserting into the middle of a node.\n\t\t\t\tconst nodesToDel: TreeNode[] = [];\n\t\t\t\tlet newRightPiece = new Piece(\n\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\tinsertPosInBuffer,\n\t\t\t\t\tpiece.end,\n\t\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end),\n\t\t\t\t\tthis.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer)\n\t\t\t\t);\n\n\t\t\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\t\t\tconst headOfRight = this.nodeCharCodeAt(node, remainder);\n\n\t\t\t\t\tif (headOfRight === 10 /** \\n */) {\n\t\t\t\t\t\tconst newStart: BufferCursor = { line: newRightPiece.start.line + 1, column: 0 };\n\t\t\t\t\t\tnewRightPiece = new Piece(\n\t\t\t\t\t\t\tnewRightPiece.bufferIndex,\n\t\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\t\tnewRightPiece.end,\n\t\t\t\t\t\t\tthis.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end),\n\t\t\t\t\t\t\tnewRightPiece.length - 1\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tvalue += '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// reuse node for content before insertion point.\n\t\t\t\tif (this.shouldCheckCRLF() && this.startWithLF(value)) {\n\t\t\t\t\tconst tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\t\t\t\t\tif (tailOfLeft === 13 /** \\r */) {\n\t\t\t\t\t\tconst previousPos = this.positionInBuffer(node, remainder - 1);\n\t\t\t\t\t\tthis.deleteNodeTail(node, previousPos);\n\t\t\t\t\t\tvalue = '\\r' + value;\n\n\t\t\t\t\t\tif (node.piece.length === 0) {\n\t\t\t\t\t\t\tnodesToDel.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t}\n\n\t\t\t\tconst newPieces = this.createNewPieces(value);\n\t\t\t\tif (newRightPiece.length > 0) {\n\t\t\t\t\tthis.rbInsertRight(node, newRightPiece);\n\t\t\t\t}\n\n\t\t\t\tlet tmpNode = node;\n\t\t\t\tfor (let k = 0; k < newPieces.length; k++) {\n\t\t\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t\t\t}\n\t\t\t\tthis.deleteNodes(nodesToDel);\n\t\t\t} else {\n\t\t\t\tthis.insertContentToNodeRight(value, node);\n\t\t\t}\n\t\t} else {\n\t\t\t// insert new node\n\t\t\tconst pieces = this.createNewPieces(value);\n\t\t\tlet node = this.rbInsertLeft(null, pieces[0]);\n\n\t\t\tfor (let k = 1; k < pieces.length; k++) {\n\t\t\t\tnode = this.rbInsertRight(node, pieces[k]);\n\t\t\t}\n\t\t}\n\n\t\t// todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tpublic delete(offset: number, cnt: number): void {\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (cnt <= 0 || this.root === SENTINEL) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst startPosition = this.nodeAt(offset);\n\t\tconst endPosition = this.nodeAt(offset + cnt);\n\t\tconst startNode = startPosition.node;\n\t\tconst endNode = endPosition.node;\n\n\t\tif (startNode === endNode) {\n\t\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\t\tconst endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n\n\t\t\tif (startPosition.nodeStartOffset === offset) {\n\t\t\t\tif (cnt === startNode.piece.length) { // delete node\n\t\t\t\t\tconst next = startNode.next();\n\t\t\t\t\trbDelete(this, startNode);\n\t\t\t\t\tthis.validateCRLFWithPrevNode(next);\n\t\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.deleteNodeHead(startNode, endSplitPosInBuffer);\n\t\t\t\tthis._searchCache.validate(offset);\n\t\t\t\tthis.validateCRLFWithPrevNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n\t\t\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\t\t\tthis.validateCRLFWithNextNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// delete content in the middle, this node will be splitted to nodes\n\t\t\tthis.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n\t\t\tthis.computeBufferMetadata();\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodesToDel: TreeNode[] = [];\n\n\t\tconst startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\tthis._searchCache.validate(offset);\n\t\tif (startNode.piece.length === 0) {\n\t\t\tnodesToDel.push(startNode);\n\t\t}\n\n\t\t// update last touched node\n\t\tconst endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n\t\tthis.deleteNodeHead(endNode, endSplitPosInBuffer);\n\t\tif (endNode.piece.length === 0) {\n\t\t\tnodesToDel.push(endNode);\n\t\t}\n\n\t\t// delete nodes in between\n\t\tconst secondNode = startNode.next();\n\t\tfor (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n\t\t\tnodesToDel.push(node);\n\t\t}\n\n\t\tconst prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n\t\tthis.deleteNodes(nodesToDel);\n\t\tthis.validateCRLFWithNextNode(prev);\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tprivate insertContentToNodeLeft(value: string, node: TreeNode) {\n\t\t// we are inserting content to the beginning of node\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n\t\t\t// move `\\n` to new node.\n\n\t\t\tconst piece = node.piece;\n\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\tconst nPiece = new Piece(\n\t\t\t\tpiece.bufferIndex,\n\t\t\t\tnewStart,\n\t\t\t\tpiece.end,\n\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, newStart, piece.end),\n\t\t\t\tpiece.length - 1\n\t\t\t);\n\n\t\t\tnode.piece = nPiece;\n\n\t\t\tvalue += '\\n';\n\t\t\tupdateTreeMetadata(this, node, -1, -1);\n\n\t\t\tif (node.piece.length === 0) {\n\t\t\t\tnodesToDel.push(node);\n\t\t\t}\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tlet newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\t\tfor (let k = newPieces.length - 2; k >= 0; k--) {\n\t\t\tnewNode = this.rbInsertLeft(newNode, newPieces[k]);\n\t\t}\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t\tthis.deleteNodes(nodesToDel);\n\t}\n\n\tprivate insertContentToNodeRight(value: string, node: TreeNode) {\n\t\t// we are inserting to the right of this node.\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\t// move \\n to the new node.\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst newPieces = this.createNewPieces(value);\n\t\tconst newNode = this.rbInsertRight(node, newPieces[0]);\n\t\tlet tmpNode = newNode;\n\n\t\tfor (let k = 1; k < newPieces.length; k++) {\n\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t}\n\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate positionInBuffer(node: TreeNode, remainder: number): BufferCursor;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret: BufferCursor): null;\n\tprivate positionInBuffer(node: TreeNode, remainder: number, ret?: BufferCursor): BufferCursor | null {\n\t\tconst piece = node.piece;\n\t\tconst bufferIndex = node.piece.bufferIndex;\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\n\t\tconst startOffset = lineStarts[piece.start.line] + piece.start.column;\n\n\t\tconst offset = startOffset + remainder;\n\n\t\t// binary search offset between startOffset and endOffset\n\t\tlet low = piece.start.line;\n\t\tlet high = piece.end.line;\n\n\t\tlet mid: number = 0;\n\t\tlet midStop: number = 0;\n\t\tlet midStart: number = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\t\t\tmidStart = lineStarts[mid];\n\n\t\t\tif (mid === high) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmidStop = lineStarts[mid + 1];\n\n\t\t\tif (offset < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (offset >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret.line = mid;\n\t\t\tret.column = offset - midStart;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tline: mid,\n\t\t\tcolumn: offset - midStart\n\t\t};\n\t}\n\n\tprivate getLineFeedCnt(bufferIndex: number, start: BufferCursor, end: BufferCursor): number {\n\t\t// we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n\t\t// now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n\t\tif (end.column === 0) {\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\tif (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tconst nextLineStartOffset = lineStarts[end.line + 1];\n\t\tconst endOffset = lineStarts[end.line] + end.column;\n\t\tif (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n\t\t\treturn end.line - start.line;\n\t\t}\n\t\t// endOffset + 1 === nextLineStartOffset\n\t\t// character at endOffset is \\n, so we check the character before first\n\t\t// if character at endOffset is \\r, end.column is 0 and we can't get here.\n\t\tconst previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\t\tconst buffer = this._buffers[bufferIndex].buffer;\n\n\t\tif (buffer.charCodeAt(previousCharOffset) === 13) {\n\t\t\treturn end.line - start.line + 1;\n\t\t} else {\n\t\t\treturn end.line - start.line;\n\t\t}\n\t}\n\n\tprivate offsetInBuffer(bufferIndex: number, cursor: BufferCursor): number {\n\t\tconst lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\treturn lineStarts[cursor.line] + cursor.column;\n\t}\n\n\tprivate deleteNodes(nodes: TreeNode[]): void {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\trbDelete(this, nodes[i]);\n\t\t}\n\t}\n\n\tprivate createNewPieces(text: string): Piece[] {\n\t\tif (text.length > AverageBufferSize) {\n\t\t\t// the content is large, operations like substring, charCode becomes slow\n\t\t\t// so here we split it into smaller chunks, just like what we did for CR/LF normalization\n\t\t\tconst newPieces: Piece[] = [];\n\t\t\twhile (text.length > AverageBufferSize) {\n\t\t\t\tconst lastChar = text.charCodeAt(AverageBufferSize - 1);\n\t\t\t\tlet splitText;\n\t\t\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize - 1);\n\t\t\t\t\ttext = text.substring(AverageBufferSize - 1);\n\t\t\t\t} else {\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize);\n\t\t\t\t\ttext = text.substring(AverageBufferSize);\n\t\t\t\t}\n\n\t\t\t\tconst lineStarts = createLineStartsFast(splitText);\n\t\t\t\tnewPieces.push(new Piece(\n\t\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\t\tlineStarts.length - 1,\n\t\t\t\t\tsplitText.length\n\t\t\t\t));\n\t\t\t\tthis._buffers.push(new StringBuffer(splitText, lineStarts));\n\t\t\t}\n\n\t\t\tconst lineStarts = createLineStartsFast(text);\n\t\t\tnewPieces.push(new Piece(\n\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t{ line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\tlineStarts.length - 1,\n\t\t\t\ttext.length\n\t\t\t));\n\t\t\tthis._buffers.push(new StringBuffer(text, lineStarts));\n\n\t\t\treturn newPieces;\n\t\t}\n\n\t\tlet startOffset = this._buffers[0].buffer.length;\n\t\tconst lineStarts = createLineStartsFast(text, false);\n\n\t\tlet start = this._lastChangeBufferPos;\n\t\tif (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n\t\t\t&& startOffset !== 0\n\t\t\t&& this.startWithLF(text)\n\t\t\t&& this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n\t\t) {\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n\t\t\tstart = this._lastChangeBufferPos;\n\n\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\tlineStarts[i] += startOffset + 1;\n\t\t\t}\n\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += '_' + text;\n\t\t\tstartOffset += 1;\n\t\t} else {\n\t\t\tif (startOffset !== 0) {\n\t\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\t\tlineStarts[i] += startOffset;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += text;\n\t\t}\n\n\t\tconst endOffset = this._buffers[0].buffer.length;\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n\t\tconst endPos = { line: endIndex, column: endColumn };\n\t\tconst newPiece = new Piece(\n\t\t\t0, /** todo@peng */\n\t\t\tstart,\n\t\t\tendPos,\n\t\t\tthis.getLineFeedCnt(0, start, endPos),\n\t\t\tendOffset - startOffset\n\t\t);\n\t\tthis._lastChangeBufferPos = endPos;\n\t\treturn [newPiece];\n\t}\n\n\tpublic getLineRawContent(lineNumber: number, endOffset: number = 0): string {\n\t\tlet x = this.root;\n\n\t\tlet ret = '';\n\t\tconst cache = this._searchCache.get2(lineNumber);\n\t\tif (cache) {\n\t\t\tx = cache.node;\n\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\tif (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t} else {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tlet nodeStartOffset = 0;\n\t\t\tconst originalLineNumber = lineNumber;\n\t\t\twhile (x !== SENTINEL) {\n\t\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\t\tx = x.left;\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\t\tthis._searchCache.set({\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tnodeStartOffset,\n\t\t\t\t\t\tnodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n\t\t\t\t\t});\n\n\t\t\t\t\treturn buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\t\tconst prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\t\tret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains end column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tconst buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\tret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tconst startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tprivate computeBufferMetadata() {\n\t\tlet x = this.root;\n\n\t\tlet lfCnt = 1;\n\t\tlet len = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\t\t\tlen += x.size_left + x.piece.length;\n\t\t\tx = x.right;\n\t\t}\n\n\t\tthis._lineCnt = lfCnt;\n\t\tthis._length = len;\n\t\tthis._searchCache.validate(this._length);\n\t}\n\n\t// #region node operations\n\tprivate getIndexOf(node: TreeNode, accumulatedValue: number): { index: number; remainder: number } {\n\t\tconst piece = node.piece;\n\t\tconst pos = this.positionInBuffer(node, accumulatedValue);\n\t\tconst lineCnt = pos.line - piece.start.line;\n\n\t\tif (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n\t\t\t// we are checking the end of this node, so a CRLF check is necessary.\n\t\t\tconst realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\t\t\tif (realLineCnt !== lineCnt) {\n\t\t\t\t// aha yes, CRLF\n\t\t\t\treturn { index: realLineCnt, remainder: 0 };\n\t\t\t}\n\t\t}\n\n\t\treturn { index: lineCnt, remainder: pos.column };\n\t}\n\n\tprivate getAccumulatedValue(node: TreeNode, index: number) {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst piece = node.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst expectedLineStartIndex = piece.start.line + index + 1;\n\t\tif (expectedLineStartIndex > piece.end.line) {\n\t\t\treturn lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n\t\t} else {\n\t\t\treturn lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n\t\t}\n\t}\n\n\tprivate deleteNodeTail(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\n\t\tconst newEnd = pos;\n\t\tconst newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = newEndOffset - originalEndOffset;\n\t\tconst newLength = piece.length + size_delta;\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate deleteNodeHead(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\n\t\tconst newStart = pos;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\tconst newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = originalStartOffset - newStartOffset;\n\t\tconst newLength = piece.length + size_delta;\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tpiece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tprivate shrinkNode(node: TreeNode, start: BufferCursor, end: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalStartPos = piece.start;\n\t\tconst originalEndPos = piece.end;\n\n\t\t// old piece, originalStartPos, start\n\t\tconst oldLength = piece.length;\n\t\tconst oldLFCnt = piece.lineFeedCnt;\n\t\tconst newEnd = start;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\t\tconst newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n\n\t\t// new right piece, end, originalEndPos\n\t\tconst newPiece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tend,\n\t\t\toriginalEndPos,\n\t\t\tthis.getLineFeedCnt(piece.bufferIndex, end, originalEndPos),\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end)\n\t\t);\n\n\t\tconst newNode = this.rbInsertRight(node, newPiece);\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tprivate appendToNode(node: TreeNode, value: string): void {\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n\t\tconst startOffset = this._buffers[0].buffer.length;\n\t\tthis._buffers[0].buffer += value;\n\t\tconst lineStarts = createLineStartsFast(value, false);\n\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\tlineStarts[i] += startOffset;\n\t\t}\n\t\tif (hitCRLF) {\n\t\t\tconst prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\t\t\t(<number[]>this._buffers[0].lineStarts).pop();\n\t\t\t// _lastChangeBufferPos is already wrong\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n\t\t}\n\n\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n\t\tconst newEnd = { line: endIndex, column: endColumn };\n\t\tconst newLength = node.piece.length + value.length;\n\t\tconst oldLineFeedCnt = node.piece.lineFeedCnt;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n\t\tconst lf_delta = newLineFeedCnt - oldLineFeedCnt;\n\n\t\tnode.piece = new Piece(\n\t\t\tnode.piece.bufferIndex,\n\t\t\tnode.piece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tthis._lastChangeBufferPos = newEnd;\n\t\tupdateTreeMetadata(this, node, value.length, lf_delta);\n\t}\n\n\tprivate nodeAt(offset: number): NodePosition {\n\t\tlet x = this.root;\n\t\tconst cache = this._searchCache.get(offset);\n\t\tif (cache) {\n\t\t\treturn {\n\t\t\t\tnode: cache.node,\n\t\t\t\tnodeStartOffset: cache.nodeStartOffset,\n\t\t\t\tremainder: offset - cache.nodeStartOffset\n\t\t\t};\n\t\t}\n\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left > offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\tconst ret = {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: offset - x.size_left,\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t\tthis._searchCache.set(ret);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeAt2(lineNumber: number, column: number): NodePosition {\n\t\tlet x = this.root;\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\tnodeStartOffset += x.size_left;\n\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\tconst prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tif (prevAccumualtedValue + column - 1 <= x.piece.length) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: prevAccumualtedValue + column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length - prevAccumualtedValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains position.column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tconst accumulatedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(column - 1, accumulatedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (x.piece.length >= column - 1) {\n\t\t\t\t\tconst nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tprivate nodeCharCodeAt(node: TreeNode, offset: number): number {\n\t\tif (node.piece.lineFeedCnt < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n\t\treturn buffer.buffer.charCodeAt(newOffset);\n\t}\n\n\tprivate offsetOfNode(node: TreeNode): number {\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet pos = node.size_left;\n\t\twhile (node !== this.root) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tpos += node.parent.size_left + node.parent.piece.length;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// #endregion\n\n\t// #region CRLF\n\tprivate shouldCheckCRLF() {\n\t\treturn !(this._EOLNormalized && this._EOL === '\\n');\n\t}\n\n\tprivate startWithLF(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(0) === 10;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst piece = val.piece;\n\t\tconst lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tconst line = piece.start.line;\n\t\tconst startOffset = lineStarts[line] + piece.start.column;\n\t\tif (line === lineStarts.length - 1) {\n\t\t\t// last line, so there is no line feed at the end of this line\n\t\t\treturn false;\n\t\t}\n\t\tconst nextLineOffset = lineStarts[line + 1];\n\t\tif (nextLineOffset > startOffset + 1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n\t}\n\n\tprivate endWithCR(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(val.length - 1) === 13;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n\t}\n\n\tprivate validateCRLFWithPrevNode(nextNode: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n\t\t\tconst node = nextNode.prev();\n\t\t\tif (this.endWithCR(node)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate validateCRLFWithNextNode(node: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(node)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fixCRLF(prev: TreeNode, next: TreeNode) {\n\t\tconst nodesToDel: TreeNode[] = [];\n\t\t// update node\n\t\tconst lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n\t\tlet newEnd: BufferCursor;\n\t\tif (prev.piece.end.column === 0) {\n\t\t\t// it means, last line ends with \\r, not \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n\t\t} else {\n\t\t\t// \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n\t\t}\n\n\t\tconst prevNewLength = prev.piece.length - 1;\n\t\tconst prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n\t\tprev.piece = new Piece(\n\t\t\tprev.piece.bufferIndex,\n\t\t\tprev.piece.start,\n\t\t\tnewEnd,\n\t\t\tprevNewLFCnt,\n\t\t\tprevNewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, prev, - 1, -1);\n\t\tif (prev.piece.length === 0) {\n\t\t\tnodesToDel.push(prev);\n\t\t}\n\n\t\t// update nextNode\n\t\tconst newStart: BufferCursor = { line: next.piece.start.line + 1, column: 0 };\n\t\tconst newLength = next.piece.length - 1;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n\t\tnext.piece = new Piece(\n\t\t\tnext.piece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tnext.piece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, next, - 1, -1);\n\t\tif (next.piece.length === 0) {\n\t\t\tnodesToDel.push(next);\n\t\t}\n\n\t\t// create new piece which contains \\r\\n\n\t\tconst pieces = this.createNewPieces('\\r\\n');\n\t\tthis.rbInsertRight(prev, pieces[0]);\n\t\t// delete empty nodes\n\n\t\tfor (let i = 0; i < nodesToDel.length; i++) {\n\t\t\trbDelete(this, nodesToDel[i]);\n\t\t}\n\t}\n\n\tprivate adjustCarriageReturnFromNext(value: string, node: TreeNode): boolean {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\tconst nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\t// move `\\n` forward\n\t\t\t\tvalue += '\\n';\n\n\t\t\t\tif (nextNode.piece.length === 1) {\n\t\t\t\t\trbDelete(this, nextNode);\n\t\t\t\t} else {\n\n\t\t\t\t\tconst piece = nextNode.piece;\n\t\t\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\t\t\tconst newLength = piece.length - 1;\n\t\t\t\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\t\t\t\tnextNode.piece = new Piece(\n\t\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\tpiece.end,\n\t\t\t\t\t\tnewLineFeedCnt,\n\t\t\t\t\t\tnewLength\n\t\t\t\t\t);\n\n\t\t\t\t\tupdateTreeMetadata(this, nextNode, -1, -1);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// #endregion\n\n\t// #endregion\n\n\t// #region Tree operations\n\titerate(node: TreeNode, callback: (node: TreeNode) => boolean): boolean {\n\t\tif (node === SENTINEL) {\n\t\t\treturn callback(SENTINEL);\n\t\t}\n\n\t\tconst leftRet = this.iterate(node.left, callback);\n\t\tif (!leftRet) {\n\t\t\treturn leftRet;\n\t\t}\n\n\t\treturn callback(node) && this.iterate(node.right, callback);\n\t}\n\n\tprivate getNodeContent(node: TreeNode) {\n\t\tif (node === SENTINEL) {\n\t\t\treturn '';\n\t\t}\n\t\tconst buffer = this._buffers[node.piece.bufferIndex];\n\t\tconst piece = node.piece;\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\tgetPieceContent(piece: Piece) {\n\t\tconst buffer = this._buffers[piece.bufferIndex];\n\t\tconst startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tconst endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tconst currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b    <----   a    b\n\t *                         /\n\t *                        z\n\t */\n\tprivate rbInsertRight(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tconst x = this.root;\n\t\tif (x === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.right === SENTINEL) {\n\t\t\tnode!.right = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst nextNode = leftest(node!.right);\n\t\t\tnextNode.left = z;\n\t\t\tz.parent = nextNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b     ---->   a    b\n\t *                       \\\n\t *                        z\n\t */\n\tprivate rbInsertLeft(node: TreeNode | null, p: Piece): TreeNode {\n\t\tconst z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tif (this.root === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.left === SENTINEL) {\n\t\t\tnode!.left = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tconst prevNode = righttest(node!.left); // a\n\t\t\tprevNode.right = z;\n\t\t\tz.parent = prevNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\t// #endregion\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 7376, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult, EndOfLinePreference, FindMatch, IInternalModelContentChange, ISingleEditOperationIdentifier, ITextBuffer, ITextSnapshot, ValidAnnotatedEditOperation, IValidEditOperation, SearchData } from '../../model.js';\nimport { PieceTreeBase, StringBuffer } from './pieceTreeBase.js';\nimport { countEOL, StringEOL } from '../../core/misc/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\n\nexport interface IValidatedEditOperation {\n\tsortIndex: number;\n\tidentifier: ISingleEditOperationIdentifier | null;\n\trange: Range;\n\trangeOffset: number;\n\trangeLength: number;\n\ttext: string;\n\teolCount: number;\n\tfirstLineLength: number;\n\tlastLineLength: number;\n\tforceMoveMarkers: boolean;\n\tisAutoWhitespaceEdit: boolean;\n}\n\ninterface IReverseSingleEditOperation extends IValidEditOperation {\n\tsortIndex: number;\n}\n\nexport class PieceTreeTextBuffer extends Disposable implements ITextBuffer {\n\tprivate _pieceTree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\tprivate _mightContainRTL: boolean;\n\tprivate _mightContainUnusualLineTerminators: boolean;\n\tprivate _mightContainNonBasicASCII: boolean;\n\n\tprivate readonly _onDidChangeContent: Emitter<void> = this._register(new Emitter<void>());\n\n\tconstructor(chunks: StringBuffer[], BOM: string, eol: '\\r\\n' | '\\n', containsRTL: boolean, containsUnusualLineTerminators: boolean, isBasicASCII: boolean, eolNormalized: boolean) {\n\t\tsuper();\n\t\tthis._BOM = BOM;\n\t\tthis._mightContainNonBasicASCII = !isBasicASCII;\n\t\tthis._mightContainRTL = containsRTL;\n\t\tthis._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n\t\tthis._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n\t}\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._mightContainRTL;\n\t}\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._mightContainUnusualLineTerminators;\n\t}\n\tpublic resetMightContainUnusualLineTerminators(): void {\n\t\tthis._mightContainUnusualLineTerminators = false;\n\t}\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._mightContainNonBasicASCII;\n\t}\n\tpublic getBOM(): string {\n\t\treturn this._BOM;\n\t}\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._pieceTree.getEOL();\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean): ITextSnapshot {\n\t\treturn this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\treturn this._pieceTree.getOffsetAt(lineNumber, column);\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\treturn this._pieceTree.getPositionAt(offset);\n\t}\n\n\tpublic getRangeAt(start: number, length: number): Range {\n\t\tconst end = start + length;\n\t\tconst startPosition = this.getPositionAt(start);\n\t\tconst endPosition = this.getPositionAt(end);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tpublic getValueInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): string {\n\t\tif (range.isEmpty()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst lineEnding = this._getEndOfLine(eol);\n\t\treturn this._pieceTree.getValueInRange(range, lineEnding);\n\t}\n\n\tpublic getValueLengthInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (range.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn (range.endColumn - range.startColumn);\n\t\t}\n\n\t\tconst startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t// offsets use the text EOL, so we need to compensate for length differences\n\t\t// if the requested EOL doesn't match the text EOL\n\t\tlet eolOffsetCompensation = 0;\n\t\tconst desiredEOL = this._getEndOfLine(eol);\n\t\tconst actualEOL = this.getEOL();\n\t\tif (desiredEOL.length !== actualEOL.length) {\n\t\t\tconst delta = desiredEOL.length - actualEOL.length;\n\t\t\tconst eolCount = range.endLineNumber - range.startLineNumber;\n\t\t\teolOffsetCompensation = delta * eolCount;\n\t\t}\n\n\t\treturn endOffset - startOffset + eolOffsetCompensation;\n\t}\n\n\tpublic getCharacterCountInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (this._mightContainNonBasicASCII) {\n\t\t\t// we must count by iterating\n\n\t\t\tlet result = 0;\n\n\t\t\tconst fromLineNumber = range.startLineNumber;\n\t\t\tconst toLineNumber = range.endLineNumber;\n\t\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\t\t\t\tconst fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n\t\t\t\tconst toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n\n\t\t\t\tfor (let offset = fromOffset; offset < toOffset; offset++) {\n\t\t\t\t\tif (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t\toffset = offset + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.getValueLengthInRange(range, eol);\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\treturn this._pieceTree.getNearestChunk(offset);\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._pieceTree.getLength();\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._pieceTree.getLineCount();\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._pieceTree.getLinesContent();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._pieceTree.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\treturn this._pieceTree.getLineCharCode(lineNumber, index);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\treturn this._pieceTree.getLineLength(lineNumber);\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 1;\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 2;\n\t}\n\n\tprivate _getEndOfLine(eol: EndOfLinePreference): string {\n\t\tswitch (eol) {\n\t\t\tcase EndOfLinePreference.LF:\n\t\t\t\treturn '\\n';\n\t\t\tcase EndOfLinePreference.CRLF:\n\t\t\t\treturn '\\r\\n';\n\t\t\tcase EndOfLinePreference.TextDefined:\n\t\t\t\treturn this.getEOL();\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown EOL preference');\n\t\t}\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._pieceTree.setEOL(newEOL);\n\t}\n\n\tpublic applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult {\n\t\tlet mightContainRTL = this._mightContainRTL;\n\t\tlet mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n\t\tlet mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n\t\tlet canReduceOperations = true;\n\n\t\tlet operations: IValidatedEditOperation[] = [];\n\t\tfor (let i = 0; i < rawOperations.length; i++) {\n\t\t\tconst op = rawOperations[i];\n\t\t\tif (canReduceOperations && op._isTracked) {\n\t\t\t\tcanReduceOperations = false;\n\t\t\t}\n\t\t\tconst validatedRange = op.range;\n\t\t\tif (op.text) {\n\t\t\t\tlet textMightContainNonBasicASCII = true;\n\t\t\t\tif (!mightContainNonBasicASCII) {\n\t\t\t\t\ttextMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n\t\t\t\t\tmightContainNonBasicASCII = textMightContainNonBasicASCII;\n\t\t\t\t}\n\t\t\t\tif (!mightContainRTL && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains RTL\n\t\t\t\t\tmightContainRTL = strings.containsRTL(op.text);\n\t\t\t\t}\n\t\t\t\tif (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains unusual line terminators\n\t\t\t\t\tmightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet validText = '';\n\t\t\tlet eolCount = 0;\n\t\t\tlet firstLineLength = 0;\n\t\t\tlet lastLineLength = 0;\n\t\t\tif (op.text) {\n\t\t\t\tlet strEOL: StringEOL;\n\t\t\t\t[eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n\n\t\t\t\tconst bufferEOL = this.getEOL();\n\t\t\t\tconst expectedStrEOL = (bufferEOL === '\\r\\n' ? StringEOL.CRLF : StringEOL.LF);\n\t\t\t\tif (strEOL === StringEOL.Unknown || strEOL === expectedStrEOL) {\n\t\t\t\t\tvalidText = op.text;\n\t\t\t\t} else {\n\t\t\t\t\tvalidText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations[i] = {\n\t\t\t\tsortIndex: i,\n\t\t\t\tidentifier: op.identifier || null,\n\t\t\t\trange: validatedRange,\n\t\t\t\trangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n\t\t\t\trangeLength: this.getValueLengthInRange(validatedRange),\n\t\t\t\ttext: validText,\n\t\t\t\teolCount: eolCount,\n\t\t\t\tfirstLineLength: firstLineLength,\n\t\t\t\tlastLineLength: lastLineLength,\n\t\t\t\tforceMoveMarkers: Boolean(op.forceMoveMarkers),\n\t\t\t\tisAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n\t\t\t};\n\t\t}\n\n\t\t// Sort operations ascending\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsAscending);\n\n\t\tlet hasTouchingRanges = false;\n\t\tfor (let i = 0, count = operations.length - 1; i < count; i++) {\n\t\t\tconst rangeEnd = operations[i].range.getEndPosition();\n\t\t\tconst nextRangeStart = operations[i + 1].range.getStartPosition();\n\n\t\t\tif (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n\t\t\t\tif (nextRangeStart.isBefore(rangeEnd)) {\n\t\t\t\t\t// overlapping ranges\n\t\t\t\t\tthrow new Error('Overlapping ranges are not allowed!');\n\t\t\t\t}\n\t\t\t\thasTouchingRanges = true;\n\t\t\t}\n\t\t}\n\n\t\tif (canReduceOperations) {\n\t\t\toperations = this._reduceOperations(operations);\n\t\t}\n\n\t\t// Delta encode operations\n\t\tconst reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n\t\tconst newTrimAutoWhitespaceCandidates: { lineNumber: number; oldContent: string }[] = [];\n\t\tif (recordTrimAutoWhitespace) {\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\n\t\t\t\tif (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n\t\t\t\t\t// Record already the future line numbers that might be auto whitespace removal candidates on next edit\n\t\t\t\t\tfor (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n\t\t\t\t\t\tlet currentLineContent = '';\n\t\t\t\t\t\tif (lineNumber === reverseRange.startLineNumber) {\n\t\t\t\t\t\t\tcurrentLineContent = this.getLineContent(op.range.startLineNumber);\n\t\t\t\t\t\t\tif (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet reverseOperations: IReverseSingleEditOperation[] | null = null;\n\t\tif (computeUndoEdits) {\n\n\t\t\tlet reverseRangeDeltaOffset = 0;\n\t\t\treverseOperations = [];\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\t\t\t\tconst bufferText = this.getValueInRange(op.range);\n\t\t\t\tconst reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n\t\t\t\treverseRangeDeltaOffset += (op.text.length - bufferText.length);\n\n\t\t\t\treverseOperations[i] = {\n\t\t\t\t\tsortIndex: op.sortIndex,\n\t\t\t\t\tidentifier: op.identifier,\n\t\t\t\t\trange: reverseRange,\n\t\t\t\t\ttext: bufferText,\n\t\t\t\t\ttextChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Can only sort reverse operations when the order is not significant\n\t\t\tif (!hasTouchingRanges) {\n\t\t\t\treverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n\t\t\t}\n\t\t}\n\n\n\t\tthis._mightContainRTL = mightContainRTL;\n\t\tthis._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n\t\tthis._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n\t\tconst contentChanges = this._doApplyEdits(operations);\n\n\t\tlet trimAutoWhitespaceLineNumbers: number[] | null = null;\n\t\tif (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n\t\t\t// sort line numbers auto whitespace removal candidates for next edit descending\n\t\t\tnewTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n\n\t\t\ttrimAutoWhitespaceLineNumbers = [];\n\t\t\tfor (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n\t\t\t\tconst lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\t\t\t\tif (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n\t\t\t\t\t// Do not have the same line number twice\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\n\t\t\t\tif (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttrimAutoWhitespaceLineNumbers.push(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeContent.fire();\n\n\t\treturn new ApplyEditsResult(\n\t\t\treverseOperations,\n\t\t\tcontentChanges,\n\t\t\ttrimAutoWhitespaceLineNumbers\n\t\t);\n\t}\n\n\t/**\n\t * Transform operations such that they represent the same logic edit,\n\t * but that they also do not cause OOM crashes.\n\t */\n\tprivate _reduceOperations(operations: IValidatedEditOperation[]): IValidatedEditOperation[] {\n\t\tif (operations.length < 1000) {\n\t\t\t// We know from empirical testing that a thousand edits work fine regardless of their shape.\n\t\t\treturn operations;\n\t\t}\n\n\t\t// At one point, due to how events are emitted and how each operation is handled,\n\t\t// some operations can trigger a high amount of temporary string allocations,\n\t\t// that will immediately get edited again.\n\t\t// e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n\t\t// Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\t\treturn [this._toSingleEditOperation(operations)];\n\t}\n\n\t_toSingleEditOperation(operations: IValidatedEditOperation[]): IValidatedEditOperation {\n\t\tlet forceMoveMarkers = false;\n\t\tconst firstEditRange = operations[0].range;\n\t\tconst lastEditRange = operations[operations.length - 1].range;\n\t\tconst entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n\t\tlet lastEndLineNumber = firstEditRange.startLineNumber;\n\t\tlet lastEndColumn = firstEditRange.startColumn;\n\t\tconst result: string[] = [];\n\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst operation = operations[i];\n\t\t\tconst range = operation.range;\n\n\t\t\tforceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n\n\t\t\t// (1) -- Push old text\n\t\t\tresult.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n\n\t\t\t// (2) -- Push new text\n\t\t\tif (operation.text.length > 0) {\n\t\t\t\tresult.push(operation.text);\n\t\t\t}\n\n\t\t\tlastEndLineNumber = range.endLineNumber;\n\t\t\tlastEndColumn = range.endColumn;\n\t\t}\n\n\t\tconst text = result.join('');\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\n\t\treturn {\n\t\t\tsortIndex: 0,\n\t\t\tidentifier: operations[0].identifier,\n\t\t\trange: entireEditRange,\n\t\t\trangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n\t\t\trangeLength: this.getValueLengthInRange(entireEditRange, EndOfLinePreference.TextDefined),\n\t\t\ttext: text,\n\t\t\teolCount: eolCount,\n\t\t\tfirstLineLength: firstLineLength,\n\t\t\tlastLineLength: lastLineLength,\n\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\tisAutoWhitespaceEdit: false\n\t\t};\n\t}\n\n\tprivate _doApplyEdits(operations: IValidatedEditOperation[]): IInternalModelContentChange[] {\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsDescending);\n\n\t\tconst contentChanges: IInternalModelContentChange[] = [];\n\n\t\t// operations are from bottom to top\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tconst startLineNumber = op.range.startLineNumber;\n\t\t\tconst startColumn = op.range.startColumn;\n\t\t\tconst endLineNumber = op.range.endLineNumber;\n\t\t\tconst endColumn = op.range.endColumn;\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n\t\t\t\t// no-op\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (op.text) {\n\t\t\t\t// replacement\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t\tthis._pieceTree.insert(op.rangeOffset, op.text, true);\n\n\t\t\t} else {\n\t\t\t\t// deletion\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t}\n\n\t\t\tconst contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\tcontentChanges.push({\n\t\t\t\trange: contentChangeRange,\n\t\t\t\trangeLength: op.rangeLength,\n\t\t\t\ttext: op.text,\n\t\t\t\trangeOffset: op.rangeOffset,\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers\n\t\t\t});\n\t\t}\n\t\treturn contentChanges;\n\t}\n\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\treturn this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Assumes `operations` are validated and sorted ascending\n\t */\n\tpublic static _getInverseEditRanges(operations: IValidatedEditOperation[]): Range[] {\n\t\tconst result: Range[] = [];\n\n\t\tlet prevOpEndLineNumber: number = 0;\n\t\tlet prevOpEndColumn: number = 0;\n\t\tlet prevOp: IValidatedEditOperation | null = null;\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tlet startLineNumber: number;\n\t\t\tlet startColumn: number;\n\n\t\t\tif (prevOp) {\n\t\t\t\tif (prevOp.range.endLineNumber === op.range.startLineNumber) {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber;\n\t\t\t\t\tstartColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n\t\t\t\t} else {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n\t\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartLineNumber = op.range.startLineNumber;\n\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t}\n\n\t\t\tlet resultRange: Range;\n\n\t\t\tif (op.text.length > 0) {\n\t\t\t\t// the operation inserts something\n\t\t\t\tconst lineCount = op.eolCount + 1;\n\n\t\t\t\tif (lineCount === 1) {\n\t\t\t\t\t// single line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n\t\t\t\t} else {\n\t\t\t\t\t// multi line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is nothing to insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t\t}\n\n\t\t\tprevOpEndLineNumber = resultRange.endLineNumber;\n\t\t\tprevOpEndColumn = resultRange.endColumn;\n\n\t\t\tresult.push(resultRange);\n\t\t\tprevOp = op;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _sortOpsAscending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn a.sortIndex - b.sortIndex;\n\t\t}\n\t\treturn r;\n\t}\n\n\tprivate static _sortOpsDescending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn b.sortIndex - a.sortIndex;\n\t\t}\n\t\treturn -r;\n\t}\n\t// #endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult, EndOfLinePreference, FindMatch, IInternalModelContentChange, ISingleEditOperationIdentifier, ITextBuffer, ITextSnapshot, ValidAnnotatedEditOperation, IValidEditOperation, SearchData } from '../../model.js';\nimport { PieceTreeBase, StringBuffer } from './pieceTreeBase.js';\nimport { countEOL, StringEOL } from '../../core/misc/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\n\nexport interface IValidatedEditOperation {\n\tsortIndex: number;\n\tidentifier: ISingleEditOperationIdentifier | null;\n\trange: Range;\n\trangeOffset: number;\n\trangeLength: number;\n\ttext: string;\n\teolCount: number;\n\tfirstLineLength: number;\n\tlastLineLength: number;\n\tforceMoveMarkers: boolean;\n\tisAutoWhitespaceEdit: boolean;\n}\n\ninterface IReverseSingleEditOperation extends IValidEditOperation {\n\tsortIndex: number;\n}\n\nexport class PieceTreeTextBuffer extends Disposable implements ITextBuffer {\n\tprivate _pieceTree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\tprivate _mightContainRTL: boolean;\n\tprivate _mightContainUnusualLineTerminators: boolean;\n\tprivate _mightContainNonBasicASCII: boolean;\n\n\tprivate readonly _onDidChangeContent: Emitter<void> = this._register(new Emitter<void>());\n\n\tconstructor(chunks: StringBuffer[], BOM: string, eol: '\\r\\n' | '\\n', containsRTL: boolean, containsUnusualLineTerminators: boolean, isBasicASCII: boolean, eolNormalized: boolean) {\n\t\tsuper();\n\t\tthis._BOM = BOM;\n\t\tthis._mightContainNonBasicASCII = !isBasicASCII;\n\t\tthis._mightContainRTL = containsRTL;\n\t\tthis._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n\t\tthis._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n\t}\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._mightContainRTL;\n\t}\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._mightContainUnusualLineTerminators;\n\t}\n\tpublic resetMightContainUnusualLineTerminators(): void {\n\t\tthis._mightContainUnusualLineTerminators = false;\n\t}\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._mightContainNonBasicASCII;\n\t}\n\tpublic getBOM(): string {\n\t\treturn this._BOM;\n\t}\n\tpublic getEOL(): '\\r\\n' | '\\n' {\n\t\treturn this._pieceTree.getEOL();\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean): ITextSnapshot {\n\t\treturn this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\treturn this._pieceTree.getOffsetAt(lineNumber, column);\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\treturn this._pieceTree.getPositionAt(offset);\n\t}\n\n\tpublic getRangeAt(start: number, length: number): Range {\n\t\tconst end = start + length;\n\t\tconst startPosition = this.getPositionAt(start);\n\t\tconst endPosition = this.getPositionAt(end);\n\t\treturn new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n\t}\n\n\tpublic getValueInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): string {\n\t\tif (range.isEmpty()) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst lineEnding = this._getEndOfLine(eol);\n\t\treturn this._pieceTree.getValueInRange(range, lineEnding);\n\t}\n\n\tpublic getValueLengthInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (range.isEmpty()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn (range.endColumn - range.startColumn);\n\t\t}\n\n\t\tconst startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t// offsets use the text EOL, so we need to compensate for length differences\n\t\t// if the requested EOL doesn't match the text EOL\n\t\tlet eolOffsetCompensation = 0;\n\t\tconst desiredEOL = this._getEndOfLine(eol);\n\t\tconst actualEOL = this.getEOL();\n\t\tif (desiredEOL.length !== actualEOL.length) {\n\t\t\tconst delta = desiredEOL.length - actualEOL.length;\n\t\t\tconst eolCount = range.endLineNumber - range.startLineNumber;\n\t\t\teolOffsetCompensation = delta * eolCount;\n\t\t}\n\n\t\treturn endOffset - startOffset + eolOffsetCompensation;\n\t}\n\n\tpublic getCharacterCountInRange(range: Range, eol: EndOfLinePreference = EndOfLinePreference.TextDefined): number {\n\t\tif (this._mightContainNonBasicASCII) {\n\t\t\t// we must count by iterating\n\n\t\t\tlet result = 0;\n\n\t\t\tconst fromLineNumber = range.startLineNumber;\n\t\t\tconst toLineNumber = range.endLineNumber;\n\t\t\tfor (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\t\t\t\tconst fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n\t\t\t\tconst toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n\n\t\t\t\tfor (let offset = fromOffset; offset < toOffset; offset++) {\n\t\t\t\t\tif (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t\toffset = offset + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = result + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.getValueLengthInRange(range, eol);\n\t}\n\n\tpublic getNearestChunk(offset: number): string {\n\t\treturn this._pieceTree.getNearestChunk(offset);\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._pieceTree.getLength();\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._pieceTree.getLineCount();\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._pieceTree.getLinesContent();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\treturn this._pieceTree.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\treturn this._pieceTree.getLineCharCode(lineNumber, index);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\treturn this._pieceTree.getLineLength(lineNumber);\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 1;\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tconst result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\t\tif (result === -1) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn result + 2;\n\t}\n\n\tprivate _getEndOfLine(eol: EndOfLinePreference): string {\n\t\tswitch (eol) {\n\t\t\tcase EndOfLinePreference.LF:\n\t\t\t\treturn '\\n';\n\t\t\tcase EndOfLinePreference.CRLF:\n\t\t\t\treturn '\\r\\n';\n\t\t\tcase EndOfLinePreference.TextDefined:\n\t\t\t\treturn this.getEOL();\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown EOL preference');\n\t\t}\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._pieceTree.setEOL(newEOL);\n\t}\n\n\tpublic applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult {\n\t\tlet mightContainRTL = this._mightContainRTL;\n\t\tlet mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n\t\tlet mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n\t\tlet canReduceOperations = true;\n\n\t\tlet operations: IValidatedEditOperation[] = [];\n\t\tfor (let i = 0; i < rawOperations.length; i++) {\n\t\t\tconst op = rawOperations[i];\n\t\t\tif (canReduceOperations && op._isTracked) {\n\t\t\t\tcanReduceOperations = false;\n\t\t\t}\n\t\t\tconst validatedRange = op.range;\n\t\t\tif (op.text) {\n\t\t\t\tlet textMightContainNonBasicASCII = true;\n\t\t\t\tif (!mightContainNonBasicASCII) {\n\t\t\t\t\ttextMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n\t\t\t\t\tmightContainNonBasicASCII = textMightContainNonBasicASCII;\n\t\t\t\t}\n\t\t\t\tif (!mightContainRTL && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains RTL\n\t\t\t\t\tmightContainRTL = strings.containsRTL(op.text);\n\t\t\t\t}\n\t\t\t\tif (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n\t\t\t\t\t// check if the new inserted text contains unusual line terminators\n\t\t\t\t\tmightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet validText = '';\n\t\t\tlet eolCount = 0;\n\t\t\tlet firstLineLength = 0;\n\t\t\tlet lastLineLength = 0;\n\t\t\tif (op.text) {\n\t\t\t\tlet strEOL: StringEOL;\n\t\t\t\t[eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n\n\t\t\t\tconst bufferEOL = this.getEOL();\n\t\t\t\tconst expectedStrEOL = (bufferEOL === '\\r\\n' ? StringEOL.CRLF : StringEOL.LF);\n\t\t\t\tif (strEOL === StringEOL.Unknown || strEOL === expectedStrEOL) {\n\t\t\t\t\tvalidText = op.text;\n\t\t\t\t} else {\n\t\t\t\t\tvalidText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toperations[i] = {\n\t\t\t\tsortIndex: i,\n\t\t\t\tidentifier: op.identifier || null,\n\t\t\t\trange: validatedRange,\n\t\t\t\trangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n\t\t\t\trangeLength: this.getValueLengthInRange(validatedRange),\n\t\t\t\ttext: validText,\n\t\t\t\teolCount: eolCount,\n\t\t\t\tfirstLineLength: firstLineLength,\n\t\t\t\tlastLineLength: lastLineLength,\n\t\t\t\tforceMoveMarkers: Boolean(op.forceMoveMarkers),\n\t\t\t\tisAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n\t\t\t};\n\t\t}\n\n\t\t// Sort operations ascending\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsAscending);\n\n\t\tlet hasTouchingRanges = false;\n\t\tfor (let i = 0, count = operations.length - 1; i < count; i++) {\n\t\t\tconst rangeEnd = operations[i].range.getEndPosition();\n\t\t\tconst nextRangeStart = operations[i + 1].range.getStartPosition();\n\n\t\t\tif (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n\t\t\t\tif (nextRangeStart.isBefore(rangeEnd)) {\n\t\t\t\t\t// overlapping ranges\n\t\t\t\t\tthrow new Error('Overlapping ranges are not allowed!');\n\t\t\t\t}\n\t\t\t\thasTouchingRanges = true;\n\t\t\t}\n\t\t}\n\n\t\tif (canReduceOperations) {\n\t\t\toperations = this._reduceOperations(operations);\n\t\t}\n\n\t\t// Delta encode operations\n\t\tconst reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n\t\tconst newTrimAutoWhitespaceCandidates: { lineNumber: number; oldContent: string }[] = [];\n\t\tif (recordTrimAutoWhitespace) {\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\n\t\t\t\tif (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n\t\t\t\t\t// Record already the future line numbers that might be auto whitespace removal candidates on next edit\n\t\t\t\t\tfor (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n\t\t\t\t\t\tlet currentLineContent = '';\n\t\t\t\t\t\tif (lineNumber === reverseRange.startLineNumber) {\n\t\t\t\t\t\t\tcurrentLineContent = this.getLineContent(op.range.startLineNumber);\n\t\t\t\t\t\t\tif (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet reverseOperations: IReverseSingleEditOperation[] | null = null;\n\t\tif (computeUndoEdits) {\n\n\t\t\tlet reverseRangeDeltaOffset = 0;\n\t\t\treverseOperations = [];\n\t\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\t\tconst op = operations[i];\n\t\t\t\tconst reverseRange = reverseRanges[i];\n\t\t\t\tconst bufferText = this.getValueInRange(op.range);\n\t\t\t\tconst reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n\t\t\t\treverseRangeDeltaOffset += (op.text.length - bufferText.length);\n\n\t\t\t\treverseOperations[i] = {\n\t\t\t\t\tsortIndex: op.sortIndex,\n\t\t\t\t\tidentifier: op.identifier,\n\t\t\t\t\trange: reverseRange,\n\t\t\t\t\ttext: bufferText,\n\t\t\t\t\ttextChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Can only sort reverse operations when the order is not significant\n\t\t\tif (!hasTouchingRanges) {\n\t\t\t\treverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n\t\t\t}\n\t\t}\n\n\n\t\tthis._mightContainRTL = mightContainRTL;\n\t\tthis._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n\t\tthis._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n\t\tconst contentChanges = this._doApplyEdits(operations);\n\n\t\tlet trimAutoWhitespaceLineNumbers: number[] | null = null;\n\t\tif (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n\t\t\t// sort line numbers auto whitespace removal candidates for next edit descending\n\t\t\tnewTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n\n\t\t\ttrimAutoWhitespaceLineNumbers = [];\n\t\t\tfor (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n\t\t\t\tconst lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n\t\t\t\tif (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n\t\t\t\t\t// Do not have the same line number twice\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n\t\t\t\tconst lineContent = this.getLineContent(lineNumber);\n\n\t\t\t\tif (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttrimAutoWhitespaceLineNumbers.push(lineNumber);\n\t\t\t}\n\t\t}\n\n\t\tthis._onDidChangeContent.fire();\n\n\t\treturn new ApplyEditsResult(\n\t\t\treverseOperations,\n\t\t\tcontentChanges,\n\t\t\ttrimAutoWhitespaceLineNumbers\n\t\t);\n\t}\n\n\t/**\n\t * Transform operations such that they represent the same logic edit,\n\t * but that they also do not cause OOM crashes.\n\t */\n\tprivate _reduceOperations(operations: IValidatedEditOperation[]): IValidatedEditOperation[] {\n\t\tif (operations.length < 1000) {\n\t\t\t// We know from empirical testing that a thousand edits work fine regardless of their shape.\n\t\t\treturn operations;\n\t\t}\n\n\t\t// At one point, due to how events are emitted and how each operation is handled,\n\t\t// some operations can trigger a high amount of temporary string allocations,\n\t\t// that will immediately get edited again.\n\t\t// e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n\t\t// Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\t\treturn [this._toSingleEditOperation(operations)];\n\t}\n\n\t_toSingleEditOperation(operations: IValidatedEditOperation[]): IValidatedEditOperation {\n\t\tlet forceMoveMarkers = false;\n\t\tconst firstEditRange = operations[0].range;\n\t\tconst lastEditRange = operations[operations.length - 1].range;\n\t\tconst entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n\t\tlet lastEndLineNumber = firstEditRange.startLineNumber;\n\t\tlet lastEndColumn = firstEditRange.startColumn;\n\t\tconst result: string[] = [];\n\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst operation = operations[i];\n\t\t\tconst range = operation.range;\n\n\t\t\tforceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n\n\t\t\t// (1) -- Push old text\n\t\t\tresult.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n\n\t\t\t// (2) -- Push new text\n\t\t\tif (operation.text.length > 0) {\n\t\t\t\tresult.push(operation.text);\n\t\t\t}\n\n\t\t\tlastEndLineNumber = range.endLineNumber;\n\t\t\tlastEndColumn = range.endColumn;\n\t\t}\n\n\t\tconst text = result.join('');\n\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n\n\t\treturn {\n\t\t\tsortIndex: 0,\n\t\t\tidentifier: operations[0].identifier,\n\t\t\trange: entireEditRange,\n\t\t\trangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n\t\t\trangeLength: this.getValueLengthInRange(entireEditRange, EndOfLinePreference.TextDefined),\n\t\t\ttext: text,\n\t\t\teolCount: eolCount,\n\t\t\tfirstLineLength: firstLineLength,\n\t\t\tlastLineLength: lastLineLength,\n\t\t\tforceMoveMarkers: forceMoveMarkers,\n\t\t\tisAutoWhitespaceEdit: false\n\t\t};\n\t}\n\n\tprivate _doApplyEdits(operations: IValidatedEditOperation[]): IInternalModelContentChange[] {\n\t\toperations.sort(PieceTreeTextBuffer._sortOpsDescending);\n\n\t\tconst contentChanges: IInternalModelContentChange[] = [];\n\n\t\t// operations are from bottom to top\n\t\tfor (let i = 0; i < operations.length; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tconst startLineNumber = op.range.startLineNumber;\n\t\t\tconst startColumn = op.range.startColumn;\n\t\t\tconst endLineNumber = op.range.endLineNumber;\n\t\t\tconst endColumn = op.range.endColumn;\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n\t\t\t\t// no-op\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (op.text) {\n\t\t\t\t// replacement\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t\tthis._pieceTree.insert(op.rangeOffset, op.text, true);\n\n\t\t\t} else {\n\t\t\t\t// deletion\n\t\t\t\tthis._pieceTree.delete(op.rangeOffset, op.rangeLength);\n\t\t\t}\n\n\t\t\tconst contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\tcontentChanges.push({\n\t\t\t\trange: contentChangeRange,\n\t\t\t\trangeLength: op.rangeLength,\n\t\t\t\ttext: op.text,\n\t\t\t\trangeOffset: op.rangeOffset,\n\t\t\t\tforceMoveMarkers: op.forceMoveMarkers\n\t\t\t});\n\t\t}\n\t\treturn contentChanges;\n\t}\n\n\tfindMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\treturn this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\t/**\n\t * Assumes `operations` are validated and sorted ascending\n\t */\n\tpublic static _getInverseEditRanges(operations: IValidatedEditOperation[]): Range[] {\n\t\tconst result: Range[] = [];\n\n\t\tlet prevOpEndLineNumber: number = 0;\n\t\tlet prevOpEndColumn: number = 0;\n\t\tlet prevOp: IValidatedEditOperation | null = null;\n\t\tfor (let i = 0, len = operations.length; i < len; i++) {\n\t\t\tconst op = operations[i];\n\n\t\t\tlet startLineNumber: number;\n\t\t\tlet startColumn: number;\n\n\t\t\tif (prevOp) {\n\t\t\t\tif (prevOp.range.endLineNumber === op.range.startLineNumber) {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber;\n\t\t\t\t\tstartColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n\t\t\t\t} else {\n\t\t\t\t\tstartLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n\t\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartLineNumber = op.range.startLineNumber;\n\t\t\t\tstartColumn = op.range.startColumn;\n\t\t\t}\n\n\t\t\tlet resultRange: Range;\n\n\t\t\tif (op.text.length > 0) {\n\t\t\t\t// the operation inserts something\n\t\t\t\tconst lineCount = op.eolCount + 1;\n\n\t\t\t\tif (lineCount === 1) {\n\t\t\t\t\t// single line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n\t\t\t\t} else {\n\t\t\t\t\t// multi line insert\n\t\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is nothing to insert\n\t\t\t\tresultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n\t\t\t}\n\n\t\t\tprevOpEndLineNumber = resultRange.endLineNumber;\n\t\t\tprevOpEndColumn = resultRange.endColumn;\n\n\t\t\tresult.push(resultRange);\n\t\t\tprevOp = op;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate static _sortOpsAscending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn a.sortIndex - b.sortIndex;\n\t\t}\n\t\treturn r;\n\t}\n\n\tprivate static _sortOpsDescending(a: IValidatedEditOperation, b: IValidatedEditOperation): number {\n\t\tconst r = Range.compareRangesUsingEnds(a.range, b.range);\n\t\tif (r === 0) {\n\t\t\treturn b.sortIndex - a.sortIndex;\n\t\t}\n\t\treturn -r;\n\t}\n\t// #endregion\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 7846, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { DefaultEndOfLine, ITextBuffer, ITextBufferBuilder, ITextBufferFactory } from '../../model.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\n\nclass PieceTreeTextBufferFactory implements ITextBufferFactory {\n\n\tconstructor(\n\t\tprivate readonly _chunks: StringBuffer[],\n\t\tprivate readonly _bom: string,\n\t\tprivate readonly _cr: number,\n\t\tprivate readonly _lf: number,\n\t\tprivate readonly _crlf: number,\n\t\tprivate readonly _containsRTL: boolean,\n\t\tprivate readonly _containsUnusualLineTerminators: boolean,\n\t\tprivate readonly _isBasicASCII: boolean,\n\t\tprivate readonly _normalizeEOL: boolean\n\t) { }\n\n\tprivate _getEOL(defaultEOL: DefaultEndOfLine): '\\r\\n' | '\\n' {\n\t\tconst totalEOLCount = this._cr + this._lf + this._crlf;\n\t\tconst totalCRCount = this._cr + this._crlf;\n\t\tif (totalEOLCount === 0) {\n\t\t\t// This is an empty file or a file with precisely one line\n\t\t\treturn (defaultEOL === DefaultEndOfLine.LF ? '\\n' : '\\r\\n');\n\t\t}\n\t\tif (totalCRCount > totalEOLCount / 2) {\n\t\t\t// More than half of the file contains \\r\\n ending lines\n\t\t\treturn '\\r\\n';\n\t\t}\n\t\t// At least one line more ends in \\n\n\t\treturn '\\n';\n\t}\n\n\tpublic create(defaultEOL: DefaultEndOfLine): { textBuffer: ITextBuffer; disposable: IDisposable } {\n\t\tconst eol = this._getEOL(defaultEOL);\n\t\tconst chunks = this._chunks;\n\n\t\tif (this._normalizeEOL &&\n\t\t\t((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n\t\t\t\t|| (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))\n\t\t) {\n\t\t\t// Normalize pieces\n\t\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\t\tconst str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t\tconst newLineStart = createLineStartsFast(str);\n\t\t\t\tchunks[i] = new StringBuffer(str, newLineStart);\n\t\t\t}\n\t\t}\n\n\t\tconst textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n\t\treturn { textBuffer: textBuffer, disposable: textBuffer };\n\t}\n}\n\nexport class PieceTreeTextBufferBuilder implements ITextBufferBuilder {\n\tprivate readonly chunks: StringBuffer[];\n\tprivate BOM: string;\n\n\tprivate _hasPreviousChar: boolean;\n\tprivate _previousChar: number;\n\tprivate readonly _tmpLineStarts: number[];\n\n\tprivate cr: number;\n\tprivate lf: number;\n\tprivate crlf: number;\n\tprivate containsRTL: boolean;\n\tprivate containsUnusualLineTerminators: boolean;\n\tprivate isBasicASCII: boolean;\n\n\tconstructor() {\n\t\tthis.chunks = [];\n\t\tthis.BOM = '';\n\n\t\tthis._hasPreviousChar = false;\n\t\tthis._previousChar = 0;\n\t\tthis._tmpLineStarts = [];\n\n\t\tthis.cr = 0;\n\t\tthis.lf = 0;\n\t\tthis.crlf = 0;\n\t\tthis.containsRTL = false;\n\t\tthis.containsUnusualLineTerminators = false;\n\t\tthis.isBasicASCII = true;\n\t}\n\n\tpublic acceptChunk(chunk: string): void {\n\t\tif (chunk.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.chunks.length === 0) {\n\t\t\tif (strings.startsWithUTF8BOM(chunk)) {\n\t\t\t\tthis.BOM = strings.UTF8_BOM_CHARACTER;\n\t\t\t\tchunk = chunk.substr(1);\n\t\t\t}\n\t\t}\n\n\t\tconst lastChar = chunk.charCodeAt(chunk.length - 1);\n\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\tthis._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n\t\t\tthis._hasPreviousChar = true;\n\t\t\tthis._previousChar = lastChar;\n\t\t} else {\n\t\t\tthis._acceptChunk1(chunk, false);\n\t\t\tthis._hasPreviousChar = false;\n\t\t\tthis._previousChar = lastChar;\n\t\t}\n\t}\n\n\tprivate _acceptChunk1(chunk: string, allowEmptyStrings: boolean): void {\n\t\tif (!allowEmptyStrings && chunk.length === 0) {\n\t\t\t// Nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n\t\t} else {\n\t\t\tthis._acceptChunk2(chunk);\n\t\t}\n\t}\n\n\tprivate _acceptChunk2(chunk: string): void {\n\t\tconst lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n\n\t\tthis.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n\t\tthis.cr += lineStarts.cr;\n\t\tthis.lf += lineStarts.lf;\n\t\tthis.crlf += lineStarts.crlf;\n\n\t\tif (!lineStarts.isBasicASCII) {\n\t\t\t// this chunk contains non basic ASCII characters\n\t\t\tthis.isBasicASCII = false;\n\t\t\tif (!this.containsRTL) {\n\t\t\t\tthis.containsRTL = strings.containsRTL(chunk);\n\t\t\t}\n\t\t\tif (!this.containsUnusualLineTerminators) {\n\t\t\t\tthis.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic finish(normalizeEOL: boolean = true): PieceTreeTextBufferFactory {\n\t\tthis._finish();\n\t\treturn new PieceTreeTextBufferFactory(\n\t\t\tthis.chunks,\n\t\t\tthis.BOM,\n\t\t\tthis.cr,\n\t\t\tthis.lf,\n\t\t\tthis.crlf,\n\t\t\tthis.containsRTL,\n\t\t\tthis.containsUnusualLineTerminators,\n\t\t\tthis.isBasicASCII,\n\t\t\tnormalizeEOL\n\t\t);\n\t}\n\n\tprivate _finish(): void {\n\t\tif (this.chunks.length === 0) {\n\t\t\tthis._acceptChunk1('', true);\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._hasPreviousChar = false;\n\t\t\t// recreate last chunk\n\t\t\tconst lastChunk = this.chunks[this.chunks.length - 1];\n\t\t\tlastChunk.buffer += String.fromCharCode(this._previousChar);\n\t\t\tconst newLineStarts = createLineStartsFast(lastChunk.buffer);\n\t\t\tlastChunk.lineStarts = newLineStarts;\n\t\t\tif (this._previousChar === CharCode.CarriageReturn) {\n\t\t\t\tthis.cr++;\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { IDisposable } from '../../../../base/common/lifecycle.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { DefaultEndOfLine, ITextBuffer, ITextBufferBuilder, ITextBufferFactory } from '../../model.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\n\nclass PieceTreeTextBufferFactory implements ITextBufferFactory {\n\n\tconstructor(\n\t\tprivate readonly _chunks: StringBuffer[],\n\t\tprivate readonly _bom: string,\n\t\tprivate readonly _cr: number,\n\t\tprivate readonly _lf: number,\n\t\tprivate readonly _crlf: number,\n\t\tprivate readonly _containsRTL: boolean,\n\t\tprivate readonly _containsUnusualLineTerminators: boolean,\n\t\tprivate readonly _isBasicASCII: boolean,\n\t\tprivate readonly _normalizeEOL: boolean\n\t) { }\n\n\tprivate _getEOL(defaultEOL: DefaultEndOfLine): '\\r\\n' | '\\n' {\n\t\tconst totalEOLCount = this._cr + this._lf + this._crlf;\n\t\tconst totalCRCount = this._cr + this._crlf;\n\t\tif (totalEOLCount === 0) {\n\t\t\t// This is an empty file or a file with precisely one line\n\t\t\treturn (defaultEOL === DefaultEndOfLine.LF ? '\\n' : '\\r\\n');\n\t\t}\n\t\tif (totalCRCount > totalEOLCount / 2) {\n\t\t\t// More than half of the file contains \\r\\n ending lines\n\t\t\treturn '\\r\\n';\n\t\t}\n\t\t// At least one line more ends in \\n\n\t\treturn '\\n';\n\t}\n\n\tpublic create(defaultEOL: DefaultEndOfLine): { textBuffer: ITextBuffer; disposable: IDisposable } {\n\t\tconst eol = this._getEOL(defaultEOL);\n\t\tconst chunks = this._chunks;\n\n\t\tif (this._normalizeEOL &&\n\t\t\t((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n\t\t\t\t|| (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))\n\t\t) {\n\t\t\t// Normalize pieces\n\t\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\t\tconst str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t\tconst newLineStart = createLineStartsFast(str);\n\t\t\t\tchunks[i] = new StringBuffer(str, newLineStart);\n\t\t\t}\n\t\t}\n\n\t\tconst textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n\t\treturn { textBuffer: textBuffer, disposable: textBuffer };\n\t}\n}\n\nexport class PieceTreeTextBufferBuilder implements ITextBufferBuilder {\n\tprivate readonly chunks: StringBuffer[];\n\tprivate BOM: string;\n\n\tprivate _hasPreviousChar: boolean;\n\tprivate _previousChar: number;\n\tprivate readonly _tmpLineStarts: number[];\n\n\tprivate cr: number;\n\tprivate lf: number;\n\tprivate crlf: number;\n\tprivate containsRTL: boolean;\n\tprivate containsUnusualLineTerminators: boolean;\n\tprivate isBasicASCII: boolean;\n\n\tconstructor() {\n\t\tthis.chunks = [];\n\t\tthis.BOM = '';\n\n\t\tthis._hasPreviousChar = false;\n\t\tthis._previousChar = 0;\n\t\tthis._tmpLineStarts = [];\n\n\t\tthis.cr = 0;\n\t\tthis.lf = 0;\n\t\tthis.crlf = 0;\n\t\tthis.containsRTL = false;\n\t\tthis.containsUnusualLineTerminators = false;\n\t\tthis.isBasicASCII = true;\n\t}\n\n\tpublic acceptChunk(chunk: string): void {\n\t\tif (chunk.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.chunks.length === 0) {\n\t\t\tif (strings.startsWithUTF8BOM(chunk)) {\n\t\t\t\tthis.BOM = strings.UTF8_BOM_CHARACTER;\n\t\t\t\tchunk = chunk.substr(1);\n\t\t\t}\n\t\t}\n\n\t\tconst lastChar = chunk.charCodeAt(chunk.length - 1);\n\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\tthis._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n\t\t\tthis._hasPreviousChar = true;\n\t\t\tthis._previousChar = lastChar;\n\t\t} else {\n\t\t\tthis._acceptChunk1(chunk, false);\n\t\t\tthis._hasPreviousChar = false;\n\t\t\tthis._previousChar = lastChar;\n\t\t}\n\t}\n\n\tprivate _acceptChunk1(chunk: string, allowEmptyStrings: boolean): void {\n\t\tif (!allowEmptyStrings && chunk.length === 0) {\n\t\t\t// Nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n\t\t} else {\n\t\t\tthis._acceptChunk2(chunk);\n\t\t}\n\t}\n\n\tprivate _acceptChunk2(chunk: string): void {\n\t\tconst lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n\n\t\tthis.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n\t\tthis.cr += lineStarts.cr;\n\t\tthis.lf += lineStarts.lf;\n\t\tthis.crlf += lineStarts.crlf;\n\n\t\tif (!lineStarts.isBasicASCII) {\n\t\t\t// this chunk contains non basic ASCII characters\n\t\t\tthis.isBasicASCII = false;\n\t\t\tif (!this.containsRTL) {\n\t\t\t\tthis.containsRTL = strings.containsRTL(chunk);\n\t\t\t}\n\t\t\tif (!this.containsUnusualLineTerminators) {\n\t\t\t\tthis.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic finish(normalizeEOL: boolean = true): PieceTreeTextBufferFactory {\n\t\tthis._finish();\n\t\treturn new PieceTreeTextBufferFactory(\n\t\t\tthis.chunks,\n\t\t\tthis.BOM,\n\t\t\tthis.cr,\n\t\t\tthis.lf,\n\t\t\tthis.crlf,\n\t\t\tthis.containsRTL,\n\t\t\tthis.containsUnusualLineTerminators,\n\t\t\tthis.isBasicASCII,\n\t\t\tnormalizeEOL\n\t\t);\n\t}\n\n\tprivate _finish(): void {\n\t\tif (this.chunks.length === 0) {\n\t\t\tthis._acceptChunk1('', true);\n\t\t}\n\n\t\tif (this._hasPreviousChar) {\n\t\t\tthis._hasPreviousChar = false;\n\t\t\t// recreate last chunk\n\t\t\tconst lastChunk = this.chunks[this.chunks.length - 1];\n\t\t\tlastChunk.buffer += String.fromCharCode(this._previousChar);\n\t\t\tconst newLineStarts = createLineStartsFast(lastChunk.buffer);\n\t\t\tlastChunk.lineStarts = newLineStarts;\n\t\t\tif (this._previousChar === CharCode.CarriageReturn) {\n\t\t\t\tthis.cr++;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAIhG,OAAO,KAAK,OAAO,MAAM,oCAAoC,CAAC;AAE9D,OAAO,EAAE,YAAY,EAAE,gBAAgB,EAAE,oBAAoB,EAAE,MAAM,oBAAoB,CAAC;AAC1F,OAAO,EAAE,mBAAmB,EAAE,MAAM,0BAA0B,CAAC;;;;AAE/D,MAAM,0BAA0B;IAcvB,OAAO,CAAC,UAA4B,EAAA;QAC3C,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;QACvD,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;QAC3C,IAAI,aAAa,KAAK,CAAC,EAAE,CAAC;YACzB,0DAA0D;YAC1D,OAAO,AAAC,UAAU,KAAA,EAAA,uBAAA,EAAwB,CAAC,CAAC,EAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QAC7D,CAAC;QACD,IAAI,YAAY,GAAG,aAAa,GAAG,CAAC,EAAE,CAAC;YACtC,wDAAwD;YACxD,OAAO,MAAM,CAAC;QACf,CAAC;QACD,oCAAoC;QACpC,OAAO,IAAI,CAAC;IACb,CAAC;IAEM,MAAM,CAAC,UAA4B,EAAA;QACzC,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QACrC,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC;QAE5B,IAAI,IAAI,CAAC,aAAa,IACrB,CAAC,AAAC,GAAG,KAAK,MAAM,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,GAC9C,GAAG,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,AAAC,CAAC,EACtD,CAAC;YACF,mBAAmB;YACnB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,CAAE,CAAC;gBACnD,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;gBACzD,MAAM,YAAY,OAAG,6OAAoB,EAAC,GAAG,CAAC,CAAC;gBAC/C,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,qOAAY,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;YACjD,CAAC;QACF,CAAC;QAED,MAAM,UAAU,GAAG,IAAI,kPAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,+BAA+B,EAAE,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QACpK,OAAO;YAAE,UAAU,EAAE,UAAU;YAAE,UAAU,EAAE,UAAU;QAAA,CAAE,CAAC;IAC3D,CAAC;IA7CD,YACkB,OAAuB,EACvB,IAAY,EACZ,GAAW,EACX,GAAW,EACX,KAAa,EACb,YAAqB,EACrB,+BAAwC,EACxC,aAAsB,EACtB,aAAsB,CAAA;QARtB,IAAA,CAAA,OAAO,GAAP,OAAO,CAAgB;QACvB,IAAA,CAAA,IAAI,GAAJ,IAAI,CAAQ;QACZ,IAAA,CAAA,GAAG,GAAH,GAAG,CAAQ;QACX,IAAA,CAAA,GAAG,GAAH,GAAG,CAAQ;QACX,IAAA,CAAA,KAAK,GAAL,KAAK,CAAQ;QACb,IAAA,CAAA,YAAY,GAAZ,YAAY,CAAS;QACrB,IAAA,CAAA,+BAA+B,GAA/B,+BAA+B,CAAS;QACxC,IAAA,CAAA,aAAa,GAAb,aAAa,CAAS;QACtB,IAAA,CAAA,aAAa,GAAb,aAAa,CAAS;IACpC,CAAC;CAoCL;AAEK,MAAO,0BAA0B;IA+B/B,WAAW,CAAC,KAAa,EAAA;QAC/B,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO;QACR,CAAC;QAED,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC9B,IAAI,OAAO,CAAC,0LAAiB,CAAC,KAAK,CAAC,EAAE,CAAC;gBACtC,IAAI,CAAC,GAAG,GAAG,OAAO,CAAC,2LAAkB,CAAC;gBACtC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YACzB,CAAC;QACF,CAAC;QAED,MAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACpD,IAAI,QAAQ,KAAA,GAAA,2BAAA,EAA4B,IAAI,CAAC,QAAQ,IAAI,MAAM,IAAI,QAAQ,IAAI,MAAM,CAAC,CAAE,CAAC;YACxF,2DAA2D;YAC3D,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;YAC7D,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;YAC7B,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;QAC/B,CAAC,MAAM,CAAC;YACP,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YACjC,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;YAC9B,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC;QAC/B,CAAC;IACF,CAAC;IAEO,aAAa,CAAC,KAAa,EAAE,iBAA0B,EAAA;QAC9D,IAAI,CAAC,iBAAiB,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC9C,gBAAgB;YAChB,OAAO;QACR,CAAC;QAED,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC3B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,KAAK,CAAC,CAAC;QACrE,CAAC,MAAM,CAAC;YACP,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAC3B,CAAC;IACF,CAAC;IAEO,aAAa,CAAC,KAAa,EAAA;QAClC,MAAM,UAAU,OAAG,yOAAgB,EAAC,IAAI,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC;QAEhE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,qOAAY,CAAC,KAAK,EAAE,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;QACjE,IAAI,CAAC,EAAE,IAAI,UAAU,CAAC,EAAE,CAAC;QACzB,IAAI,CAAC,EAAE,IAAI,UAAU,CAAC,EAAE,CAAC;QACzB,IAAI,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,CAAC;QAE7B,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE,CAAC;YAC9B,iDAAiD;YACjD,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;YAC1B,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC;gBACvB,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,oLAAW,CAAC,KAAK,CAAC,CAAC;YAC/C,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,8BAA8B,EAAE,CAAC;gBAC1C,IAAI,CAAC,8BAA8B,GAAG,OAAO,CAAC,uMAA8B,CAAC,KAAK,CAAC,CAAC;YACrF,CAAC;QACF,CAAC;IACF,CAAC;IAEM,MAAM,GAA6B;YAA5B,gFAAwB,IAAI;QACzC,IAAI,CAAC,OAAO,EAAE,CAAC;QACf,OAAO,IAAI,0BAA0B,CACpC,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,GAAG,EACR,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,EAAE,EACP,IAAI,CAAC,IAAI,EACT,IAAI,CAAC,WAAW,EAChB,IAAI,CAAC,8BAA8B,EACnC,IAAI,CAAC,YAAY,EACjB,YAAY,CACZ,CAAC;IACH,CAAC;IAEO,OAAO,GAAA;QACd,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC9B,IAAI,CAAC,aAAa,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;QAC9B,CAAC;QAED,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC3B,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;YAC9B,sBAAsB;YACtB,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACtD,SAAS,CAAC,MAAM,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YAC5D,MAAM,aAAa,OAAG,6OAAoB,EAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAC7D,SAAS,CAAC,UAAU,GAAG,aAAa,CAAC;YACrC,IAAI,IAAI,CAAC,aAAa,KAAA,GAAA,2BAAA,EAA4B,GAAE,CAAC;gBACpD,IAAI,CAAC,EAAE,EAAE,CAAC;YACX,CAAC;QACF,CAAC;IACF,CAAC;IAzGD,aAAA;QACC,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;QAEd,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;QAC9B,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QACvB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QAEzB,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QACd,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QACzB,IAAI,CAAC,8BAA8B,GAAG,KAAK,CAAC;QAC5C,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;IAC1B,CAAC;CA4FD","debugId":null}},
    {"offset": {"line": 7993, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/abstractSyntaxTokenBackend.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/abstractSyntaxTokenBackend.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/vs/editor/common/model/tokens/abstractSyntaxTokenBackend.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { StandardTokenType } from '../../encodedTokenAttributes.js';\nimport { ILanguageIdCodec } from '../../languages.js';\nimport { IAttachedView } from '../../model.js';\nimport { TextModel } from '../textModel.js';\nimport { IModelContentChangedEvent, IModelTokensChangedEvent } from '../../textModelEvents.js';\nimport { BackgroundTokenizationState } from '../../tokenizationTextModelPart.js';\nimport { LineTokens } from '../../tokens/lineTokens.js';\nimport { derivedOpts, IObservable, ISettableObservable, observableSignal, observableValueOpts } from '../../../../base/common/observable.js';\nimport { equalsIfDefined, itemEquals, itemsEquals } from '../../../../base/common/equals.js';\n\n/**\n * @internal\n */\nexport class AttachedViews {\n\tprivate readonly _onDidChangeVisibleRanges = new Emitter<{ view: IAttachedView; state: AttachedViewState | undefined }>();\n\tpublic readonly onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n\n\tprivate readonly _views = new Set<AttachedViewImpl>();\n\tprivate readonly _viewsChanged = observableSignal(this);\n\n\tpublic readonly visibleLineRanges: IObservable<readonly LineRange[]>;\n\n\tconstructor() {\n\t\tthis.visibleLineRanges = derivedOpts({\n\t\t\towner: this,\n\t\t\tequalsFn: itemsEquals(itemEquals())\n\t\t}, reader => {\n\t\t\tthis._viewsChanged.read(reader);\n\t\t\tconst ranges = LineRange.joinMany(\n\t\t\t\t[...this._views].map(view => view.state.read(reader)?.visibleLineRanges ?? [])\n\t\t\t);\n\t\t\treturn ranges;\n\t\t});\n\t}\n\n\tpublic attachView(): IAttachedView {\n\t\tconst view = new AttachedViewImpl((state) => {\n\t\t\tthis._onDidChangeVisibleRanges.fire({ view, state });\n\t\t});\n\t\tthis._views.add(view);\n\t\tthis._viewsChanged.trigger(undefined);\n\t\treturn view;\n\t}\n\n\tpublic detachView(view: IAttachedView): void {\n\t\tthis._views.delete(view as AttachedViewImpl);\n\t\tthis._onDidChangeVisibleRanges.fire({ view, state: undefined });\n\t\tthis._viewsChanged.trigger(undefined);\n\t}\n}\n\n/**\n * @internal\n */\nexport class AttachedViewState {\n\tconstructor(\n\t\treadonly visibleLineRanges: readonly LineRange[],\n\t\treadonly stabilized: boolean,\n\t) { }\n\n\tpublic equals(other: AttachedViewState): boolean {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!equals(this.visibleLineRanges, other.visibleLineRanges, (a, b) => a.equals(b))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.stabilized !== other.stabilized) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n\nclass AttachedViewImpl implements IAttachedView {\n\tprivate readonly _state: ISettableObservable<AttachedViewState | undefined>;\n\tpublic get state(): IObservable<AttachedViewState | undefined> { return this._state; }\n\n\tconstructor(\n\t\tprivate readonly handleStateChange: (state: AttachedViewState) => void\n\t) {\n\t\tthis._state = observableValueOpts<AttachedViewState | undefined>({ owner: this, equalsFn: equalsIfDefined((a, b) => a.equals(b)) }, undefined);\n\t}\n\n\tsetVisibleLines(visibleLines: { startLineNumber: number; endLineNumber: number }[], stabilized: boolean): void {\n\t\tconst visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n\t\tconst state = new AttachedViewState(visibleLineRanges, stabilized);\n\t\tthis._state.set(state, undefined, undefined);\n\t\tthis.handleStateChange(state);\n\t}\n}\n\n\nexport class AttachedViewHandler extends Disposable {\n\tprivate readonly runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n\n\tprivate _computedLineRanges: readonly LineRange[] = [];\n\tprivate _lineRanges: readonly LineRange[] = [];\n\tpublic get lineRanges(): readonly LineRange[] { return this._lineRanges; }\n\n\tconstructor(private readonly _refreshTokens: () => void) {\n\t\tsuper();\n\t}\n\n\tprivate update(): void {\n\t\tif (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n\t\t\treturn;\n\t\t}\n\t\tthis._computedLineRanges = this._lineRanges;\n\t\tthis._refreshTokens();\n\t}\n\n\tpublic handleStateChange(state: AttachedViewState): void {\n\t\tthis._lineRanges = state.visibleLineRanges;\n\t\tif (state.stabilized) {\n\t\t\tthis.runner.cancel();\n\t\t\tthis.update();\n\t\t} else {\n\t\t\tthis.runner.schedule();\n\t\t}\n\t}\n}\n\nexport abstract class AbstractSyntaxTokenBackend extends Disposable {\n\tprotected abstract _backgroundTokenizationState: BackgroundTokenizationState;\n\tpublic get backgroundTokenizationState(): BackgroundTokenizationState {\n\t\treturn this._backgroundTokenizationState;\n\t}\n\n\tprotected abstract readonly _onDidChangeBackgroundTokenizationState: Emitter<void>;\n\t/** @internal, should not be exposed by the text model! */\n\tpublic abstract readonly onDidChangeBackgroundTokenizationState: Event<void>;\n\n\tprotected readonly _onDidChangeTokens = this._register(new Emitter<IModelTokensChangedEvent>());\n\t/** @internal, should not be exposed by the text model! */\n\tpublic readonly onDidChangeTokens: Event<IModelTokensChangedEvent> = this._onDidChangeTokens.event;\n\n\tconstructor(\n\t\tprotected readonly _languageIdCodec: ILanguageIdCodec,\n\t\tprotected readonly _textModel: TextModel,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic abstract todo_resetTokenization(fireTokenChangeEvent?: boolean): void;\n\n\tpublic abstract handleDidChangeAttached(): void;\n\n\tpublic abstract handleDidChangeContent(e: IModelContentChangedEvent): void;\n\n\tpublic abstract forceTokenization(lineNumber: number): void;\n\n\tpublic abstract hasAccurateTokensForLine(lineNumber: number): boolean;\n\n\tpublic abstract isCheapToTokenize(lineNumber: number): boolean;\n\n\tpublic tokenizeIfCheap(lineNumber: number): void {\n\t\tif (this.isCheapToTokenize(lineNumber)) {\n\t\t\tthis.forceTokenization(lineNumber);\n\t\t}\n\t}\n\n\tpublic abstract getLineTokens(lineNumber: number): LineTokens;\n\n\tpublic abstract getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType;\n\n\tpublic abstract tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null;\n\n\tpublic abstract get hasTokens(): boolean;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { StandardTokenType } from '../../encodedTokenAttributes.js';\nimport { ILanguageIdCodec } from '../../languages.js';\nimport { IAttachedView } from '../../model.js';\nimport { TextModel } from '../textModel.js';\nimport { IModelContentChangedEvent, IModelTokensChangedEvent } from '../../textModelEvents.js';\nimport { BackgroundTokenizationState } from '../../tokenizationTextModelPart.js';\nimport { LineTokens } from '../../tokens/lineTokens.js';\nimport { derivedOpts, IObservable, ISettableObservable, observableSignal, observableValueOpts } from '../../../../base/common/observable.js';\nimport { equalsIfDefined, itemEquals, itemsEquals } from '../../../../base/common/equals.js';\n\n/**\n * @internal\n */\nexport class AttachedViews {\n\tprivate readonly _onDidChangeVisibleRanges = new Emitter<{ view: IAttachedView; state: AttachedViewState | undefined }>();\n\tpublic readonly onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n\n\tprivate readonly _views = new Set<AttachedViewImpl>();\n\tprivate readonly _viewsChanged = observableSignal(this);\n\n\tpublic readonly visibleLineRanges: IObservable<readonly LineRange[]>;\n\n\tconstructor() {\n\t\tthis.visibleLineRanges = derivedOpts({\n\t\t\towner: this,\n\t\t\tequalsFn: itemsEquals(itemEquals())\n\t\t}, reader => {\n\t\t\tthis._viewsChanged.read(reader);\n\t\t\tconst ranges = LineRange.joinMany(\n\t\t\t\t[...this._views].map(view => view.state.read(reader)?.visibleLineRanges ?? [])\n\t\t\t);\n\t\t\treturn ranges;\n\t\t});\n\t}\n\n\tpublic attachView(): IAttachedView {\n\t\tconst view = new AttachedViewImpl((state) => {\n\t\t\tthis._onDidChangeVisibleRanges.fire({ view, state });\n\t\t});\n\t\tthis._views.add(view);\n\t\tthis._viewsChanged.trigger(undefined);\n\t\treturn view;\n\t}\n\n\tpublic detachView(view: IAttachedView): void {\n\t\tthis._views.delete(view as AttachedViewImpl);\n\t\tthis._onDidChangeVisibleRanges.fire({ view, state: undefined });\n\t\tthis._viewsChanged.trigger(undefined);\n\t}\n}\n\n/**\n * @internal\n */\nexport class AttachedViewState {\n\tconstructor(\n\t\treadonly visibleLineRanges: readonly LineRange[],\n\t\treadonly stabilized: boolean,\n\t) { }\n\n\tpublic equals(other: AttachedViewState): boolean {\n\t\tif (this === other) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!equals(this.visibleLineRanges, other.visibleLineRanges, (a, b) => a.equals(b))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.stabilized !== other.stabilized) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n\nclass AttachedViewImpl implements IAttachedView {\n\tprivate readonly _state: ISettableObservable<AttachedViewState | undefined>;\n\tpublic get state(): IObservable<AttachedViewState | undefined> { return this._state; }\n\n\tconstructor(\n\t\tprivate readonly handleStateChange: (state: AttachedViewState) => void\n\t) {\n\t\tthis._state = observableValueOpts<AttachedViewState | undefined>({ owner: this, equalsFn: equalsIfDefined((a, b) => a.equals(b)) }, undefined);\n\t}\n\n\tsetVisibleLines(visibleLines: { startLineNumber: number; endLineNumber: number }[], stabilized: boolean): void {\n\t\tconst visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n\t\tconst state = new AttachedViewState(visibleLineRanges, stabilized);\n\t\tthis._state.set(state, undefined, undefined);\n\t\tthis.handleStateChange(state);\n\t}\n}\n\n\nexport class AttachedViewHandler extends Disposable {\n\tprivate readonly runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n\n\tprivate _computedLineRanges: readonly LineRange[] = [];\n\tprivate _lineRanges: readonly LineRange[] = [];\n\tpublic get lineRanges(): readonly LineRange[] { return this._lineRanges; }\n\n\tconstructor(private readonly _refreshTokens: () => void) {\n\t\tsuper();\n\t}\n\n\tprivate update(): void {\n\t\tif (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n\t\t\treturn;\n\t\t}\n\t\tthis._computedLineRanges = this._lineRanges;\n\t\tthis._refreshTokens();\n\t}\n\n\tpublic handleStateChange(state: AttachedViewState): void {\n\t\tthis._lineRanges = state.visibleLineRanges;\n\t\tif (state.stabilized) {\n\t\t\tthis.runner.cancel();\n\t\t\tthis.update();\n\t\t} else {\n\t\t\tthis.runner.schedule();\n\t\t}\n\t}\n}\n\nexport abstract class AbstractSyntaxTokenBackend extends Disposable {\n\tprotected abstract _backgroundTokenizationState: BackgroundTokenizationState;\n\tpublic get backgroundTokenizationState(): BackgroundTokenizationState {\n\t\treturn this._backgroundTokenizationState;\n\t}\n\n\tprotected abstract readonly _onDidChangeBackgroundTokenizationState: Emitter<void>;\n\t/** @internal, should not be exposed by the text model! */\n\tpublic abstract readonly onDidChangeBackgroundTokenizationState: Event<void>;\n\n\tprotected readonly _onDidChangeTokens = this._register(new Emitter<IModelTokensChangedEvent>());\n\t/** @internal, should not be exposed by the text model! */\n\tpublic readonly onDidChangeTokens: Event<IModelTokensChangedEvent> = this._onDidChangeTokens.event;\n\n\tconstructor(\n\t\tprotected readonly _languageIdCodec: ILanguageIdCodec,\n\t\tprotected readonly _textModel: TextModel,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic abstract todo_resetTokenization(fireTokenChangeEvent?: boolean): void;\n\n\tpublic abstract handleDidChangeAttached(): void;\n\n\tpublic abstract handleDidChangeContent(e: IModelContentChangedEvent): void;\n\n\tpublic abstract forceTokenization(lineNumber: number): void;\n\n\tpublic abstract hasAccurateTokensForLine(lineNumber: number): boolean;\n\n\tpublic abstract isCheapToTokenize(lineNumber: number): boolean;\n\n\tpublic tokenizeIfCheap(lineNumber: number): void {\n\t\tif (this.isCheapToTokenize(lineNumber)) {\n\t\t\tthis.forceTokenization(lineNumber);\n\t\t}\n\t}\n\n\tpublic abstract getLineTokens(lineNumber: number): LineTokens;\n\n\tpublic abstract getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType;\n\n\tpublic abstract tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null;\n\n\tpublic abstract get hasTokens(): boolean;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 8147, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/cursorUtils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/treeSitter/cursorUtils.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/vs/editor/common/model/tokens/treeSitter/cursorUtils.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport type * as TreeSitter from '@vscode/tree-sitter-wasm';\n\nexport function gotoNextSibling(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tconst n = newCursor.gotoNextSibling();\n\tconst o = oldCursor.gotoNextSibling();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\treturn n && o;\n}\n\nexport function gotoParent(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tconst n = newCursor.gotoParent();\n\tconst o = oldCursor.gotoParent();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\treturn n && o;\n}\n\nexport function gotoNthChild(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor, index: number) {\n\tconst n = newCursor.gotoFirstChild();\n\tconst o = oldCursor.gotoFirstChild();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\tif (index === 0) {\n\t\treturn n && o;\n\t}\n\tfor (let i = 1; i <= index; i++) {\n\t\tconst nn = newCursor.gotoNextSibling();\n\t\tconst oo = oldCursor.gotoNextSibling();\n\t\tif (nn !== oo) {\n\t\t\tthrow new Error('Trees are out of sync');\n\t\t}\n\t\tif (!nn || !oo) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn n && o;\n}\n\nexport function nextSiblingOrParentSibling(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tdo {\n\t\tif (newCursor.currentNode.nextSibling) {\n\t\t\treturn gotoNextSibling(newCursor, oldCursor);\n\t\t}\n\t\tif (newCursor.currentNode.parent) {\n\t\t\tgotoParent(newCursor, oldCursor);\n\t\t}\n\t} while (newCursor.currentNode.nextSibling || newCursor.currentNode.parent);\n\treturn false;\n}\n\nexport function getClosestPreviousNodes(cursor: TreeSitter.TreeCursor, tree: TreeSitter.Tree): TreeSitter.Node | undefined {\n\t// Go up parents until the end of the parent is before the start of the current.\n\tconst findPrev = tree.walk();\n\tfindPrev.resetTo(cursor);\n\n\tconst startingNode = cursor.currentNode;\n\tdo {\n\t\tif (findPrev.currentNode.previousSibling && ((findPrev.currentNode.endIndex - findPrev.currentNode.startIndex) !== 0)) {\n\t\t\tfindPrev.gotoPreviousSibling();\n\t\t} else {\n\t\t\twhile (!findPrev.currentNode.previousSibling && findPrev.currentNode.parent) {\n\t\t\t\tfindPrev.gotoParent();\n\t\t\t}\n\t\t\tfindPrev.gotoPreviousSibling();\n\t\t}\n\t} while ((findPrev.currentNode.endIndex > startingNode.startIndex)\n\t&& (findPrev.currentNode.parent || findPrev.currentNode.previousSibling)\n\n\t\t&& (findPrev.currentNode.id !== startingNode.id));\n\n\tif ((findPrev.currentNode.id !== startingNode.id) && findPrev.currentNode.endIndex <= startingNode.startIndex) {\n\t\treturn findPrev.currentNode;\n\t} else {\n\t\treturn undefined;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport type * as TreeSitter from '@vscode/tree-sitter-wasm';\n\nexport function gotoNextSibling(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tconst n = newCursor.gotoNextSibling();\n\tconst o = oldCursor.gotoNextSibling();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\treturn n && o;\n}\n\nexport function gotoParent(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tconst n = newCursor.gotoParent();\n\tconst o = oldCursor.gotoParent();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\treturn n && o;\n}\n\nexport function gotoNthChild(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor, index: number) {\n\tconst n = newCursor.gotoFirstChild();\n\tconst o = oldCursor.gotoFirstChild();\n\tif (n !== o) {\n\t\tthrow new Error('Trees are out of sync');\n\t}\n\tif (index === 0) {\n\t\treturn n && o;\n\t}\n\tfor (let i = 1; i <= index; i++) {\n\t\tconst nn = newCursor.gotoNextSibling();\n\t\tconst oo = oldCursor.gotoNextSibling();\n\t\tif (nn !== oo) {\n\t\t\tthrow new Error('Trees are out of sync');\n\t\t}\n\t\tif (!nn || !oo) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn n && o;\n}\n\nexport function nextSiblingOrParentSibling(newCursor: TreeSitter.TreeCursor, oldCursor: TreeSitter.TreeCursor) {\n\tdo {\n\t\tif (newCursor.currentNode.nextSibling) {\n\t\t\treturn gotoNextSibling(newCursor, oldCursor);\n\t\t}\n\t\tif (newCursor.currentNode.parent) {\n\t\t\tgotoParent(newCursor, oldCursor);\n\t\t}\n\t} while (newCursor.currentNode.nextSibling || newCursor.currentNode.parent);\n\treturn false;\n}\n\nexport function getClosestPreviousNodes(cursor: TreeSitter.TreeCursor, tree: TreeSitter.Tree): TreeSitter.Node | undefined {\n\t// Go up parents until the end of the parent is before the start of the current.\n\tconst findPrev = tree.walk();\n\tfindPrev.resetTo(cursor);\n\n\tconst startingNode = cursor.currentNode;\n\tdo {\n\t\tif (findPrev.currentNode.previousSibling && ((findPrev.currentNode.endIndex - findPrev.currentNode.startIndex) !== 0)) {\n\t\t\tfindPrev.gotoPreviousSibling();\n\t\t} else {\n\t\t\twhile (!findPrev.currentNode.previousSibling && findPrev.currentNode.parent) {\n\t\t\t\tfindPrev.gotoParent();\n\t\t\t}\n\t\t\tfindPrev.gotoPreviousSibling();\n\t\t}\n\t} while ((findPrev.currentNode.endIndex > startingNode.startIndex)\n\t&& (findPrev.currentNode.parent || findPrev.currentNode.previousSibling)\n\n\t\t&& (findPrev.currentNode.id !== startingNode.id));\n\n\tif ((findPrev.currentNode.id !== startingNode.id) && findPrev.currentNode.endIndex <= startingNode.startIndex) {\n\t\treturn findPrev.currentNode;\n\t} else {\n\t\treturn undefined;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 8232, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/treeSitterTree.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/treeSitter/treeSitterTree.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/vs/editor/common/model/tokens/treeSitter/treeSitterTree.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport type * as TreeSitter from '@vscode/tree-sitter-wasm';\nimport { TaskQueue } from '../../../../../base/common/async.js';\nimport { Disposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { IObservable, observableValue, transaction, IObservableWithChange } from '../../../../../base/common/observable.js';\nimport { setTimeout0 } from '../../../../../base/common/platform.js';\nimport { ILogService } from '../../../../../platform/log/common/log.js';\nimport { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.js';\nimport { TextLength } from '../../../core/text/textLength.js';\nimport { IModelContentChangedEvent } from '../../../textModelEvents.js';\nimport { IModelContentChange } from '../../mirrorTextModel.js';\nimport { TextModel } from '../../textModel.js';\nimport { gotoParent, getClosestPreviousNodes, nextSiblingOrParentSibling, gotoNthChild } from './cursorUtils.js';\nimport { Range } from '../../../core/range.js';\n\nexport class TreeSitterTree extends Disposable {\n\n\tprivate readonly _tree = observableValue<TreeSitter.Tree | undefined, TreeParseUpdateEvent>(this, undefined);\n\tpublic readonly tree: IObservableWithChange<TreeSitter.Tree | undefined, TreeParseUpdateEvent> = this._tree;\n\n\tprivate readonly _treeLastParsedVersion = observableValue(this, -1);\n\tpublic readonly treeLastParsedVersion: IObservable<number> = this._treeLastParsedVersion;\n\n\tprivate _lastFullyParsed: TreeSitter.Tree | undefined;\n\tprivate _lastFullyParsedWithEdits: TreeSitter.Tree | undefined;\n\n\tprivate _onDidChangeContentQueue: TaskQueue = new TaskQueue();\n\n\tconstructor(\n\t\tpublic readonly languageId: string,\n\t\tprivate _ranges: TreeSitter.Range[] | undefined,\n\t\t// readonly treeSitterLanguage: Language,\n\t\t/** Must have the language set! */\n\t\tprivate readonly _parser: TreeSitter.Parser,\n\t\tprivate readonly _parserClass: typeof TreeSitter.Parser,\n\t\t// private readonly _injectionQuery: TreeSitter.Query,\n\t\tpublic readonly textModel: TextModel,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService\n\t) {\n\t\tsuper();\n\n\t\tthis._tree = observableValue(this, undefined);\n\t\tthis.tree = this._tree;\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._tree.get()?.delete();\n\t\t\tthis._lastFullyParsed?.delete();\n\t\t\tthis._lastFullyParsedWithEdits?.delete();\n\t\t\tthis._parser.delete();\n\t\t}));\n\t\tthis.handleContentChange(undefined, this._ranges);\n\t}\n\n\tpublic handleContentChange(e: IModelContentChangedEvent | undefined, ranges?: TreeSitter.Range[]): void {\n\t\tconst version = this.textModel.getVersionId();\n\t\tlet newRanges: TreeSitter.Range[] = [];\n\t\tif (ranges) {\n\t\t\tnewRanges = this._setRanges(ranges);\n\t\t}\n\t\tif (e) {\n\t\t\tthis._applyEdits(e.changes);\n\t\t}\n\n\t\tthis._onDidChangeContentQueue.clearPending();\n\t\tthis._onDidChangeContentQueue.schedule(async () => {\n\t\t\tif (this._store.isDisposed) {\n\t\t\t\t// No need to continue the queue if we are disposed\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst oldTree = this._lastFullyParsed;\n\t\t\tlet changedNodes: TreeSitter.Range[] | undefined;\n\t\t\tif (this._lastFullyParsedWithEdits && this._lastFullyParsed) {\n\t\t\t\tchangedNodes = this._findChangedNodes(this._lastFullyParsedWithEdits, this._lastFullyParsed);\n\t\t\t}\n\n\t\t\tconst completed = await this._parseAndUpdateTree(version);\n\t\t\tif (completed) {\n\t\t\t\tlet ranges: RangeChange[] | undefined;\n\t\t\t\tif (!changedNodes) {\n\t\t\t\t\tif (this._ranges) {\n\t\t\t\t\t\tranges = this._ranges.map(r => ({ newRange: new Range(r.startPosition.row + 1, r.startPosition.column + 1, r.endPosition.row + 1, r.endPosition.column + 1), oldRangeLength: r.endIndex - r.startIndex, newRangeStartOffset: r.startIndex, newRangeEndOffset: r.endIndex }));\n\t\t\t\t\t}\n\t\t\t\t} else if (oldTree && changedNodes) {\n\t\t\t\t\tranges = this._findTreeChanges(completed, changedNodes, newRanges);\n\t\t\t\t}\n\t\t\t\tif (!ranges) {\n\t\t\t\t\tranges = [{ newRange: this.textModel.getFullModelRange(), newRangeStartOffset: 0, newRangeEndOffset: this.textModel.getValueLength() }];\n\t\t\t\t}\n\n\t\t\t\tconst previousTree = this._tree.get();\n\t\t\t\ttransaction(tx => {\n\t\t\t\t\tthis._tree.set(completed, tx, { ranges, versionId: version });\n\t\t\t\t\tthis._treeLastParsedVersion.set(version, tx);\n\t\t\t\t});\n\t\t\t\tpreviousTree?.delete();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _applyEdits(changes: IModelContentChange[]) {\n\t\tfor (const change of changes) {\n\t\t\tconst originalTextLength = TextLength.ofRange(Range.lift(change.range));\n\t\t\tconst newTextLength = TextLength.ofText(change.text);\n\t\t\tconst summedTextLengths = change.text.length === 0 ? newTextLength : originalTextLength.add(newTextLength);\n\t\t\tconst edit = {\n\t\t\t\tstartIndex: change.rangeOffset,\n\t\t\t\toldEndIndex: change.rangeOffset + change.rangeLength,\n\t\t\t\tnewEndIndex: change.rangeOffset + change.text.length,\n\t\t\t\tstartPosition: { row: change.range.startLineNumber - 1, column: change.range.startColumn - 1 },\n\t\t\t\toldEndPosition: { row: change.range.endLineNumber - 1, column: change.range.endColumn - 1 },\n\t\t\t\tnewEndPosition: { row: change.range.startLineNumber + summedTextLengths.lineCount - 1, column: summedTextLengths.lineCount ? summedTextLengths.columnCount : (change.range.endColumn + summedTextLengths.columnCount) }\n\t\t\t};\n\t\t\tthis._tree.get()?.edit(edit);\n\t\t\tthis._lastFullyParsedWithEdits?.edit(edit);\n\t\t}\n\t}\n\n\tprivate _findChangedNodes(newTree: TreeSitter.Tree, oldTree: TreeSitter.Tree): TreeSitter.Range[] | undefined {\n\t\tif ((this._ranges && this._ranges.every(range => range.startPosition.row !== newTree.rootNode.startPosition.row)) || newTree.rootNode.startPosition.row !== 0) {\n\t\t\treturn [];\n\t\t}\n\t\tconst newCursor = newTree.walk();\n\t\tconst oldCursor = oldTree.walk();\n\n\t\tconst nodes: TreeSitter.Range[] = [];\n\t\tlet next = true;\n\n\t\tdo {\n\t\t\tif (newCursor.currentNode.hasChanges) {\n\t\t\t\t// Check if only one of the children has changes.\n\t\t\t\t// If it's only one, then we go to that child.\n\t\t\t\t// If it's more then, we need to go to each child\n\t\t\t\t// If it's none, then we've found one of our ranges\n\t\t\t\tconst newChildren = newCursor.currentNode.children;\n\t\t\t\tconst indexChangedChildren: number[] = [];\n\t\t\t\tconst changedChildren = newChildren.filter((c, index) => {\n\t\t\t\t\tif (c?.hasChanges || (oldCursor.currentNode.children.length <= index)) {\n\t\t\t\t\t\tindexChangedChildren.push(index);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t\t// If we have changes and we *had* an error, the whole node should be refreshed.\n\t\t\t\tif ((changedChildren.length === 0) || (newCursor.currentNode.hasError !== oldCursor.currentNode.hasError)) {\n\t\t\t\t\t// walk up again until we get to the first one that's named as unnamed nodes can be too granular\n\t\t\t\t\twhile (newCursor.currentNode.parent && next && !newCursor.currentNode.isNamed) {\n\t\t\t\t\t\tnext = gotoParent(newCursor, oldCursor);\n\t\t\t\t\t}\n\t\t\t\t\t// Use the end position of the previous node and the start position of the current node\n\t\t\t\t\tconst newNode = newCursor.currentNode;\n\t\t\t\t\tconst closestPreviousNode = getClosestPreviousNodes(newCursor, newTree) ?? newNode;\n\t\t\t\t\tnodes.push({\n\t\t\t\t\t\tstartIndex: closestPreviousNode.startIndex,\n\t\t\t\t\t\tendIndex: newNode.endIndex,\n\t\t\t\t\t\tstartPosition: closestPreviousNode.startPosition,\n\t\t\t\t\t\tendPosition: newNode.endPosition\n\t\t\t\t\t});\n\t\t\t\t\tnext = nextSiblingOrParentSibling(newCursor, oldCursor);\n\t\t\t\t} else if (changedChildren.length >= 1) {\n\t\t\t\t\tnext = gotoNthChild(newCursor, oldCursor, indexChangedChildren[0]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnext = nextSiblingOrParentSibling(newCursor, oldCursor);\n\t\t\t}\n\t\t} while (next);\n\n\t\tnewCursor.delete();\n\t\toldCursor.delete();\n\t\treturn nodes;\n\t}\n\n\tprivate _findTreeChanges(newTree: TreeSitter.Tree, changedNodes: TreeSitter.Range[], newRanges: TreeSitter.Range[]): RangeChange[] {\n\t\tlet newRangeIndex = 0;\n\t\tconst mergedChanges: RangeChange[] = [];\n\n\t\t// Find the parent in the new tree of the changed node\n\t\tfor (let nodeIndex = 0; nodeIndex < changedNodes.length; nodeIndex++) {\n\t\t\tconst node = changedNodes[nodeIndex];\n\n\t\t\tif (mergedChanges.length > 0) {\n\t\t\t\tif ((node.startIndex >= mergedChanges[mergedChanges.length - 1].newRangeStartOffset) && (node.endIndex <= mergedChanges[mergedChanges.length - 1].newRangeEndOffset)) {\n\t\t\t\t\t// This node is within the previous range, skip it\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst cursor = newTree.walk();\n\t\t\tconst cursorContainersNode = () => cursor.startIndex < node.startIndex && cursor.endIndex > node.endIndex;\n\n\t\t\twhile (cursorContainersNode()) {\n\t\t\t\t// See if we can go to a child\n\t\t\t\tlet child = cursor.gotoFirstChild();\n\t\t\t\tlet foundChild = false;\n\t\t\t\twhile (child) {\n\t\t\t\t\tif (cursorContainersNode() && cursor.currentNode.isNamed) {\n\t\t\t\t\t\tfoundChild = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild = cursor.gotoNextSibling();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!foundChild) {\n\t\t\t\t\tcursor.gotoParent();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cursor.currentNode.childCount === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst startPosition = cursor.currentNode.startPosition;\n\t\t\tconst endPosition = cursor.currentNode.endPosition;\n\t\t\tconst startIndex = cursor.currentNode.startIndex;\n\t\t\tconst endIndex = cursor.currentNode.endIndex;\n\n\t\t\tconst newChange = { newRange: new Range(startPosition.row + 1, startPosition.column + 1, endPosition.row + 1, endPosition.column + 1), newRangeStartOffset: startIndex, newRangeEndOffset: endIndex };\n\t\t\tif ((newRangeIndex < newRanges.length) && rangesIntersect(newRanges[newRangeIndex], { startIndex, endIndex, startPosition, endPosition })) {\n\t\t\t\t// combine the new change with the range\n\t\t\t\tif (newRanges[newRangeIndex].startIndex < newChange.newRangeStartOffset) {\n\t\t\t\t\tnewChange.newRange = newChange.newRange.setStartPosition(newRanges[newRangeIndex].startPosition.row + 1, newRanges[newRangeIndex].startPosition.column + 1);\n\t\t\t\t\tnewChange.newRangeStartOffset = newRanges[newRangeIndex].startIndex;\n\t\t\t\t}\n\t\t\t\tif (newRanges[newRangeIndex].endIndex > newChange.newRangeEndOffset) {\n\t\t\t\t\tnewChange.newRange = newChange.newRange.setEndPosition(newRanges[newRangeIndex].endPosition.row + 1, newRanges[newRangeIndex].endPosition.column + 1);\n\t\t\t\t\tnewChange.newRangeEndOffset = newRanges[newRangeIndex].endIndex;\n\t\t\t\t}\n\t\t\t\tnewRangeIndex++;\n\t\t\t} else if (newRangeIndex < newRanges.length && newRanges[newRangeIndex].endIndex < newChange.newRangeStartOffset) {\n\t\t\t\t// add the full range to the merged changes\n\t\t\t\tmergedChanges.push({\n\t\t\t\t\tnewRange: new Range(newRanges[newRangeIndex].startPosition.row + 1, newRanges[newRangeIndex].startPosition.column + 1, newRanges[newRangeIndex].endPosition.row + 1, newRanges[newRangeIndex].endPosition.column + 1),\n\t\t\t\t\tnewRangeStartOffset: newRanges[newRangeIndex].startIndex,\n\t\t\t\t\tnewRangeEndOffset: newRanges[newRangeIndex].endIndex\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ((mergedChanges.length > 0) && (mergedChanges[mergedChanges.length - 1].newRangeEndOffset >= newChange.newRangeStartOffset)) {\n\t\t\t\t// Merge the changes\n\t\t\t\tmergedChanges[mergedChanges.length - 1].newRange = Range.fromPositions(mergedChanges[mergedChanges.length - 1].newRange.getStartPosition(), newChange.newRange.getEndPosition());\n\t\t\t\tmergedChanges[mergedChanges.length - 1].newRangeEndOffset = newChange.newRangeEndOffset;\n\t\t\t} else {\n\t\t\t\tmergedChanges.push(newChange);\n\t\t\t}\n\t\t}\n\t\treturn this._constrainRanges(mergedChanges);\n\t}\n\n\tprivate _constrainRanges(changes: RangeChange[]): RangeChange[] {\n\t\tif (!this._ranges) {\n\t\t\treturn changes;\n\t\t}\n\n\t\tconst constrainedChanges: RangeChange[] = [];\n\t\tlet changesIndex = 0;\n\t\tlet rangesIndex = 0;\n\t\twhile (changesIndex < changes.length && rangesIndex < this._ranges.length) {\n\t\t\tconst change = changes[changesIndex];\n\t\t\tconst range = this._ranges[rangesIndex];\n\t\t\tif (change.newRangeEndOffset < range.startIndex) {\n\t\t\t\t// Change is before the range, move to the next change\n\t\t\t\tchangesIndex++;\n\t\t\t} else if (change.newRangeStartOffset > range.endIndex) {\n\t\t\t\t// Change is after the range, move to the next range\n\t\t\t\trangesIndex++;\n\t\t\t} else {\n\t\t\t\t// Change is within the range, constrain it\n\t\t\t\tconst newRangeStartOffset = Math.max(change.newRangeStartOffset, range.startIndex);\n\t\t\t\tconst newRangeEndOffset = Math.min(change.newRangeEndOffset, range.endIndex);\n\t\t\t\tconst newRange = change.newRange.intersectRanges(new Range(range.startPosition.row + 1, range.startPosition.column + 1, range.endPosition.row + 1, range.endPosition.column + 1))!;\n\t\t\t\tconstrainedChanges.push({\n\t\t\t\t\tnewRange,\n\t\t\t\t\tnewRangeEndOffset,\n\t\t\t\t\tnewRangeStartOffset\n\t\t\t\t});\n\t\t\t\t// Remove the intersected range from the current change\n\t\t\t\tif (newRangeEndOffset < change.newRangeEndOffset) {\n\t\t\t\t\tchange.newRange = Range.fromPositions(newRange.getEndPosition(), change.newRange.getEndPosition());\n\t\t\t\t\tchange.newRangeStartOffset = newRangeEndOffset + 1;\n\t\t\t\t} else {\n\t\t\t\t\t// Move to the next change\n\t\t\t\t\tchangesIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn constrainedChanges;\n\t}\n\n\tprivate async _parseAndUpdateTree(version: number): Promise<TreeSitter.Tree | undefined> {\n\t\tconst tree = await this._parse();\n\t\tif (tree) {\n\t\t\tthis._lastFullyParsed?.delete();\n\t\t\tthis._lastFullyParsed = tree.copy();\n\t\t\tthis._lastFullyParsedWithEdits?.delete();\n\t\t\tthis._lastFullyParsedWithEdits = tree.copy();\n\n\t\t\treturn tree;\n\t\t} else if (!this._tree.get()) {\n\t\t\t// No tree means this is the initial parse and there were edits\n\t\t\t// parse function doesn't handle this well and we can end up with an incorrect tree, so we reset\n\t\t\tthis._parser.reset();\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _parse(): Promise<TreeSitter.Tree | undefined> {\n\t\tlet parseType: TelemetryParseType = TelemetryParseType.Full;\n\t\tif (this._tree.get()) {\n\t\t\tparseType = TelemetryParseType.Incremental;\n\t\t}\n\t\treturn this._parseAndYield(parseType);\n\t}\n\n\tprivate async _parseAndYield(parseType: TelemetryParseType): Promise<TreeSitter.Tree | undefined> {\n\t\tlet time: number = 0;\n\t\tlet passes: number = 0;\n\t\tconst inProgressVersion = this.textModel.getVersionId();\n\t\tlet newTree: TreeSitter.Tree | null | undefined;\n\n\t\tconst progressCallback = newTimeOutProgressCallback();\n\n\t\tdo {\n\t\t\tconst timer = performance.now();\n\n\t\t\tnewTree = this._parser.parse((index: number, position?: TreeSitter.Point) => this._parseCallback(index), this._tree.get(), { progressCallback, includedRanges: this._ranges });\n\n\t\t\ttime += performance.now() - timer;\n\t\t\tpasses++;\n\n\t\t\t// So long as this isn't the initial parse, even if the model changes and edits are applied, the tree parsing will continue correctly after the await.\n\t\t\tawait new Promise<void>(resolve => setTimeout0(resolve));\n\n\t\t} while (!this._store.isDisposed && !newTree && inProgressVersion === this.textModel.getVersionId());\n\t\tthis._sendParseTimeTelemetry(parseType, time, passes);\n\t\treturn (newTree && (inProgressVersion === this.textModel.getVersionId())) ? newTree : undefined;\n\t}\n\n\tprivate _parseCallback(index: number): string | undefined {\n\t\ttry {\n\t\t\treturn this.textModel.getTextBuffer().getNearestChunk(index);\n\t\t} catch (e) {\n\t\t\tthis._logService.debug('Error getting chunk for tree-sitter parsing', e);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _setRanges(newRanges: TreeSitter.Range[]): TreeSitter.Range[] {\n\t\tconst unKnownRanges: TreeSitter.Range[] = [];\n\t\t// If we have existing ranges, find the parts of the new ranges that are not included in the existing ones\n\t\tif (this._ranges) {\n\t\t\tfor (const newRange of newRanges) {\n\t\t\t\tlet isFullyIncluded = false;\n\n\t\t\t\tfor (let i = 0; i < this._ranges.length; i++) {\n\t\t\t\t\tconst existingRange = this._ranges[i];\n\n\t\t\t\t\tif (rangesEqual(existingRange, newRange) || rangesIntersect(existingRange, newRange)) {\n\t\t\t\t\t\tisFullyIncluded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!isFullyIncluded) {\n\t\t\t\t\tunKnownRanges.push(newRange);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// No existing ranges, all new ranges are unknown\n\t\t\tunKnownRanges.push(...newRanges);\n\t\t}\n\n\t\tthis._ranges = newRanges;\n\t\treturn unKnownRanges;\n\t}\n\n\tprivate _sendParseTimeTelemetry(parseType: TelemetryParseType, time: number, passes: number): void {\n\t\tthis._logService.debug(`Tree parsing (${parseType}) took ${time} ms and ${passes} passes.`);\n\t\ttype ParseTimeClassification = {\n\t\t\towner: 'alexr00';\n\t\t\tcomment: 'Used to understand how long it takes to parse a tree-sitter tree';\n\t\t\tlanguageId: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The programming language ID.' };\n\t\t\ttime: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; isMeasurement: true; comment: 'The ms it took to parse' };\n\t\t\tpasses: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; isMeasurement: true; comment: 'The number of passes it took to parse' };\n\t\t};\n\t\tif (parseType === TelemetryParseType.Full) {\n\t\t\tthis._telemetryService.publicLog2<{ languageId: string; time: number; passes: number }, ParseTimeClassification>(`treeSitter.fullParse`, { languageId: this.languageId, time, passes });\n\t\t} else {\n\t\t\tthis._telemetryService.publicLog2<{ languageId: string; time: number; passes: number }, ParseTimeClassification>(`treeSitter.incrementalParse`, { languageId: this.languageId, time, passes });\n\t\t}\n\t}\n\n\tpublic createParsedTreeSync(src: string): TreeSitter.Tree | undefined {\n\t\tconst parser = new this._parserClass();\n\t\tparser.setLanguage(this._parser.language!);\n\t\tconst tree = parser.parse(src);\n\t\tparser.delete();\n\t\treturn tree ?? undefined;\n\t}\n}\n\nconst enum TelemetryParseType {\n\tFull = 'fullParse',\n\tIncremental = 'incrementalParse'\n}\n\nexport interface TreeParseUpdateEvent {\n\tranges: RangeChange[];\n\tversionId: number;\n}\n\nexport interface RangeWithOffsets {\n\trange: Range;\n\tstartOffset: number;\n\tendOffset: number;\n}\n\nexport interface RangeChange {\n\tnewRange: Range;\n\tnewRangeStartOffset: number;\n\tnewRangeEndOffset: number;\n}\n\nfunction newTimeOutProgressCallback(): (state: TreeSitter.ParseState) => void {\n\tlet lastYieldTime: number = performance.now();\n\treturn function parseProgressCallback(_state: TreeSitter.ParseState) {\n\t\tconst now = performance.now();\n\t\tif (now - lastYieldTime > 50) {\n\t\t\tlastYieldTime = now;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n}\nexport function rangesEqual(a: TreeSitter.Range, b: TreeSitter.Range) {\n\treturn (a.startPosition.row === b.startPosition.row)\n\t\t&& (a.startPosition.column === b.startPosition.column)\n\t\t&& (a.endPosition.row === b.endPosition.row)\n\t\t&& (a.endPosition.column === b.endPosition.column)\n\t\t&& (a.startIndex === b.startIndex)\n\t\t&& (a.endIndex === b.endIndex);\n}\n\nexport function rangesIntersect(a: TreeSitter.Range, b: TreeSitter.Range) {\n\treturn (a.startIndex <= b.startIndex && a.endIndex >= b.startIndex) ||\n\t\t(b.startIndex <= a.startIndex && b.endIndex >= a.startIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport type * as TreeSitter from '@vscode/tree-sitter-wasm';\nimport { TaskQueue } from '../../../../../base/common/async.js';\nimport { Disposable, toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { IObservable, observableValue, transaction, IObservableWithChange } from '../../../../../base/common/observable.js';\nimport { setTimeout0 } from '../../../../../base/common/platform.js';\nimport { ILogService } from '../../../../../platform/log/common/log.js';\nimport { ITelemetryService } from '../../../../../platform/telemetry/common/telemetry.js';\nimport { TextLength } from '../../../core/text/textLength.js';\nimport { IModelContentChangedEvent } from '../../../textModelEvents.js';\nimport { IModelContentChange } from '../../mirrorTextModel.js';\nimport { TextModel } from '../../textModel.js';\nimport { gotoParent, getClosestPreviousNodes, nextSiblingOrParentSibling, gotoNthChild } from './cursorUtils.js';\nimport { Range } from '../../../core/range.js';\n\nexport class TreeSitterTree extends Disposable {\n\n\tprivate readonly _tree = observableValue<TreeSitter.Tree | undefined, TreeParseUpdateEvent>(this, undefined);\n\tpublic readonly tree: IObservableWithChange<TreeSitter.Tree | undefined, TreeParseUpdateEvent> = this._tree;\n\n\tprivate readonly _treeLastParsedVersion = observableValue(this, -1);\n\tpublic readonly treeLastParsedVersion: IObservable<number> = this._treeLastParsedVersion;\n\n\tprivate _lastFullyParsed: TreeSitter.Tree | undefined;\n\tprivate _lastFullyParsedWithEdits: TreeSitter.Tree | undefined;\n\n\tprivate _onDidChangeContentQueue: TaskQueue = new TaskQueue();\n\n\tconstructor(\n\t\tpublic readonly languageId: string,\n\t\tprivate _ranges: TreeSitter.Range[] | undefined,\n\t\t// readonly treeSitterLanguage: Language,\n\t\t/** Must have the language set! */\n\t\tprivate readonly _parser: TreeSitter.Parser,\n\t\tprivate readonly _parserClass: typeof TreeSitter.Parser,\n\t\t// private readonly _injectionQuery: TreeSitter.Query,\n\t\tpublic readonly textModel: TextModel,\n\t\t@ILogService private readonly _logService: ILogService,\n\t\t@ITelemetryService private readonly _telemetryService: ITelemetryService\n\t) {\n\t\tsuper();\n\n\t\tthis._tree = observableValue(this, undefined);\n\t\tthis.tree = this._tree;\n\n\t\tthis._register(toDisposable(() => {\n\t\t\tthis._tree.get()?.delete();\n\t\t\tthis._lastFullyParsed?.delete();\n\t\t\tthis._lastFullyParsedWithEdits?.delete();\n\t\t\tthis._parser.delete();\n\t\t}));\n\t\tthis.handleContentChange(undefined, this._ranges);\n\t}\n\n\tpublic handleContentChange(e: IModelContentChangedEvent | undefined, ranges?: TreeSitter.Range[]): void {\n\t\tconst version = this.textModel.getVersionId();\n\t\tlet newRanges: TreeSitter.Range[] = [];\n\t\tif (ranges) {\n\t\t\tnewRanges = this._setRanges(ranges);\n\t\t}\n\t\tif (e) {\n\t\t\tthis._applyEdits(e.changes);\n\t\t}\n\n\t\tthis._onDidChangeContentQueue.clearPending();\n\t\tthis._onDidChangeContentQueue.schedule(async () => {\n\t\t\tif (this._store.isDisposed) {\n\t\t\t\t// No need to continue the queue if we are disposed\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst oldTree = this._lastFullyParsed;\n\t\t\tlet changedNodes: TreeSitter.Range[] | undefined;\n\t\t\tif (this._lastFullyParsedWithEdits && this._lastFullyParsed) {\n\t\t\t\tchangedNodes = this._findChangedNodes(this._lastFullyParsedWithEdits, this._lastFullyParsed);\n\t\t\t}\n\n\t\t\tconst completed = await this._parseAndUpdateTree(version);\n\t\t\tif (completed) {\n\t\t\t\tlet ranges: RangeChange[] | undefined;\n\t\t\t\tif (!changedNodes) {\n\t\t\t\t\tif (this._ranges) {\n\t\t\t\t\t\tranges = this._ranges.map(r => ({ newRange: new Range(r.startPosition.row + 1, r.startPosition.column + 1, r.endPosition.row + 1, r.endPosition.column + 1), oldRangeLength: r.endIndex - r.startIndex, newRangeStartOffset: r.startIndex, newRangeEndOffset: r.endIndex }));\n\t\t\t\t\t}\n\t\t\t\t} else if (oldTree && changedNodes) {\n\t\t\t\t\tranges = this._findTreeChanges(completed, changedNodes, newRanges);\n\t\t\t\t}\n\t\t\t\tif (!ranges) {\n\t\t\t\t\tranges = [{ newRange: this.textModel.getFullModelRange(), newRangeStartOffset: 0, newRangeEndOffset: this.textModel.getValueLength() }];\n\t\t\t\t}\n\n\t\t\t\tconst previousTree = this._tree.get();\n\t\t\t\ttransaction(tx => {\n\t\t\t\t\tthis._tree.set(completed, tx, { ranges, versionId: version });\n\t\t\t\t\tthis._treeLastParsedVersion.set(version, tx);\n\t\t\t\t});\n\t\t\t\tpreviousTree?.delete();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _applyEdits(changes: IModelContentChange[]) {\n\t\tfor (const change of changes) {\n\t\t\tconst originalTextLength = TextLength.ofRange(Range.lift(change.range));\n\t\t\tconst newTextLength = TextLength.ofText(change.text);\n\t\t\tconst summedTextLengths = change.text.length === 0 ? newTextLength : originalTextLength.add(newTextLength);\n\t\t\tconst edit = {\n\t\t\t\tstartIndex: change.rangeOffset,\n\t\t\t\toldEndIndex: change.rangeOffset + change.rangeLength,\n\t\t\t\tnewEndIndex: change.rangeOffset + change.text.length,\n\t\t\t\tstartPosition: { row: change.range.startLineNumber - 1, column: change.range.startColumn - 1 },\n\t\t\t\toldEndPosition: { row: change.range.endLineNumber - 1, column: change.range.endColumn - 1 },\n\t\t\t\tnewEndPosition: { row: change.range.startLineNumber + summedTextLengths.lineCount - 1, column: summedTextLengths.lineCount ? summedTextLengths.columnCount : (change.range.endColumn + summedTextLengths.columnCount) }\n\t\t\t};\n\t\t\tthis._tree.get()?.edit(edit);\n\t\t\tthis._lastFullyParsedWithEdits?.edit(edit);\n\t\t}\n\t}\n\n\tprivate _findChangedNodes(newTree: TreeSitter.Tree, oldTree: TreeSitter.Tree): TreeSitter.Range[] | undefined {\n\t\tif ((this._ranges && this._ranges.every(range => range.startPosition.row !== newTree.rootNode.startPosition.row)) || newTree.rootNode.startPosition.row !== 0) {\n\t\t\treturn [];\n\t\t}\n\t\tconst newCursor = newTree.walk();\n\t\tconst oldCursor = oldTree.walk();\n\n\t\tconst nodes: TreeSitter.Range[] = [];\n\t\tlet next = true;\n\n\t\tdo {\n\t\t\tif (newCursor.currentNode.hasChanges) {\n\t\t\t\t// Check if only one of the children has changes.\n\t\t\t\t// If it's only one, then we go to that child.\n\t\t\t\t// If it's more then, we need to go to each child\n\t\t\t\t// If it's none, then we've found one of our ranges\n\t\t\t\tconst newChildren = newCursor.currentNode.children;\n\t\t\t\tconst indexChangedChildren: number[] = [];\n\t\t\t\tconst changedChildren = newChildren.filter((c, index) => {\n\t\t\t\t\tif (c?.hasChanges || (oldCursor.currentNode.children.length <= index)) {\n\t\t\t\t\t\tindexChangedChildren.push(index);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t\t// If we have changes and we *had* an error, the whole node should be refreshed.\n\t\t\t\tif ((changedChildren.length === 0) || (newCursor.currentNode.hasError !== oldCursor.currentNode.hasError)) {\n\t\t\t\t\t// walk up again until we get to the first one that's named as unnamed nodes can be too granular\n\t\t\t\t\twhile (newCursor.currentNode.parent && next && !newCursor.currentNode.isNamed) {\n\t\t\t\t\t\tnext = gotoParent(newCursor, oldCursor);\n\t\t\t\t\t}\n\t\t\t\t\t// Use the end position of the previous node and the start position of the current node\n\t\t\t\t\tconst newNode = newCursor.currentNode;\n\t\t\t\t\tconst closestPreviousNode = getClosestPreviousNodes(newCursor, newTree) ?? newNode;\n\t\t\t\t\tnodes.push({\n\t\t\t\t\t\tstartIndex: closestPreviousNode.startIndex,\n\t\t\t\t\t\tendIndex: newNode.endIndex,\n\t\t\t\t\t\tstartPosition: closestPreviousNode.startPosition,\n\t\t\t\t\t\tendPosition: newNode.endPosition\n\t\t\t\t\t});\n\t\t\t\t\tnext = nextSiblingOrParentSibling(newCursor, oldCursor);\n\t\t\t\t} else if (changedChildren.length >= 1) {\n\t\t\t\t\tnext = gotoNthChild(newCursor, oldCursor, indexChangedChildren[0]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnext = nextSiblingOrParentSibling(newCursor, oldCursor);\n\t\t\t}\n\t\t} while (next);\n\n\t\tnewCursor.delete();\n\t\toldCursor.delete();\n\t\treturn nodes;\n\t}\n\n\tprivate _findTreeChanges(newTree: TreeSitter.Tree, changedNodes: TreeSitter.Range[], newRanges: TreeSitter.Range[]): RangeChange[] {\n\t\tlet newRangeIndex = 0;\n\t\tconst mergedChanges: RangeChange[] = [];\n\n\t\t// Find the parent in the new tree of the changed node\n\t\tfor (let nodeIndex = 0; nodeIndex < changedNodes.length; nodeIndex++) {\n\t\t\tconst node = changedNodes[nodeIndex];\n\n\t\t\tif (mergedChanges.length > 0) {\n\t\t\t\tif ((node.startIndex >= mergedChanges[mergedChanges.length - 1].newRangeStartOffset) && (node.endIndex <= mergedChanges[mergedChanges.length - 1].newRangeEndOffset)) {\n\t\t\t\t\t// This node is within the previous range, skip it\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst cursor = newTree.walk();\n\t\t\tconst cursorContainersNode = () => cursor.startIndex < node.startIndex && cursor.endIndex > node.endIndex;\n\n\t\t\twhile (cursorContainersNode()) {\n\t\t\t\t// See if we can go to a child\n\t\t\t\tlet child = cursor.gotoFirstChild();\n\t\t\t\tlet foundChild = false;\n\t\t\t\twhile (child) {\n\t\t\t\t\tif (cursorContainersNode() && cursor.currentNode.isNamed) {\n\t\t\t\t\t\tfoundChild = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild = cursor.gotoNextSibling();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!foundChild) {\n\t\t\t\t\tcursor.gotoParent();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cursor.currentNode.childCount === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst startPosition = cursor.currentNode.startPosition;\n\t\t\tconst endPosition = cursor.currentNode.endPosition;\n\t\t\tconst startIndex = cursor.currentNode.startIndex;\n\t\t\tconst endIndex = cursor.currentNode.endIndex;\n\n\t\t\tconst newChange = { newRange: new Range(startPosition.row + 1, startPosition.column + 1, endPosition.row + 1, endPosition.column + 1), newRangeStartOffset: startIndex, newRangeEndOffset: endIndex };\n\t\t\tif ((newRangeIndex < newRanges.length) && rangesIntersect(newRanges[newRangeIndex], { startIndex, endIndex, startPosition, endPosition })) {\n\t\t\t\t// combine the new change with the range\n\t\t\t\tif (newRanges[newRangeIndex].startIndex < newChange.newRangeStartOffset) {\n\t\t\t\t\tnewChange.newRange = newChange.newRange.setStartPosition(newRanges[newRangeIndex].startPosition.row + 1, newRanges[newRangeIndex].startPosition.column + 1);\n\t\t\t\t\tnewChange.newRangeStartOffset = newRanges[newRangeIndex].startIndex;\n\t\t\t\t}\n\t\t\t\tif (newRanges[newRangeIndex].endIndex > newChange.newRangeEndOffset) {\n\t\t\t\t\tnewChange.newRange = newChange.newRange.setEndPosition(newRanges[newRangeIndex].endPosition.row + 1, newRanges[newRangeIndex].endPosition.column + 1);\n\t\t\t\t\tnewChange.newRangeEndOffset = newRanges[newRangeIndex].endIndex;\n\t\t\t\t}\n\t\t\t\tnewRangeIndex++;\n\t\t\t} else if (newRangeIndex < newRanges.length && newRanges[newRangeIndex].endIndex < newChange.newRangeStartOffset) {\n\t\t\t\t// add the full range to the merged changes\n\t\t\t\tmergedChanges.push({\n\t\t\t\t\tnewRange: new Range(newRanges[newRangeIndex].startPosition.row + 1, newRanges[newRangeIndex].startPosition.column + 1, newRanges[newRangeIndex].endPosition.row + 1, newRanges[newRangeIndex].endPosition.column + 1),\n\t\t\t\t\tnewRangeStartOffset: newRanges[newRangeIndex].startIndex,\n\t\t\t\t\tnewRangeEndOffset: newRanges[newRangeIndex].endIndex\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ((mergedChanges.length > 0) && (mergedChanges[mergedChanges.length - 1].newRangeEndOffset >= newChange.newRangeStartOffset)) {\n\t\t\t\t// Merge the changes\n\t\t\t\tmergedChanges[mergedChanges.length - 1].newRange = Range.fromPositions(mergedChanges[mergedChanges.length - 1].newRange.getStartPosition(), newChange.newRange.getEndPosition());\n\t\t\t\tmergedChanges[mergedChanges.length - 1].newRangeEndOffset = newChange.newRangeEndOffset;\n\t\t\t} else {\n\t\t\t\tmergedChanges.push(newChange);\n\t\t\t}\n\t\t}\n\t\treturn this._constrainRanges(mergedChanges);\n\t}\n\n\tprivate _constrainRanges(changes: RangeChange[]): RangeChange[] {\n\t\tif (!this._ranges) {\n\t\t\treturn changes;\n\t\t}\n\n\t\tconst constrainedChanges: RangeChange[] = [];\n\t\tlet changesIndex = 0;\n\t\tlet rangesIndex = 0;\n\t\twhile (changesIndex < changes.length && rangesIndex < this._ranges.length) {\n\t\t\tconst change = changes[changesIndex];\n\t\t\tconst range = this._ranges[rangesIndex];\n\t\t\tif (change.newRangeEndOffset < range.startIndex) {\n\t\t\t\t// Change is before the range, move to the next change\n\t\t\t\tchangesIndex++;\n\t\t\t} else if (change.newRangeStartOffset > range.endIndex) {\n\t\t\t\t// Change is after the range, move to the next range\n\t\t\t\trangesIndex++;\n\t\t\t} else {\n\t\t\t\t// Change is within the range, constrain it\n\t\t\t\tconst newRangeStartOffset = Math.max(change.newRangeStartOffset, range.startIndex);\n\t\t\t\tconst newRangeEndOffset = Math.min(change.newRangeEndOffset, range.endIndex);\n\t\t\t\tconst newRange = change.newRange.intersectRanges(new Range(range.startPosition.row + 1, range.startPosition.column + 1, range.endPosition.row + 1, range.endPosition.column + 1))!;\n\t\t\t\tconstrainedChanges.push({\n\t\t\t\t\tnewRange,\n\t\t\t\t\tnewRangeEndOffset,\n\t\t\t\t\tnewRangeStartOffset\n\t\t\t\t});\n\t\t\t\t// Remove the intersected range from the current change\n\t\t\t\tif (newRangeEndOffset < change.newRangeEndOffset) {\n\t\t\t\t\tchange.newRange = Range.fromPositions(newRange.getEndPosition(), change.newRange.getEndPosition());\n\t\t\t\t\tchange.newRangeStartOffset = newRangeEndOffset + 1;\n\t\t\t\t} else {\n\t\t\t\t\t// Move to the next change\n\t\t\t\t\tchangesIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn constrainedChanges;\n\t}\n\n\tprivate async _parseAndUpdateTree(version: number): Promise<TreeSitter.Tree | undefined> {\n\t\tconst tree = await this._parse();\n\t\tif (tree) {\n\t\t\tthis._lastFullyParsed?.delete();\n\t\t\tthis._lastFullyParsed = tree.copy();\n\t\t\tthis._lastFullyParsedWithEdits?.delete();\n\t\t\tthis._lastFullyParsedWithEdits = tree.copy();\n\n\t\t\treturn tree;\n\t\t} else if (!this._tree.get()) {\n\t\t\t// No tree means this is the initial parse and there were edits\n\t\t\t// parse function doesn't handle this well and we can end up with an incorrect tree, so we reset\n\t\t\tthis._parser.reset();\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _parse(): Promise<TreeSitter.Tree | undefined> {\n\t\tlet parseType: TelemetryParseType = TelemetryParseType.Full;\n\t\tif (this._tree.get()) {\n\t\t\tparseType = TelemetryParseType.Incremental;\n\t\t}\n\t\treturn this._parseAndYield(parseType);\n\t}\n\n\tprivate async _parseAndYield(parseType: TelemetryParseType): Promise<TreeSitter.Tree | undefined> {\n\t\tlet time: number = 0;\n\t\tlet passes: number = 0;\n\t\tconst inProgressVersion = this.textModel.getVersionId();\n\t\tlet newTree: TreeSitter.Tree | null | undefined;\n\n\t\tconst progressCallback = newTimeOutProgressCallback();\n\n\t\tdo {\n\t\t\tconst timer = performance.now();\n\n\t\t\tnewTree = this._parser.parse((index: number, position?: TreeSitter.Point) => this._parseCallback(index), this._tree.get(), { progressCallback, includedRanges: this._ranges });\n\n\t\t\ttime += performance.now() - timer;\n\t\t\tpasses++;\n\n\t\t\t// So long as this isn't the initial parse, even if the model changes and edits are applied, the tree parsing will continue correctly after the await.\n\t\t\tawait new Promise<void>(resolve => setTimeout0(resolve));\n\n\t\t} while (!this._store.isDisposed && !newTree && inProgressVersion === this.textModel.getVersionId());\n\t\tthis._sendParseTimeTelemetry(parseType, time, passes);\n\t\treturn (newTree && (inProgressVersion === this.textModel.getVersionId())) ? newTree : undefined;\n\t}\n\n\tprivate _parseCallback(index: number): string | undefined {\n\t\ttry {\n\t\t\treturn this.textModel.getTextBuffer().getNearestChunk(index);\n\t\t} catch (e) {\n\t\t\tthis._logService.debug('Error getting chunk for tree-sitter parsing', e);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _setRanges(newRanges: TreeSitter.Range[]): TreeSitter.Range[] {\n\t\tconst unKnownRanges: TreeSitter.Range[] = [];\n\t\t// If we have existing ranges, find the parts of the new ranges that are not included in the existing ones\n\t\tif (this._ranges) {\n\t\t\tfor (const newRange of newRanges) {\n\t\t\t\tlet isFullyIncluded = false;\n\n\t\t\t\tfor (let i = 0; i < this._ranges.length; i++) {\n\t\t\t\t\tconst existingRange = this._ranges[i];\n\n\t\t\t\t\tif (rangesEqual(existingRange, newRange) || rangesIntersect(existingRange, newRange)) {\n\t\t\t\t\t\tisFullyIncluded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!isFullyIncluded) {\n\t\t\t\t\tunKnownRanges.push(newRange);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// No existing ranges, all new ranges are unknown\n\t\t\tunKnownRanges.push(...newRanges);\n\t\t}\n\n\t\tthis._ranges = newRanges;\n\t\treturn unKnownRanges;\n\t}\n\n\tprivate _sendParseTimeTelemetry(parseType: TelemetryParseType, time: number, passes: number): void {\n\t\tthis._logService.debug(`Tree parsing (${parseType}) took ${time} ms and ${passes} passes.`);\n\t\ttype ParseTimeClassification = {\n\t\t\towner: 'alexr00';\n\t\t\tcomment: 'Used to understand how long it takes to parse a tree-sitter tree';\n\t\t\tlanguageId: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; comment: 'The programming language ID.' };\n\t\t\ttime: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; isMeasurement: true; comment: 'The ms it took to parse' };\n\t\t\tpasses: { classification: 'SystemMetaData'; purpose: 'FeatureInsight'; isMeasurement: true; comment: 'The number of passes it took to parse' };\n\t\t};\n\t\tif (parseType === TelemetryParseType.Full) {\n\t\t\tthis._telemetryService.publicLog2<{ languageId: string; time: number; passes: number }, ParseTimeClassification>(`treeSitter.fullParse`, { languageId: this.languageId, time, passes });\n\t\t} else {\n\t\t\tthis._telemetryService.publicLog2<{ languageId: string; time: number; passes: number }, ParseTimeClassification>(`treeSitter.incrementalParse`, { languageId: this.languageId, time, passes });\n\t\t}\n\t}\n\n\tpublic createParsedTreeSync(src: string): TreeSitter.Tree | undefined {\n\t\tconst parser = new this._parserClass();\n\t\tparser.setLanguage(this._parser.language!);\n\t\tconst tree = parser.parse(src);\n\t\tparser.delete();\n\t\treturn tree ?? undefined;\n\t}\n}\n\nconst enum TelemetryParseType {\n\tFull = 'fullParse',\n\tIncremental = 'incrementalParse'\n}\n\nexport interface TreeParseUpdateEvent {\n\tranges: RangeChange[];\n\tversionId: number;\n}\n\nexport interface RangeWithOffsets {\n\trange: Range;\n\tstartOffset: number;\n\tendOffset: number;\n}\n\nexport interface RangeChange {\n\tnewRange: Range;\n\tnewRangeStartOffset: number;\n\tnewRangeEndOffset: number;\n}\n\nfunction newTimeOutProgressCallback(): (state: TreeSitter.ParseState) => void {\n\tlet lastYieldTime: number = performance.now();\n\treturn function parseProgressCallback(_state: TreeSitter.ParseState) {\n\t\tconst now = performance.now();\n\t\tif (now - lastYieldTime > 50) {\n\t\t\tlastYieldTime = now;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n}\nexport function rangesEqual(a: TreeSitter.Range, b: TreeSitter.Range) {\n\treturn (a.startPosition.row === b.startPosition.row)\n\t\t&& (a.startPosition.column === b.startPosition.column)\n\t\t&& (a.endPosition.row === b.endPosition.row)\n\t\t&& (a.endPosition.column === b.endPosition.column)\n\t\t&& (a.startIndex === b.startIndex)\n\t\t&& (a.endIndex === b.endIndex);\n}\n\nexport function rangesIntersect(a: TreeSitter.Range, b: TreeSitter.Range) {\n\treturn (a.startIndex <= b.startIndex && a.endIndex >= b.startIndex) ||\n\t\t(b.startIndex <= a.startIndex && b.endIndex >= a.startIndex);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 8671, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/fixedArray.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/fixedArray.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from '../../../base/common/arrays.js';\n\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray<T> {\n\tprivate _store: T[] = [];\n\n\tconstructor(\n\t\tprivate readonly _default: T\n\t) { }\n\n\tpublic get(index: number): T {\n\t\tif (index < this._store.length) {\n\t\t\treturn this._store[index];\n\t\t}\n\t\treturn this._default;\n\t}\n\n\tpublic set(index: number, value: T): void {\n\t\twhile (index >= this._store.length) {\n\t\t\tthis._store[this._store.length] = this._default;\n\t\t}\n\t\tthis._store[index] = value;\n\t}\n\n\tpublic replace(index: number, oldLength: number, newLength: number): void {\n\t\tif (index >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (oldLength === 0) {\n\t\t\tthis.insert(index, newLength);\n\t\t\treturn;\n\t\t} else if (newLength === 0) {\n\t\t\tthis.delete(index, oldLength);\n\t\t\treturn;\n\t\t}\n\n\t\tconst before = this._store.slice(0, index);\n\t\tconst after = this._store.slice(index + oldLength);\n\t\tconst insertArr = arrayFill(newLength, this._default);\n\t\tthis._store = before.concat(insertArr, after);\n\t}\n\n\tpublic delete(deleteIndex: number, deleteCount: number): void {\n\t\tif (deleteCount === 0 || deleteIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._store.splice(deleteIndex, deleteCount);\n\t}\n\n\tpublic insert(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0 || insertIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr: T[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tarr[i] = this._default;\n\t\t}\n\t\tthis._store = arrayInsert(this._store, insertIndex, arr);\n\t}\n}\n\nfunction arrayFill<T>(length: number, value: T): T[] {\n\tconst arr: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tarr[i] = value;\n\t}\n\treturn arr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from '../../../base/common/arrays.js';\n\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray<T> {\n\tprivate _store: T[] = [];\n\n\tconstructor(\n\t\tprivate readonly _default: T\n\t) { }\n\n\tpublic get(index: number): T {\n\t\tif (index < this._store.length) {\n\t\t\treturn this._store[index];\n\t\t}\n\t\treturn this._default;\n\t}\n\n\tpublic set(index: number, value: T): void {\n\t\twhile (index >= this._store.length) {\n\t\t\tthis._store[this._store.length] = this._default;\n\t\t}\n\t\tthis._store[index] = value;\n\t}\n\n\tpublic replace(index: number, oldLength: number, newLength: number): void {\n\t\tif (index >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (oldLength === 0) {\n\t\t\tthis.insert(index, newLength);\n\t\t\treturn;\n\t\t} else if (newLength === 0) {\n\t\t\tthis.delete(index, oldLength);\n\t\t\treturn;\n\t\t}\n\n\t\tconst before = this._store.slice(0, index);\n\t\tconst after = this._store.slice(index + oldLength);\n\t\tconst insertArr = arrayFill(newLength, this._default);\n\t\tthis._store = before.concat(insertArr, after);\n\t}\n\n\tpublic delete(deleteIndex: number, deleteCount: number): void {\n\t\tif (deleteCount === 0 || deleteIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._store.splice(deleteIndex, deleteCount);\n\t}\n\n\tpublic insert(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0 || insertIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr: T[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tarr[i] = this._default;\n\t\t}\n\t\tthis._store = arrayInsert(this._store, insertIndex, arr);\n\t}\n}\n\nfunction arrayFill<T>(length: number, value: T): T[] {\n\tconst arr: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tarr[i] = value;\n\t}\n\treturn arr;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 8741, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/textModelTokens.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/textModelTokens.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleDeadline, runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { StandardTokenType } from '../encodedTokenAttributes.js';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport } from '../languages.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { ITextModel } from '../model.js';\nimport { FixedArray } from './fixedArray.js';\nimport { IModelContentChange } from './mirrorTextModel.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState;\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport\n\t) {\n\t\tthis.initialState = this.tokenizationSupport.getInitialState() as TState;\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\treturn this.store.getStartState(lineNumber, this.initialState);\n\t}\n\n\tpublic getFirstInvalidLine(): { lineNumber: number; startState: TState } | null {\n\t\treturn this.store.getFirstInvalidLine(this.initialState);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<TState extends IState = IState> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst lineToTokenize = this.getFirstInvalidLine();\n\t\t\tif (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n\t\t\tbuilder.add(lineToTokenize.lineNumber, r.tokens);\n\t\t\tthis.store.setEndState(lineToTokenize.lineNumber, r.endState as TState);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tconst lineStartState: IState | null = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst result: LineTokens[] = [];\n\n\t\tlet state = lineStartState;\n\t\tfor (const line of lines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, true, state);\n\t\t\tresult.push(new LineTokens(r.tokens, line, this._languageIdCodec));\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\treturn (lineNumber < firstInvalidLineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lineNumber === firstInvalidLineNumber\n\t\t\t&& this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): { heuristicTokens: boolean } {\n\t\tif (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet { likelyRelevantLines, initialState } = findLikelyRelevantLines(this._textModel, lineNumber, this);\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\nexport function findLikelyRelevantLines(model: ITextModel, lineNumber: number, store?: TokenizerWithStateStore): { likelyRelevantLines: string[]; initialState?: IState } {\n\tlet nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n\tconst likelyRelevantLines: string[] = [];\n\tlet initialState: IState | null | undefined = null;\n\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\tconst newNonWhitespaceIndex = model.getLineFirstNonWhitespaceColumn(i);\n\t\t// Ignore lines full of whitespace\n\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\tlikelyRelevantLines.push(model.getLineContent(i));\n\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\tinitialState = store?.getStartState(i);\n\t\t\tif (initialState) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlikelyRelevantLines.reverse();\n\treturn { likelyRelevantLines, initialState: initialState ?? undefined };\n}\n\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly _tokenizationStateStore = new TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\t/**\n\t * @returns if the end state has changed.\n\t */\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tif (!state) {\n\t\t\tthrow new BugIndicatingError('Cannot set null/undefined state');\n\t\t}\n\n\t\tthis._invalidEndStatesLineNumbers.delete(lineNumber);\n\t\tconst r = this._tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis._tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null { return this._invalidEndStatesLineNumbers.min; }\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n\t}\n\n\tpublic allStatesValid(): boolean { return this._invalidEndStatesLineNumbers.min === null; }\n\n\tpublic getStartState(lineNumber: number, initialState: TState): TState | null {\n\t\tif (lineNumber === 1) { return initialState; }\n\t\treturn this.getEndState(lineNumber - 1);\n\t}\n\n\tpublic getFirstInvalidLine(initialState: TState): { lineNumber: number; startState: TState } | null {\n\t\tconst lineNumber = this.getFirstInvalidEndStateLineNumber();\n\t\tif (lineNumber === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startState = this.getStartState(lineNumber, initialState);\n\t\tif (!startState) {\n\t\t\tthrow new BugIndicatingError('Start state must be defined');\n\t\t}\n\n\t\treturn { lineNumber, startState };\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic delete(value: number): void {\n\t\tconst idx = this._ranges.findIndex(r => r.contains(value));\n\t\tif (idx !== -1) {\n\t\t\tconst range = this._ranges[idx];\n\t\t\tif (range.start === value) {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges.splice(idx, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(range.start, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(range.start, range.start + newLength);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n\t\t\tconst endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map(r => r.toString()).join(' + ');\n\t}\n}\n\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenGlobalIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.allStatesValid();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tconst firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n\t\tif (!firstInvalidLine) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n\t\treturn firstInvalidLine.lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.allStatesValid()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleDeadline, runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { StandardTokenType } from '../encodedTokenAttributes.js';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport } from '../languages.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { ITextModel } from '../model.js';\nimport { FixedArray } from './fixedArray.js';\nimport { IModelContentChange } from './mirrorTextModel.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState;\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport\n\t) {\n\t\tthis.initialState = this.tokenizationSupport.getInitialState() as TState;\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\treturn this.store.getStartState(lineNumber, this.initialState);\n\t}\n\n\tpublic getFirstInvalidLine(): { lineNumber: number; startState: TState } | null {\n\t\treturn this.store.getFirstInvalidLine(this.initialState);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<TState extends IState = IState> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst lineToTokenize = this.getFirstInvalidLine();\n\t\t\tif (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n\t\t\tbuilder.add(lineToTokenize.lineNumber, r.tokens);\n\t\t\tthis.store.setEndState(lineToTokenize.lineNumber, r.endState as TState);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tconst lineStartState: IState | null = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst result: LineTokens[] = [];\n\n\t\tlet state = lineStartState;\n\t\tfor (const line of lines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, true, state);\n\t\t\tresult.push(new LineTokens(r.tokens, line, this._languageIdCodec));\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\treturn (lineNumber < firstInvalidLineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lineNumber === firstInvalidLineNumber\n\t\t\t&& this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): { heuristicTokens: boolean } {\n\t\tif (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet { likelyRelevantLines, initialState } = findLikelyRelevantLines(this._textModel, lineNumber, this);\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\nexport function findLikelyRelevantLines(model: ITextModel, lineNumber: number, store?: TokenizerWithStateStore): { likelyRelevantLines: string[]; initialState?: IState } {\n\tlet nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n\tconst likelyRelevantLines: string[] = [];\n\tlet initialState: IState | null | undefined = null;\n\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\tconst newNonWhitespaceIndex = model.getLineFirstNonWhitespaceColumn(i);\n\t\t// Ignore lines full of whitespace\n\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\tlikelyRelevantLines.push(model.getLineContent(i));\n\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\tinitialState = store?.getStartState(i);\n\t\t\tif (initialState) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlikelyRelevantLines.reverse();\n\treturn { likelyRelevantLines, initialState: initialState ?? undefined };\n}\n\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly _tokenizationStateStore = new TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\t/**\n\t * @returns if the end state has changed.\n\t */\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tif (!state) {\n\t\t\tthrow new BugIndicatingError('Cannot set null/undefined state');\n\t\t}\n\n\t\tthis._invalidEndStatesLineNumbers.delete(lineNumber);\n\t\tconst r = this._tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis._tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null { return this._invalidEndStatesLineNumbers.min; }\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n\t}\n\n\tpublic allStatesValid(): boolean { return this._invalidEndStatesLineNumbers.min === null; }\n\n\tpublic getStartState(lineNumber: number, initialState: TState): TState | null {\n\t\tif (lineNumber === 1) { return initialState; }\n\t\treturn this.getEndState(lineNumber - 1);\n\t}\n\n\tpublic getFirstInvalidLine(initialState: TState): { lineNumber: number; startState: TState } | null {\n\t\tconst lineNumber = this.getFirstInvalidEndStateLineNumber();\n\t\tif (lineNumber === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startState = this.getStartState(lineNumber, initialState);\n\t\tif (!startState) {\n\t\t\tthrow new BugIndicatingError('Start state must be defined');\n\t\t}\n\n\t\treturn { lineNumber, startState };\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic delete(value: number): void {\n\t\tconst idx = this._ranges.findIndex(r => r.contains(value));\n\t\tif (idx !== -1) {\n\t\t\tconst range = this._ranges[idx];\n\t\t\tif (range.start === value) {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges.splice(idx, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(range.start, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(range.start, range.start + newLength);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n\t\t\tconst endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map(r => r.toString()).join(' + ');\n\t}\n}\n\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenGlobalIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.allStatesValid();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tconst firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n\t\tif (!firstInvalidLine) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n\t\treturn firstInvalidLine.lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.allStatesValid()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;;;;;AAEhG,OAAO,EAAgB,iBAAiB,EAAE,MAAM,+BAA+B,CAAC;AAChF,OAAO,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,MAAM,gCAAgC,CAAC;AACvF,OAAO,EAAE,WAAW,EAAE,MAAM,kCAAkC,CAAC;AAC/D,OAAO,EAAE,SAAS,EAAE,MAAM,mCAAmC,CAAC;AAC9D,OAAO,EAAE,QAAQ,EAAE,MAAM,4BAA4B,CAAC;AACtD,OAAO,EAAE,SAAS,EAAE,MAAM,6BAA6B,CAAC;AACxD,OAAO,EAAE,WAAW,EAAE,MAAM,+BAA+B,CAAC;AAI5D,OAAO,EAAE,mBAAmB,EAAE,MAAM,8BAA8B,CAAC;AAEnE,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAE7C,OAAO,EAAE,gCAAgC,EAAE,MAAM,+CAA+C,CAAC;AACjG,OAAO,EAAE,UAAU,EAAE,MAAM,yBAAyB,CAAC;;;;;;;;;;;;AAM/C,MAAO,uBAAuB;IAa5B,aAAa,CAAC,UAAkB,EAAA;QACtC,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,UAAU,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;IAChE,CAAC;IAEM,mBAAmB,GAAA;QACzB,OAAO,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAC1D,CAAC;IAdD,YACC,SAAiB,EACD,mBAAyC,CAAA;QAAzC,IAAA,CAAA,mBAAmB,GAAnB,mBAAmB,CAAsB;QAEzD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,mBAAmB,CAAC,eAAe,EAAY,CAAC;QACzE,IAAI,CAAC,KAAK,GAAG,IAAI,8BAA8B,CAAS,SAAS,CAAC,CAAC;IACpE,CAAC;CASD;AAEK,MAAO,mCAAoE,SAAQ,uBAA+B;IAUhH,qBAAqB,CAAC,OAAyC,EAAE,UAAkB,EAAA;QACzF,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC;QAEnD,MAAO,IAAI,CAAE,CAAC;YACb,MAAM,cAAc,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAClD,IAAI,CAAC,cAAc,IAAI,cAAc,CAAC,UAAU,GAAG,UAAU,EAAE,CAAC;gBAC/D,MAAM;YACP,CAAC;YAED,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAEvE,MAAM,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,gBAAgB,EAAE,UAAU,EAAE,IAAI,CAAC,mBAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,cAAc,CAAC,UAAU,CAAC,CAAC;YAC3H,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,UAAU,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;YACjD,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,cAAc,CAAC,UAAU,EAAE,CAAC,CAAC,QAAkB,CAAC,CAAC;QACzE,CAAC;IACF,CAAC;IAED,gCAAA,EAAkC,CAC3B,gCAAgC,CAAC,QAAkB,EAAE,SAAiB,EAAA;QAC5E,wCAAwC;QACxC,MAAM,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAC/D,IAAI,CAAC,cAAc,EAAE,CAAC;YACrB,OAAA,EAAA,2BAAA,GAA+B;QAChC,CAAC;QAED,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC;QACnD,MAAM,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAExE,iDAAiD;QACjD,MAAM,IAAI,GAAG,AACZ,WAAW,CAAC,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,GAC3C,SAAS,GACT,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAC5C,CAAC;QAEF,MAAM,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,gBAAgB,EAAE,UAAU,EAAE,IAAI,CAAC,mBAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,cAAc,CAAC,CAAC;QAChH,MAAM,UAAU,GAAG,IAAI,0MAAU,CAAC,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACzE,IAAI,UAAU,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE,CAAC;YACjC,OAAA,EAAA,2BAAA,GAA+B;QAChC,CAAC;QAED,MAAM,UAAU,GAAG,UAAU,CAAC,sBAAsB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC1E,OAAO,UAAU,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;IACpD,CAAC;IAED,gCAAA,EAAkC,CAC3B,eAAe,CAAC,UAAkB,EAAE,KAAe,EAAA;QACzD,MAAM,cAAc,GAAkB,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QACrE,IAAI,CAAC,cAAc,EAAE,CAAC;YACrB,OAAO,IAAI,CAAC;QACb,CAAC;QAED,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC;QACnD,MAAM,MAAM,GAAiB,EAAE,CAAC;QAEhC,IAAI,KAAK,GAAG,cAAc,CAAC;QAC3B,KAAK,MAAM,IAAI,IAAI,KAAK,CAAE,CAAC;YAC1B,MAAM,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,gBAAgB,EAAE,UAAU,EAAE,IAAI,CAAC,mBAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YACvG,MAAM,CAAC,IAAI,CAAC,IAAI,0MAAU,CAAC,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC;YACnE,KAAK,GAAG,CAAC,CAAC,QAAQ,CAAC;QACpB,CAAC;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAEM,wBAAwB,CAAC,UAAkB,EAAA;QACjD,MAAM,sBAAsB,GAAG,IAAI,CAAC,KAAK,CAAC,sCAAsC,EAAE,CAAC;QACnF,OAAO,AAAC,UAAU,GAAG,sBAAsB,CAAC,CAAC;IAC9C,CAAC;IAEM,iBAAiB,CAAC,UAAkB,EAAA;QAC1C,MAAM,sBAAsB,GAAG,IAAI,CAAC,KAAK,CAAC,sCAAsC,EAAE,CAAC;QACnF,IAAI,UAAU,GAAG,sBAAsB,EAAE,CAAC;YACzC,OAAO,IAAI,CAAC;QACb,CAAC;QACD,IAAI,UAAU,KAAK,sBAAsB,IACrC,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,GAAA,KAAA,6CAAA,EAA4C,GAAE,CAAC;YAC3F,OAAO,IAAI,CAAC;QACb,CAAC;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IAED;;OAEG,CACI,qBAAqB,CAAC,OAAyC,EAAE,eAAuB,EAAE,aAAqB,EAAA;QACrH,IAAI,aAAa,IAAI,IAAI,CAAC,KAAK,CAAC,sCAAsC,EAAE,EAAE,CAAC;YAC1E,gBAAgB;YAChB,OAAO;gBAAE,eAAe,EAAE,KAAK;YAAA,CAAE,CAAC;QACnC,CAAC;QAED,IAAI,eAAe,IAAI,IAAI,CAAC,KAAK,CAAC,sCAAsC,EAAE,EAAE,CAAC;YAC5E,iDAAiD;YACjD,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;YACnD,OAAO;gBAAE,eAAe,EAAE,KAAK;YAAA,CAAE,CAAC;QACnC,CAAC;QAED,IAAI,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,eAAe,CAAC,CAAC;QAClD,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC;QAEnD,IAAK,IAAI,UAAU,GAAG,eAAe,EAAE,UAAU,IAAI,aAAa,EAAE,UAAU,EAAE,CAAE,CAAC;YAClF,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YACxD,MAAM,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,gBAAgB,EAAE,UAAU,EAAE,IAAI,CAAC,mBAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YACvG,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;YAClC,KAAK,GAAG,CAAC,CAAC,QAAQ,CAAC;QACpB,CAAC;QAED,OAAO;YAAE,eAAe,EAAE,IAAI;QAAA,CAAE,CAAC;IAClC,CAAC;IAEO,eAAe,CAAC,UAAkB,EAAA;QACzC,IAAI,EAAE,mBAAmB,EAAE,YAAY,EAAE,GAAG,uBAAuB,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;QAEvG,IAAI,CAAC,YAAY,EAAE,CAAC;YACnB,YAAY,GAAG,IAAI,CAAC,mBAAmB,CAAC,eAAe,EAAE,CAAC;QAC3D,CAAC;QAED,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC;QACnD,IAAI,KAAK,GAAG,YAAY,CAAC;QACzB,KAAK,MAAM,IAAI,IAAI,mBAAmB,CAAE,CAAC;YACxC,MAAM,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,gBAAgB,EAAE,UAAU,EAAE,IAAI,CAAC,mBAAmB,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACxG,KAAK,GAAG,CAAC,CAAC,QAAQ,CAAC;QACpB,CAAC;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAtID,YACC,SAAiB,EACjB,mBAAyC,EACzB,UAAsB,EACtB,gBAAkC,CAAA;QAElD,KAAK,CAAC,SAAS,EAAE,mBAAmB,CAAC,CAAC;QAHtB,IAAA,CAAA,UAAU,GAAV,UAAU,CAAY;QACtB,IAAA,CAAA,gBAAgB,GAAhB,gBAAgB,CAAkB;IAGnD,CAAC;CAgID;AAEK,SAAU,uBAAuB,CAAC,KAAiB,EAAE,UAAkB,EAAE,KAA+B;IAC7G,IAAI,mBAAmB,GAAG,KAAK,CAAC,+BAA+B,CAAC,UAAU,CAAC,CAAC;IAC5E,MAAM,mBAAmB,GAAa,EAAE,CAAC;IACzC,IAAI,YAAY,GAA8B,IAAI,CAAC;IACnD,IAAK,IAAI,CAAC,GAAG,UAAU,GAAG,CAAC,EAAE,mBAAmB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAE,CAAC;QACrE,MAAM,qBAAqB,GAAG,KAAK,CAAC,+BAA+B,CAAC,CAAC,CAAC,CAAC;QACvE,kCAAkC;QAClC,IAAI,qBAAqB,KAAK,CAAC,EAAE,CAAC;YACjC,SAAS;QACV,CAAC;QACD,IAAI,qBAAqB,GAAG,mBAAmB,EAAE,CAAC;YACjD,mBAAmB,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;YAClD,mBAAmB,GAAG,qBAAqB,CAAC;YAC5C,YAAY,iDAAG,KAAK,CAAE,aAAa,CAAC,CAAC,CAAC,CAAC;YACvC,IAAI,YAAY,EAAE,CAAC;gBAClB,MAAM;YACP,CAAC;QACF,CAAC;IACF,CAAC;IAED,mBAAmB,CAAC,OAAO,EAAE,CAAC;IAC9B,OAAO;QAAE,mBAAmB;QAAE,YAAY,qDAAE,YAAY,GAAI,SAAS;IAAA,CAAE,CAAC;AACzE,CAAC;AAOK,MAAO,8BAA8B;IAQnC,WAAW,CAAC,UAAkB,EAAA;QACpC,OAAO,IAAI,CAAC,uBAAuB,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;IAC7D,CAAC;IAED;;OAEG,CACI,WAAW,CAAC,UAAkB,EAAE,KAAa,EAAA;QACnD,IAAI,CAAC,KAAK,EAAE,CAAC;YACZ,MAAM,IAAI,kMAAkB,CAAC,iCAAiC,CAAC,CAAC;QACjE,CAAC;QAED,IAAI,CAAC,4BAA4B,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QACrD,MAAM,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,WAAW,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;QACtE,IAAI,CAAC,IAAI,UAAU,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;YACtC,+FAA+F;YAC/F,IAAI,CAAC,4BAA4B,CAAC,QAAQ,CAAC,IAAI,oNAAW,CAAC,UAAU,GAAG,CAAC,EAAE,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;QAC7F,CAAC;QAED,OAAO,CAAC,CAAC;IACV,CAAC;IAEM,YAAY,CAAC,KAAgB,EAAE,YAAoB,EAAA;QACzD,IAAI,CAAC,SAAS,IAAI,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC;QAC9C,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;QAC/D,IAAI,CAAC,4BAA4B,CAAC,iBAAiB,CAAC,IAAI,oNAAW,CAAC,KAAK,CAAC,eAAe,EAAE,KAAK,CAAC,sBAAsB,CAAC,EAAE,YAAY,CAAC,CAAC;IACzI,CAAC;IAEM,aAAa,CAAC,OAA8B,EAAA;QAClD,KAAK,MAAM,CAAC,IAAI,OAAO,CAAE,CAAC;YACzB,MAAM,CAAC,QAAQ,CAAC,OAAG,8MAAQ,EAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YACpC,IAAI,CAAC,YAAY,CAAC,IAAI,gNAAS,CAAC,CAAC,CAAC,KAAK,CAAC,eAAe,EAAE,CAAC,CAAC,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC,EAAE,QAAQ,GAAG,CAAC,CAAC,CAAC;QACpG,CAAC;IACF,CAAC;IAEM,uBAAuB,CAAC,KAAgB,EAAA;QAC9C,IAAI,CAAC,4BAA4B,CAAC,QAAQ,CAAC,IAAI,oNAAW,CAAC,KAAK,CAAC,eAAe,EAAE,KAAK,CAAC,sBAAsB,CAAC,CAAC,CAAC;IAClH,CAAC;IAEM,iCAAiC,GAAA;QAAoB,OAAO,IAAI,CAAC,4BAA4B,CAAC,GAAG,CAAC;IAAC,CAAC;IAEpG,sCAAsC,GAAA;QAC5C,OAAO,IAAI,CAAC,iCAAiC,EAAE,IAAI,MAAM,CAAC,gBAAgB,CAAC;IAC5E,CAAC;IAEM,cAAc,GAAA;QAAc,OAAO,IAAI,CAAC,4BAA4B,CAAC,GAAG,KAAK,IAAI,CAAC;IAAC,CAAC;IAEpF,aAAa,CAAC,UAAkB,EAAE,YAAoB,EAAA;QAC5D,IAAI,UAAU,KAAK,CAAC,EAAE,CAAC;YAAC,OAAO,YAAY,CAAC;QAAC,CAAC;QAC9C,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IACzC,CAAC;IAEM,mBAAmB,CAAC,YAAoB,EAAA;QAC9C,MAAM,UAAU,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;QAC5D,IAAI,UAAU,KAAK,IAAI,EAAE,CAAC;YACzB,OAAO,IAAI,CAAC;QACb,CAAC;QACD,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;QAChE,IAAI,CAAC,UAAU,EAAE,CAAC;YACjB,MAAM,IAAI,kMAAkB,CAAC,6BAA6B,CAAC,CAAC;QAC7D,CAAC;QAED,OAAO;YAAE,UAAU;YAAE,UAAU;QAAA,CAAE,CAAC;IACnC,CAAC;IAnED,YAAoB,SAAiB,CAAA;QAAjB,IAAA,CAAA,SAAS,GAAT,SAAS,CAAQ;QAHpB,IAAA,CAAA,uBAAuB,GAAG,IAAI,sBAAsB,EAAU,CAAC;QAC/D,IAAA,CAAA,4BAA4B,GAAG,IAAI,sBAAsB,EAAE,CAAC;QAG5E,IAAI,CAAC,4BAA4B,CAAC,QAAQ,CAAC,IAAI,oNAAW,CAAC,CAAC,EAAE,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;IAC/E,CAAC;CAkED;AAEK,MAAO,sBAAsB;IAG3B,WAAW,CAAC,UAAkB,EAAA;QACpC,OAAO,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IAC5C,CAAC;IAEM,WAAW,CAAC,UAAkB,EAAE,KAAa,EAAA;QACnD,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QACrD,IAAI,QAAQ,IAAI,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;YACxC,OAAO,KAAK,CAAC;QACd,CAAC;QAED,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;QAC3C,OAAO,IAAI,CAAC;IACb,CAAC;IAEM,YAAY,CAAC,KAAgB,EAAE,YAAoB,EAAA;QACzD,IAAI,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAC1B,IAAI,YAAY,GAAG,CAAC,IAAI,MAAM,GAAG,CAAC,EAAE,CAAC;YACpC,oDAAoD;YACpD,mGAAmG;YACnG,MAAM,EAAE,CAAC;YACT,YAAY,EAAE,CAAC;QAChB,CAAC;QAED,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,eAAe,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC;IAC1E,CAAC;IA3BF,aAAA;QACkB,IAAA,CAAA,cAAc,GAAG,IAAI,yMAAU,CAAgB,IAAI,CAAC,CAAC;IA2BvE,CAAC;CAAA;AAMK,MAAO,sBAAsB;IAGlC,IAAW,GAAG,GAAA;QACb,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC/B,OAAO,IAAI,CAAC;QACb,CAAC;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IAC9B,CAAC;IAEM,MAAM,CAAC,KAAa,EAAA;QAC1B,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;QAC3D,IAAI,GAAG,KAAK,CAAC,CAAC,EAAE,CAAC;YAChB,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAChC,IAAI,KAAK,CAAC,KAAK,KAAK,KAAK,EAAE,CAAC;gBAC3B,IAAI,KAAK,CAAC,YAAY,KAAK,KAAK,GAAG,CAAC,EAAE,CAAC;oBACtC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;gBAC7B,CAAC,MAAM,CAAC;oBACP,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,oNAAW,CAAC,KAAK,GAAG,CAAC,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC;gBACpE,CAAC;YACF,CAAC,MAAM,CAAC;gBACP,IAAI,KAAK,CAAC,YAAY,KAAK,KAAK,GAAG,CAAC,EAAE,CAAC;oBACtC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,oNAAW,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;gBACzD,CAAC,MAAM,CAAC;oBACP,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI,oNAAW,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,oNAAW,CAAC,KAAK,GAAG,CAAC,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;gBAClH,CAAC;YACF,CAAC;QACF,CAAC;IACF,CAAC;IAEM,QAAQ,CAAC,KAAkB,EAAA;QACjC,oNAAW,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;IAC3C,CAAC;IAEM,iBAAiB,CAAC,KAAkB,EAAE,SAAiB,EAAA;QAC7D,IAAI,2BAA2B,GAAG,CAAC,CAAC;QACpC,MAAO,CAAC,CAAC,2BAA2B,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,KAAK,CAAC,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,2BAA2B,CAAC,CAAC,YAAY,CAAC,CAAE,CAAC;YACvI,2BAA2B,EAAE,CAAC;QAC/B,CAAC;QACD,IAAI,eAAe,GAAG,2BAA2B,CAAC;QAClD,MAAO,CAAC,CAAC,eAAe,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,KAAK,CAAC,CAAE,CAAC;YAC9G,eAAe,EAAE,CAAC;QACnB,CAAC;QACD,MAAM,KAAK,GAAG,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC;QAEvC,IAAK,IAAI,CAAC,GAAG,eAAe,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE,CAAC;YAC5D,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAChD,CAAC;QAED,IAAI,2BAA2B,KAAK,eAAe,EAAE,CAAC;YACrD,MAAM,QAAQ,GAAG,IAAI,oNAAW,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC,CAAC;YACvE,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;gBACvB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,2BAA2B,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;YAC/D,CAAC;QACF,CAAC,MAAM,CAAC;YACP,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,2BAA2B,CAAC,CAAC,KAAK,CAAC,CAAC;YACrF,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC,OAAO,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC;YAE3F,MAAM,QAAQ,GAAG,IAAI,oNAAW,CAAC,KAAK,EAAE,KAAK,GAAG,KAAK,CAAC,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;gBACvB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,2BAA2B,EAAE,eAAe,GAAG,2BAA2B,EAAE,QAAQ,CAAC,CAAC;YAC3G,CAAC,MAAM,CAAC;gBACP,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,2BAA2B,EAAE,eAAe,GAAG,2BAA2B,CAAC,CAAC;YACjG,CAAC;QACF,CAAC;IACF,CAAC;IAED,QAAQ,GAAA;QACP,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACxD,CAAC;IArEF,aAAA;QACkB,IAAA,CAAA,OAAO,GAAkB,EAAE,CAAC;IAqE9C,CAAC;CAAA;AAGD,SAAS,YAAY,CAAC,eAAiC,EAAE,UAAkB,EAAE,mBAAgD,EAAE,IAAY,EAAE,MAAe,EAAE,KAAa;IAC1K,IAAI,CAAC,GAAqC,IAAI,CAAC;IAE/C,IAAI,mBAAmB,EAAE,CAAC;QACzB,IAAI,CAAC;YACJ,CAAC,GAAG,mBAAmB,CAAC,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;QACtE,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;gBACZ,iMAAiB,EAAC,CAAC,CAAC,CAAC;QACtB,CAAC;IACF,CAAC;IAED,IAAI,CAAC,CAAC,EAAE,CAAC;QACR,CAAC,OAAG,wNAAmB,EAAC,eAAe,CAAC,gBAAgB,CAAC,UAAU,CAAC,EAAE,KAAK,CAAC,CAAC;IAC9E,CAAC;IAED,0MAAU,CAAC,kBAAkB,CAAC,CAAC,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;IACrD,OAAO,CAAC,CAAC;AACV,CAAC;AAEK,MAAO,0BAA0B;IAS/B,OAAO,GAAA;QACb,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;IACzB,CAAC;IAEM,aAAa,GAAA;QACnB,IAAI,CAAC,4BAA4B,EAAE,CAAC;IACrC,CAAC;IAGO,4BAA4B,GAAA;QACnC,IAAI,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,kBAAkB,EAAE,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,EAAE,CAAC;YACxH,OAAO;QACR,CAAC;QAED,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YACzB,gMAAiB,EAAC,CAAC,QAAQ,EAAE,EAAE;YAC9B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;YAE1B,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,CAAC;QAChD,CAAC,CAAC,CAAC;IACJ,CAAC;IAED;;OAEG,CACK,+BAA+B,CAAC,QAAsB,EAAA;QAC7D,gFAAgF;QAChF,+EAA+E;QAC/E,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,QAAQ,CAAC,aAAa,EAAE,CAAC;QAEtD,MAAM,OAAO,GAAG,GAAG,EAAE;YACpB,IAAI,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,kBAAkB,EAAE,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,EAAE,CAAC;gBACvH,mDAAmD;gBACnD,OAAO;YACR,CAAC;YAED,IAAI,CAAC,gCAAgC,EAAE,CAAC;YAExC,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,OAAO,EAAE,CAAC;gBAC1B,qFAAqF;gBACrF,qBAAqB;oBACrB,6LAAW,EAAC,OAAO,CAAC,CAAC;YACtB,CAAC,MAAM,CAAC;gBACP,8EAA8E;gBAC9E,IAAI,CAAC,4BAA4B,EAAE,CAAC;YACrC,CAAC;QACF,CAAC,CAAC;QACF,OAAO,EAAE,CAAC;IACX,CAAC;IAED;;OAEG,CACK,gCAAgC,GAAA;QACvC,MAAM,SAAS,GAAG,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,YAAY,EAAE,CAAC;QAC1E,MAAM,OAAO,GAAG,IAAI,sPAAgC,EAAE,CAAC;QACvD,MAAM,EAAE,GAAG,4LAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEnC,GAAG,CAAC;YACH,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,CAAC,EAAE,CAAC;gBAItB,MAAM;YACP,CAAC;YAED,MAAM,mBAAmB,GAAG,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC;YAElE,IAAI,mBAAmB,IAAI,SAAS,EAAE,CAAC;gBACtC,MAAM;YACP,CAAC;QACF,CAAC,OAAQ,IAAI,CAAC,mBAAmB,EAAE,CAAE;QAErC,IAAI,CAAC,qBAAqB,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC;QACzD,IAAI,CAAC,aAAa,EAAE,CAAC;IACtB,CAAC;IAEO,mBAAmB,GAAA;QAC1B,IAAI,CAAC,IAAI,CAAC,wBAAwB,EAAE,CAAC;YACpC,OAAO,KAAK,CAAC;QACd,CAAC;QACD,OAAO,CAAC,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC;IAC9D,CAAC;IAEO,uBAAuB,CAAC,OAAyC,EAAA;;QACxE,MAAM,gBAAgB,qCAAG,IAAI,CAAC,wBAAwB,kGAAE,mBAAmB,EAAE,CAAC;QAC9E,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACvB,OAAO,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;QACpE,CAAC;QACD,IAAI,CAAC,wBAAwB,CAAC,qBAAqB,CAAC,OAAO,EAAE,gBAAgB,CAAC,UAAU,CAAC,CAAC;QAC1F,OAAO,gBAAgB,CAAC,UAAU,CAAC;IACpC,CAAC;IAEM,aAAa,GAAA;QACnB,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACtB,OAAO;QACR,CAAC;QACD,IAAI,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,cAAc,EAAE,EAAE,CAAC;YAC1D,IAAI,CAAC,qBAAqB,CAAC,8BAA8B,EAAE,CAAC;QAC7D,CAAC;IACF,CAAC;IAEM,aAAa,CAAC,eAAuB,EAAE,sBAA8B,EAAA;QAC3E,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,uBAAuB,CAAC,IAAI,gNAAS,CAAC,eAAe,EAAE,sBAAsB,CAAC,CAAC,CAAC;IACrH,CAAC;IA9GD,YACkB,wBAA6D,EAC7D,qBAAmD,CAAA;QADnD,IAAA,CAAA,wBAAwB,GAAxB,wBAAwB,CAAqC;QAC7D,IAAA,CAAA,qBAAqB,GAArB,qBAAqB,CAA8B;QAJ7D,IAAA,CAAA,WAAW,GAAG,KAAK,CAAC;QAgBpB,IAAA,CAAA,YAAY,GAAG,KAAK,CAAC;IAV7B,CAAC;CA2GD","debugId":null}},
    {"offset": {"line": 9197, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/tokenStore.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/treeSitter/tokenStore.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/vs/editor/common/model/tokens/treeSitter/tokenStore.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { ITextModel } from '../../../model.js';\n\nclass ListNode implements IDisposable {\n\tparent?: ListNode;\n\tprivate readonly _children: Node[] = [];\n\tget children(): ReadonlyArray<Node> { return this._children; }\n\n\tprivate _length: number = 0;\n\tget length(): number { return this._length; }\n\n\tconstructor(public readonly height: number) { }\n\n\tstatic create(node1: Node, node2: Node) {\n\t\tconst list = new ListNode(node1.height + 1);\n\t\tlist.appendChild(node1);\n\t\tlist.appendChild(node2);\n\t\treturn list;\n\t}\n\n\tcanAppendChild(): boolean {\n\t\treturn this._children.length < 3;\n\t}\n\n\tappendChild(node: Node) {\n\t\tif (!this.canAppendChild()) {\n\t\t\tthrow new Error('Cannot insert more than 3 children in a ListNode');\n\t\t}\n\t\tthis._children.push(node);\n\n\t\tthis._length += node.length;\n\t\tthis._updateParentLength(node.length);\n\t\tif (!isLeaf(node)) {\n\t\t\tnode.parent = this;\n\t\t}\n\t}\n\n\tprivate _updateParentLength(delta: number) {\n\t\tlet updateParent = this.parent;\n\t\twhile (updateParent) {\n\t\t\tupdateParent._length += delta;\n\t\t\tupdateParent = updateParent.parent;\n\t\t}\n\t}\n\n\tunappendChild(): Node {\n\t\tconst child = this._children.pop()!;\n\t\tthis._length -= child.length;\n\t\tthis._updateParentLength(-child.length);\n\t\treturn child;\n\t}\n\n\tprependChild(node: Node) {\n\t\tif (this._children.length >= 3) {\n\t\t\tthrow new Error('Cannot prepend more than 3 children in a ListNode');\n\t\t}\n\t\tthis._children.unshift(node);\n\n\t\tthis._length += node.length;\n\t\tthis._updateParentLength(node.length);\n\t\tif (!isLeaf(node)) {\n\t\t\tnode.parent = this;\n\t\t}\n\t}\n\n\tunprependChild(): Node {\n\t\tconst child = this._children.shift()!;\n\t\tthis._length -= child.length;\n\t\tthis._updateParentLength(-child.length);\n\t\treturn child;\n\t}\n\n\tlastChild(): Node {\n\t\treturn this._children[this._children.length - 1];\n\t}\n\n\tdispose() {\n\t\tthis._children.splice(0, this._children.length);\n\t}\n}\n\nexport enum TokenQuality {\n\tNone = 0,\n\tViewportGuess = 1,\n\tEditGuess = 2,\n\tAccurate = 3\n}\n\ntype Node = ListNode | LeafNode;\n\ninterface LeafNode {\n\treadonly length: number;\n\ttoken: number;\n\ttokenQuality: TokenQuality;\n\theight: 0;\n}\n\nexport interface TokenUpdate {\n\treadonly startOffsetInclusive: number;\n\treadonly length: number;\n\treadonly token: number;\n}\n\nfunction isLeaf(node: Node): node is LeafNode {\n\treturn (node as LeafNode).token !== undefined;\n}\n\n// Heavily inspired by https://github.com/microsoft/vscode/blob/4eb2658d592cb6114a7a393655574176cc790c5b/src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.ts#L108-L109\nfunction append(node: Node, nodeToAppend: Node): Node {\n\tlet curNode = node;\n\tconst parents: ListNode[] = [];\n\tlet nodeToAppendOfCorrectHeight: Node | undefined;\n\twhile (true) {\n\t\tif (nodeToAppend.height === curNode.height) {\n\t\t\tnodeToAppendOfCorrectHeight = nodeToAppend;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (isLeaf(curNode)) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\tcurNode = curNode.lastChild();\n\t}\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToAppendOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.children.length >= 3) {\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tconst newList = ListNode.create(parent.unappendChild()!, nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = newList;\n\t\t\t} else {\n\t\t\t\tparent.appendChild(nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = undefined;\n\t\t\t}\n\t\t}\n\t}\n\tif (nodeToAppendOfCorrectHeight) {\n\t\tconst newList = new ListNode(nodeToAppendOfCorrectHeight.height + 1);\n\t\tnewList.appendChild(node);\n\t\tnewList.appendChild(nodeToAppendOfCorrectHeight);\n\t\treturn newList;\n\t} else {\n\t\treturn node;\n\t}\n}\n\nfunction prepend(list: Node, nodeToAppend: Node): Node {\n\tlet curNode = list;\n\tconst parents: ListNode[] = [];\n\twhile (nodeToAppend.height !== curNode.height) {\n\t\tif (isLeaf(curNode)) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenFast.length <= 3\n\t\tcurNode = curNode.children[0] as ListNode;\n\t}\n\tlet nodeToPrependOfCorrectHeight: Node | undefined = nodeToAppend;\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToPrependOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.children.length >= 3) {\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToPrependOfCorrectHeight = ListNode.create(nodeToPrependOfCorrectHeight, parent.unprependChild());\n\t\t\t} else {\n\t\t\t\tparent.prependChild(nodeToPrependOfCorrectHeight);\n\t\t\t\tnodeToPrependOfCorrectHeight = undefined;\n\t\t\t}\n\t\t}\n\t}\n\tif (nodeToPrependOfCorrectHeight) {\n\t\treturn ListNode.create(nodeToPrependOfCorrectHeight, list);\n\t} else {\n\t\treturn list;\n\t}\n}\n\nfunction concat(node1: Node, node2: Node): Node {\n\tif (node1.height === node2.height) {\n\t\treturn ListNode.create(node1, node2);\n\t}\n\telse if (node1.height > node2.height) {\n\t\t// node1 is the tree we want to insert into\n\t\treturn append(node1, node2);\n\t} else {\n\t\treturn prepend(node2, node1);\n\t}\n}\n\nexport class TokenStore implements IDisposable {\n\tprivate _root: Node;\n\n\tconstructor(private readonly _textModel: ITextModel) {\n\t\tthis._root = this.createEmptyRoot();\n\t}\n\n\tprivate createEmptyRoot(): Node {\n\t\treturn {\n\t\t\tlength: this._textModel.getValueLength(),\n\t\t\ttoken: 0,\n\t\t\theight: 0,\n\t\t\ttokenQuality: TokenQuality.None\n\t\t};\n\t}\n\n\t/**\n\t *\n\t * @param update all the tokens for the document in sequence\n\t */\n\tbuildStore(tokens: TokenUpdate[], tokenQuality: TokenQuality): void {\n\t\tthis._root = this.createFromUpdates(tokens, tokenQuality);\n\t}\n\n\tprivate createFromUpdates(tokens: TokenUpdate[], tokenQuality: TokenQuality): Node {\n\t\tif (tokens.length === 0) {\n\t\t\treturn this.createEmptyRoot();\n\t\t}\n\t\tlet newRoot: Node = {\n\t\t\tlength: tokens[0].length,\n\t\t\ttoken: tokens[0].token,\n\t\t\theight: 0,\n\t\t\ttokenQuality\n\t\t};\n\t\tfor (let j = 1; j < tokens.length; j++) {\n\t\t\tnewRoot = append(newRoot, { length: tokens[j].length, token: tokens[j].token, height: 0, tokenQuality });\n\t\t}\n\t\treturn newRoot;\n\t}\n\n\t/**\n\t *\n\t * @param tokens tokens are in sequence in the document.\n\t */\n\tupdate(length: number, tokens: TokenUpdate[], tokenQuality: TokenQuality) {\n\t\tif (tokens.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis.replace(length, tokens[0].startOffsetInclusive, tokens, tokenQuality);\n\t}\n\n\tdelete(length: number, startOffset: number) {\n\t\tthis.replace(length, startOffset, [], TokenQuality.EditGuess);\n\t}\n\n\t/**\n\t *\n\t * @param tokens tokens are in sequence in the document.\n\t */\n\tprivate replace(length: number, updateOffsetStart: number, tokens: TokenUpdate[], tokenQuality: TokenQuality) {\n\t\tconst firstUnchangedOffsetAfterUpdate = updateOffsetStart + length;\n\t\t// Find the last unchanged node preceding the update\n\t\tconst precedingNodes: Node[] = [];\n\t\t// Find the first unchanged node after the update\n\t\tconst postcedingNodes: Node[] = [];\n\t\tconst stack: { node: Node; offset: number }[] = [{ node: this._root, offset: 0 }];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst node = stack.pop()!;\n\t\t\tconst currentOffset = node.offset;\n\n\t\t\tif (currentOffset < updateOffsetStart && currentOffset + node.node.length <= updateOffsetStart) {\n\t\t\t\tif (!isLeaf(node.node)) {\n\t\t\t\t\tnode.node.parent = undefined;\n\t\t\t\t}\n\t\t\t\tprecedingNodes.push(node.node);\n\t\t\t\tcontinue;\n\t\t\t} else if (isLeaf(node.node) && (currentOffset < updateOffsetStart)) {\n\t\t\t\t// We have a partial preceding node\n\t\t\t\tprecedingNodes.push({ length: updateOffsetStart - currentOffset, token: node.node.token, height: 0, tokenQuality: node.node.tokenQuality });\n\t\t\t\t// Node could also be postceeding, so don't continue\n\t\t\t}\n\n\t\t\tif ((updateOffsetStart <= currentOffset) && (currentOffset + node.node.length <= firstUnchangedOffsetAfterUpdate)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currentOffset >= firstUnchangedOffsetAfterUpdate) {\n\t\t\t\tif (!isLeaf(node.node)) {\n\t\t\t\t\tnode.node.parent = undefined;\n\t\t\t\t}\n\t\t\t\tpostcedingNodes.push(node.node);\n\t\t\t\tcontinue;\n\t\t\t} else if (isLeaf(node.node) && (currentOffset + node.node.length > firstUnchangedOffsetAfterUpdate)) {\n\t\t\t\t// we have a partial postceeding node\n\t\t\t\tpostcedingNodes.push({ length: currentOffset + node.node.length - firstUnchangedOffsetAfterUpdate, token: node.node.token, height: 0, tokenQuality: node.node.tokenQuality });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!isLeaf(node.node)) {\n\t\t\t\t// Push children in reverse order to process them left-to-right when popping\n\t\t\t\tlet childOffset = currentOffset + node.node.length;\n\t\t\t\tfor (let i = node.node.children.length - 1; i >= 0; i--) {\n\t\t\t\t\tchildOffset -= node.node.children[i].length;\n\t\t\t\t\tstack.push({ node: node.node.children[i], offset: childOffset });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet allNodes: Node[];\n\t\tif (tokens.length > 0) {\n\t\t\tallNodes = precedingNodes.concat(this.createFromUpdates(tokens, tokenQuality), postcedingNodes);\n\t\t} else {\n\t\t\tallNodes = precedingNodes.concat(postcedingNodes);\n\t\t}\n\t\tlet newRoot: Node = allNodes[0];\n\t\tfor (let i = 1; i < allNodes.length; i++) {\n\t\t\tnewRoot = concat(newRoot, allNodes[i]);\n\t\t}\n\n\t\tthis._root = newRoot ?? this.createEmptyRoot();\n\t}\n\n\t/**\n\t *\n\t * @param startOffsetInclusive\n\t * @param endOffsetExclusive\n\t * @param visitor Return true from visitor to exit early\n\t * @returns\n\t */\n\tprivate traverseInOrderInRange(startOffsetInclusive: number, endOffsetExclusive: number, visitor: (node: Node, offset: number) => boolean): void {\n\t\tconst stack: { node: Node; offset: number }[] = [{ node: this._root, offset: 0 }];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst { node, offset } = stack.pop()!;\n\t\t\tconst nodeEnd = offset + node.length;\n\n\t\t\t// Skip nodes that are completely before or after the range\n\t\t\tif (nodeEnd <= startOffsetInclusive || offset >= endOffsetExclusive) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (visitor(node, offset)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isLeaf(node)) {\n\t\t\t\t// Push children in reverse order to process them left-to-right when popping\n\t\t\t\tlet childOffset = offset + node.length;\n\t\t\t\tfor (let i = node.children.length - 1; i >= 0; i--) {\n\t\t\t\t\tchildOffset -= node.children[i].length;\n\t\t\t\t\tstack.push({ node: node.children[i], offset: childOffset });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetTokenAt(offset: number): TokenUpdate | undefined {\n\t\tlet result: TokenUpdate | undefined;\n\t\tthis.traverseInOrderInRange(offset, this._root.length, (node, offset) => {\n\t\t\tif (isLeaf(node)) {\n\t\t\t\tresult = { token: node.token, startOffsetInclusive: offset, length: node.length };\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn result;\n\t}\n\n\tgetTokensInRange(startOffsetInclusive: number, endOffsetExclusive: number): TokenUpdate[] {\n\t\tconst result: { token: number; startOffsetInclusive: number; length: number }[] = [];\n\t\tthis.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node, offset) => {\n\t\t\tif (isLeaf(node)) {\n\t\t\t\tlet clippedLength = node.length;\n\t\t\t\tlet clippedOffset = offset;\n\t\t\t\tif ((offset < startOffsetInclusive) && (offset + node.length > endOffsetExclusive)) {\n\t\t\t\t\tclippedOffset = startOffsetInclusive;\n\t\t\t\t\tclippedLength = endOffsetExclusive - startOffsetInclusive;\n\t\t\t\t} else if (offset < startOffsetInclusive) {\n\t\t\t\t\tclippedLength -= (startOffsetInclusive - offset);\n\t\t\t\t\tclippedOffset = startOffsetInclusive;\n\t\t\t\t} else if (offset + node.length > endOffsetExclusive) {\n\t\t\t\t\tclippedLength -= (offset + node.length - endOffsetExclusive);\n\t\t\t\t}\n\t\t\t\tresult.push({ token: node.token, startOffsetInclusive: clippedOffset, length: clippedLength });\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn result;\n\t}\n\n\tmarkForRefresh(startOffsetInclusive: number, endOffsetExclusive: number): void {\n\t\tthis.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node) => {\n\t\t\tif (isLeaf(node)) {\n\t\t\t\tnode.tokenQuality = TokenQuality.None;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n\n\trangeHasTokens(startOffsetInclusive: number, endOffsetExclusive: number, minimumTokenQuality: TokenQuality): boolean {\n\t\tlet hasAny = true;\n\t\tthis.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node) => {\n\t\t\tif (isLeaf(node) && (node.tokenQuality < minimumTokenQuality)) {\n\t\t\t\thasAny = false;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn hasAny;\n\t}\n\n\trangeNeedsRefresh(startOffsetInclusive: number, endOffsetExclusive: number): boolean {\n\t\tlet needsRefresh = false;\n\t\tthis.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node) => {\n\t\t\tif (isLeaf(node) && (node.tokenQuality !== TokenQuality.Accurate)) {\n\t\t\t\tneedsRefresh = true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn needsRefresh;\n\t}\n\n\tgetNeedsRefresh(): { startOffset: number; endOffset: number }[] {\n\t\tconst result: { startOffset: number; endOffset: number }[] = [];\n\n\t\tthis.traverseInOrderInRange(0, this._textModel.getValueLength(), (node, offset) => {\n\t\t\tif (isLeaf(node) && (node.tokenQuality !== TokenQuality.Accurate)) {\n\t\t\t\tif ((result.length > 0) && (result[result.length - 1].endOffset === offset)) {\n\t\t\t\t\tresult[result.length - 1].endOffset += node.length;\n\t\t\t\t} else {\n\t\t\t\t\tresult.push({ startOffset: offset, endOffset: offset + node.length });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn result;\n\t}\n\n\tdispose(): void {\n\t\tconst stack: Array<[Node, boolean]> = [[this._root, false]];\n\t\twhile (stack.length > 0) {\n\t\t\tconst [node, visited] = stack.pop()!;\n\t\t\tif (isLeaf(node)) {\n\t\t\t\t// leaf node does not need to be disposed\n\t\t\t} else if (!visited) {\n\t\t\t\tstack.push([node, true]);\n\t\t\t\tfor (let i = node.children.length - 1; i >= 0; i--) {\n\t\t\t\t\tstack.push([node.children[i], false]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.dispose();\n\t\t\t\tnode.parent = undefined;\n\t\t\t}\n\t\t}\n\t\tthis._root = undefined!;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable } from '../../../../../base/common/lifecycle.js';\nimport { ITextModel } from '../../../model.js';\n\nclass ListNode implements IDisposable {\n\tparent?: ListNode;\n\tprivate readonly _children: Node[] = [];\n\tget children(): ReadonlyArray<Node> { return this._children; }\n\n\tprivate _length: number = 0;\n\tget length(): number { return this._length; }\n\n\tconstructor(public readonly height: number) { }\n\n\tstatic create(node1: Node, node2: Node) {\n\t\tconst list = new ListNode(node1.height + 1);\n\t\tlist.appendChild(node1);\n\t\tlist.appendChild(node2);\n\t\treturn list;\n\t}\n\n\tcanAppendChild(): boolean {\n\t\treturn this._children.length < 3;\n\t}\n\n\tappendChild(node: Node) {\n\t\tif (!this.canAppendChild()) {\n\t\t\tthrow new Error('Cannot insert more than 3 children in a ListNode');\n\t\t}\n\t\tthis._children.push(node);\n\n\t\tthis._length += node.length;\n\t\tthis._updateParentLength(node.length);\n\t\tif (!isLeaf(node)) {\n\t\t\tnode.parent = this;\n\t\t}\n\t}\n\n\tprivate _updateParentLength(delta: number) {\n\t\tlet updateParent = this.parent;\n\t\twhile (updateParent) {\n\t\t\tupdateParent._length += delta;\n\t\t\tupdateParent = updateParent.parent;\n\t\t}\n\t}\n\n\tunappendChild(): Node {\n\t\tconst child = this._children.pop()!;\n\t\tthis._length -= child.length;\n\t\tthis._updateParentLength(-child.length);\n\t\treturn child;\n\t}\n\n\tprependChild(node: Node) {\n\t\tif (this._children.length >= 3) {\n\t\t\tthrow new Error('Cannot prepend more than 3 children in a ListNode');\n\t\t}\n\t\tthis._children.unshift(node);\n\n\t\tthis._length += node.length;\n\t\tthis._updateParentLength(node.length);\n\t\tif (!isLeaf(node)) {\n\t\t\tnode.parent = this;\n\t\t}\n\t}\n\n\tunprependChild(): Node {\n\t\tconst child = this._children.shift()!;\n\t\tthis._length -= child.length;\n\t\tthis._updateParentLength(-child.length);\n\t\treturn child;\n\t}\n\n\tlastChild(): Node {\n\t\treturn this._children[this._children.length - 1];\n\t}\n\n\tdispose() {\n\t\tthis._children.splice(0, this._children.length);\n\t}\n}\n\nexport enum TokenQuality {\n\tNone = 0,\n\tViewportGuess = 1,\n\tEditGuess = 2,\n\tAccurate = 3\n}\n\ntype Node = ListNode | LeafNode;\n\ninterface LeafNode {\n\treadonly length: number;\n\ttoken: number;\n\ttokenQuality: TokenQuality;\n\theight: 0;\n}\n\nexport interface TokenUpdate {\n\treadonly startOffsetInclusive: number;\n\treadonly length: number;\n\treadonly token: number;\n}\n\nfunction isLeaf(node: Node): node is LeafNode {\n\treturn (node as LeafNode).token !== undefined;\n}\n\n// Heavily inspired by https://github.com/microsoft/vscode/blob/4eb2658d592cb6114a7a393655574176cc790c5b/src/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.ts#L108-L109\nfunction append(node: Node, nodeToAppend: Node): Node {\n\tlet curNode = node;\n\tconst parents: ListNode[] = [];\n\tlet nodeToAppendOfCorrectHeight: Node | undefined;\n\twhile (true) {\n\t\tif (nodeToAppend.height === curNode.height) {\n\t\t\tnodeToAppendOfCorrectHeight = nodeToAppend;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (isLeaf(curNode)) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\tcurNode = curNode.lastChild();\n\t}\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToAppendOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.children.length >= 3) {\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tconst newList = ListNode.create(parent.unappendChild()!, nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = newList;\n\t\t\t} else {\n\t\t\t\tparent.appendChild(nodeToAppendOfCorrectHeight);\n\t\t\t\tnodeToAppendOfCorrectHeight = undefined;\n\t\t\t}\n\t\t}\n\t}\n\tif (nodeToAppendOfCorrectHeight) {\n\t\tconst newList = new ListNode(nodeToAppendOfCorrectHeight.height + 1);\n\t\tnewList.appendChild(node);\n\t\tnewList.appendChild(nodeToAppendOfCorrectHeight);\n\t\treturn newList;\n\t} else {\n\t\treturn node;\n\t}\n}\n\nfunction prepend(list: Node, nodeToAppend: Node): Node {\n\tlet curNode = list;\n\tconst parents: ListNode[] = [];\n\twhile (nodeToAppend.height !== curNode.height) {\n\t\tif (isLeaf(curNode)) {\n\t\t\tthrow new Error('unexpected');\n\t\t}\n\t\tparents.push(curNode);\n\t\t// assert 2 <= curNode.childrenFast.length <= 3\n\t\tcurNode = curNode.children[0] as ListNode;\n\t}\n\tlet nodeToPrependOfCorrectHeight: Node | undefined = nodeToAppend;\n\t// assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n\tfor (let i = parents.length - 1; i >= 0; i--) {\n\t\tconst parent = parents[i];\n\t\tif (nodeToPrependOfCorrectHeight) {\n\t\t\t// Can we take the element?\n\t\t\tif (parent.children.length >= 3) {\n\t\t\t\t// we need to split to maintain (2,3)-tree property.\n\t\t\t\t// Send the third element + the new element to the parent.\n\t\t\t\tnodeToPrependOfCorrectHeight = ListNode.create(nodeToPrependOfCorrectHeight, parent.unprependChild());\n\t\t\t} else {\n\t\t\t\tparent.prependChild(nodeToPrependOfCorrectHeight);\n\t\t\t\tnodeToPrependOfCorrectHeight = undefined;\n\t\t\t}\n\t\t}\n\t}\n\tif (nodeToPrependOfCorrectHeight) {\n\t\treturn ListNode.create(nodeToPrependOfCorrectHeight, list);\n\t} else {\n\t\treturn list;\n\t}\n}\n\nfunction concat(node1: Node, node2: Node): Node {\n\tif (node1.height === node2.height) {\n\t\treturn ListNode.create(node1, node2);\n\t}\n\telse if (node1.height > node2.height) {\n\t\t// node1 is the tree we want to insert into\n\t\treturn append(node1, node2);\n\t} else {\n\t\treturn prepend(node2, node1);\n\t}\n}\n\nexport class TokenStore implements IDisposable {\n\tprivate _root: Node;\n\n\tconstructor(private readonly _textModel: ITextModel) {\n\t\tthis._root = this.createEmptyRoot();\n\t}\n\n\tprivate createEmptyRoot(): Node {\n\t\treturn {\n\t\t\tlength: this._textModel.getValueLength(),\n\t\t\ttoken: 0,\n\t\t\theight: 0,\n\t\t\ttokenQuality: TokenQuality.None\n\t\t};\n\t}\n\n\t/**\n\t *\n\t * @param update all the tokens for the document in sequence\n\t */\n\tbuildStore(tokens: TokenUpdate[], tokenQuality: TokenQuality): void {\n\t\tthis._root = this.createFromUpdates(tokens, tokenQuality);\n\t}\n\n\tprivate createFromUpdates(tokens: TokenUpdate[], tokenQuality: TokenQuality): Node {\n\t\tif (tokens.length === 0) {\n\t\t\treturn this.createEmptyRoot();\n\t\t}\n\t\tlet newRoot: Node = {\n\t\t\tlength: tokens[0].length,\n\t\t\ttoken: tokens[0].token,\n\t\t\theight: 0,\n\t\t\ttokenQuality\n\t\t};\n\t\tfor (let j = 1; j < tokens.length; j++) {\n\t\t\tnewRoot = append(newRoot, { length: tokens[j].length, token: tokens[j].token, height: 0, tokenQuality });\n\t\t}\n\t\treturn newRoot;\n\t}\n\n\t/**\n\t *\n\t * @param tokens tokens are in sequence in the document.\n\t */\n\tupdate(length: number, tokens: TokenUpdate[], tokenQuality: TokenQuality) {\n\t\tif (tokens.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis.replace(length, tokens[0].startOffsetInclusive, tokens, tokenQuality);\n\t}\n\n\tdelete(length: number, startOffset: number) {\n\t\tthis.replace(length, startOffset, [], TokenQuality.EditGuess);\n\t}\n\n\t/**\n\t *\n\t * @param tokens tokens are in sequence in the document.\n\t */\n\tprivate replace(length: number, updateOffsetStart: number, tokens: TokenUpdate[], tokenQuality: TokenQuality) {\n\t\tconst firstUnchangedOffsetAfterUpdate = updateOffsetStart + length;\n\t\t// Find the last unchanged node preceding the update\n\t\tconst precedingNodes: Node[] = [];\n\t\t// Find the first unchanged node after the update\n\t\tconst postcedingNodes: Node[] = [];\n\t\tconst stack: { node: Node; offset: number }[] = [{ node: this._root, offset: 0 }];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst node = stack.pop()!;\n\t\t\tconst currentOffset = node.offset;\n\n\t\t\tif (currentOffset < updateOffsetStart && currentOffset + node.node.length <= updateOffsetStart) {\n\t\t\t\tif (!isLeaf(node.node)) {\n\t\t\t\t\tnode.node.parent = undefined;\n\t\t\t\t}\n\t\t\t\tprecedingNodes.push(node.node);\n\t\t\t\tcontinue;\n\t\t\t} else if (isLeaf(node.node) && (currentOffset < updateOffsetStart)) {\n\t\t\t\t// We have a partial preceding node\n\t\t\t\tprecedingNodes.push({ length: updateOffsetStart - currentOffset, token: node.node.token, height: 0, tokenQuality: node.node.tokenQuality });\n\t\t\t\t// Node could also be postceeding, so don't continue\n\t\t\t}\n\n\t\t\tif ((updateOffsetStart <= currentOffset) && (currentOffset + node.node.length <= firstUnchangedOffsetAfterUpdate)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currentOffset >= firstUnchangedOffsetAfterUpdate) {\n\t\t\t\tif (!isLeaf(node.node)) {\n\t\t\t\t\tnode.node.parent = undefined;\n\t\t\t\t}\n\t\t\t\tpostcedingNodes.push(node.node);\n\t\t\t\tcontinue;\n\t\t\t} else if (isLeaf(node.node) && (currentOffset + node.node.length > firstUnchangedOffsetAfterUpdate)) {\n\t\t\t\t// we have a partial postceeding node\n\t\t\t\tpostcedingNodes.push({ length: currentOffset + node.node.length - firstUnchangedOffsetAfterUpdate, token: node.node.token, height: 0, tokenQuality: node.node.tokenQuality });\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!isLeaf(node.node)) {\n\t\t\t\t// Push children in reverse order to process them left-to-right when popping\n\t\t\t\tlet childOffset = currentOffset + node.node.length;\n\t\t\t\tfor (let i = node.node.children.length - 1; i >= 0; i--) {\n\t\t\t\t\tchildOffset -= node.node.children[i].length;\n\t\t\t\t\tstack.push({ node: node.node.children[i], offset: childOffset });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet allNodes: Node[];\n\t\tif (tokens.length > 0) {\n\t\t\tallNodes = precedingNodes.concat(this.createFromUpdates(tokens, tokenQuality), postcedingNodes);\n\t\t} else {\n\t\t\tallNodes = precedingNodes.concat(postcedingNodes);\n\t\t}\n\t\tlet newRoot: Node = allNodes[0];\n\t\tfor (let i = 1; i < allNodes.length; i++) {\n\t\t\tnewRoot = concat(newRoot, allNodes[i]);\n\t\t}\n\n\t\tthis._root = newRoot ?? this.createEmptyRoot();\n\t}\n\n\t/**\n\t *\n\t * @param startOffsetInclusive\n\t * @param endOffsetExclusive\n\t * @param visitor Return true from visitor to exit early\n\t * @returns\n\t */\n\tprivate traverseInOrderInRange(startOffsetInclusive: number, endOffsetExclusive: number, visitor: (node: Node, offset: number) => boolean): void {\n\t\tconst stack: { node: Node; offset: number }[] = [{ node: this._root, offset: 0 }];\n\n\t\twhile (stack.length > 0) {\n\t\t\tconst { node, offset } = stack.pop()!;\n\t\t\tconst nodeEnd = offset + node.length;\n\n\t\t\t// Skip nodes that are completely before or after the range\n\t\t\tif (nodeEnd <= startOffsetInclusive || offset >= endOffsetExclusive) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (visitor(node, offset)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!isLeaf(node)) {\n\t\t\t\t// Push children in reverse order to process them left-to-right when popping\n\t\t\t\tlet childOffset = offset + node.length;\n\t\t\t\tfor (let i = node.children.length - 1; i >= 0; i--) {\n\t\t\t\t\tchildOffset -= node.children[i].length;\n\t\t\t\t\tstack.push({ node: node.children[i], offset: childOffset });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetTokenAt(offset: number): TokenUpdate | undefined {\n\t\tlet result: TokenUpdate | undefined;\n\t\tthis.traverseInOrderInRange(offset, this._root.length, (node, offset) => {\n\t\t\tif (isLeaf(node)) {\n\t\t\t\tresult = { token: node.token, startOffsetInclusive: offset, length: node.length };\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn result;\n\t}\n\n\tgetTokensInRange(startOffsetInclusive: number, endOffsetExclusive: number): TokenUpdate[] {\n\t\tconst result: { token: number; startOffsetInclusive: number; length: number }[] = [];\n\t\tthis.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node, offset) => {\n\t\t\tif (isLeaf(node)) {\n\t\t\t\tlet clippedLength = node.length;\n\t\t\t\tlet clippedOffset = offset;\n\t\t\t\tif ((offset < startOffsetInclusive) && (offset + node.length > endOffsetExclusive)) {\n\t\t\t\t\tclippedOffset = startOffsetInclusive;\n\t\t\t\t\tclippedLength = endOffsetExclusive - startOffsetInclusive;\n\t\t\t\t} else if (offset < startOffsetInclusive) {\n\t\t\t\t\tclippedLength -= (startOffsetInclusive - offset);\n\t\t\t\t\tclippedOffset = startOffsetInclusive;\n\t\t\t\t} else if (offset + node.length > endOffsetExclusive) {\n\t\t\t\t\tclippedLength -= (offset + node.length - endOffsetExclusive);\n\t\t\t\t}\n\t\t\t\tresult.push({ token: node.token, startOffsetInclusive: clippedOffset, length: clippedLength });\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn result;\n\t}\n\n\tmarkForRefresh(startOffsetInclusive: number, endOffsetExclusive: number): void {\n\t\tthis.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node) => {\n\t\t\tif (isLeaf(node)) {\n\t\t\t\tnode.tokenQuality = TokenQuality.None;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t}\n\n\trangeHasTokens(startOffsetInclusive: number, endOffsetExclusive: number, minimumTokenQuality: TokenQuality): boolean {\n\t\tlet hasAny = true;\n\t\tthis.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node) => {\n\t\t\tif (isLeaf(node) && (node.tokenQuality < minimumTokenQuality)) {\n\t\t\t\thasAny = false;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn hasAny;\n\t}\n\n\trangeNeedsRefresh(startOffsetInclusive: number, endOffsetExclusive: number): boolean {\n\t\tlet needsRefresh = false;\n\t\tthis.traverseInOrderInRange(startOffsetInclusive, endOffsetExclusive, (node) => {\n\t\t\tif (isLeaf(node) && (node.tokenQuality !== TokenQuality.Accurate)) {\n\t\t\t\tneedsRefresh = true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn needsRefresh;\n\t}\n\n\tgetNeedsRefresh(): { startOffset: number; endOffset: number }[] {\n\t\tconst result: { startOffset: number; endOffset: number }[] = [];\n\n\t\tthis.traverseInOrderInRange(0, this._textModel.getValueLength(), (node, offset) => {\n\t\t\tif (isLeaf(node) && (node.tokenQuality !== TokenQuality.Accurate)) {\n\t\t\t\tif ((result.length > 0) && (result[result.length - 1].endOffset === offset)) {\n\t\t\t\t\tresult[result.length - 1].endOffset += node.length;\n\t\t\t\t} else {\n\t\t\t\t\tresult.push({ startOffset: offset, endOffset: offset + node.length });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn result;\n\t}\n\n\tdispose(): void {\n\t\tconst stack: Array<[Node, boolean]> = [[this._root, false]];\n\t\twhile (stack.length > 0) {\n\t\t\tconst [node, visited] = stack.pop()!;\n\t\t\tif (isLeaf(node)) {\n\t\t\t\t// leaf node does not need to be disposed\n\t\t\t} else if (!visited) {\n\t\t\t\tstack.push([node, true]);\n\t\t\t\tfor (let i = node.children.length - 1; i >= 0; i--) {\n\t\t\t\t\tstack.push([node.children[i], false]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.dispose();\n\t\t\t\tnode.parent = undefined;\n\t\t\t}\n\t\t}\n\t\tthis._root = undefined!;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 9651, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/treeSitterTokenizationImpl.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/treeSitter/treeSitterTokenizationImpl.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/vs/editor/common/model/tokens/treeSitter/treeSitterTokenizationImpl.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { setTimeout0 } from '../../../../../base/common/platform.js';\nimport { StopWatch } from '../../../../../base/common/stopwatch.js';\nimport { LanguageId } from '../../../encodedTokenAttributes.js';\nimport { ILanguageIdCodec, QueryCapture } from '../../../languages.js';\nimport { IModelContentChangedEvent, IModelTokensChangedEvent } from '../../../textModelEvents.js';\nimport { findLikelyRelevantLines } from '../../textModelTokens.js';\nimport { TokenStore, TokenUpdate, TokenQuality } from './tokenStore.js';\nimport { TreeSitterTree, RangeChange, RangeWithOffsets } from './treeSitterTree.js';\nimport type * as TreeSitter from '@vscode/tree-sitter-wasm';\nimport { autorun, autorunHandleChanges, IObservable, recordChanges, runOnChange } from '../../../../../base/common/observable.js';\nimport { LineRange } from '../../../core/ranges/lineRange.js';\nimport { LineTokens } from '../../../tokens/lineTokens.js';\nimport { Position } from '../../../core/position.js';\nimport { Range } from '../../../core/range.js';\nimport { isDefined } from '../../../../../base/common/types.js';\nimport { ITreeSitterThemeService } from '../../../services/treeSitter/treeSitterThemeService.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\n\nexport class TreeSitterTokenizationImpl extends Disposable {\n\tprivate readonly _tokenStore: TokenStore;\n\tprivate _accurateVersion: number;\n\tprivate _guessVersion: number;\n\n\tprivate readonly _onDidChangeTokens: Emitter<{ changes: IModelTokensChangedEvent }> = this._register(new Emitter());\n\tpublic readonly onDidChangeTokens: Event<{ changes: IModelTokensChangedEvent }> = this._onDidChangeTokens.event;\n\tprivate readonly _onDidCompleteBackgroundTokenization: Emitter<void> = this._register(new Emitter());\n\tpublic readonly onDidChangeBackgroundTokenization: Event<void> = this._onDidCompleteBackgroundTokenization.event;\n\n\tprivate _encodedLanguageId: LanguageId;\n\n\tprivate get _textModel() {\n\t\treturn this._tree.textModel;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tree: TreeSitterTree,\n\t\tprivate readonly _highlightingQueries: TreeSitter.Query,\n\t\tprivate readonly _languageIdCodec: ILanguageIdCodec,\n\t\tprivate readonly _visibleLineRanges: IObservable<readonly LineRange[]>,\n\n\t\t@ITreeSitterThemeService private readonly _treeSitterThemeService: ITreeSitterThemeService,\n\t) {\n\t\tsuper();\n\n\t\tthis._encodedLanguageId = this._languageIdCodec.encodeLanguageId(this._tree.languageId);\n\n\t\tthis._register(runOnChange(this._treeSitterThemeService.onChange, () => {\n\t\t\tthis._updateTheme();\n\t\t}));\n\n\t\tthis._tokenStore = this._register(new TokenStore(this._textModel));\n\t\tthis._accurateVersion = this._textModel.getVersionId();\n\t\tthis._guessVersion = this._textModel.getVersionId();\n\t\tthis._tokenStore.buildStore(this._createEmptyTokens(), TokenQuality.None);\n\n\t\tthis._register(autorun(reader => {\n\t\t\tconst visibleLineRanges = this._visibleLineRanges.read(reader);\n\t\t\tthis._parseAndTokenizeViewPort(visibleLineRanges);\n\t\t}));\n\n\t\tthis._register(autorunHandleChanges({\n\t\t\towner: this,\n\t\t\tchangeTracker: recordChanges({ tree: this._tree.tree }),\n\t\t}, (reader, ctx) => {\n\t\t\tconst changeEvent = ctx.changes.at(0)?.change;\n\t\t\tif (ctx.changes.length > 1) {\n\t\t\t\tthrow new BugIndicatingError('The tree changed twice in one transaction. This is currently not supported and should not happen.');\n\t\t\t}\n\n\t\t\tif (!changeEvent) {\n\t\t\t\tif (ctx.tree) {\n\t\t\t\t\tthis._firstTreeUpdate(this._tree.treeLastParsedVersion.read(reader));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.hasTokens()) {\n\t\t\t\t\t// Mark the range for refresh immediately\n\n\t\t\t\t\tfor (const range of changeEvent.ranges) {\n\t\t\t\t\t\tthis._markForRefresh(range.newRange);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// First time we see a tree we need to build a token store.\n\t\t\t\tif (!this.hasTokens()) {\n\t\t\t\t\tthis._firstTreeUpdate(changeEvent.versionId);\n\t\t\t\t} else {\n\t\t\t\t\tthis._handleTreeUpdate(changeEvent.ranges, changeEvent.versionId);\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic handleContentChanged(e: IModelContentChangedEvent): void {\n\t\tthis._guessVersion = e.versionId;\n\t\tfor (const change of e.changes) {\n\t\t\tif (change.text.length > change.rangeLength) {\n\t\t\t\t// If possible, use the token before the change as the starting point for the new token.\n\t\t\t\t// This is more likely to let the new text be the correct color as typeing is usually at the end of the token.\n\t\t\t\tconst offset = change.rangeOffset > 0 ? change.rangeOffset - 1 : change.rangeOffset;\n\t\t\t\tconst oldToken = this._tokenStore.getTokenAt(offset);\n\t\t\t\tlet newToken: TokenUpdate;\n\t\t\t\tif (oldToken) {\n\t\t\t\t\t// Insert. Just grow the token at this position to include the insert.\n\t\t\t\t\tnewToken = { startOffsetInclusive: oldToken.startOffsetInclusive, length: oldToken.length + change.text.length - change.rangeLength, token: oldToken.token };\n\t\t\t\t\t// Also mark tokens that are in the range of the change as needing a refresh.\n\t\t\t\t\tthis._tokenStore.markForRefresh(offset, change.rangeOffset + (change.text.length > change.rangeLength ? change.text.length : change.rangeLength));\n\t\t\t\t} else {\n\t\t\t\t\t// The document got larger and the change is at the end of the document.\n\t\t\t\t\tnewToken = { startOffsetInclusive: offset, length: change.text.length, token: 0 };\n\t\t\t\t}\n\t\t\t\tthis._tokenStore.update(oldToken?.length ?? 0, [newToken], TokenQuality.EditGuess);\n\t\t\t} else if (change.text.length < change.rangeLength) {\n\t\t\t\t// Delete. Delete the tokens at the corresponding range.\n\t\t\t\tconst deletedCharCount = change.rangeLength - change.text.length;\n\t\t\t\tthis._tokenStore.delete(deletedCharCount, change.rangeOffset);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getLineTokens(lineNumber: number) {\n\t\tconst content = this._textModel.getLineContent(lineNumber);\n\t\tconst rawTokens = this.getTokens(lineNumber);\n\t\treturn new LineTokens(rawTokens, content, this._languageIdCodec);\n\t}\n\n\tprivate _createEmptyTokens() {\n\t\tconst emptyToken = this._emptyToken();\n\t\tconst modelEndOffset = this._textModel.getValueLength();\n\n\t\tconst emptyTokens: TokenUpdate[] = [this._emptyTokensForOffsetAndLength(0, modelEndOffset, emptyToken)];\n\t\treturn emptyTokens;\n\t}\n\n\tprivate _emptyToken() {\n\t\treturn this._treeSitterThemeService.findMetadata([], this._encodedLanguageId, false, undefined);\n\t}\n\n\tprivate _emptyTokensForOffsetAndLength(offset: number, length: number, emptyToken: number): TokenUpdate {\n\t\treturn { token: emptyToken, length: offset + length, startOffsetInclusive: 0 };\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\treturn this.hasTokens(new Range(lineNumber, 1, lineNumber, this._textModel.getLineMaxColumn(lineNumber)));\n\t}\n\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tconst rawLineTokens = this._guessTokensForLinesContent(lineNumber, lines);\n\t\tconst lineTokens: LineTokens[] = [];\n\t\tif (!rawLineTokens) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (let i = 0; i < rawLineTokens.length; i++) {\n\t\t\tlineTokens.push(new LineTokens(rawLineTokens[i], lines[i], this._languageIdCodec));\n\t\t}\n\t\treturn lineTokens;\n\t}\n\n\tprivate _rangeHasTokens(range: Range, minimumTokenQuality: TokenQuality): boolean {\n\t\treturn this._tokenStore.rangeHasTokens(this._textModel.getOffsetAt(range.getStartPosition()), this._textModel.getOffsetAt(range.getEndPosition()), minimumTokenQuality);\n\t}\n\n\tpublic hasTokens(accurateForRange?: Range): boolean {\n\t\tif (!accurateForRange || (this._guessVersion === this._accurateVersion)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !this._tokenStore.rangeNeedsRefresh(this._textModel.getOffsetAt(accurateForRange.getStartPosition()), this._textModel.getOffsetAt(accurateForRange.getEndPosition()));\n\t}\n\n\tpublic getTokens(line: number): Uint32Array {\n\t\tconst lineStartOffset = this._textModel.getOffsetAt({ lineNumber: line, column: 1 });\n\t\tconst lineEndOffset = this._textModel.getOffsetAt({ lineNumber: line, column: this._textModel.getLineLength(line) + 1 });\n\t\tconst lineTokens = this._tokenStore.getTokensInRange(lineStartOffset, lineEndOffset);\n\t\tconst result = new Uint32Array(lineTokens.length * 2);\n\t\tfor (let i = 0; i < lineTokens.length; i++) {\n\t\t\tresult[i * 2] = lineTokens[i].startOffsetInclusive - lineStartOffset + lineTokens[i].length;\n\t\t\tresult[i * 2 + 1] = lineTokens[i].token;\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetTokensInRange(range: Range, rangeStartOffset: number, rangeEndOffset: number, captures?: QueryCapture[]): TokenUpdate[] | undefined {\n\t\tconst tokens = captures ? this._tokenizeCapturesWithMetadata(captures, rangeStartOffset, rangeEndOffset) : this._tokenize(range, rangeStartOffset, rangeEndOffset);\n\t\tif (tokens?.endOffsetsAndMetadata) {\n\t\t\treturn this._rangeTokensAsUpdates(rangeStartOffset, tokens.endOffsetsAndMetadata);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _updateTokensInStore(version: number, updates: { oldRangeLength?: number; newTokens: TokenUpdate[] }[], tokenQuality: TokenQuality): void {\n\t\tthis._accurateVersion = version;\n\t\tfor (const update of updates) {\n\t\t\tconst lastToken = update.newTokens.length > 0 ? update.newTokens[update.newTokens.length - 1] : undefined;\n\t\t\tlet oldRangeLength: number;\n\t\t\tif (lastToken && (this._guessVersion >= version)) {\n\t\t\t\toldRangeLength = lastToken.startOffsetInclusive + lastToken.length - update.newTokens[0].startOffsetInclusive;\n\t\t\t} else if (update.oldRangeLength) {\n\t\t\t\toldRangeLength = update.oldRangeLength;\n\t\t\t} else {\n\t\t\t\toldRangeLength = 0;\n\t\t\t}\n\t\t\tthis._tokenStore.update(oldRangeLength, update.newTokens, tokenQuality);\n\t\t}\n\t}\n\n\tprivate _markForRefresh(range: Range): void {\n\t\tthis._tokenStore.markForRefresh(this._textModel.getOffsetAt(range.getStartPosition()), this._textModel.getOffsetAt(range.getEndPosition()));\n\t}\n\n\tprivate _getNeedsRefresh(): { range: Range; startOffset: number; endOffset: number }[] {\n\t\tconst needsRefreshOffsetRanges = this._tokenStore.getNeedsRefresh();\n\t\tif (!needsRefreshOffsetRanges) {\n\t\t\treturn [];\n\t\t}\n\t\treturn needsRefreshOffsetRanges.map(range => ({\n\t\t\trange: Range.fromPositions(this._textModel.getPositionAt(range.startOffset), this._textModel.getPositionAt(range.endOffset)),\n\t\t\tstartOffset: range.startOffset,\n\t\t\tendOffset: range.endOffset\n\t\t}));\n\t}\n\n\n\tprivate _parseAndTokenizeViewPort(lineRanges: readonly LineRange[]) {\n\t\tconst viewportRanges = lineRanges.map(r => r.toInclusiveRange()).filter(isDefined);\n\t\tfor (const range of viewportRanges) {\n\t\t\tconst startOffsetOfRangeInDocument = this._textModel.getOffsetAt(range.getStartPosition());\n\t\t\tconst endOffsetOfRangeInDocument = this._textModel.getOffsetAt(range.getEndPosition());\n\t\t\tconst version = this._textModel.getVersionId();\n\t\t\tif (this._rangeHasTokens(range, TokenQuality.ViewportGuess)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst content = this._textModel.getValueInRange(range);\n\t\t\tconst tokenUpdates = this._forceParseAndTokenizeContent(range, startOffsetOfRangeInDocument, endOffsetOfRangeInDocument, content, true);\n\t\t\tif (!tokenUpdates || this._rangeHasTokens(range, TokenQuality.ViewportGuess)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tokenUpdates.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst lastToken = tokenUpdates[tokenUpdates.length - 1];\n\t\t\tconst oldRangeLength = lastToken.startOffsetInclusive + lastToken.length - tokenUpdates[0].startOffsetInclusive;\n\t\t\tthis._updateTokensInStore(version, [{ newTokens: tokenUpdates, oldRangeLength }], TokenQuality.ViewportGuess);\n\t\t\tthis._onDidChangeTokens.fire({ changes: { semanticTokensApplied: false, ranges: [{ fromLineNumber: range.startLineNumber, toLineNumber: range.endLineNumber }] } });\n\t\t}\n\t}\n\n\tprivate _guessTokensForLinesContent(lineNumber: number, lines: string[]): Uint32Array[] | undefined {\n\t\tif (lines.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst lineContent = lines.join(this._textModel.getEOL());\n\t\tconst range = new Range(1, 1, lineNumber + lines.length, lines[lines.length - 1].length + 1);\n\t\tconst startOffset = this._textModel.getOffsetAt({ lineNumber, column: 1 });\n\t\tconst tokens = this._forceParseAndTokenizeContent(range, startOffset, startOffset + lineContent.length, lineContent, false);\n\t\tif (!tokens) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst tokensByLine: Uint32Array[] = new Array(lines.length);\n\t\tlet tokensIndex: number = 0;\n\t\tlet tokenStartOffset = 0;\n\t\tlet lineStartOffset = 0;\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst tokensForLine: EndOffsetToken[] = [];\n\t\t\tlet moveToNextLine = false;\n\t\t\tfor (let j = tokensIndex; (!moveToNextLine && (j < tokens.length)); j++) {\n\t\t\t\tconst token = tokens[j];\n\t\t\t\tconst lineAdjustedEndOffset = token.endOffset - lineStartOffset;\n\t\t\t\tconst lineAdjustedStartOffset = tokenStartOffset - lineStartOffset;\n\t\t\t\tif (lineAdjustedEndOffset <= lines[i].length) {\n\t\t\t\t\ttokensForLine.push({ endOffset: lineAdjustedEndOffset, metadata: token.metadata });\n\t\t\t\t\ttokensIndex++;\n\t\t\t\t} else if (lineAdjustedStartOffset < lines[i].length) {\n\t\t\t\t\tconst partialToken: EndOffsetToken = { endOffset: lines[i].length, metadata: token.metadata };\n\t\t\t\t\ttokensForLine.push(partialToken);\n\t\t\t\t\tmoveToNextLine = true;\n\t\t\t\t} else {\n\t\t\t\t\tmoveToNextLine = true;\n\t\t\t\t}\n\t\t\t\ttokenStartOffset = token.endOffset;\n\t\t\t}\n\n\t\t\ttokensByLine[i] = this._endOffsetTokensToUint32Array(tokensForLine);\n\t\t\tlineStartOffset += lines[i].length + this._textModel.getEOL().length;\n\t\t}\n\n\t\treturn tokensByLine;\n\t}\n\n\tprivate _forceParseAndTokenizeContent(range: Range, startOffsetOfRangeInDocument: number, endOffsetOfRangeInDocument: number, content: string, asUpdate: true): TokenUpdate[] | undefined;\n\tprivate _forceParseAndTokenizeContent(range: Range, startOffsetOfRangeInDocument: number, endOffsetOfRangeInDocument: number, content: string, asUpdate: false): EndOffsetToken[] | undefined;\n\tprivate _forceParseAndTokenizeContent(range: Range, startOffsetOfRangeInDocument: number, endOffsetOfRangeInDocument: number, content: string, asUpdate: boolean): EndOffsetToken[] | TokenUpdate[] | undefined {\n\t\tconst likelyRelevantLines = findLikelyRelevantLines(this._textModel, range.startLineNumber).likelyRelevantLines;\n\t\tconst likelyRelevantPrefix = likelyRelevantLines.join(this._textModel.getEOL());\n\n\t\tconst tree = this._tree.createParsedTreeSync(`${likelyRelevantPrefix}${content}`);\n\t\tif (!tree) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst treeRange = new Range(1, 1, range.endLineNumber - range.startLineNumber + 1 + likelyRelevantLines.length, range.endColumn);\n\t\tconst captures = this.captureAtRange(treeRange);\n\t\tconst tokens = this._tokenizeCapturesWithMetadata(captures, likelyRelevantPrefix.length, endOffsetOfRangeInDocument - startOffsetOfRangeInDocument + likelyRelevantPrefix.length);\n\t\ttree.delete();\n\n\t\tif (!tokens) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (asUpdate) {\n\t\t\treturn this._rangeTokensAsUpdates(startOffsetOfRangeInDocument, tokens.endOffsetsAndMetadata, likelyRelevantPrefix.length);\n\t\t} else {\n\t\t\treturn tokens.endOffsetsAndMetadata;\n\t\t}\n\t}\n\n\n\tprivate _firstTreeUpdate(versionId: number) {\n\t\treturn this._setViewPortTokens(versionId);\n\t}\n\n\tprivate _setViewPortTokens(versionId: number) {\n\t\tconst rangeChanges = this._visibleLineRanges.get().map<RangeChange | undefined>(lineRange => {\n\t\t\tconst range = lineRange.toInclusiveRange();\n\t\t\tif (!range) { return undefined; }\n\t\t\tconst newRangeStartOffset = this._textModel.getOffsetAt(range.getStartPosition());\n\t\t\tconst newRangeEndOffset = this._textModel.getOffsetAt(range.getEndPosition());\n\t\t\treturn {\n\t\t\t\tnewRange: range,\n\t\t\t\tnewRangeEndOffset,\n\t\t\t\tnewRangeStartOffset,\n\t\t\t};\n\t\t}).filter(isDefined);\n\n\t\treturn this._handleTreeUpdate(rangeChanges, versionId);\n\t}\n\n\t/**\n\t * Do not await in this method, it will cause a race\n\t */\n\tprivate _handleTreeUpdate(ranges: RangeChange[], versionId: number) {\n\t\tconst rangeChanges: RangeWithOffsets[] = [];\n\t\tconst chunkSize = 1000;\n\n\t\tfor (let i = 0; i < ranges.length; i++) {\n\t\t\tconst rangeLinesLength = ranges[i].newRange.endLineNumber - ranges[i].newRange.startLineNumber;\n\t\t\tif (rangeLinesLength > chunkSize) {\n\t\t\t\t// Split the range into chunks to avoid long operations\n\t\t\t\tconst fullRangeEndLineNumber = ranges[i].newRange.endLineNumber;\n\t\t\t\tlet chunkLineStart = ranges[i].newRange.startLineNumber;\n\t\t\t\tlet chunkColumnStart = ranges[i].newRange.startColumn;\n\t\t\t\tlet chunkLineEnd = chunkLineStart + chunkSize;\n\t\t\t\tdo {\n\t\t\t\t\tconst chunkStartingPosition = new Position(chunkLineStart, chunkColumnStart);\n\t\t\t\t\tconst chunkEndColumn = ((chunkLineEnd === ranges[i].newRange.endLineNumber) ? ranges[i].newRange.endColumn : this._textModel.getLineMaxColumn(chunkLineEnd));\n\t\t\t\t\tconst chunkEndPosition = new Position(chunkLineEnd, chunkEndColumn);\n\t\t\t\t\tconst chunkRange = Range.fromPositions(chunkStartingPosition, chunkEndPosition);\n\n\t\t\t\t\trangeChanges.push({\n\t\t\t\t\t\trange: chunkRange,\n\t\t\t\t\t\tstartOffset: this._textModel.getOffsetAt(chunkRange.getStartPosition()),\n\t\t\t\t\t\tendOffset: this._textModel.getOffsetAt(chunkRange.getEndPosition())\n\t\t\t\t\t});\n\n\t\t\t\t\tchunkLineStart = chunkLineEnd + 1;\n\t\t\t\t\tchunkColumnStart = 1;\n\t\t\t\t\tif (chunkLineEnd < fullRangeEndLineNumber && chunkLineEnd + chunkSize > fullRangeEndLineNumber) {\n\t\t\t\t\t\tchunkLineEnd = fullRangeEndLineNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunkLineEnd = chunkLineEnd + chunkSize;\n\t\t\t\t\t}\n\t\t\t\t} while (chunkLineEnd <= fullRangeEndLineNumber);\n\t\t\t} else {\n\t\t\t\t// Check that the previous range doesn't overlap\n\t\t\t\tif ((i === 0) || (rangeChanges[i - 1].endOffset < ranges[i].newRangeStartOffset)) {\n\t\t\t\t\trangeChanges.push({\n\t\t\t\t\t\trange: ranges[i].newRange,\n\t\t\t\t\t\tstartOffset: ranges[i].newRangeStartOffset,\n\t\t\t\t\t\tendOffset: ranges[i].newRangeEndOffset\n\t\t\t\t\t});\n\t\t\t\t} else if (rangeChanges[i - 1].endOffset < ranges[i].newRangeEndOffset) {\n\t\t\t\t\t// clip the range to the previous range\n\t\t\t\t\tconst startPosition = this._textModel.getPositionAt(rangeChanges[i - 1].endOffset + 1);\n\t\t\t\t\tconst range = new Range(startPosition.lineNumber, startPosition.column, ranges[i].newRange.endLineNumber, ranges[i].newRange.endColumn);\n\t\t\t\t\trangeChanges.push({\n\t\t\t\t\t\trange,\n\t\t\t\t\t\tstartOffset: rangeChanges[i - 1].endOffset + 1,\n\t\t\t\t\t\tendOffset: ranges[i].newRangeEndOffset\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Get the captures immediately while the text model is correct\n\t\tconst captures = rangeChanges.map(range => this._getCaptures(range.range));\n\t\t// Don't block\n\t\treturn this._updateTreeForRanges(rangeChanges, versionId, captures).then(() => {\n\t\t\tif (!this._textModel.isDisposed() && (this._tree.treeLastParsedVersion.get() === this._textModel.getVersionId())) {\n\t\t\t\tthis._refreshNeedsRefresh(versionId);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async _updateTreeForRanges(rangeChanges: RangeWithOffsets[], versionId: number, captures: QueryCapture[][]) {\n\t\tlet tokenUpdate: { newTokens: TokenUpdate[] } | undefined;\n\n\t\tfor (let i = 0; i < rangeChanges.length; i++) {\n\t\t\tif (!this._textModel.isDisposed() && versionId !== this._textModel.getVersionId()) {\n\t\t\t\t// Our captures have become invalid and we need to re-capture\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst capture = captures[i];\n\t\t\tconst range = rangeChanges[i];\n\n\t\t\tconst updates = this.getTokensInRange(range.range, range.startOffset, range.endOffset, capture);\n\t\t\tif (updates) {\n\t\t\t\ttokenUpdate = { newTokens: updates };\n\t\t\t} else {\n\t\t\t\ttokenUpdate = { newTokens: [] };\n\t\t\t}\n\t\t\tthis._updateTokensInStore(versionId, [tokenUpdate], TokenQuality.Accurate);\n\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\tchanges: {\n\t\t\t\t\tsemanticTokensApplied: false,\n\t\t\t\t\tranges: [{ fromLineNumber: range.range.getStartPosition().lineNumber, toLineNumber: range.range.getEndPosition().lineNumber }]\n\t\t\t\t}\n\t\t\t});\n\t\t\tawait new Promise<void>(resolve => setTimeout0(resolve));\n\t\t}\n\t\tthis._onDidCompleteBackgroundTokenization.fire();\n\t}\n\n\tprivate _refreshNeedsRefresh(versionId: number) {\n\t\tconst rangesToRefresh = this._getNeedsRefresh();\n\t\tif (rangesToRefresh.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst rangeChanges: RangeChange[] = new Array(rangesToRefresh.length);\n\n\t\tfor (let i = 0; i < rangesToRefresh.length; i++) {\n\t\t\tconst range = rangesToRefresh[i];\n\t\t\trangeChanges[i] = {\n\t\t\t\tnewRange: range.range,\n\t\t\t\tnewRangeStartOffset: range.startOffset,\n\t\t\t\tnewRangeEndOffset: range.endOffset\n\t\t\t};\n\t\t}\n\n\t\tthis._handleTreeUpdate(rangeChanges, versionId);\n\t}\n\n\tprivate _rangeTokensAsUpdates(rangeOffset: number, endOffsetToken: EndOffsetToken[], startingOffsetInArray?: number) {\n\t\tconst updates: TokenUpdate[] = [];\n\t\tlet lastEnd = 0;\n\t\tfor (const token of endOffsetToken) {\n\t\t\tif (token.endOffset <= lastEnd || (startingOffsetInArray && (token.endOffset < startingOffsetInArray))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet tokenUpdate: TokenUpdate;\n\t\t\tif (startingOffsetInArray && (lastEnd < startingOffsetInArray)) {\n\t\t\t\ttokenUpdate = { startOffsetInclusive: rangeOffset + startingOffsetInArray, length: token.endOffset - startingOffsetInArray, token: token.metadata };\n\t\t\t} else {\n\t\t\t\ttokenUpdate = { startOffsetInclusive: rangeOffset + lastEnd, length: token.endOffset - lastEnd, token: token.metadata };\n\t\t\t}\n\t\t\tupdates.push(tokenUpdate);\n\t\t\tlastEnd = token.endOffset;\n\t\t}\n\t\treturn updates;\n\t}\n\n\tprivate _updateTheme() {\n\t\tconst modelRange = this._textModel.getFullModelRange();\n\t\tthis._markForRefresh(modelRange);\n\t\tthis._parseAndTokenizeViewPort(this._visibleLineRanges.get());\n\t}\n\n\tprivate captureAtRange(range: Range): QueryCapture[] {\n\t\tconst tree = this._tree.tree.get();\n\t\tif (!tree) {\n\t\t\treturn [];\n\t\t}\n\t\t// Tree sitter row is 0 based, column is 0 based\n\t\treturn this._highlightingQueries.captures(tree.rootNode, { startPosition: { row: range.startLineNumber - 1, column: range.startColumn - 1 }, endPosition: { row: range.endLineNumber - 1, column: range.endColumn - 1 } }).map(capture => (\n\t\t\t{\n\t\t\t\tname: capture.name,\n\t\t\t\ttext: capture.node.text,\n\t\t\t\tnode: {\n\t\t\t\t\tstartIndex: capture.node.startIndex,\n\t\t\t\t\tendIndex: capture.node.endIndex,\n\t\t\t\t\tstartPosition: {\n\t\t\t\t\t\tlineNumber: capture.node.startPosition.row + 1,\n\t\t\t\t\t\tcolumn: capture.node.startPosition.column + 1\n\t\t\t\t\t},\n\t\t\t\t\tendPosition: {\n\t\t\t\t\t\tlineNumber: capture.node.endPosition.row + 1,\n\t\t\t\t\t\tcolumn: capture.node.endPosition.column + 1\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tencodedLanguageId: this._encodedLanguageId\n\t\t\t}\n\t\t));\n\t}\n\n\tprivate captureAtRangeWithInjections(range: Range): QueryCapture[] {\n\t\tconst captures: QueryCapture[] = this.captureAtRange(range);\n\t\tfor (let i = 0; i < captures.length; i++) {\n\t\t\tconst capture = captures[i];\n\n\t\t\tconst capStartLine = capture.node.startPosition.lineNumber;\n\t\t\tconst capEndLine = capture.node.endPosition.lineNumber;\n\t\t\tconst capStartColumn = capture.node.startPosition.column;\n\t\t\tconst capEndColumn = capture.node.endPosition.column;\n\n\t\t\tconst startLine = ((capStartLine > range.startLineNumber) && (capStartLine < range.endLineNumber)) ? capStartLine : range.startLineNumber;\n\t\t\tconst endLine = ((capEndLine > range.startLineNumber) && (capEndLine < range.endLineNumber)) ? capEndLine : range.endLineNumber;\n\t\t\tconst startColumn = (capStartLine === range.startLineNumber) ? (capStartColumn < range.startColumn ? range.startColumn : capStartColumn) : (capStartLine < range.startLineNumber ? range.startColumn : capStartColumn);\n\t\t\tconst endColumn = (capEndLine === range.endLineNumber) ? (capEndColumn > range.endColumn ? range.endColumn : capEndColumn) : (capEndLine > range.endLineNumber ? range.endColumn : capEndColumn);\n\t\t\tconst injectionRange = new Range(startLine, startColumn, endLine, endColumn);\n\n\t\t\tconst injection = this._getInjectionCaptures(capture, injectionRange);\n\t\t\tif (injection && injection.length > 0) {\n\t\t\t\tcaptures.splice(i + 1, 0, ...injection);\n\t\t\t\ti += injection.length;\n\t\t\t}\n\t\t}\n\t\treturn captures;\n\t}\n\n\t/**\n\t * Gets the tokens for a given line.\n\t * Each token takes 2 elements in the array. The first element is the offset of the end of the token *in the line, not in the document*, and the second element is the metadata.\n\t *\n\t * @param lineNumber\n\t * @returns\n\t */\n\tpublic tokenizeEncoded(lineNumber: number) {\n\t\tconst tokens = this._tokenizeEncoded(lineNumber);\n\t\tif (!tokens) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst updates = this._rangeTokensAsUpdates(this._textModel.getOffsetAt({ lineNumber, column: 1 }), tokens.result);\n\t\tif (tokens.versionId === this._textModel.getVersionId()) {\n\t\t\tthis._updateTokensInStore(tokens.versionId, [{ newTokens: updates, oldRangeLength: this._textModel.getLineLength(lineNumber) }], TokenQuality.Accurate);\n\t\t}\n\t}\n\n\tprivate _getCaptures(range: Range): QueryCapture[] {\n\t\tconst captures = this.captureAtRangeWithInjections(range);\n\t\treturn captures;\n\t}\n\n\tprivate _tokenize(range: Range, rangeStartOffset: number, rangeEndOffset: number): { endOffsetsAndMetadata: { endOffset: number; metadata: number }[]; versionId: number; captureTime: number; metadataTime: number } | undefined {\n\t\tconst captures = this._getCaptures(range);\n\t\tconst result = this._tokenizeCapturesWithMetadata(captures, rangeStartOffset, rangeEndOffset);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn { ...result, versionId: this._tree.treeLastParsedVersion.get() };\n\t}\n\n\tprivate _createTokensFromCaptures(captures: QueryCapture[], rangeStartOffset: number, rangeEndOffset: number): { endOffsets: EndOffsetAndScopes[]; captureTime: number } | undefined {\n\t\tconst tree = this._tree.tree.get();\n\t\tconst stopwatch = StopWatch.create();\n\t\tconst rangeLength = rangeEndOffset - rangeStartOffset;\n\t\tconst encodedLanguageId = this._languageIdCodec.encodeLanguageId(this._tree.languageId);\n\t\tconst baseScope: string = TREESITTER_BASE_SCOPES[this._tree.languageId] || 'source';\n\n\t\tif (captures.length === 0) {\n\t\t\tif (tree) {\n\t\t\t\tstopwatch.stop();\n\t\t\t\tconst endOffsetsAndMetadata = [{ endOffset: rangeLength, scopes: [], encodedLanguageId }];\n\t\t\t\treturn { endOffsets: endOffsetsAndMetadata, captureTime: stopwatch.elapsed() };\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst endOffsetsAndScopes: EndOffsetAndScopes[] = Array(captures.length);\n\t\tendOffsetsAndScopes.fill({ endOffset: 0, scopes: [baseScope], encodedLanguageId });\n\t\tlet tokenIndex = 0;\n\n\t\tconst increaseSizeOfTokensByOneToken = () => {\n\t\t\tendOffsetsAndScopes.push({ endOffset: 0, scopes: [baseScope], encodedLanguageId });\n\t\t};\n\n\t\tconst brackets = (capture: QueryCapture, startOffset: number): number[] | undefined => {\n\t\t\treturn (capture.name.includes('punctuation') && capture.text) ? Array.from(capture.text.matchAll(BRACKETS)).map(match => startOffset + match.index) : undefined;\n\t\t};\n\n\t\tconst addCurrentTokenToArray = (capture: QueryCapture, startOffset: number, endOffset: number, position?: number) => {\n\t\t\tif (position !== undefined) {\n\t\t\t\tconst oldScopes = endOffsetsAndScopes[position].scopes;\n\t\t\t\tlet oldBracket = endOffsetsAndScopes[position].bracket;\n\t\t\t\t// Check that the previous token ends at the same point that the current token starts\n\t\t\t\tconst prevEndOffset = position > 0 ? endOffsetsAndScopes[position - 1].endOffset : 0;\n\t\t\t\tif (prevEndOffset !== startOffset) {\n\t\t\t\t\tlet preInsertBracket: number[] | undefined = undefined;\n\t\t\t\t\tif (oldBracket && oldBracket.length > 0) {\n\t\t\t\t\t\tpreInsertBracket = [];\n\t\t\t\t\t\tconst postInsertBracket: number[] = [];\n\t\t\t\t\t\tfor (let i = 0; i < oldBracket.length; i++) {\n\t\t\t\t\t\t\tconst bracket = oldBracket[i];\n\t\t\t\t\t\t\tif (bracket < startOffset) {\n\t\t\t\t\t\t\t\tpreInsertBracket.push(bracket);\n\t\t\t\t\t\t\t} else if (bracket > endOffset) {\n\t\t\t\t\t\t\t\tpostInsertBracket.push(bracket);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preInsertBracket.length === 0) {\n\t\t\t\t\t\t\tpreInsertBracket = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (postInsertBracket.length === 0) {\n\t\t\t\t\t\t\toldBracket = undefined;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toldBracket = postInsertBracket;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// We need to add some of the position token to cover the space\n\t\t\t\t\tendOffsetsAndScopes.splice(position, 0, { endOffset: startOffset, scopes: [...oldScopes], bracket: preInsertBracket, encodedLanguageId: capture.encodedLanguageId });\n\t\t\t\t\tposition++;\n\t\t\t\t\tincreaseSizeOfTokensByOneToken();\n\t\t\t\t\ttokenIndex++;\n\t\t\t\t}\n\n\t\t\t\tendOffsetsAndScopes.splice(position, 0, { endOffset: endOffset, scopes: [...oldScopes, capture.name], bracket: brackets(capture, startOffset), encodedLanguageId: capture.encodedLanguageId });\n\t\t\t\tendOffsetsAndScopes[tokenIndex].bracket = oldBracket;\n\t\t\t} else {\n\t\t\t\tendOffsetsAndScopes[tokenIndex] = { endOffset: endOffset, scopes: [baseScope, capture.name], bracket: brackets(capture, startOffset), encodedLanguageId: capture.encodedLanguageId };\n\t\t\t}\n\t\t\ttokenIndex++;\n\t\t};\n\n\t\tfor (let captureIndex = 0; captureIndex < captures.length; captureIndex++) {\n\t\t\tconst capture = captures[captureIndex];\n\t\t\tconst tokenEndIndex = capture.node.endIndex < rangeEndOffset ? ((capture.node.endIndex < rangeStartOffset) ? rangeStartOffset : capture.node.endIndex) : rangeEndOffset;\n\t\t\tconst tokenStartIndex = capture.node.startIndex < rangeStartOffset ? rangeStartOffset : capture.node.startIndex;\n\n\t\t\tconst endOffset = tokenEndIndex - rangeStartOffset;\n\n\t\t\t// Not every character will get captured, so we need to make sure that our current capture doesn't bleed toward the start of the line and cover characters that it doesn't apply to.\n\t\t\t// We do this by creating a new token in the array if the previous token ends before the current token starts.\n\t\t\tlet previousEndOffset: number;\n\t\t\tconst currentTokenLength = tokenEndIndex - tokenStartIndex;\n\t\t\tif (captureIndex > 0) {\n\t\t\t\tpreviousEndOffset = endOffsetsAndScopes[(tokenIndex - 1)].endOffset;\n\t\t\t} else {\n\t\t\t\tpreviousEndOffset = tokenStartIndex - rangeStartOffset - 1;\n\t\t\t}\n\t\t\tconst startOffset = endOffset - currentTokenLength;\n\t\t\tif ((previousEndOffset >= 0) && (previousEndOffset < startOffset)) {\n\t\t\t\t// Add en empty token to cover the space where there were no captures\n\t\t\t\tendOffsetsAndScopes[tokenIndex] = { endOffset: startOffset, scopes: [baseScope], encodedLanguageId: this._encodedLanguageId };\n\t\t\t\ttokenIndex++;\n\n\t\t\t\tincreaseSizeOfTokensByOneToken();\n\t\t\t}\n\n\t\t\tif (currentTokenLength < 0) {\n\t\t\t\t// This happens when we have a token \"gap\" right at the end of the capture range. The last capture isn't used because it's start index isn't included in the range.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (previousEndOffset >= endOffset) {\n\t\t\t\t// walk back through the tokens until we find the one that contains the current token\n\t\t\t\tlet withinTokenIndex = tokenIndex - 1;\n\t\t\t\tlet previousTokenEndOffset = endOffsetsAndScopes[withinTokenIndex].endOffset;\n\n\t\t\t\tlet previousTokenStartOffset = ((withinTokenIndex >= 2) ? endOffsetsAndScopes[withinTokenIndex - 1].endOffset : 0);\n\t\t\t\tdo {\n\n\t\t\t\t\t// Check that the current token doesn't just replace the last token\n\t\t\t\t\tif ((previousTokenStartOffset + currentTokenLength) === previousTokenEndOffset) {\n\t\t\t\t\t\tif (previousTokenStartOffset === startOffset) {\n\t\t\t\t\t\t\t// Current token and previous token span the exact same characters, add the scopes to the previous token\n\t\t\t\t\t\t\tendOffsetsAndScopes[withinTokenIndex].scopes.push(capture.name);\n\t\t\t\t\t\t\tconst oldBracket = endOffsetsAndScopes[withinTokenIndex].bracket;\n\t\t\t\t\t\t\tendOffsetsAndScopes[withinTokenIndex].bracket = ((oldBracket && (oldBracket.length > 0)) ? oldBracket : brackets(capture, startOffset));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (previousTokenStartOffset <= startOffset) {\n\t\t\t\t\t\taddCurrentTokenToArray(capture, startOffset, endOffset, withinTokenIndex);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twithinTokenIndex--;\n\t\t\t\t\tpreviousTokenStartOffset = ((withinTokenIndex >= 1) ? endOffsetsAndScopes[withinTokenIndex - 1].endOffset : 0);\n\t\t\t\t\tpreviousTokenEndOffset = ((withinTokenIndex >= 0) ? endOffsetsAndScopes[withinTokenIndex].endOffset : 0);\n\t\t\t\t} while (previousTokenEndOffset > startOffset);\n\t\t\t} else {\n\t\t\t\t// Just add the token to the array\n\t\t\t\taddCurrentTokenToArray(capture, startOffset, endOffset);\n\t\t\t}\n\t\t}\n\n\t\t// Account for uncaptured characters at the end of the line\n\t\tif ((endOffsetsAndScopes[tokenIndex - 1].endOffset < rangeLength)) {\n\t\t\tif (rangeLength - endOffsetsAndScopes[tokenIndex - 1].endOffset > 0) {\n\t\t\t\tincreaseSizeOfTokensByOneToken();\n\t\t\t\tendOffsetsAndScopes[tokenIndex] = { endOffset: rangeLength, scopes: endOffsetsAndScopes[tokenIndex].scopes, encodedLanguageId: this._encodedLanguageId };\n\t\t\t\ttokenIndex++;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < endOffsetsAndScopes.length; i++) {\n\t\t\tconst token = endOffsetsAndScopes[i];\n\t\t\tif (token.endOffset === 0 && i !== 0) {\n\t\t\t\tendOffsetsAndScopes.splice(i, endOffsetsAndScopes.length - i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst captureTime = stopwatch.elapsed();\n\t\treturn { endOffsets: endOffsetsAndScopes as { endOffset: number; scopes: string[]; encodedLanguageId: LanguageId }[], captureTime };\n\t}\n\n\tprivate _getInjectionCaptures(parentCapture: QueryCapture, range: Range): QueryCapture[] {\n\t\t/*\n\t\t\t\tconst injection = textModelTreeSitter.getInjection(parentCapture.node.startIndex, this._treeSitterModel.languageId);\n\t\t\t\tif (!injection?.tree || injection.versionId !== textModelTreeSitter.parseResult?.versionId) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tconst feature = TreeSitterTokenizationRegistry.get(injection.languageId);\n\t\t\t\tif (!feature) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\treturn feature.tokSupport_captureAtRangeTree(range, injection.tree, textModelTreeSitter);*/\n\t\treturn [];\n\t}\n\n\tprivate _tokenizeCapturesWithMetadata(captures: QueryCapture[], rangeStartOffset: number, rangeEndOffset: number): { endOffsetsAndMetadata: EndOffsetToken[]; captureTime: number; metadataTime: number } | undefined {\n\t\tconst stopwatch = StopWatch.create();\n\t\tconst emptyTokens = this._createTokensFromCaptures(captures, rangeStartOffset, rangeEndOffset);\n\t\tif (!emptyTokens) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst endOffsetsAndScopes: EndOffsetWithMeta[] = emptyTokens.endOffsets;\n\t\tfor (let i = 0; i < endOffsetsAndScopes.length; i++) {\n\t\t\tconst token = endOffsetsAndScopes[i];\n\t\t\ttoken.metadata = this._treeSitterThemeService.findMetadata(token.scopes, token.encodedLanguageId, !!token.bracket && (token.bracket.length > 0), undefined);\n\t\t}\n\n\t\tconst metadataTime = stopwatch.elapsed();\n\t\treturn { endOffsetsAndMetadata: endOffsetsAndScopes as { endOffset: number; scopes: string[]; metadata: number }[], captureTime: emptyTokens.captureTime, metadataTime };\n\t}\n\n\tprivate _tokenizeEncoded(lineNumber: number): { result: EndOffsetToken[]; captureTime: number; metadataTime: number; versionId: number } | undefined {\n\t\tconst lineOffset = this._textModel.getOffsetAt({ lineNumber: lineNumber, column: 1 });\n\t\tconst maxLine = this._textModel.getLineCount();\n\t\tconst lineEndOffset = (lineNumber + 1 <= maxLine) ? this._textModel.getOffsetAt({ lineNumber: lineNumber + 1, column: 1 }) : this._textModel.getValueLength();\n\t\tconst lineLength = lineEndOffset - lineOffset;\n\n\t\tconst result = this._tokenize(new Range(lineNumber, 1, lineNumber, lineLength + 1), lineOffset, lineEndOffset);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn { result: result.endOffsetsAndMetadata, captureTime: result.captureTime, metadataTime: result.metadataTime, versionId: result.versionId };\n\t}\n\n\tprivate _endOffsetTokensToUint32Array(endOffsetsAndMetadata: EndOffsetToken[]): Uint32Array {\n\n\t\tconst uint32Array = new Uint32Array(endOffsetsAndMetadata.length * 2);\n\t\tfor (let i = 0; i < endOffsetsAndMetadata.length; i++) {\n\t\t\tuint32Array[i * 2] = endOffsetsAndMetadata[i].endOffset;\n\t\t\tuint32Array[i * 2 + 1] = endOffsetsAndMetadata[i].metadata;\n\t\t}\n\t\treturn uint32Array;\n\t}\n}\n\n\ninterface EndOffsetToken {\n\tendOffset: number;\n\tmetadata: number;\n}\n\ninterface EndOffsetAndScopes {\n\tendOffset: number;\n\tscopes: string[];\n\tbracket?: number[];\n\tencodedLanguageId: LanguageId;\n}\n\ninterface EndOffsetWithMeta extends EndOffsetAndScopes {\n\tmetadata?: number;\n}\nexport const TREESITTER_BASE_SCOPES: Record<string, string> = {\n\t'css': 'source.css',\n\t'typescript': 'source.ts',\n\t'ini': 'source.ini',\n\t'regex': 'source.regex',\n};\n\nconst BRACKETS = /[\\{\\}\\[\\]\\<\\>\\(\\)]/g;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { setTimeout0 } from '../../../../../base/common/platform.js';\nimport { StopWatch } from '../../../../../base/common/stopwatch.js';\nimport { LanguageId } from '../../../encodedTokenAttributes.js';\nimport { ILanguageIdCodec, QueryCapture } from '../../../languages.js';\nimport { IModelContentChangedEvent, IModelTokensChangedEvent } from '../../../textModelEvents.js';\nimport { findLikelyRelevantLines } from '../../textModelTokens.js';\nimport { TokenStore, TokenUpdate, TokenQuality } from './tokenStore.js';\nimport { TreeSitterTree, RangeChange, RangeWithOffsets } from './treeSitterTree.js';\nimport type * as TreeSitter from '@vscode/tree-sitter-wasm';\nimport { autorun, autorunHandleChanges, IObservable, recordChanges, runOnChange } from '../../../../../base/common/observable.js';\nimport { LineRange } from '../../../core/ranges/lineRange.js';\nimport { LineTokens } from '../../../tokens/lineTokens.js';\nimport { Position } from '../../../core/position.js';\nimport { Range } from '../../../core/range.js';\nimport { isDefined } from '../../../../../base/common/types.js';\nimport { ITreeSitterThemeService } from '../../../services/treeSitter/treeSitterThemeService.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\n\nexport class TreeSitterTokenizationImpl extends Disposable {\n\tprivate readonly _tokenStore: TokenStore;\n\tprivate _accurateVersion: number;\n\tprivate _guessVersion: number;\n\n\tprivate readonly _onDidChangeTokens: Emitter<{ changes: IModelTokensChangedEvent }> = this._register(new Emitter());\n\tpublic readonly onDidChangeTokens: Event<{ changes: IModelTokensChangedEvent }> = this._onDidChangeTokens.event;\n\tprivate readonly _onDidCompleteBackgroundTokenization: Emitter<void> = this._register(new Emitter());\n\tpublic readonly onDidChangeBackgroundTokenization: Event<void> = this._onDidCompleteBackgroundTokenization.event;\n\n\tprivate _encodedLanguageId: LanguageId;\n\n\tprivate get _textModel() {\n\t\treturn this._tree.textModel;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _tree: TreeSitterTree,\n\t\tprivate readonly _highlightingQueries: TreeSitter.Query,\n\t\tprivate readonly _languageIdCodec: ILanguageIdCodec,\n\t\tprivate readonly _visibleLineRanges: IObservable<readonly LineRange[]>,\n\n\t\t@ITreeSitterThemeService private readonly _treeSitterThemeService: ITreeSitterThemeService,\n\t) {\n\t\tsuper();\n\n\t\tthis._encodedLanguageId = this._languageIdCodec.encodeLanguageId(this._tree.languageId);\n\n\t\tthis._register(runOnChange(this._treeSitterThemeService.onChange, () => {\n\t\t\tthis._updateTheme();\n\t\t}));\n\n\t\tthis._tokenStore = this._register(new TokenStore(this._textModel));\n\t\tthis._accurateVersion = this._textModel.getVersionId();\n\t\tthis._guessVersion = this._textModel.getVersionId();\n\t\tthis._tokenStore.buildStore(this._createEmptyTokens(), TokenQuality.None);\n\n\t\tthis._register(autorun(reader => {\n\t\t\tconst visibleLineRanges = this._visibleLineRanges.read(reader);\n\t\t\tthis._parseAndTokenizeViewPort(visibleLineRanges);\n\t\t}));\n\n\t\tthis._register(autorunHandleChanges({\n\t\t\towner: this,\n\t\t\tchangeTracker: recordChanges({ tree: this._tree.tree }),\n\t\t}, (reader, ctx) => {\n\t\t\tconst changeEvent = ctx.changes.at(0)?.change;\n\t\t\tif (ctx.changes.length > 1) {\n\t\t\t\tthrow new BugIndicatingError('The tree changed twice in one transaction. This is currently not supported and should not happen.');\n\t\t\t}\n\n\t\t\tif (!changeEvent) {\n\t\t\t\tif (ctx.tree) {\n\t\t\t\t\tthis._firstTreeUpdate(this._tree.treeLastParsedVersion.read(reader));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.hasTokens()) {\n\t\t\t\t\t// Mark the range for refresh immediately\n\n\t\t\t\t\tfor (const range of changeEvent.ranges) {\n\t\t\t\t\t\tthis._markForRefresh(range.newRange);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// First time we see a tree we need to build a token store.\n\t\t\t\tif (!this.hasTokens()) {\n\t\t\t\t\tthis._firstTreeUpdate(changeEvent.versionId);\n\t\t\t\t} else {\n\t\t\t\t\tthis._handleTreeUpdate(changeEvent.ranges, changeEvent.versionId);\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic handleContentChanged(e: IModelContentChangedEvent): void {\n\t\tthis._guessVersion = e.versionId;\n\t\tfor (const change of e.changes) {\n\t\t\tif (change.text.length > change.rangeLength) {\n\t\t\t\t// If possible, use the token before the change as the starting point for the new token.\n\t\t\t\t// This is more likely to let the new text be the correct color as typeing is usually at the end of the token.\n\t\t\t\tconst offset = change.rangeOffset > 0 ? change.rangeOffset - 1 : change.rangeOffset;\n\t\t\t\tconst oldToken = this._tokenStore.getTokenAt(offset);\n\t\t\t\tlet newToken: TokenUpdate;\n\t\t\t\tif (oldToken) {\n\t\t\t\t\t// Insert. Just grow the token at this position to include the insert.\n\t\t\t\t\tnewToken = { startOffsetInclusive: oldToken.startOffsetInclusive, length: oldToken.length + change.text.length - change.rangeLength, token: oldToken.token };\n\t\t\t\t\t// Also mark tokens that are in the range of the change as needing a refresh.\n\t\t\t\t\tthis._tokenStore.markForRefresh(offset, change.rangeOffset + (change.text.length > change.rangeLength ? change.text.length : change.rangeLength));\n\t\t\t\t} else {\n\t\t\t\t\t// The document got larger and the change is at the end of the document.\n\t\t\t\t\tnewToken = { startOffsetInclusive: offset, length: change.text.length, token: 0 };\n\t\t\t\t}\n\t\t\t\tthis._tokenStore.update(oldToken?.length ?? 0, [newToken], TokenQuality.EditGuess);\n\t\t\t} else if (change.text.length < change.rangeLength) {\n\t\t\t\t// Delete. Delete the tokens at the corresponding range.\n\t\t\t\tconst deletedCharCount = change.rangeLength - change.text.length;\n\t\t\t\tthis._tokenStore.delete(deletedCharCount, change.rangeOffset);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getLineTokens(lineNumber: number) {\n\t\tconst content = this._textModel.getLineContent(lineNumber);\n\t\tconst rawTokens = this.getTokens(lineNumber);\n\t\treturn new LineTokens(rawTokens, content, this._languageIdCodec);\n\t}\n\n\tprivate _createEmptyTokens() {\n\t\tconst emptyToken = this._emptyToken();\n\t\tconst modelEndOffset = this._textModel.getValueLength();\n\n\t\tconst emptyTokens: TokenUpdate[] = [this._emptyTokensForOffsetAndLength(0, modelEndOffset, emptyToken)];\n\t\treturn emptyTokens;\n\t}\n\n\tprivate _emptyToken() {\n\t\treturn this._treeSitterThemeService.findMetadata([], this._encodedLanguageId, false, undefined);\n\t}\n\n\tprivate _emptyTokensForOffsetAndLength(offset: number, length: number, emptyToken: number): TokenUpdate {\n\t\treturn { token: emptyToken, length: offset + length, startOffsetInclusive: 0 };\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\treturn this.hasTokens(new Range(lineNumber, 1, lineNumber, this._textModel.getLineMaxColumn(lineNumber)));\n\t}\n\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tconst rawLineTokens = this._guessTokensForLinesContent(lineNumber, lines);\n\t\tconst lineTokens: LineTokens[] = [];\n\t\tif (!rawLineTokens) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (let i = 0; i < rawLineTokens.length; i++) {\n\t\t\tlineTokens.push(new LineTokens(rawLineTokens[i], lines[i], this._languageIdCodec));\n\t\t}\n\t\treturn lineTokens;\n\t}\n\n\tprivate _rangeHasTokens(range: Range, minimumTokenQuality: TokenQuality): boolean {\n\t\treturn this._tokenStore.rangeHasTokens(this._textModel.getOffsetAt(range.getStartPosition()), this._textModel.getOffsetAt(range.getEndPosition()), minimumTokenQuality);\n\t}\n\n\tpublic hasTokens(accurateForRange?: Range): boolean {\n\t\tif (!accurateForRange || (this._guessVersion === this._accurateVersion)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !this._tokenStore.rangeNeedsRefresh(this._textModel.getOffsetAt(accurateForRange.getStartPosition()), this._textModel.getOffsetAt(accurateForRange.getEndPosition()));\n\t}\n\n\tpublic getTokens(line: number): Uint32Array {\n\t\tconst lineStartOffset = this._textModel.getOffsetAt({ lineNumber: line, column: 1 });\n\t\tconst lineEndOffset = this._textModel.getOffsetAt({ lineNumber: line, column: this._textModel.getLineLength(line) + 1 });\n\t\tconst lineTokens = this._tokenStore.getTokensInRange(lineStartOffset, lineEndOffset);\n\t\tconst result = new Uint32Array(lineTokens.length * 2);\n\t\tfor (let i = 0; i < lineTokens.length; i++) {\n\t\t\tresult[i * 2] = lineTokens[i].startOffsetInclusive - lineStartOffset + lineTokens[i].length;\n\t\t\tresult[i * 2 + 1] = lineTokens[i].token;\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetTokensInRange(range: Range, rangeStartOffset: number, rangeEndOffset: number, captures?: QueryCapture[]): TokenUpdate[] | undefined {\n\t\tconst tokens = captures ? this._tokenizeCapturesWithMetadata(captures, rangeStartOffset, rangeEndOffset) : this._tokenize(range, rangeStartOffset, rangeEndOffset);\n\t\tif (tokens?.endOffsetsAndMetadata) {\n\t\t\treturn this._rangeTokensAsUpdates(rangeStartOffset, tokens.endOffsetsAndMetadata);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate _updateTokensInStore(version: number, updates: { oldRangeLength?: number; newTokens: TokenUpdate[] }[], tokenQuality: TokenQuality): void {\n\t\tthis._accurateVersion = version;\n\t\tfor (const update of updates) {\n\t\t\tconst lastToken = update.newTokens.length > 0 ? update.newTokens[update.newTokens.length - 1] : undefined;\n\t\t\tlet oldRangeLength: number;\n\t\t\tif (lastToken && (this._guessVersion >= version)) {\n\t\t\t\toldRangeLength = lastToken.startOffsetInclusive + lastToken.length - update.newTokens[0].startOffsetInclusive;\n\t\t\t} else if (update.oldRangeLength) {\n\t\t\t\toldRangeLength = update.oldRangeLength;\n\t\t\t} else {\n\t\t\t\toldRangeLength = 0;\n\t\t\t}\n\t\t\tthis._tokenStore.update(oldRangeLength, update.newTokens, tokenQuality);\n\t\t}\n\t}\n\n\tprivate _markForRefresh(range: Range): void {\n\t\tthis._tokenStore.markForRefresh(this._textModel.getOffsetAt(range.getStartPosition()), this._textModel.getOffsetAt(range.getEndPosition()));\n\t}\n\n\tprivate _getNeedsRefresh(): { range: Range; startOffset: number; endOffset: number }[] {\n\t\tconst needsRefreshOffsetRanges = this._tokenStore.getNeedsRefresh();\n\t\tif (!needsRefreshOffsetRanges) {\n\t\t\treturn [];\n\t\t}\n\t\treturn needsRefreshOffsetRanges.map(range => ({\n\t\t\trange: Range.fromPositions(this._textModel.getPositionAt(range.startOffset), this._textModel.getPositionAt(range.endOffset)),\n\t\t\tstartOffset: range.startOffset,\n\t\t\tendOffset: range.endOffset\n\t\t}));\n\t}\n\n\n\tprivate _parseAndTokenizeViewPort(lineRanges: readonly LineRange[]) {\n\t\tconst viewportRanges = lineRanges.map(r => r.toInclusiveRange()).filter(isDefined);\n\t\tfor (const range of viewportRanges) {\n\t\t\tconst startOffsetOfRangeInDocument = this._textModel.getOffsetAt(range.getStartPosition());\n\t\t\tconst endOffsetOfRangeInDocument = this._textModel.getOffsetAt(range.getEndPosition());\n\t\t\tconst version = this._textModel.getVersionId();\n\t\t\tif (this._rangeHasTokens(range, TokenQuality.ViewportGuess)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst content = this._textModel.getValueInRange(range);\n\t\t\tconst tokenUpdates = this._forceParseAndTokenizeContent(range, startOffsetOfRangeInDocument, endOffsetOfRangeInDocument, content, true);\n\t\t\tif (!tokenUpdates || this._rangeHasTokens(range, TokenQuality.ViewportGuess)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tokenUpdates.length === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst lastToken = tokenUpdates[tokenUpdates.length - 1];\n\t\t\tconst oldRangeLength = lastToken.startOffsetInclusive + lastToken.length - tokenUpdates[0].startOffsetInclusive;\n\t\t\tthis._updateTokensInStore(version, [{ newTokens: tokenUpdates, oldRangeLength }], TokenQuality.ViewportGuess);\n\t\t\tthis._onDidChangeTokens.fire({ changes: { semanticTokensApplied: false, ranges: [{ fromLineNumber: range.startLineNumber, toLineNumber: range.endLineNumber }] } });\n\t\t}\n\t}\n\n\tprivate _guessTokensForLinesContent(lineNumber: number, lines: string[]): Uint32Array[] | undefined {\n\t\tif (lines.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst lineContent = lines.join(this._textModel.getEOL());\n\t\tconst range = new Range(1, 1, lineNumber + lines.length, lines[lines.length - 1].length + 1);\n\t\tconst startOffset = this._textModel.getOffsetAt({ lineNumber, column: 1 });\n\t\tconst tokens = this._forceParseAndTokenizeContent(range, startOffset, startOffset + lineContent.length, lineContent, false);\n\t\tif (!tokens) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst tokensByLine: Uint32Array[] = new Array(lines.length);\n\t\tlet tokensIndex: number = 0;\n\t\tlet tokenStartOffset = 0;\n\t\tlet lineStartOffset = 0;\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst tokensForLine: EndOffsetToken[] = [];\n\t\t\tlet moveToNextLine = false;\n\t\t\tfor (let j = tokensIndex; (!moveToNextLine && (j < tokens.length)); j++) {\n\t\t\t\tconst token = tokens[j];\n\t\t\t\tconst lineAdjustedEndOffset = token.endOffset - lineStartOffset;\n\t\t\t\tconst lineAdjustedStartOffset = tokenStartOffset - lineStartOffset;\n\t\t\t\tif (lineAdjustedEndOffset <= lines[i].length) {\n\t\t\t\t\ttokensForLine.push({ endOffset: lineAdjustedEndOffset, metadata: token.metadata });\n\t\t\t\t\ttokensIndex++;\n\t\t\t\t} else if (lineAdjustedStartOffset < lines[i].length) {\n\t\t\t\t\tconst partialToken: EndOffsetToken = { endOffset: lines[i].length, metadata: token.metadata };\n\t\t\t\t\ttokensForLine.push(partialToken);\n\t\t\t\t\tmoveToNextLine = true;\n\t\t\t\t} else {\n\t\t\t\t\tmoveToNextLine = true;\n\t\t\t\t}\n\t\t\t\ttokenStartOffset = token.endOffset;\n\t\t\t}\n\n\t\t\ttokensByLine[i] = this._endOffsetTokensToUint32Array(tokensForLine);\n\t\t\tlineStartOffset += lines[i].length + this._textModel.getEOL().length;\n\t\t}\n\n\t\treturn tokensByLine;\n\t}\n\n\tprivate _forceParseAndTokenizeContent(range: Range, startOffsetOfRangeInDocument: number, endOffsetOfRangeInDocument: number, content: string, asUpdate: true): TokenUpdate[] | undefined;\n\tprivate _forceParseAndTokenizeContent(range: Range, startOffsetOfRangeInDocument: number, endOffsetOfRangeInDocument: number, content: string, asUpdate: false): EndOffsetToken[] | undefined;\n\tprivate _forceParseAndTokenizeContent(range: Range, startOffsetOfRangeInDocument: number, endOffsetOfRangeInDocument: number, content: string, asUpdate: boolean): EndOffsetToken[] | TokenUpdate[] | undefined {\n\t\tconst likelyRelevantLines = findLikelyRelevantLines(this._textModel, range.startLineNumber).likelyRelevantLines;\n\t\tconst likelyRelevantPrefix = likelyRelevantLines.join(this._textModel.getEOL());\n\n\t\tconst tree = this._tree.createParsedTreeSync(`${likelyRelevantPrefix}${content}`);\n\t\tif (!tree) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst treeRange = new Range(1, 1, range.endLineNumber - range.startLineNumber + 1 + likelyRelevantLines.length, range.endColumn);\n\t\tconst captures = this.captureAtRange(treeRange);\n\t\tconst tokens = this._tokenizeCapturesWithMetadata(captures, likelyRelevantPrefix.length, endOffsetOfRangeInDocument - startOffsetOfRangeInDocument + likelyRelevantPrefix.length);\n\t\ttree.delete();\n\n\t\tif (!tokens) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (asUpdate) {\n\t\t\treturn this._rangeTokensAsUpdates(startOffsetOfRangeInDocument, tokens.endOffsetsAndMetadata, likelyRelevantPrefix.length);\n\t\t} else {\n\t\t\treturn tokens.endOffsetsAndMetadata;\n\t\t}\n\t}\n\n\n\tprivate _firstTreeUpdate(versionId: number) {\n\t\treturn this._setViewPortTokens(versionId);\n\t}\n\n\tprivate _setViewPortTokens(versionId: number) {\n\t\tconst rangeChanges = this._visibleLineRanges.get().map<RangeChange | undefined>(lineRange => {\n\t\t\tconst range = lineRange.toInclusiveRange();\n\t\t\tif (!range) { return undefined; }\n\t\t\tconst newRangeStartOffset = this._textModel.getOffsetAt(range.getStartPosition());\n\t\t\tconst newRangeEndOffset = this._textModel.getOffsetAt(range.getEndPosition());\n\t\t\treturn {\n\t\t\t\tnewRange: range,\n\t\t\t\tnewRangeEndOffset,\n\t\t\t\tnewRangeStartOffset,\n\t\t\t};\n\t\t}).filter(isDefined);\n\n\t\treturn this._handleTreeUpdate(rangeChanges, versionId);\n\t}\n\n\t/**\n\t * Do not await in this method, it will cause a race\n\t */\n\tprivate _handleTreeUpdate(ranges: RangeChange[], versionId: number) {\n\t\tconst rangeChanges: RangeWithOffsets[] = [];\n\t\tconst chunkSize = 1000;\n\n\t\tfor (let i = 0; i < ranges.length; i++) {\n\t\t\tconst rangeLinesLength = ranges[i].newRange.endLineNumber - ranges[i].newRange.startLineNumber;\n\t\t\tif (rangeLinesLength > chunkSize) {\n\t\t\t\t// Split the range into chunks to avoid long operations\n\t\t\t\tconst fullRangeEndLineNumber = ranges[i].newRange.endLineNumber;\n\t\t\t\tlet chunkLineStart = ranges[i].newRange.startLineNumber;\n\t\t\t\tlet chunkColumnStart = ranges[i].newRange.startColumn;\n\t\t\t\tlet chunkLineEnd = chunkLineStart + chunkSize;\n\t\t\t\tdo {\n\t\t\t\t\tconst chunkStartingPosition = new Position(chunkLineStart, chunkColumnStart);\n\t\t\t\t\tconst chunkEndColumn = ((chunkLineEnd === ranges[i].newRange.endLineNumber) ? ranges[i].newRange.endColumn : this._textModel.getLineMaxColumn(chunkLineEnd));\n\t\t\t\t\tconst chunkEndPosition = new Position(chunkLineEnd, chunkEndColumn);\n\t\t\t\t\tconst chunkRange = Range.fromPositions(chunkStartingPosition, chunkEndPosition);\n\n\t\t\t\t\trangeChanges.push({\n\t\t\t\t\t\trange: chunkRange,\n\t\t\t\t\t\tstartOffset: this._textModel.getOffsetAt(chunkRange.getStartPosition()),\n\t\t\t\t\t\tendOffset: this._textModel.getOffsetAt(chunkRange.getEndPosition())\n\t\t\t\t\t});\n\n\t\t\t\t\tchunkLineStart = chunkLineEnd + 1;\n\t\t\t\t\tchunkColumnStart = 1;\n\t\t\t\t\tif (chunkLineEnd < fullRangeEndLineNumber && chunkLineEnd + chunkSize > fullRangeEndLineNumber) {\n\t\t\t\t\t\tchunkLineEnd = fullRangeEndLineNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunkLineEnd = chunkLineEnd + chunkSize;\n\t\t\t\t\t}\n\t\t\t\t} while (chunkLineEnd <= fullRangeEndLineNumber);\n\t\t\t} else {\n\t\t\t\t// Check that the previous range doesn't overlap\n\t\t\t\tif ((i === 0) || (rangeChanges[i - 1].endOffset < ranges[i].newRangeStartOffset)) {\n\t\t\t\t\trangeChanges.push({\n\t\t\t\t\t\trange: ranges[i].newRange,\n\t\t\t\t\t\tstartOffset: ranges[i].newRangeStartOffset,\n\t\t\t\t\t\tendOffset: ranges[i].newRangeEndOffset\n\t\t\t\t\t});\n\t\t\t\t} else if (rangeChanges[i - 1].endOffset < ranges[i].newRangeEndOffset) {\n\t\t\t\t\t// clip the range to the previous range\n\t\t\t\t\tconst startPosition = this._textModel.getPositionAt(rangeChanges[i - 1].endOffset + 1);\n\t\t\t\t\tconst range = new Range(startPosition.lineNumber, startPosition.column, ranges[i].newRange.endLineNumber, ranges[i].newRange.endColumn);\n\t\t\t\t\trangeChanges.push({\n\t\t\t\t\t\trange,\n\t\t\t\t\t\tstartOffset: rangeChanges[i - 1].endOffset + 1,\n\t\t\t\t\t\tendOffset: ranges[i].newRangeEndOffset\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Get the captures immediately while the text model is correct\n\t\tconst captures = rangeChanges.map(range => this._getCaptures(range.range));\n\t\t// Don't block\n\t\treturn this._updateTreeForRanges(rangeChanges, versionId, captures).then(() => {\n\t\t\tif (!this._textModel.isDisposed() && (this._tree.treeLastParsedVersion.get() === this._textModel.getVersionId())) {\n\t\t\t\tthis._refreshNeedsRefresh(versionId);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async _updateTreeForRanges(rangeChanges: RangeWithOffsets[], versionId: number, captures: QueryCapture[][]) {\n\t\tlet tokenUpdate: { newTokens: TokenUpdate[] } | undefined;\n\n\t\tfor (let i = 0; i < rangeChanges.length; i++) {\n\t\t\tif (!this._textModel.isDisposed() && versionId !== this._textModel.getVersionId()) {\n\t\t\t\t// Our captures have become invalid and we need to re-capture\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst capture = captures[i];\n\t\t\tconst range = rangeChanges[i];\n\n\t\t\tconst updates = this.getTokensInRange(range.range, range.startOffset, range.endOffset, capture);\n\t\t\tif (updates) {\n\t\t\t\ttokenUpdate = { newTokens: updates };\n\t\t\t} else {\n\t\t\t\ttokenUpdate = { newTokens: [] };\n\t\t\t}\n\t\t\tthis._updateTokensInStore(versionId, [tokenUpdate], TokenQuality.Accurate);\n\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\tchanges: {\n\t\t\t\t\tsemanticTokensApplied: false,\n\t\t\t\t\tranges: [{ fromLineNumber: range.range.getStartPosition().lineNumber, toLineNumber: range.range.getEndPosition().lineNumber }]\n\t\t\t\t}\n\t\t\t});\n\t\t\tawait new Promise<void>(resolve => setTimeout0(resolve));\n\t\t}\n\t\tthis._onDidCompleteBackgroundTokenization.fire();\n\t}\n\n\tprivate _refreshNeedsRefresh(versionId: number) {\n\t\tconst rangesToRefresh = this._getNeedsRefresh();\n\t\tif (rangesToRefresh.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst rangeChanges: RangeChange[] = new Array(rangesToRefresh.length);\n\n\t\tfor (let i = 0; i < rangesToRefresh.length; i++) {\n\t\t\tconst range = rangesToRefresh[i];\n\t\t\trangeChanges[i] = {\n\t\t\t\tnewRange: range.range,\n\t\t\t\tnewRangeStartOffset: range.startOffset,\n\t\t\t\tnewRangeEndOffset: range.endOffset\n\t\t\t};\n\t\t}\n\n\t\tthis._handleTreeUpdate(rangeChanges, versionId);\n\t}\n\n\tprivate _rangeTokensAsUpdates(rangeOffset: number, endOffsetToken: EndOffsetToken[], startingOffsetInArray?: number) {\n\t\tconst updates: TokenUpdate[] = [];\n\t\tlet lastEnd = 0;\n\t\tfor (const token of endOffsetToken) {\n\t\t\tif (token.endOffset <= lastEnd || (startingOffsetInArray && (token.endOffset < startingOffsetInArray))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet tokenUpdate: TokenUpdate;\n\t\t\tif (startingOffsetInArray && (lastEnd < startingOffsetInArray)) {\n\t\t\t\ttokenUpdate = { startOffsetInclusive: rangeOffset + startingOffsetInArray, length: token.endOffset - startingOffsetInArray, token: token.metadata };\n\t\t\t} else {\n\t\t\t\ttokenUpdate = { startOffsetInclusive: rangeOffset + lastEnd, length: token.endOffset - lastEnd, token: token.metadata };\n\t\t\t}\n\t\t\tupdates.push(tokenUpdate);\n\t\t\tlastEnd = token.endOffset;\n\t\t}\n\t\treturn updates;\n\t}\n\n\tprivate _updateTheme() {\n\t\tconst modelRange = this._textModel.getFullModelRange();\n\t\tthis._markForRefresh(modelRange);\n\t\tthis._parseAndTokenizeViewPort(this._visibleLineRanges.get());\n\t}\n\n\tprivate captureAtRange(range: Range): QueryCapture[] {\n\t\tconst tree = this._tree.tree.get();\n\t\tif (!tree) {\n\t\t\treturn [];\n\t\t}\n\t\t// Tree sitter row is 0 based, column is 0 based\n\t\treturn this._highlightingQueries.captures(tree.rootNode, { startPosition: { row: range.startLineNumber - 1, column: range.startColumn - 1 }, endPosition: { row: range.endLineNumber - 1, column: range.endColumn - 1 } }).map(capture => (\n\t\t\t{\n\t\t\t\tname: capture.name,\n\t\t\t\ttext: capture.node.text,\n\t\t\t\tnode: {\n\t\t\t\t\tstartIndex: capture.node.startIndex,\n\t\t\t\t\tendIndex: capture.node.endIndex,\n\t\t\t\t\tstartPosition: {\n\t\t\t\t\t\tlineNumber: capture.node.startPosition.row + 1,\n\t\t\t\t\t\tcolumn: capture.node.startPosition.column + 1\n\t\t\t\t\t},\n\t\t\t\t\tendPosition: {\n\t\t\t\t\t\tlineNumber: capture.node.endPosition.row + 1,\n\t\t\t\t\t\tcolumn: capture.node.endPosition.column + 1\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tencodedLanguageId: this._encodedLanguageId\n\t\t\t}\n\t\t));\n\t}\n\n\tprivate captureAtRangeWithInjections(range: Range): QueryCapture[] {\n\t\tconst captures: QueryCapture[] = this.captureAtRange(range);\n\t\tfor (let i = 0; i < captures.length; i++) {\n\t\t\tconst capture = captures[i];\n\n\t\t\tconst capStartLine = capture.node.startPosition.lineNumber;\n\t\t\tconst capEndLine = capture.node.endPosition.lineNumber;\n\t\t\tconst capStartColumn = capture.node.startPosition.column;\n\t\t\tconst capEndColumn = capture.node.endPosition.column;\n\n\t\t\tconst startLine = ((capStartLine > range.startLineNumber) && (capStartLine < range.endLineNumber)) ? capStartLine : range.startLineNumber;\n\t\t\tconst endLine = ((capEndLine > range.startLineNumber) && (capEndLine < range.endLineNumber)) ? capEndLine : range.endLineNumber;\n\t\t\tconst startColumn = (capStartLine === range.startLineNumber) ? (capStartColumn < range.startColumn ? range.startColumn : capStartColumn) : (capStartLine < range.startLineNumber ? range.startColumn : capStartColumn);\n\t\t\tconst endColumn = (capEndLine === range.endLineNumber) ? (capEndColumn > range.endColumn ? range.endColumn : capEndColumn) : (capEndLine > range.endLineNumber ? range.endColumn : capEndColumn);\n\t\t\tconst injectionRange = new Range(startLine, startColumn, endLine, endColumn);\n\n\t\t\tconst injection = this._getInjectionCaptures(capture, injectionRange);\n\t\t\tif (injection && injection.length > 0) {\n\t\t\t\tcaptures.splice(i + 1, 0, ...injection);\n\t\t\t\ti += injection.length;\n\t\t\t}\n\t\t}\n\t\treturn captures;\n\t}\n\n\t/**\n\t * Gets the tokens for a given line.\n\t * Each token takes 2 elements in the array. The first element is the offset of the end of the token *in the line, not in the document*, and the second element is the metadata.\n\t *\n\t * @param lineNumber\n\t * @returns\n\t */\n\tpublic tokenizeEncoded(lineNumber: number) {\n\t\tconst tokens = this._tokenizeEncoded(lineNumber);\n\t\tif (!tokens) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst updates = this._rangeTokensAsUpdates(this._textModel.getOffsetAt({ lineNumber, column: 1 }), tokens.result);\n\t\tif (tokens.versionId === this._textModel.getVersionId()) {\n\t\t\tthis._updateTokensInStore(tokens.versionId, [{ newTokens: updates, oldRangeLength: this._textModel.getLineLength(lineNumber) }], TokenQuality.Accurate);\n\t\t}\n\t}\n\n\tprivate _getCaptures(range: Range): QueryCapture[] {\n\t\tconst captures = this.captureAtRangeWithInjections(range);\n\t\treturn captures;\n\t}\n\n\tprivate _tokenize(range: Range, rangeStartOffset: number, rangeEndOffset: number): { endOffsetsAndMetadata: { endOffset: number; metadata: number }[]; versionId: number; captureTime: number; metadataTime: number } | undefined {\n\t\tconst captures = this._getCaptures(range);\n\t\tconst result = this._tokenizeCapturesWithMetadata(captures, rangeStartOffset, rangeEndOffset);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn { ...result, versionId: this._tree.treeLastParsedVersion.get() };\n\t}\n\n\tprivate _createTokensFromCaptures(captures: QueryCapture[], rangeStartOffset: number, rangeEndOffset: number): { endOffsets: EndOffsetAndScopes[]; captureTime: number } | undefined {\n\t\tconst tree = this._tree.tree.get();\n\t\tconst stopwatch = StopWatch.create();\n\t\tconst rangeLength = rangeEndOffset - rangeStartOffset;\n\t\tconst encodedLanguageId = this._languageIdCodec.encodeLanguageId(this._tree.languageId);\n\t\tconst baseScope: string = TREESITTER_BASE_SCOPES[this._tree.languageId] || 'source';\n\n\t\tif (captures.length === 0) {\n\t\t\tif (tree) {\n\t\t\t\tstopwatch.stop();\n\t\t\t\tconst endOffsetsAndMetadata = [{ endOffset: rangeLength, scopes: [], encodedLanguageId }];\n\t\t\t\treturn { endOffsets: endOffsetsAndMetadata, captureTime: stopwatch.elapsed() };\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst endOffsetsAndScopes: EndOffsetAndScopes[] = Array(captures.length);\n\t\tendOffsetsAndScopes.fill({ endOffset: 0, scopes: [baseScope], encodedLanguageId });\n\t\tlet tokenIndex = 0;\n\n\t\tconst increaseSizeOfTokensByOneToken = () => {\n\t\t\tendOffsetsAndScopes.push({ endOffset: 0, scopes: [baseScope], encodedLanguageId });\n\t\t};\n\n\t\tconst brackets = (capture: QueryCapture, startOffset: number): number[] | undefined => {\n\t\t\treturn (capture.name.includes('punctuation') && capture.text) ? Array.from(capture.text.matchAll(BRACKETS)).map(match => startOffset + match.index) : undefined;\n\t\t};\n\n\t\tconst addCurrentTokenToArray = (capture: QueryCapture, startOffset: number, endOffset: number, position?: number) => {\n\t\t\tif (position !== undefined) {\n\t\t\t\tconst oldScopes = endOffsetsAndScopes[position].scopes;\n\t\t\t\tlet oldBracket = endOffsetsAndScopes[position].bracket;\n\t\t\t\t// Check that the previous token ends at the same point that the current token starts\n\t\t\t\tconst prevEndOffset = position > 0 ? endOffsetsAndScopes[position - 1].endOffset : 0;\n\t\t\t\tif (prevEndOffset !== startOffset) {\n\t\t\t\t\tlet preInsertBracket: number[] | undefined = undefined;\n\t\t\t\t\tif (oldBracket && oldBracket.length > 0) {\n\t\t\t\t\t\tpreInsertBracket = [];\n\t\t\t\t\t\tconst postInsertBracket: number[] = [];\n\t\t\t\t\t\tfor (let i = 0; i < oldBracket.length; i++) {\n\t\t\t\t\t\t\tconst bracket = oldBracket[i];\n\t\t\t\t\t\t\tif (bracket < startOffset) {\n\t\t\t\t\t\t\t\tpreInsertBracket.push(bracket);\n\t\t\t\t\t\t\t} else if (bracket > endOffset) {\n\t\t\t\t\t\t\t\tpostInsertBracket.push(bracket);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (preInsertBracket.length === 0) {\n\t\t\t\t\t\t\tpreInsertBracket = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (postInsertBracket.length === 0) {\n\t\t\t\t\t\t\toldBracket = undefined;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toldBracket = postInsertBracket;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// We need to add some of the position token to cover the space\n\t\t\t\t\tendOffsetsAndScopes.splice(position, 0, { endOffset: startOffset, scopes: [...oldScopes], bracket: preInsertBracket, encodedLanguageId: capture.encodedLanguageId });\n\t\t\t\t\tposition++;\n\t\t\t\t\tincreaseSizeOfTokensByOneToken();\n\t\t\t\t\ttokenIndex++;\n\t\t\t\t}\n\n\t\t\t\tendOffsetsAndScopes.splice(position, 0, { endOffset: endOffset, scopes: [...oldScopes, capture.name], bracket: brackets(capture, startOffset), encodedLanguageId: capture.encodedLanguageId });\n\t\t\t\tendOffsetsAndScopes[tokenIndex].bracket = oldBracket;\n\t\t\t} else {\n\t\t\t\tendOffsetsAndScopes[tokenIndex] = { endOffset: endOffset, scopes: [baseScope, capture.name], bracket: brackets(capture, startOffset), encodedLanguageId: capture.encodedLanguageId };\n\t\t\t}\n\t\t\ttokenIndex++;\n\t\t};\n\n\t\tfor (let captureIndex = 0; captureIndex < captures.length; captureIndex++) {\n\t\t\tconst capture = captures[captureIndex];\n\t\t\tconst tokenEndIndex = capture.node.endIndex < rangeEndOffset ? ((capture.node.endIndex < rangeStartOffset) ? rangeStartOffset : capture.node.endIndex) : rangeEndOffset;\n\t\t\tconst tokenStartIndex = capture.node.startIndex < rangeStartOffset ? rangeStartOffset : capture.node.startIndex;\n\n\t\t\tconst endOffset = tokenEndIndex - rangeStartOffset;\n\n\t\t\t// Not every character will get captured, so we need to make sure that our current capture doesn't bleed toward the start of the line and cover characters that it doesn't apply to.\n\t\t\t// We do this by creating a new token in the array if the previous token ends before the current token starts.\n\t\t\tlet previousEndOffset: number;\n\t\t\tconst currentTokenLength = tokenEndIndex - tokenStartIndex;\n\t\t\tif (captureIndex > 0) {\n\t\t\t\tpreviousEndOffset = endOffsetsAndScopes[(tokenIndex - 1)].endOffset;\n\t\t\t} else {\n\t\t\t\tpreviousEndOffset = tokenStartIndex - rangeStartOffset - 1;\n\t\t\t}\n\t\t\tconst startOffset = endOffset - currentTokenLength;\n\t\t\tif ((previousEndOffset >= 0) && (previousEndOffset < startOffset)) {\n\t\t\t\t// Add en empty token to cover the space where there were no captures\n\t\t\t\tendOffsetsAndScopes[tokenIndex] = { endOffset: startOffset, scopes: [baseScope], encodedLanguageId: this._encodedLanguageId };\n\t\t\t\ttokenIndex++;\n\n\t\t\t\tincreaseSizeOfTokensByOneToken();\n\t\t\t}\n\n\t\t\tif (currentTokenLength < 0) {\n\t\t\t\t// This happens when we have a token \"gap\" right at the end of the capture range. The last capture isn't used because it's start index isn't included in the range.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (previousEndOffset >= endOffset) {\n\t\t\t\t// walk back through the tokens until we find the one that contains the current token\n\t\t\t\tlet withinTokenIndex = tokenIndex - 1;\n\t\t\t\tlet previousTokenEndOffset = endOffsetsAndScopes[withinTokenIndex].endOffset;\n\n\t\t\t\tlet previousTokenStartOffset = ((withinTokenIndex >= 2) ? endOffsetsAndScopes[withinTokenIndex - 1].endOffset : 0);\n\t\t\t\tdo {\n\n\t\t\t\t\t// Check that the current token doesn't just replace the last token\n\t\t\t\t\tif ((previousTokenStartOffset + currentTokenLength) === previousTokenEndOffset) {\n\t\t\t\t\t\tif (previousTokenStartOffset === startOffset) {\n\t\t\t\t\t\t\t// Current token and previous token span the exact same characters, add the scopes to the previous token\n\t\t\t\t\t\t\tendOffsetsAndScopes[withinTokenIndex].scopes.push(capture.name);\n\t\t\t\t\t\t\tconst oldBracket = endOffsetsAndScopes[withinTokenIndex].bracket;\n\t\t\t\t\t\t\tendOffsetsAndScopes[withinTokenIndex].bracket = ((oldBracket && (oldBracket.length > 0)) ? oldBracket : brackets(capture, startOffset));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (previousTokenStartOffset <= startOffset) {\n\t\t\t\t\t\taddCurrentTokenToArray(capture, startOffset, endOffset, withinTokenIndex);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\twithinTokenIndex--;\n\t\t\t\t\tpreviousTokenStartOffset = ((withinTokenIndex >= 1) ? endOffsetsAndScopes[withinTokenIndex - 1].endOffset : 0);\n\t\t\t\t\tpreviousTokenEndOffset = ((withinTokenIndex >= 0) ? endOffsetsAndScopes[withinTokenIndex].endOffset : 0);\n\t\t\t\t} while (previousTokenEndOffset > startOffset);\n\t\t\t} else {\n\t\t\t\t// Just add the token to the array\n\t\t\t\taddCurrentTokenToArray(capture, startOffset, endOffset);\n\t\t\t}\n\t\t}\n\n\t\t// Account for uncaptured characters at the end of the line\n\t\tif ((endOffsetsAndScopes[tokenIndex - 1].endOffset < rangeLength)) {\n\t\t\tif (rangeLength - endOffsetsAndScopes[tokenIndex - 1].endOffset > 0) {\n\t\t\t\tincreaseSizeOfTokensByOneToken();\n\t\t\t\tendOffsetsAndScopes[tokenIndex] = { endOffset: rangeLength, scopes: endOffsetsAndScopes[tokenIndex].scopes, encodedLanguageId: this._encodedLanguageId };\n\t\t\t\ttokenIndex++;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < endOffsetsAndScopes.length; i++) {\n\t\t\tconst token = endOffsetsAndScopes[i];\n\t\t\tif (token.endOffset === 0 && i !== 0) {\n\t\t\t\tendOffsetsAndScopes.splice(i, endOffsetsAndScopes.length - i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst captureTime = stopwatch.elapsed();\n\t\treturn { endOffsets: endOffsetsAndScopes as { endOffset: number; scopes: string[]; encodedLanguageId: LanguageId }[], captureTime };\n\t}\n\n\tprivate _getInjectionCaptures(parentCapture: QueryCapture, range: Range): QueryCapture[] {\n\t\t/*\n\t\t\t\tconst injection = textModelTreeSitter.getInjection(parentCapture.node.startIndex, this._treeSitterModel.languageId);\n\t\t\t\tif (!injection?.tree || injection.versionId !== textModelTreeSitter.parseResult?.versionId) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tconst feature = TreeSitterTokenizationRegistry.get(injection.languageId);\n\t\t\t\tif (!feature) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\treturn feature.tokSupport_captureAtRangeTree(range, injection.tree, textModelTreeSitter);*/\n\t\treturn [];\n\t}\n\n\tprivate _tokenizeCapturesWithMetadata(captures: QueryCapture[], rangeStartOffset: number, rangeEndOffset: number): { endOffsetsAndMetadata: EndOffsetToken[]; captureTime: number; metadataTime: number } | undefined {\n\t\tconst stopwatch = StopWatch.create();\n\t\tconst emptyTokens = this._createTokensFromCaptures(captures, rangeStartOffset, rangeEndOffset);\n\t\tif (!emptyTokens) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst endOffsetsAndScopes: EndOffsetWithMeta[] = emptyTokens.endOffsets;\n\t\tfor (let i = 0; i < endOffsetsAndScopes.length; i++) {\n\t\t\tconst token = endOffsetsAndScopes[i];\n\t\t\ttoken.metadata = this._treeSitterThemeService.findMetadata(token.scopes, token.encodedLanguageId, !!token.bracket && (token.bracket.length > 0), undefined);\n\t\t}\n\n\t\tconst metadataTime = stopwatch.elapsed();\n\t\treturn { endOffsetsAndMetadata: endOffsetsAndScopes as { endOffset: number; scopes: string[]; metadata: number }[], captureTime: emptyTokens.captureTime, metadataTime };\n\t}\n\n\tprivate _tokenizeEncoded(lineNumber: number): { result: EndOffsetToken[]; captureTime: number; metadataTime: number; versionId: number } | undefined {\n\t\tconst lineOffset = this._textModel.getOffsetAt({ lineNumber: lineNumber, column: 1 });\n\t\tconst maxLine = this._textModel.getLineCount();\n\t\tconst lineEndOffset = (lineNumber + 1 <= maxLine) ? this._textModel.getOffsetAt({ lineNumber: lineNumber + 1, column: 1 }) : this._textModel.getValueLength();\n\t\tconst lineLength = lineEndOffset - lineOffset;\n\n\t\tconst result = this._tokenize(new Range(lineNumber, 1, lineNumber, lineLength + 1), lineOffset, lineEndOffset);\n\t\tif (!result) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn { result: result.endOffsetsAndMetadata, captureTime: result.captureTime, metadataTime: result.metadataTime, versionId: result.versionId };\n\t}\n\n\tprivate _endOffsetTokensToUint32Array(endOffsetsAndMetadata: EndOffsetToken[]): Uint32Array {\n\n\t\tconst uint32Array = new Uint32Array(endOffsetsAndMetadata.length * 2);\n\t\tfor (let i = 0; i < endOffsetsAndMetadata.length; i++) {\n\t\t\tuint32Array[i * 2] = endOffsetsAndMetadata[i].endOffset;\n\t\t\tuint32Array[i * 2 + 1] = endOffsetsAndMetadata[i].metadata;\n\t\t}\n\t\treturn uint32Array;\n\t}\n}\n\n\ninterface EndOffsetToken {\n\tendOffset: number;\n\tmetadata: number;\n}\n\ninterface EndOffsetAndScopes {\n\tendOffset: number;\n\tscopes: string[];\n\tbracket?: number[];\n\tencodedLanguageId: LanguageId;\n}\n\ninterface EndOffsetWithMeta extends EndOffsetAndScopes {\n\tmetadata?: number;\n}\nexport const TREESITTER_BASE_SCOPES: Record<string, string> = {\n\t'css': 'source.css',\n\t'typescript': 'source.ts',\n\t'ini': 'source.ini',\n\t'regex': 'source.regex',\n};\n\nconst BRACKETS = /[\\{\\}\\[\\]\\<\\>\\(\\)]/g;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 10520, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/treeSitterSyntaxTokenBackend.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/treeSitter/treeSitterSyntaxTokenBackend.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/treeSitter/vs/editor/common/model/tokens/treeSitter/treeSitterSyntaxTokenBackend.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { StandardTokenType } from '../../../encodedTokenAttributes.js';\nimport { ILanguageIdCodec } from '../../../languages.js';\nimport { IModelContentChangedEvent } from '../../../textModelEvents.js';\nimport { BackgroundTokenizationState } from '../../../tokenizationTextModelPart.js';\nimport { LineTokens } from '../../../tokens/lineTokens.js';\nimport { TextModel } from '../../textModel.js';\nimport { AbstractSyntaxTokenBackend } from '../abstractSyntaxTokenBackend.js';\nimport { autorun, derived, IObservable, ObservablePromise } from '../../../../../base/common/observable.js';\nimport { TreeSitterTree } from './treeSitterTree.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { TreeSitterTokenizationImpl } from './treeSitterTokenizationImpl.js';\nimport { ITreeSitterLibraryService } from '../../../services/treeSitter/treeSitterLibraryService.js';\nimport { LineRange } from '../../../core/ranges/lineRange.js';\n\nexport class TreeSitterSyntaxTokenBackend extends AbstractSyntaxTokenBackend {\n\tprotected _backgroundTokenizationState: BackgroundTokenizationState = BackgroundTokenizationState.InProgress;\n\tprotected readonly _onDidChangeBackgroundTokenizationState: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeBackgroundTokenizationState: Event<void> = this._onDidChangeBackgroundTokenizationState.event;\n\n\tprivate readonly _tree: IObservable<TreeSitterTree | undefined>;\n\tprivate readonly _tokenizationImpl: IObservable<TreeSitterTokenizationImpl | undefined>;\n\n\tconstructor(\n\t\tprivate readonly _languageIdObs: IObservable<string>,\n\t\tlanguageIdCodec: ILanguageIdCodec,\n\t\ttextModel: TextModel,\n\t\tvisibleLineRanges: IObservable<readonly LineRange[]>,\n\t\t@ITreeSitterLibraryService private readonly _treeSitterLibraryService: ITreeSitterLibraryService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService\n\t) {\n\t\tsuper(languageIdCodec, textModel);\n\n\n\t\tconst parserClassPromise = new ObservablePromise(this._treeSitterLibraryService.getParserClass());\n\n\n\t\tconst parserClassObs = derived(this, reader => {\n\t\t\tconst parser = parserClassPromise.promiseResult?.read(reader)?.getDataOrThrow();\n\t\t\treturn parser;\n\t\t});\n\n\n\t\tthis._tree = derived(this, reader => {\n\t\t\tconst parserClass = parserClassObs.read(reader);\n\t\t\tif (!parserClass) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst currentLanguage = this._languageIdObs.read(reader);\n\t\t\tconst treeSitterLang = this._treeSitterLibraryService.getLanguage(currentLanguage, reader);\n\t\t\tif (!treeSitterLang) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst parser = new parserClass();\n\t\t\treader.store.add(toDisposable(() => {\n\t\t\t\tparser.delete();\n\t\t\t}));\n\t\t\tparser.setLanguage(treeSitterLang);\n\n\t\t\tconst queries = this._treeSitterLibraryService.getInjectionQueries(currentLanguage, reader);\n\t\t\tif (queries === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn reader.store.add(this._instantiationService.createInstance(TreeSitterTree, currentLanguage, undefined, parser, parserClass, /*queries, */this._textModel));\n\t\t});\n\n\n\t\tthis._tokenizationImpl = derived(this, reader => {\n\t\t\tconst treeModel = this._tree.read(reader);\n\t\t\tif (!treeModel) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst queries = this._treeSitterLibraryService.getHighlightingQueries(treeModel.languageId, reader);\n\t\t\tif (!queries) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn reader.store.add(this._instantiationService.createInstance(TreeSitterTokenizationImpl, treeModel, queries, this._languageIdCodec, visibleLineRanges));\n\t\t});\n\n\t\tthis._register(autorun(reader => {\n\t\t\tconst tokModel = this._tokenizationImpl.read(reader);\n\t\t\tif (!tokModel) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treader.store.add(tokModel.onDidChangeTokens((e) => {\n\t\t\t\tthis._onDidChangeTokens.fire(e.changes);\n\t\t\t}));\n\t\t\treader.store.add(tokModel.onDidChangeBackgroundTokenization(e => {\n\t\t\t\tthis._backgroundTokenizationState = BackgroundTokenizationState.Completed;\n\t\t\t\tthis._onDidChangeBackgroundTokenizationState.fire();\n\t\t\t}));\n\t\t}));\n\t}\n\n\tpublic getLineTokens(lineNumber: number): LineTokens {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\tconst content = this._textModel.getLineContent(lineNumber);\n\t\t\treturn LineTokens.createEmpty(content, this._languageIdCodec);\n\t\t}\n\t\treturn model.getLineTokens(lineNumber);\n\t}\n\n\tpublic todo_resetTokenization(fireTokenChangeEvent: boolean = true): void {\n\t\tif (fireTokenChangeEvent) {\n\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\tsemanticTokensApplied: false,\n\t\t\t\tranges: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfromLineNumber: 1,\n\t\t\t\t\t\ttoLineNumber: this._textModel.getLineCount(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic override handleDidChangeAttached(): void {\n\t\t// TODO @alexr00 implement for background tokenization\n\t}\n\n\tpublic override handleDidChangeContent(e: IModelContentChangedEvent): void {\n\t\tif (e.isFlush) {\n\t\t\t// Don't fire the event, as the view might not have got the text change event yet\n\t\t\tthis.todo_resetTokenization(false);\n\t\t} else {\n\t\t\tconst model = this._tokenizationImpl.get();\n\t\t\tmodel?.handleContentChanged(e);\n\t\t}\n\n\t\tconst treeModel = this._tree.get();\n\t\ttreeModel?.handleContentChange(e);\n\t}\n\n\tpublic override forceTokenization(lineNumber: number): void {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\treturn;\n\t\t}\n\t\tif (!model.hasAccurateTokensForLine(lineNumber)) {\n\t\t\tmodel.tokenizeEncoded(lineNumber);\n\t\t}\n\t}\n\n\tpublic override hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\treturn false;\n\t\t}\n\t\treturn model.hasAccurateTokensForLine(lineNumber);\n\t}\n\n\tpublic override isCheapToTokenize(lineNumber: number): boolean {\n\t\t// TODO @alexr00 determine what makes it cheap to tokenize?\n\t\treturn true;\n\t}\n\n\tpublic override getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType {\n\t\t// TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n\t\treturn StandardTokenType.Other;\n\t}\n\n\tpublic override tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\t\treturn model.tokenizeLinesAt(lineNumber, lines);\n\t}\n\n\tpublic override get hasTokens(): boolean {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\treturn false;\n\t\t}\n\t\treturn model.hasTokens();\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from '../../../../../base/common/event.js';\nimport { toDisposable } from '../../../../../base/common/lifecycle.js';\nimport { StandardTokenType } from '../../../encodedTokenAttributes.js';\nimport { ILanguageIdCodec } from '../../../languages.js';\nimport { IModelContentChangedEvent } from '../../../textModelEvents.js';\nimport { BackgroundTokenizationState } from '../../../tokenizationTextModelPart.js';\nimport { LineTokens } from '../../../tokens/lineTokens.js';\nimport { TextModel } from '../../textModel.js';\nimport { AbstractSyntaxTokenBackend } from '../abstractSyntaxTokenBackend.js';\nimport { autorun, derived, IObservable, ObservablePromise } from '../../../../../base/common/observable.js';\nimport { TreeSitterTree } from './treeSitterTree.js';\nimport { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';\nimport { TreeSitterTokenizationImpl } from './treeSitterTokenizationImpl.js';\nimport { ITreeSitterLibraryService } from '../../../services/treeSitter/treeSitterLibraryService.js';\nimport { LineRange } from '../../../core/ranges/lineRange.js';\n\nexport class TreeSitterSyntaxTokenBackend extends AbstractSyntaxTokenBackend {\n\tprotected _backgroundTokenizationState: BackgroundTokenizationState = BackgroundTokenizationState.InProgress;\n\tprotected readonly _onDidChangeBackgroundTokenizationState: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeBackgroundTokenizationState: Event<void> = this._onDidChangeBackgroundTokenizationState.event;\n\n\tprivate readonly _tree: IObservable<TreeSitterTree | undefined>;\n\tprivate readonly _tokenizationImpl: IObservable<TreeSitterTokenizationImpl | undefined>;\n\n\tconstructor(\n\t\tprivate readonly _languageIdObs: IObservable<string>,\n\t\tlanguageIdCodec: ILanguageIdCodec,\n\t\ttextModel: TextModel,\n\t\tvisibleLineRanges: IObservable<readonly LineRange[]>,\n\t\t@ITreeSitterLibraryService private readonly _treeSitterLibraryService: ITreeSitterLibraryService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService\n\t) {\n\t\tsuper(languageIdCodec, textModel);\n\n\n\t\tconst parserClassPromise = new ObservablePromise(this._treeSitterLibraryService.getParserClass());\n\n\n\t\tconst parserClassObs = derived(this, reader => {\n\t\t\tconst parser = parserClassPromise.promiseResult?.read(reader)?.getDataOrThrow();\n\t\t\treturn parser;\n\t\t});\n\n\n\t\tthis._tree = derived(this, reader => {\n\t\t\tconst parserClass = parserClassObs.read(reader);\n\t\t\tif (!parserClass) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst currentLanguage = this._languageIdObs.read(reader);\n\t\t\tconst treeSitterLang = this._treeSitterLibraryService.getLanguage(currentLanguage, reader);\n\t\t\tif (!treeSitterLang) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst parser = new parserClass();\n\t\t\treader.store.add(toDisposable(() => {\n\t\t\t\tparser.delete();\n\t\t\t}));\n\t\t\tparser.setLanguage(treeSitterLang);\n\n\t\t\tconst queries = this._treeSitterLibraryService.getInjectionQueries(currentLanguage, reader);\n\t\t\tif (queries === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn reader.store.add(this._instantiationService.createInstance(TreeSitterTree, currentLanguage, undefined, parser, parserClass, /*queries, */this._textModel));\n\t\t});\n\n\n\t\tthis._tokenizationImpl = derived(this, reader => {\n\t\t\tconst treeModel = this._tree.read(reader);\n\t\t\tif (!treeModel) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst queries = this._treeSitterLibraryService.getHighlightingQueries(treeModel.languageId, reader);\n\t\t\tif (!queries) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn reader.store.add(this._instantiationService.createInstance(TreeSitterTokenizationImpl, treeModel, queries, this._languageIdCodec, visibleLineRanges));\n\t\t});\n\n\t\tthis._register(autorun(reader => {\n\t\t\tconst tokModel = this._tokenizationImpl.read(reader);\n\t\t\tif (!tokModel) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treader.store.add(tokModel.onDidChangeTokens((e) => {\n\t\t\t\tthis._onDidChangeTokens.fire(e.changes);\n\t\t\t}));\n\t\t\treader.store.add(tokModel.onDidChangeBackgroundTokenization(e => {\n\t\t\t\tthis._backgroundTokenizationState = BackgroundTokenizationState.Completed;\n\t\t\t\tthis._onDidChangeBackgroundTokenizationState.fire();\n\t\t\t}));\n\t\t}));\n\t}\n\n\tpublic getLineTokens(lineNumber: number): LineTokens {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\tconst content = this._textModel.getLineContent(lineNumber);\n\t\t\treturn LineTokens.createEmpty(content, this._languageIdCodec);\n\t\t}\n\t\treturn model.getLineTokens(lineNumber);\n\t}\n\n\tpublic todo_resetTokenization(fireTokenChangeEvent: boolean = true): void {\n\t\tif (fireTokenChangeEvent) {\n\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\tsemanticTokensApplied: false,\n\t\t\t\tranges: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfromLineNumber: 1,\n\t\t\t\t\t\ttoLineNumber: this._textModel.getLineCount(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic override handleDidChangeAttached(): void {\n\t\t// TODO @alexr00 implement for background tokenization\n\t}\n\n\tpublic override handleDidChangeContent(e: IModelContentChangedEvent): void {\n\t\tif (e.isFlush) {\n\t\t\t// Don't fire the event, as the view might not have got the text change event yet\n\t\t\tthis.todo_resetTokenization(false);\n\t\t} else {\n\t\t\tconst model = this._tokenizationImpl.get();\n\t\t\tmodel?.handleContentChanged(e);\n\t\t}\n\n\t\tconst treeModel = this._tree.get();\n\t\ttreeModel?.handleContentChange(e);\n\t}\n\n\tpublic override forceTokenization(lineNumber: number): void {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\treturn;\n\t\t}\n\t\tif (!model.hasAccurateTokensForLine(lineNumber)) {\n\t\t\tmodel.tokenizeEncoded(lineNumber);\n\t\t}\n\t}\n\n\tpublic override hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\treturn false;\n\t\t}\n\t\treturn model.hasAccurateTokensForLine(lineNumber);\n\t}\n\n\tpublic override isCheapToTokenize(lineNumber: number): boolean {\n\t\t// TODO @alexr00 determine what makes it cheap to tokenize?\n\t\treturn true;\n\t}\n\n\tpublic override getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType {\n\t\t// TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n\t\treturn StandardTokenType.Other;\n\t}\n\n\tpublic override tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\t\treturn model.tokenizeLinesAt(lineNumber, lines);\n\t}\n\n\tpublic override get hasTokens(): boolean {\n\t\tconst model = this._tokenizationImpl.get();\n\t\tif (!model) {\n\t\t\treturn false;\n\t\t}\n\t\treturn model.hasTokens();\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 10703, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/tokenizerSyntaxTokenBackend.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/tokenizerSyntaxTokenBackend.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/vs/editor/common/model/tokens/tokenizerSyntaxTokenBackend.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { MutableDisposable, DisposableMap } from '../../../../base/common/lifecycle.js';\nimport { countEOL } from '../../core/misc/eolCounter.js';\nimport { Position } from '../../core/position.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { StandardTokenType } from '../../encodedTokenAttributes.js';\nimport { IBackgroundTokenizer, IState, ILanguageIdCodec, TokenizationRegistry, ITokenizationSupport, IBackgroundTokenizationStore } from '../../languages.js';\nimport { IAttachedView } from '../../model.js';\nimport { IModelContentChangedEvent } from '../../textModelEvents.js';\nimport { BackgroundTokenizationState } from '../../tokenizationTextModelPart.js';\nimport { ContiguousMultilineTokens } from '../../tokens/contiguousMultilineTokens.js';\nimport { ContiguousMultilineTokensBuilder } from '../../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../../tokens/contiguousTokensStore.js';\nimport { LineTokens } from '../../tokens/lineTokens.js';\nimport { TextModel } from '../textModel.js';\nimport { TokenizerWithStateStoreAndTextModel, DefaultBackgroundTokenizer, TrackingTokenizationStateStore } from '../textModelTokens.js';\nimport { AbstractSyntaxTokenBackend, AttachedViewHandler, AttachedViews } from './abstractSyntaxTokenBackend.js';\n\n/** For TextMate */\nexport class TokenizerSyntaxTokenBackend extends AbstractSyntaxTokenBackend {\n\tprivate _tokenizer: TokenizerWithStateStoreAndTextModel | null = null;\n\tprotected _backgroundTokenizationState: BackgroundTokenizationState = BackgroundTokenizationState.InProgress;\n\tprotected readonly _onDidChangeBackgroundTokenizationState: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeBackgroundTokenizationState: Event<void> = this._onDidChangeBackgroundTokenizationState.event;\n\n\tprivate _defaultBackgroundTokenizer: DefaultBackgroundTokenizer | null = null;\n\tprivate readonly _backgroundTokenizer = this._register(new MutableDisposable<IBackgroundTokenizer>());\n\n\tprivate readonly _tokens = new ContiguousTokensStore(this._languageIdCodec);\n\tprivate _debugBackgroundTokens: ContiguousTokensStore | undefined;\n\tprivate _debugBackgroundStates: TrackingTokenizationStateStore<IState> | undefined;\n\n\tprivate readonly _debugBackgroundTokenizer = this._register(new MutableDisposable<IBackgroundTokenizer>());\n\n\tprivate readonly _attachedViewStates = this._register(new DisposableMap<IAttachedView, AttachedViewHandler>());\n\n\tconstructor(\n\t\tlanguageIdCodec: ILanguageIdCodec,\n\t\ttextModel: TextModel,\n\t\tprivate readonly getLanguageId: () => string,\n\t\tattachedViews: AttachedViews,\n\t) {\n\t\tsuper(languageIdCodec, textModel);\n\n\t\tthis._register(TokenizationRegistry.onDidChange((e) => {\n\t\t\tconst languageId = this.getLanguageId();\n\t\t\tif (e.changedLanguages.indexOf(languageId) === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.todo_resetTokenization();\n\t\t}));\n\n\t\tthis.todo_resetTokenization();\n\n\t\tthis._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n\t\t\tif (state) {\n\t\t\t\tlet existing = this._attachedViewStates.get(view);\n\t\t\t\tif (!existing) {\n\t\t\t\t\texisting = new AttachedViewHandler(() => this.refreshRanges(existing!.lineRanges));\n\t\t\t\t\tthis._attachedViewStates.set(view, existing);\n\t\t\t\t}\n\t\t\t\texisting.handleStateChange(state);\n\t\t\t} else {\n\t\t\t\tthis._attachedViewStates.deleteAndDispose(view);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic todo_resetTokenization(fireTokenChangeEvent: boolean = true): void {\n\t\tthis._tokens.flush();\n\t\tthis._debugBackgroundTokens?.flush();\n\t\tif (this._debugBackgroundStates) {\n\t\t\tthis._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n\t\t}\n\t\tif (fireTokenChangeEvent) {\n\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\tsemanticTokensApplied: false,\n\t\t\t\tranges: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfromLineNumber: 1,\n\t\t\t\t\t\ttoLineNumber: this._textModel.getLineCount(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\n\t\tconst initializeTokenization = (): [ITokenizationSupport, IState] | [null, null] => {\n\t\t\tif (this._textModel.isTooLargeForTokenization()) {\n\t\t\t\treturn [null, null];\n\t\t\t}\n\t\t\tconst tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n\t\t\tif (!tokenizationSupport) {\n\t\t\t\treturn [null, null];\n\t\t\t}\n\t\t\tlet initialState: IState;\n\t\t\ttry {\n\t\t\t\tinitialState = tokenizationSupport.getInitialState();\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\treturn [null, null];\n\t\t\t}\n\t\t\treturn [tokenizationSupport, initialState];\n\t\t};\n\n\t\tconst [tokenizationSupport, initialState] = initializeTokenization();\n\t\tif (tokenizationSupport && initialState) {\n\t\t\tthis._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n\t\t} else {\n\t\t\tthis._tokenizer = null;\n\t\t}\n\n\t\tthis._backgroundTokenizer.clear();\n\n\t\tthis._defaultBackgroundTokenizer = null;\n\t\tif (this._tokenizer) {\n\t\t\tconst b: IBackgroundTokenizationStore = {\n\t\t\t\tsetTokens: (tokens) => {\n\t\t\t\t\tthis.setTokens(tokens);\n\t\t\t\t},\n\t\t\t\tbackgroundTokenizationFinished: () => {\n\t\t\t\t\tif (this._backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\t\t\t\t// We already did a full tokenization and don't go back to progressing.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst newState = BackgroundTokenizationState.Completed;\n\t\t\t\t\tthis._backgroundTokenizationState = newState;\n\t\t\t\t\tthis._onDidChangeBackgroundTokenizationState.fire();\n\t\t\t\t},\n\t\t\t\tsetEndState: (lineNumber, state) => {\n\t\t\t\t\tif (!this._tokenizer) { return; }\n\t\t\t\t\tconst firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n\t\t\t\t\t// Don't accept states for definitely valid states, the renderer is ahead of the worker!\n\t\t\t\t\tif (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n\t\t\t\t\t\tthis._tokenizer?.store.setEndState(lineNumber, state);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n\t\t\t\tthis._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n\t\t\t}\n\t\t\tif (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n\t\t\t\tthis._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n\t\t\t\t\tnew DefaultBackgroundTokenizer(this._tokenizer, b);\n\t\t\t\tthis._defaultBackgroundTokenizer.handleChanges();\n\t\t\t}\n\n\t\t\tif (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n\t\t\t\tthis._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n\t\t\t\tthis._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n\t\t\t\tthis._debugBackgroundTokenizer.clear();\n\t\t\t\tthis._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n\t\t\t\t\tsetTokens: (tokens) => {\n\t\t\t\t\t\tthis._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n\t\t\t\t\t},\n\t\t\t\t\tbackgroundTokenizationFinished() {\n\t\t\t\t\t\t// NO OP\n\t\t\t\t\t},\n\t\t\t\t\tsetEndState: (lineNumber, state) => {\n\t\t\t\t\t\tthis._debugBackgroundStates?.setEndState(lineNumber, state);\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis._debugBackgroundTokens = undefined;\n\t\t\t\tthis._debugBackgroundStates = undefined;\n\t\t\t\tthis._debugBackgroundTokenizer.value = undefined;\n\t\t\t}\n\t\t}\n\n\t\tthis.refreshAllVisibleLineTokens();\n\t}\n\n\tpublic handleDidChangeAttached() {\n\t\tthis._defaultBackgroundTokenizer?.handleChanges();\n\t}\n\n\tpublic handleDidChangeContent(e: IModelContentChangedEvent): void {\n\t\tif (e.isFlush) {\n\t\t\t// Don't fire the event, as the view might not have got the text change event yet\n\t\t\tthis.todo_resetTokenization(false);\n\t\t} else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n\t\t\tfor (const c of e.changes) {\n\t\t\t\tconst [eolCount, firstLineLength] = countEOL(c.text);\n\n\t\t\t\tthis._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n\t\t\t\tthis._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n\t\t\t}\n\t\t\tthis._debugBackgroundStates?.acceptChanges(e.changes);\n\n\t\t\tif (this._tokenizer) {\n\t\t\t\tthis._tokenizer.store.acceptChanges(e.changes);\n\t\t\t}\n\t\t\tthis._defaultBackgroundTokenizer?.handleChanges();\n\t\t}\n\t}\n\n\tprivate setTokens(tokens: ContiguousMultilineTokens[]): { changes: { fromLineNumber: number; toLineNumber: number }[] } {\n\t\tconst { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n\n\t\tif (changes.length > 0) {\n\t\t\tthis._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n\t\t}\n\n\t\treturn { changes: changes };\n\t}\n\n\tprivate refreshAllVisibleLineTokens(): void {\n\t\tconst ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n\t\tthis.refreshRanges(ranges);\n\t}\n\n\tprivate refreshRanges(ranges: readonly LineRange[]): void {\n\t\tfor (const range of ranges) {\n\t\t\tthis.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n\t\t}\n\t}\n\n\tprivate refreshRange(startLineNumber: number, endLineNumber: number): void {\n\t\tif (!this._tokenizer) {\n\t\t\treturn;\n\t\t}\n\n\t\tstartLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n\t\tendLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n\t\tconst changedTokens = this.setTokens(builder.finalize());\n\n\t\tif (heuristicTokens) {\n\t\t\t// We overrode tokens with heuristically computed ones.\n\t\t\t// Because old states might get reused (thus stopping invalidation),\n\t\t\t// we have to explicitly request the tokens for the changed ranges again.\n\t\t\tfor (const c of changedTokens.changes) {\n\t\t\t\tthis._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n\t\t\t}\n\t\t}\n\n\t\tthis._defaultBackgroundTokenizer?.checkFinished();\n\t}\n\n\tpublic forceTokenization(lineNumber: number): void {\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tthis._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n\t\tthis.setTokens(builder.finalize());\n\t\tthis._defaultBackgroundTokenizer?.checkFinished();\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tif (!this._tokenizer) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._tokenizer.hasAccurateTokensForLine(lineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tif (!this._tokenizer) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._tokenizer.isCheapToTokenize(lineNumber);\n\t}\n\n\tpublic getLineTokens(lineNumber: number): LineTokens {\n\t\tconst lineText = this._textModel.getLineContent(lineNumber);\n\t\tconst result = this._tokens.getTokens(\n\t\t\tthis._textModel.getLanguageId(),\n\t\t\tlineNumber - 1,\n\t\t\tlineText\n\t\t);\n\t\tif (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n\t\t\tif (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n\t\t\t\tconst backgroundResult = this._debugBackgroundTokens.getTokens(\n\t\t\t\t\tthis._textModel.getLanguageId(),\n\t\t\t\t\tlineNumber - 1,\n\t\t\t\t\tlineText\n\t\t\t\t);\n\t\t\t\tif (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n\t\t\t\t\tthis._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType {\n\t\tif (!this._tokenizer) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst position = this._textModel.validatePosition(new Position(lineNumber, column));\n\t\tthis.forceTokenization(position.lineNumber);\n\t\treturn this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n\t}\n\n\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tif (!this._tokenizer) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.forceTokenization(lineNumber);\n\t\treturn this._tokenizer.tokenizeLinesAt(lineNumber, lines);\n\t}\n\n\tpublic get hasTokens(): boolean {\n\t\treturn this._tokens.hasTokens;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { MutableDisposable, DisposableMap } from '../../../../base/common/lifecycle.js';\nimport { countEOL } from '../../core/misc/eolCounter.js';\nimport { Position } from '../../core/position.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { StandardTokenType } from '../../encodedTokenAttributes.js';\nimport { IBackgroundTokenizer, IState, ILanguageIdCodec, TokenizationRegistry, ITokenizationSupport, IBackgroundTokenizationStore } from '../../languages.js';\nimport { IAttachedView } from '../../model.js';\nimport { IModelContentChangedEvent } from '../../textModelEvents.js';\nimport { BackgroundTokenizationState } from '../../tokenizationTextModelPart.js';\nimport { ContiguousMultilineTokens } from '../../tokens/contiguousMultilineTokens.js';\nimport { ContiguousMultilineTokensBuilder } from '../../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../../tokens/contiguousTokensStore.js';\nimport { LineTokens } from '../../tokens/lineTokens.js';\nimport { TextModel } from '../textModel.js';\nimport { TokenizerWithStateStoreAndTextModel, DefaultBackgroundTokenizer, TrackingTokenizationStateStore } from '../textModelTokens.js';\nimport { AbstractSyntaxTokenBackend, AttachedViewHandler, AttachedViews } from './abstractSyntaxTokenBackend.js';\n\n/** For TextMate */\nexport class TokenizerSyntaxTokenBackend extends AbstractSyntaxTokenBackend {\n\tprivate _tokenizer: TokenizerWithStateStoreAndTextModel | null = null;\n\tprotected _backgroundTokenizationState: BackgroundTokenizationState = BackgroundTokenizationState.InProgress;\n\tprotected readonly _onDidChangeBackgroundTokenizationState: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onDidChangeBackgroundTokenizationState: Event<void> = this._onDidChangeBackgroundTokenizationState.event;\n\n\tprivate _defaultBackgroundTokenizer: DefaultBackgroundTokenizer | null = null;\n\tprivate readonly _backgroundTokenizer = this._register(new MutableDisposable<IBackgroundTokenizer>());\n\n\tprivate readonly _tokens = new ContiguousTokensStore(this._languageIdCodec);\n\tprivate _debugBackgroundTokens: ContiguousTokensStore | undefined;\n\tprivate _debugBackgroundStates: TrackingTokenizationStateStore<IState> | undefined;\n\n\tprivate readonly _debugBackgroundTokenizer = this._register(new MutableDisposable<IBackgroundTokenizer>());\n\n\tprivate readonly _attachedViewStates = this._register(new DisposableMap<IAttachedView, AttachedViewHandler>());\n\n\tconstructor(\n\t\tlanguageIdCodec: ILanguageIdCodec,\n\t\ttextModel: TextModel,\n\t\tprivate readonly getLanguageId: () => string,\n\t\tattachedViews: AttachedViews,\n\t) {\n\t\tsuper(languageIdCodec, textModel);\n\n\t\tthis._register(TokenizationRegistry.onDidChange((e) => {\n\t\t\tconst languageId = this.getLanguageId();\n\t\t\tif (e.changedLanguages.indexOf(languageId) === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.todo_resetTokenization();\n\t\t}));\n\n\t\tthis.todo_resetTokenization();\n\n\t\tthis._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n\t\t\tif (state) {\n\t\t\t\tlet existing = this._attachedViewStates.get(view);\n\t\t\t\tif (!existing) {\n\t\t\t\t\texisting = new AttachedViewHandler(() => this.refreshRanges(existing!.lineRanges));\n\t\t\t\t\tthis._attachedViewStates.set(view, existing);\n\t\t\t\t}\n\t\t\t\texisting.handleStateChange(state);\n\t\t\t} else {\n\t\t\t\tthis._attachedViewStates.deleteAndDispose(view);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic todo_resetTokenization(fireTokenChangeEvent: boolean = true): void {\n\t\tthis._tokens.flush();\n\t\tthis._debugBackgroundTokens?.flush();\n\t\tif (this._debugBackgroundStates) {\n\t\t\tthis._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n\t\t}\n\t\tif (fireTokenChangeEvent) {\n\t\t\tthis._onDidChangeTokens.fire({\n\t\t\t\tsemanticTokensApplied: false,\n\t\t\t\tranges: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfromLineNumber: 1,\n\t\t\t\t\t\ttoLineNumber: this._textModel.getLineCount(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t}\n\n\t\tconst initializeTokenization = (): [ITokenizationSupport, IState] | [null, null] => {\n\t\t\tif (this._textModel.isTooLargeForTokenization()) {\n\t\t\t\treturn [null, null];\n\t\t\t}\n\t\t\tconst tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n\t\t\tif (!tokenizationSupport) {\n\t\t\t\treturn [null, null];\n\t\t\t}\n\t\t\tlet initialState: IState;\n\t\t\ttry {\n\t\t\t\tinitialState = tokenizationSupport.getInitialState();\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\treturn [null, null];\n\t\t\t}\n\t\t\treturn [tokenizationSupport, initialState];\n\t\t};\n\n\t\tconst [tokenizationSupport, initialState] = initializeTokenization();\n\t\tif (tokenizationSupport && initialState) {\n\t\t\tthis._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n\t\t} else {\n\t\t\tthis._tokenizer = null;\n\t\t}\n\n\t\tthis._backgroundTokenizer.clear();\n\n\t\tthis._defaultBackgroundTokenizer = null;\n\t\tif (this._tokenizer) {\n\t\t\tconst b: IBackgroundTokenizationStore = {\n\t\t\t\tsetTokens: (tokens) => {\n\t\t\t\t\tthis.setTokens(tokens);\n\t\t\t\t},\n\t\t\t\tbackgroundTokenizationFinished: () => {\n\t\t\t\t\tif (this._backgroundTokenizationState === BackgroundTokenizationState.Completed) {\n\t\t\t\t\t\t// We already did a full tokenization and don't go back to progressing.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst newState = BackgroundTokenizationState.Completed;\n\t\t\t\t\tthis._backgroundTokenizationState = newState;\n\t\t\t\t\tthis._onDidChangeBackgroundTokenizationState.fire();\n\t\t\t\t},\n\t\t\t\tsetEndState: (lineNumber, state) => {\n\t\t\t\t\tif (!this._tokenizer) { return; }\n\t\t\t\t\tconst firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n\t\t\t\t\t// Don't accept states for definitely valid states, the renderer is ahead of the worker!\n\t\t\t\t\tif (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n\t\t\t\t\t\tthis._tokenizer?.store.setEndState(lineNumber, state);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n\t\t\t\tthis._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n\t\t\t}\n\t\t\tif (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n\t\t\t\tthis._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n\t\t\t\t\tnew DefaultBackgroundTokenizer(this._tokenizer, b);\n\t\t\t\tthis._defaultBackgroundTokenizer.handleChanges();\n\t\t\t}\n\n\t\t\tif (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n\t\t\t\tthis._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n\t\t\t\tthis._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n\t\t\t\tthis._debugBackgroundTokenizer.clear();\n\t\t\t\tthis._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n\t\t\t\t\tsetTokens: (tokens) => {\n\t\t\t\t\t\tthis._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n\t\t\t\t\t},\n\t\t\t\t\tbackgroundTokenizationFinished() {\n\t\t\t\t\t\t// NO OP\n\t\t\t\t\t},\n\t\t\t\t\tsetEndState: (lineNumber, state) => {\n\t\t\t\t\t\tthis._debugBackgroundStates?.setEndState(lineNumber, state);\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis._debugBackgroundTokens = undefined;\n\t\t\t\tthis._debugBackgroundStates = undefined;\n\t\t\t\tthis._debugBackgroundTokenizer.value = undefined;\n\t\t\t}\n\t\t}\n\n\t\tthis.refreshAllVisibleLineTokens();\n\t}\n\n\tpublic handleDidChangeAttached() {\n\t\tthis._defaultBackgroundTokenizer?.handleChanges();\n\t}\n\n\tpublic handleDidChangeContent(e: IModelContentChangedEvent): void {\n\t\tif (e.isFlush) {\n\t\t\t// Don't fire the event, as the view might not have got the text change event yet\n\t\t\tthis.todo_resetTokenization(false);\n\t\t} else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n\t\t\tfor (const c of e.changes) {\n\t\t\t\tconst [eolCount, firstLineLength] = countEOL(c.text);\n\n\t\t\t\tthis._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n\t\t\t\tthis._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n\t\t\t}\n\t\t\tthis._debugBackgroundStates?.acceptChanges(e.changes);\n\n\t\t\tif (this._tokenizer) {\n\t\t\t\tthis._tokenizer.store.acceptChanges(e.changes);\n\t\t\t}\n\t\t\tthis._defaultBackgroundTokenizer?.handleChanges();\n\t\t}\n\t}\n\n\tprivate setTokens(tokens: ContiguousMultilineTokens[]): { changes: { fromLineNumber: number; toLineNumber: number }[] } {\n\t\tconst { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n\n\t\tif (changes.length > 0) {\n\t\t\tthis._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n\t\t}\n\n\t\treturn { changes: changes };\n\t}\n\n\tprivate refreshAllVisibleLineTokens(): void {\n\t\tconst ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n\t\tthis.refreshRanges(ranges);\n\t}\n\n\tprivate refreshRanges(ranges: readonly LineRange[]): void {\n\t\tfor (const range of ranges) {\n\t\t\tthis.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n\t\t}\n\t}\n\n\tprivate refreshRange(startLineNumber: number, endLineNumber: number): void {\n\t\tif (!this._tokenizer) {\n\t\t\treturn;\n\t\t}\n\n\t\tstartLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n\t\tendLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n\t\tconst changedTokens = this.setTokens(builder.finalize());\n\n\t\tif (heuristicTokens) {\n\t\t\t// We overrode tokens with heuristically computed ones.\n\t\t\t// Because old states might get reused (thus stopping invalidation),\n\t\t\t// we have to explicitly request the tokens for the changed ranges again.\n\t\t\tfor (const c of changedTokens.changes) {\n\t\t\t\tthis._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n\t\t\t}\n\t\t}\n\n\t\tthis._defaultBackgroundTokenizer?.checkFinished();\n\t}\n\n\tpublic forceTokenization(lineNumber: number): void {\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tthis._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n\t\tthis.setTokens(builder.finalize());\n\t\tthis._defaultBackgroundTokenizer?.checkFinished();\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tif (!this._tokenizer) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._tokenizer.hasAccurateTokensForLine(lineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tif (!this._tokenizer) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._tokenizer.isCheapToTokenize(lineNumber);\n\t}\n\n\tpublic getLineTokens(lineNumber: number): LineTokens {\n\t\tconst lineText = this._textModel.getLineContent(lineNumber);\n\t\tconst result = this._tokens.getTokens(\n\t\t\tthis._textModel.getLanguageId(),\n\t\t\tlineNumber - 1,\n\t\t\tlineText\n\t\t);\n\t\tif (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n\t\t\tif (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n\t\t\t\tconst backgroundResult = this._debugBackgroundTokens.getTokens(\n\t\t\t\t\tthis._textModel.getLanguageId(),\n\t\t\t\t\tlineNumber - 1,\n\t\t\t\t\tlineText\n\t\t\t\t);\n\t\t\t\tif (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n\t\t\t\t\tthis._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType {\n\t\tif (!this._tokenizer) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst position = this._textModel.validatePosition(new Position(lineNumber, column));\n\t\tthis.forceTokenization(position.lineNumber);\n\t\treturn this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n\t}\n\n\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\tif (!this._tokenizer) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.forceTokenization(lineNumber);\n\t\treturn this._tokenizer.tokenizeLinesAt(lineNumber, lines);\n\t}\n\n\tpublic get hasTokens(): boolean {\n\t\treturn this._tokens.hasTokens;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 11007, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/tokenizationTextModelPart.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/tokens/tokenizationTextModelPart.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/tokens/vs/editor/common/model/tokens/tokenizationTextModelPart.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { countEOL } from '../../core/misc/eolCounter.js';\nimport { IPosition, Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { IWordAtPosition, getWordAtText } from '../../core/wordHelper.js';\nimport { StandardTokenType } from '../../encodedTokenAttributes.js';\nimport { ILanguageService } from '../../languages/language.js';\nimport { ILanguageConfigurationService, LanguageConfigurationServiceChangeEvent, ResolvedLanguageConfiguration } from '../../languages/languageConfigurationRegistry.js';\nimport { BracketPairsTextModelPart } from '../bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { TextModel } from '../textModel.js';\nimport { TextModelPart } from '../textModelPart.js';\nimport { AbstractSyntaxTokenBackend, AttachedViews } from './abstractSyntaxTokenBackend.js';\nimport { TreeSitterSyntaxTokenBackend } from './treeSitter/treeSitterSyntaxTokenBackend.js';\nimport { IModelContentChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelTokensChangedEvent } from '../../textModelEvents.js';\nimport { ITokenizationTextModelPart } from '../../tokenizationTextModelPart.js';\nimport { LineTokens } from '../../tokens/lineTokens.js';\nimport { SparseMultilineTokens } from '../../tokens/sparseMultilineTokens.js';\nimport { SparseTokensStore } from '../../tokens/sparseTokensStore.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { TokenizerSyntaxTokenBackend } from './tokenizerSyntaxTokenBackend.js';\nimport { ITreeSitterLibraryService } from '../../services/treeSitter/treeSitterLibraryService.js';\nimport { derived, IObservable, ISettableObservable, observableValue } from '../../../../base/common/observable.js';\n\nexport class TokenizationTextModelPart extends TextModelPart implements ITokenizationTextModelPart {\n\tprivate readonly _semanticTokens: SparseTokensStore;\n\n\tprivate readonly _onDidChangeLanguage: Emitter<IModelLanguageChangedEvent>;\n\tpublic readonly onDidChangeLanguage: Event<IModelLanguageChangedEvent>;\n\n\tprivate readonly _onDidChangeLanguageConfiguration: Emitter<IModelLanguageConfigurationChangedEvent>;\n\tpublic readonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;\n\n\tprivate readonly _onDidChangeTokens: Emitter<IModelTokensChangedEvent>;\n\tpublic readonly onDidChangeTokens: Event<IModelTokensChangedEvent>;\n\n\tpublic readonly tokens: IObservable<AbstractSyntaxTokenBackend>;\n\tprivate readonly _useTreeSitter: IObservable<boolean>;\n\tprivate readonly _languageIdObs: ISettableObservable<string>;\n\n\tconstructor(\n\t\tprivate readonly _textModel: TextModel,\n\t\tprivate readonly _bracketPairsTextModelPart: BracketPairsTextModelPart,\n\t\tprivate _languageId: string,\n\t\tprivate readonly _attachedViews: AttachedViews,\n\t\t@ILanguageService private readonly _languageService: ILanguageService,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@ITreeSitterLibraryService private readonly _treeSitterLibraryService: ITreeSitterLibraryService,\n\t) {\n\t\tsuper();\n\n\t\tthis._languageIdObs = observableValue(this, this._languageId);\n\n\t\tthis._useTreeSitter = derived(this, reader => {\n\t\t\tconst languageId = this._languageIdObs.read(reader);\n\t\t\treturn this._treeSitterLibraryService.supportsLanguage(languageId, reader);\n\t\t});\n\n\t\tthis.tokens = derived(this, reader => {\n\t\t\tlet tokens: AbstractSyntaxTokenBackend;\n\t\t\tif (this._useTreeSitter.read(reader)) {\n\t\t\t\ttokens = reader.store.add(this._instantiationService.createInstance(\n\t\t\t\t\tTreeSitterSyntaxTokenBackend,\n\t\t\t\t\tthis._languageIdObs,\n\t\t\t\t\tthis._languageService.languageIdCodec,\n\t\t\t\t\tthis._textModel,\n\t\t\t\t\tthis._attachedViews.visibleLineRanges\n\t\t\t\t));\n\t\t\t} else {\n\t\t\t\ttokens = reader.store.add(new TokenizerSyntaxTokenBackend(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n\t\t\t}\n\n\t\t\treader.store.add(tokens.onDidChangeTokens(e => {\n\t\t\t\tthis._emitModelTokensChangedEvent(e);\n\t\t\t}));\n\n\t\t\treader.store.add(tokens.onDidChangeBackgroundTokenizationState(e => {\n\t\t\t\tthis._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n\t\t\t}));\n\t\t\treturn tokens;\n\t\t});\n\n\t\tlet hadTokens = false;\n\t\tthis.tokens.recomputeInitiallyAndOnChange(this._store, value => {\n\t\t\tif (hadTokens) {\n\t\t\t\t// We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n\t\t\t\t// TODO@hediet: Look into why this is needed.\n\t\t\t\tvalue.todo_resetTokenization();\n\t\t\t}\n\t\t\thadTokens = true;\n\t\t});\n\n\t\tthis._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n\t\tthis._onDidChangeLanguage = this._register(new Emitter<IModelLanguageChangedEvent>());\n\t\tthis.onDidChangeLanguage = this._onDidChangeLanguage.event;\n\t\tthis._onDidChangeLanguageConfiguration = this._register(new Emitter<IModelLanguageConfigurationChangedEvent>());\n\t\tthis.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n\t\tthis._onDidChangeTokens = this._register(new Emitter<IModelTokensChangedEvent>());\n\t\tthis.onDidChangeTokens = this._onDidChangeTokens.event;\n\t}\n\n\tpublic handleLanguageConfigurationServiceChange(e: LanguageConfigurationServiceChangeEvent): void {\n\t\tif (e.affects(this._languageId)) {\n\t\t\tthis._onDidChangeLanguageConfiguration.fire({});\n\t\t}\n\t}\n\n\tpublic handleDidChangeContent(e: IModelContentChangedEvent): void {\n\t\tif (e.isFlush) {\n\t\t\tthis._semanticTokens.flush();\n\t\t} else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n\t\t\tfor (const c of e.changes) {\n\t\t\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n\n\t\t\t\tthis._semanticTokens.acceptEdit(\n\t\t\t\t\tc.range,\n\t\t\t\t\teolCount,\n\t\t\t\t\tfirstLineLength,\n\t\t\t\t\tlastLineLength,\n\t\t\t\t\tc.text.length > 0 ? c.text.charCodeAt(0) : CharCode.Null\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis.tokens.get().handleDidChangeContent(e);\n\t}\n\n\tpublic handleDidChangeAttached(): void {\n\t\tthis.tokens.get().handleDidChangeAttached();\n\t}\n\n\t/**\n\t * Includes grammar and semantic tokens.\n\t */\n\tpublic getLineTokens(lineNumber: number): LineTokens {\n\t\tthis.validateLineNumber(lineNumber);\n\t\tconst syntacticTokens = this.tokens.get().getLineTokens(lineNumber);\n\t\treturn this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n\t}\n\n\tprivate _emitModelTokensChangedEvent(e: IModelTokensChangedEvent): void {\n\t\tif (!this._textModel._isDisposing()) {\n\t\t\tthis._bracketPairsTextModelPart.handleDidChangeTokens(e);\n\t\t\tthis._onDidChangeTokens.fire(e);\n\t\t}\n\t}\n\n\t// #region Grammar Tokens\n\n\tprivate validateLineNumber(lineNumber: number): void {\n\t\tif (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t}\n\n\tpublic get hasTokens(): boolean {\n\t\treturn this.tokens.get().hasTokens;\n\t}\n\n\tpublic resetTokenization() {\n\t\tthis.tokens.get().todo_resetTokenization();\n\t}\n\n\tpublic get backgroundTokenizationState() {\n\t\treturn this.tokens.get().backgroundTokenizationState;\n\t}\n\n\tpublic forceTokenization(lineNumber: number): void {\n\t\tthis.validateLineNumber(lineNumber);\n\t\tthis.tokens.get().forceTokenization(lineNumber);\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tthis.validateLineNumber(lineNumber);\n\t\treturn this.tokens.get().hasAccurateTokensForLine(lineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tthis.validateLineNumber(lineNumber);\n\t\treturn this.tokens.get().isCheapToTokenize(lineNumber);\n\t}\n\n\tpublic tokenizeIfCheap(lineNumber: number): void {\n\t\tthis.validateLineNumber(lineNumber);\n\t\tthis.tokens.get().tokenizeIfCheap(lineNumber);\n\t}\n\n\tpublic getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType {\n\t\treturn this.tokens.get().getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n\t}\n\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\treturn this.tokens.get().tokenizeLinesAt(lineNumber, lines);\n\t}\n\n\t// #endregion\n\n\t// #region Semantic Tokens\n\n\tpublic setSemanticTokens(tokens: SparseMultilineTokens[] | null, isComplete: boolean): void {\n\t\tthis._semanticTokens.set(tokens, isComplete, this._textModel);\n\n\t\tthis._emitModelTokensChangedEvent({\n\t\t\tsemanticTokensApplied: tokens !== null,\n\t\t\tranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n\t\t});\n\t}\n\n\tpublic hasCompleteSemanticTokens(): boolean {\n\t\treturn this._semanticTokens.isComplete();\n\t}\n\n\tpublic hasSomeSemanticTokens(): boolean {\n\t\treturn !this._semanticTokens.isEmpty();\n\t}\n\n\tpublic setPartialSemanticTokens(range: Range, tokens: SparseMultilineTokens[]): void {\n\t\tif (this.hasCompleteSemanticTokens()) {\n\t\t\treturn;\n\t\t}\n\t\tconst changedRange = this._textModel.validateRange(\n\t\t\tthis._semanticTokens.setPartial(range, tokens)\n\t\t);\n\n\t\tthis._emitModelTokensChangedEvent({\n\t\t\tsemanticTokensApplied: true,\n\t\t\tranges: [\n\t\t\t\t{\n\t\t\t\t\tfromLineNumber: changedRange.startLineNumber,\n\t\t\t\t\ttoLineNumber: changedRange.endLineNumber,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t}\n\n\t// #endregion\n\n\t// #region Utility Methods\n\n\tpublic getWordAtPosition(_position: IPosition): IWordAtPosition | null {\n\t\tthis.assertNotDisposed();\n\n\t\tconst position = this._textModel.validatePosition(_position);\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\t\tconst lineTokens = this.getLineTokens(position.lineNumber);\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\n\t\t// (1). First try checking right biased word\n\t\tconst [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n\t\tconst rightBiasedWord = getWordAtText(\n\t\t\tposition.column,\n\t\t\tthis.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(),\n\t\t\tlineContent.substring(rbStartOffset, rbEndOffset),\n\t\t\trbStartOffset\n\t\t);\n\t\t// Make sure the result touches the original passed in position\n\t\tif (\n\t\t\trightBiasedWord &&\n\t\t\trightBiasedWord.startColumn <= _position.column &&\n\t\t\t_position.column <= rightBiasedWord.endColumn\n\t\t) {\n\t\t\treturn rightBiasedWord;\n\t\t}\n\n\t\t// (2). Else, if we were at a language boundary, check the left biased word\n\t\tif (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n\t\t\t// edge case, where `position` sits between two tokens belonging to two different languages\n\t\t\tconst [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(\n\t\t\t\tlineTokens,\n\t\t\t\ttokenIndex - 1\n\t\t\t);\n\t\t\tconst leftBiasedWord = getWordAtText(\n\t\t\t\tposition.column,\n\t\t\t\tthis.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(),\n\t\t\t\tlineContent.substring(lbStartOffset, lbEndOffset),\n\t\t\t\tlbStartOffset\n\t\t\t);\n\t\t\t// Make sure the result touches the original passed in position\n\t\t\tif (\n\t\t\t\tleftBiasedWord &&\n\t\t\t\tleftBiasedWord.startColumn <= _position.column &&\n\t\t\t\t_position.column <= leftBiasedWord.endColumn\n\t\t\t) {\n\t\t\t\treturn leftBiasedWord;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getLanguageConfiguration(languageId: string): ResolvedLanguageConfiguration {\n\t\treturn this._languageConfigurationService.getLanguageConfiguration(languageId);\n\t}\n\n\tprivate static _findLanguageBoundaries(lineTokens: LineTokens, tokenIndex: number): [number, number] {\n\t\tconst languageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t// go left until a different language is hit\n\t\tlet startOffset = 0;\n\t\tfor (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n\t\t\tstartOffset = lineTokens.getStartOffset(i);\n\t\t}\n\n\t\t// go right until a different language is hit\n\t\tlet endOffset = lineTokens.getLineContent().length;\n\t\tfor (\n\t\t\tlet i = tokenIndex, tokenCount = lineTokens.getCount();\n\t\t\ti < tokenCount && lineTokens.getLanguageId(i) === languageId;\n\t\t\ti++\n\t\t) {\n\t\t\tendOffset = lineTokens.getEndOffset(i);\n\t\t}\n\n\t\treturn [startOffset, endOffset];\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition): IWordAtPosition {\n\t\tconst wordAtPosition = this.getWordAtPosition(position);\n\t\tif (!wordAtPosition) {\n\t\t\treturn { word: '', startColumn: position.column, endColumn: position.column, };\n\t\t}\n\t\treturn {\n\t\t\tword: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column,\n\t\t};\n\t}\n\n\t// #endregion\n\n\t// #region Language Id handling\n\n\tpublic getLanguageId(): string {\n\t\treturn this._languageId;\n\t}\n\n\tpublic getLanguageIdAtPosition(lineNumber: number, column: number): string {\n\t\tconst position = this._textModel.validatePosition(new Position(lineNumber, column));\n\t\tconst lineTokens = this.getLineTokens(position.lineNumber);\n\t\treturn lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n\t}\n\n\tpublic setLanguageId(languageId: string, source: string = 'api'): void {\n\t\tif (this._languageId === languageId) {\n\t\t\t// There's nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tconst e: IModelLanguageChangedEvent = {\n\t\t\toldLanguage: this._languageId,\n\t\t\tnewLanguage: languageId,\n\t\t\tsource\n\t\t};\n\n\t\tthis._languageId = languageId;\n\t\tthis._languageIdObs.set(languageId, undefined);\n\t\tthis._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n\n\t\tthis._onDidChangeLanguage.fire(e);\n\t\tthis._onDidChangeLanguageConfiguration.fire({});\n\t}\n\n\t// #endregion\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../../base/common/event.js';\nimport { countEOL } from '../../core/misc/eolCounter.js';\nimport { IPosition, Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { IWordAtPosition, getWordAtText } from '../../core/wordHelper.js';\nimport { StandardTokenType } from '../../encodedTokenAttributes.js';\nimport { ILanguageService } from '../../languages/language.js';\nimport { ILanguageConfigurationService, LanguageConfigurationServiceChangeEvent, ResolvedLanguageConfiguration } from '../../languages/languageConfigurationRegistry.js';\nimport { BracketPairsTextModelPart } from '../bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { TextModel } from '../textModel.js';\nimport { TextModelPart } from '../textModelPart.js';\nimport { AbstractSyntaxTokenBackend, AttachedViews } from './abstractSyntaxTokenBackend.js';\nimport { TreeSitterSyntaxTokenBackend } from './treeSitter/treeSitterSyntaxTokenBackend.js';\nimport { IModelContentChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelTokensChangedEvent } from '../../textModelEvents.js';\nimport { ITokenizationTextModelPart } from '../../tokenizationTextModelPart.js';\nimport { LineTokens } from '../../tokens/lineTokens.js';\nimport { SparseMultilineTokens } from '../../tokens/sparseMultilineTokens.js';\nimport { SparseTokensStore } from '../../tokens/sparseTokensStore.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { TokenizerSyntaxTokenBackend } from './tokenizerSyntaxTokenBackend.js';\nimport { ITreeSitterLibraryService } from '../../services/treeSitter/treeSitterLibraryService.js';\nimport { derived, IObservable, ISettableObservable, observableValue } from '../../../../base/common/observable.js';\n\nexport class TokenizationTextModelPart extends TextModelPart implements ITokenizationTextModelPart {\n\tprivate readonly _semanticTokens: SparseTokensStore;\n\n\tprivate readonly _onDidChangeLanguage: Emitter<IModelLanguageChangedEvent>;\n\tpublic readonly onDidChangeLanguage: Event<IModelLanguageChangedEvent>;\n\n\tprivate readonly _onDidChangeLanguageConfiguration: Emitter<IModelLanguageConfigurationChangedEvent>;\n\tpublic readonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;\n\n\tprivate readonly _onDidChangeTokens: Emitter<IModelTokensChangedEvent>;\n\tpublic readonly onDidChangeTokens: Event<IModelTokensChangedEvent>;\n\n\tpublic readonly tokens: IObservable<AbstractSyntaxTokenBackend>;\n\tprivate readonly _useTreeSitter: IObservable<boolean>;\n\tprivate readonly _languageIdObs: ISettableObservable<string>;\n\n\tconstructor(\n\t\tprivate readonly _textModel: TextModel,\n\t\tprivate readonly _bracketPairsTextModelPart: BracketPairsTextModelPart,\n\t\tprivate _languageId: string,\n\t\tprivate readonly _attachedViews: AttachedViews,\n\t\t@ILanguageService private readonly _languageService: ILanguageService,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService,\n\t\t@IInstantiationService private readonly _instantiationService: IInstantiationService,\n\t\t@ITreeSitterLibraryService private readonly _treeSitterLibraryService: ITreeSitterLibraryService,\n\t) {\n\t\tsuper();\n\n\t\tthis._languageIdObs = observableValue(this, this._languageId);\n\n\t\tthis._useTreeSitter = derived(this, reader => {\n\t\t\tconst languageId = this._languageIdObs.read(reader);\n\t\t\treturn this._treeSitterLibraryService.supportsLanguage(languageId, reader);\n\t\t});\n\n\t\tthis.tokens = derived(this, reader => {\n\t\t\tlet tokens: AbstractSyntaxTokenBackend;\n\t\t\tif (this._useTreeSitter.read(reader)) {\n\t\t\t\ttokens = reader.store.add(this._instantiationService.createInstance(\n\t\t\t\t\tTreeSitterSyntaxTokenBackend,\n\t\t\t\t\tthis._languageIdObs,\n\t\t\t\t\tthis._languageService.languageIdCodec,\n\t\t\t\t\tthis._textModel,\n\t\t\t\t\tthis._attachedViews.visibleLineRanges\n\t\t\t\t));\n\t\t\t} else {\n\t\t\t\ttokens = reader.store.add(new TokenizerSyntaxTokenBackend(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n\t\t\t}\n\n\t\t\treader.store.add(tokens.onDidChangeTokens(e => {\n\t\t\t\tthis._emitModelTokensChangedEvent(e);\n\t\t\t}));\n\n\t\t\treader.store.add(tokens.onDidChangeBackgroundTokenizationState(e => {\n\t\t\t\tthis._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n\t\t\t}));\n\t\t\treturn tokens;\n\t\t});\n\n\t\tlet hadTokens = false;\n\t\tthis.tokens.recomputeInitiallyAndOnChange(this._store, value => {\n\t\t\tif (hadTokens) {\n\t\t\t\t// We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n\t\t\t\t// TODO@hediet: Look into why this is needed.\n\t\t\t\tvalue.todo_resetTokenization();\n\t\t\t}\n\t\t\thadTokens = true;\n\t\t});\n\n\t\tthis._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n\t\tthis._onDidChangeLanguage = this._register(new Emitter<IModelLanguageChangedEvent>());\n\t\tthis.onDidChangeLanguage = this._onDidChangeLanguage.event;\n\t\tthis._onDidChangeLanguageConfiguration = this._register(new Emitter<IModelLanguageConfigurationChangedEvent>());\n\t\tthis.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n\t\tthis._onDidChangeTokens = this._register(new Emitter<IModelTokensChangedEvent>());\n\t\tthis.onDidChangeTokens = this._onDidChangeTokens.event;\n\t}\n\n\tpublic handleLanguageConfigurationServiceChange(e: LanguageConfigurationServiceChangeEvent): void {\n\t\tif (e.affects(this._languageId)) {\n\t\t\tthis._onDidChangeLanguageConfiguration.fire({});\n\t\t}\n\t}\n\n\tpublic handleDidChangeContent(e: IModelContentChangedEvent): void {\n\t\tif (e.isFlush) {\n\t\t\tthis._semanticTokens.flush();\n\t\t} else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n\t\t\tfor (const c of e.changes) {\n\t\t\t\tconst [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n\n\t\t\t\tthis._semanticTokens.acceptEdit(\n\t\t\t\t\tc.range,\n\t\t\t\t\teolCount,\n\t\t\t\t\tfirstLineLength,\n\t\t\t\t\tlastLineLength,\n\t\t\t\t\tc.text.length > 0 ? c.text.charCodeAt(0) : CharCode.Null\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis.tokens.get().handleDidChangeContent(e);\n\t}\n\n\tpublic handleDidChangeAttached(): void {\n\t\tthis.tokens.get().handleDidChangeAttached();\n\t}\n\n\t/**\n\t * Includes grammar and semantic tokens.\n\t */\n\tpublic getLineTokens(lineNumber: number): LineTokens {\n\t\tthis.validateLineNumber(lineNumber);\n\t\tconst syntacticTokens = this.tokens.get().getLineTokens(lineNumber);\n\t\treturn this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n\t}\n\n\tprivate _emitModelTokensChangedEvent(e: IModelTokensChangedEvent): void {\n\t\tif (!this._textModel._isDisposing()) {\n\t\t\tthis._bracketPairsTextModelPart.handleDidChangeTokens(e);\n\t\t\tthis._onDidChangeTokens.fire(e);\n\t\t}\n\t}\n\n\t// #region Grammar Tokens\n\n\tprivate validateLineNumber(lineNumber: number): void {\n\t\tif (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t}\n\n\tpublic get hasTokens(): boolean {\n\t\treturn this.tokens.get().hasTokens;\n\t}\n\n\tpublic resetTokenization() {\n\t\tthis.tokens.get().todo_resetTokenization();\n\t}\n\n\tpublic get backgroundTokenizationState() {\n\t\treturn this.tokens.get().backgroundTokenizationState;\n\t}\n\n\tpublic forceTokenization(lineNumber: number): void {\n\t\tthis.validateLineNumber(lineNumber);\n\t\tthis.tokens.get().forceTokenization(lineNumber);\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tthis.validateLineNumber(lineNumber);\n\t\treturn this.tokens.get().hasAccurateTokensForLine(lineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tthis.validateLineNumber(lineNumber);\n\t\treturn this.tokens.get().isCheapToTokenize(lineNumber);\n\t}\n\n\tpublic tokenizeIfCheap(lineNumber: number): void {\n\t\tthis.validateLineNumber(lineNumber);\n\t\tthis.tokens.get().tokenizeIfCheap(lineNumber);\n\t}\n\n\tpublic getTokenTypeIfInsertingCharacter(lineNumber: number, column: number, character: string): StandardTokenType {\n\t\treturn this.tokens.get().getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n\t}\n\n\tpublic tokenizeLinesAt(lineNumber: number, lines: string[]): LineTokens[] | null {\n\t\treturn this.tokens.get().tokenizeLinesAt(lineNumber, lines);\n\t}\n\n\t// #endregion\n\n\t// #region Semantic Tokens\n\n\tpublic setSemanticTokens(tokens: SparseMultilineTokens[] | null, isComplete: boolean): void {\n\t\tthis._semanticTokens.set(tokens, isComplete, this._textModel);\n\n\t\tthis._emitModelTokensChangedEvent({\n\t\t\tsemanticTokensApplied: tokens !== null,\n\t\t\tranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n\t\t});\n\t}\n\n\tpublic hasCompleteSemanticTokens(): boolean {\n\t\treturn this._semanticTokens.isComplete();\n\t}\n\n\tpublic hasSomeSemanticTokens(): boolean {\n\t\treturn !this._semanticTokens.isEmpty();\n\t}\n\n\tpublic setPartialSemanticTokens(range: Range, tokens: SparseMultilineTokens[]): void {\n\t\tif (this.hasCompleteSemanticTokens()) {\n\t\t\treturn;\n\t\t}\n\t\tconst changedRange = this._textModel.validateRange(\n\t\t\tthis._semanticTokens.setPartial(range, tokens)\n\t\t);\n\n\t\tthis._emitModelTokensChangedEvent({\n\t\t\tsemanticTokensApplied: true,\n\t\t\tranges: [\n\t\t\t\t{\n\t\t\t\t\tfromLineNumber: changedRange.startLineNumber,\n\t\t\t\t\ttoLineNumber: changedRange.endLineNumber,\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t}\n\n\t// #endregion\n\n\t// #region Utility Methods\n\n\tpublic getWordAtPosition(_position: IPosition): IWordAtPosition | null {\n\t\tthis.assertNotDisposed();\n\n\t\tconst position = this._textModel.validatePosition(_position);\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\t\tconst lineTokens = this.getLineTokens(position.lineNumber);\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\n\t\t// (1). First try checking right biased word\n\t\tconst [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n\t\tconst rightBiasedWord = getWordAtText(\n\t\t\tposition.column,\n\t\t\tthis.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(),\n\t\t\tlineContent.substring(rbStartOffset, rbEndOffset),\n\t\t\trbStartOffset\n\t\t);\n\t\t// Make sure the result touches the original passed in position\n\t\tif (\n\t\t\trightBiasedWord &&\n\t\t\trightBiasedWord.startColumn <= _position.column &&\n\t\t\t_position.column <= rightBiasedWord.endColumn\n\t\t) {\n\t\t\treturn rightBiasedWord;\n\t\t}\n\n\t\t// (2). Else, if we were at a language boundary, check the left biased word\n\t\tif (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n\t\t\t// edge case, where `position` sits between two tokens belonging to two different languages\n\t\t\tconst [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(\n\t\t\t\tlineTokens,\n\t\t\t\ttokenIndex - 1\n\t\t\t);\n\t\t\tconst leftBiasedWord = getWordAtText(\n\t\t\t\tposition.column,\n\t\t\t\tthis.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(),\n\t\t\t\tlineContent.substring(lbStartOffset, lbEndOffset),\n\t\t\t\tlbStartOffset\n\t\t\t);\n\t\t\t// Make sure the result touches the original passed in position\n\t\t\tif (\n\t\t\t\tleftBiasedWord &&\n\t\t\t\tleftBiasedWord.startColumn <= _position.column &&\n\t\t\t\t_position.column <= leftBiasedWord.endColumn\n\t\t\t) {\n\t\t\t\treturn leftBiasedWord;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getLanguageConfiguration(languageId: string): ResolvedLanguageConfiguration {\n\t\treturn this._languageConfigurationService.getLanguageConfiguration(languageId);\n\t}\n\n\tprivate static _findLanguageBoundaries(lineTokens: LineTokens, tokenIndex: number): [number, number] {\n\t\tconst languageId = lineTokens.getLanguageId(tokenIndex);\n\n\t\t// go left until a different language is hit\n\t\tlet startOffset = 0;\n\t\tfor (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n\t\t\tstartOffset = lineTokens.getStartOffset(i);\n\t\t}\n\n\t\t// go right until a different language is hit\n\t\tlet endOffset = lineTokens.getLineContent().length;\n\t\tfor (\n\t\t\tlet i = tokenIndex, tokenCount = lineTokens.getCount();\n\t\t\ti < tokenCount && lineTokens.getLanguageId(i) === languageId;\n\t\t\ti++\n\t\t) {\n\t\t\tendOffset = lineTokens.getEndOffset(i);\n\t\t}\n\n\t\treturn [startOffset, endOffset];\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition): IWordAtPosition {\n\t\tconst wordAtPosition = this.getWordAtPosition(position);\n\t\tif (!wordAtPosition) {\n\t\t\treturn { word: '', startColumn: position.column, endColumn: position.column, };\n\t\t}\n\t\treturn {\n\t\t\tword: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column,\n\t\t};\n\t}\n\n\t// #endregion\n\n\t// #region Language Id handling\n\n\tpublic getLanguageId(): string {\n\t\treturn this._languageId;\n\t}\n\n\tpublic getLanguageIdAtPosition(lineNumber: number, column: number): string {\n\t\tconst position = this._textModel.validatePosition(new Position(lineNumber, column));\n\t\tconst lineTokens = this.getLineTokens(position.lineNumber);\n\t\treturn lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n\t}\n\n\tpublic setLanguageId(languageId: string, source: string = 'api'): void {\n\t\tif (this._languageId === languageId) {\n\t\t\t// There's nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tconst e: IModelLanguageChangedEvent = {\n\t\t\toldLanguage: this._languageId,\n\t\t\tnewLanguage: languageId,\n\t\t\tsource\n\t\t};\n\n\t\tthis._languageId = languageId;\n\t\tthis._languageIdObs.set(languageId, undefined);\n\t\tthis._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n\n\t\tthis._onDidChangeLanguage.fire(e);\n\t\tthis._onDidChangeLanguageConfiguration.fire({});\n\t}\n\n\t// #endregion\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 11309, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/textModel.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/textModel.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IMarkdownString } from '../../../base/common/htmlContent.js';\nimport { Disposable, IDisposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ThemeColor } from '../../../base/common/themables.js';\nimport { Constants } from '../../../base/common/uint.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ISingleEditOperation } from '../core/editOperation.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { normalizeIndentation } from '../core/misc/indentation.js';\nimport { IPosition, Position } from '../core/position.js';\nimport { IRange, Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { TextChange } from '../core/textChange.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/misc/textModelDefaults.js';\nimport { IWordAtPosition } from '../core/wordHelper.js';\nimport { FormattingOptions } from '../languages.js';\nimport { ILanguageSelection, ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokens/tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens/abstractSyntaxTokenBackend.js';\nimport { IBracketPairsTextModelPart } from '../textModelBracketPairs.js';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelOptionsChangedEvent, InternalModelContentChangeEvent, ModelInjectedTextChangedEvent, ModelRawChange, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted, ModelLineHeightChangedEvent, ModelLineHeightChanged, ModelFontChangedEvent, ModelFontChanged, LineInjectedText } from '../textModelEvents.js';\nimport { IGuidesTextModelPart } from '../textModelGuides.js';\nimport { ITokenizationTextModelPart } from '../tokenizationTextModelPart.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IColorTheme } from '../../../platform/theme/common/themeService.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { TokenArray } from '../tokens/lineTokens.js';\nimport { SetWithKey } from '../../../base/common/collections.js';\nimport { EditSources, TextModelEditSource } from '../textModelEditSource.js';\n\nexport function createTextBufferFactory(text: string): model.ITextBufferFactory {\n\tconst builder = new PieceTreeTextBufferBuilder();\n\tbuilder.acceptChunk(text);\n\treturn builder.finish();\n}\n\nexport function createTextBufferFactoryFromSnapshot(snapshot: model.ITextSnapshot): model.ITextBufferFactory {\n\tconst builder = new PieceTreeTextBufferBuilder();\n\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === 'string') {\n\t\tbuilder.acceptChunk(chunk);\n\t}\n\n\treturn builder.finish();\n}\n\nexport function createTextBuffer(value: string | model.ITextBufferFactory | model.ITextSnapshot, defaultEOL: model.DefaultEndOfLine): { textBuffer: model.ITextBuffer; disposable: IDisposable } {\n\tlet factory: model.ITextBufferFactory;\n\tif (typeof value === 'string') {\n\t\tfactory = createTextBufferFactory(value);\n\t} else if (model.isITextSnapshot(value)) {\n\t\tfactory = createTextBufferFactoryFromSnapshot(value);\n\t} else {\n\t\tfactory = value;\n\t}\n\treturn factory.create(defaultEOL);\n}\n\nlet MODEL_ID = 0;\n\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nconst LINE_HEIGHT_CEILING = 300;\n\nclass TextModelSnapshot implements model.ITextSnapshot {\n\n\tprivate readonly _source: model.ITextSnapshot;\n\tprivate _eos: boolean;\n\n\tconstructor(source: model.ITextSnapshot) {\n\t\tthis._source = source;\n\t\tthis._eos = false;\n\t}\n\n\tpublic read(): string | null {\n\t\tif (this._eos) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst result: string[] = [];\n\t\tlet resultCnt = 0;\n\t\tlet resultLength = 0;\n\n\t\tdo {\n\t\t\tconst tmp = this._source.read();\n\n\t\t\tif (tmp === null) {\n\t\t\t\t// end-of-stream\n\t\t\t\tthis._eos = true;\n\t\t\t\tif (resultCnt === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\treturn result.join('');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tmp.length > 0) {\n\t\t\t\tresult[resultCnt++] = tmp;\n\t\t\t\tresultLength += tmp.length;\n\t\t\t}\n\n\t\t\tif (resultLength >= 64 * 1024) {\n\t\t\t\treturn result.join('');\n\t\t\t}\n\t\t} while (true);\n\t}\n}\n\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\n\nconst enum StringOffsetValidationType {\n\t/**\n\t * Even allowed in surrogate pairs\n\t */\n\tRelaxed = 0,\n\t/**\n\t * Not allowed in surrogate pairs\n\t */\n\tSurrogatePairs = 1,\n}\n\nexport class TextModel extends Disposable implements model.ITextModel, IDecorationsTreesHost {\n\n\tstatic _MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB,  // used in tests\n\tprivate static readonly LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\n\tprivate static readonly LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\n\tprivate static readonly LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; // 256M characters, usually ~> 512MB memory usage\n\n\tpublic static DEFAULT_CREATION_OPTIONS: model.ITextModelCreationOptions = {\n\t\tisForSimpleWidget: false,\n\t\ttabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n\t\tindentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n\t\tinsertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n\t\tdetectIndentation: false,\n\t\tdefaultEOL: model.DefaultEndOfLine.LF,\n\t\ttrimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n\t\tlargeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n\t\tbracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n\t};\n\n\tpublic static resolveOptions(textBuffer: model.ITextBuffer, options: model.ITextModelCreationOptions): model.TextModelResolvedOptions {\n\t\tif (options.detectIndentation) {\n\t\t\tconst guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n\t\t\treturn new model.TextModelResolvedOptions({\n\t\t\t\ttabSize: guessedIndentation.tabSize,\n\t\t\t\tindentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n\t\t\t\tinsertSpaces: guessedIndentation.insertSpaces,\n\t\t\t\ttrimAutoWhitespace: options.trimAutoWhitespace,\n\t\t\t\tdefaultEOL: options.defaultEOL,\n\t\t\t\tbracketPairColorizationOptions: options.bracketPairColorizationOptions,\n\t\t\t});\n\t\t}\n\n\t\treturn new model.TextModelResolvedOptions(options);\n\t}\n\n\t//#region Events\n\tprivate readonly _onWillDispose: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onWillDispose: Event<void> = this._onWillDispose.event;\n\n\tprivate readonly _onDidChangeDecorations: DidChangeDecorationsEmitter = this._register(new DidChangeDecorationsEmitter((affectedInjectedTextLines, affectedLineHeights, affectedFontLines) => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines, affectedLineHeights, affectedFontLines)));\n\tpublic readonly onDidChangeDecorations: Event<IModelDecorationsChangedEvent> = this._onDidChangeDecorations.event;\n\n\tpublic get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n\tpublic get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n\tpublic get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n\n\tprivate readonly _onDidChangeOptions: Emitter<IModelOptionsChangedEvent> = this._register(new Emitter<IModelOptionsChangedEvent>());\n\tpublic get onDidChangeOptions(): Event<IModelOptionsChangedEvent> { return this._onDidChangeOptions.event; }\n\n\tprivate readonly _onDidChangeAttached: Emitter<void> = this._register(new Emitter<void>());\n\tpublic get onDidChangeAttached(): Event<void> { return this._onDidChangeAttached.event; }\n\n\tprivate readonly _onDidChangeInjectedText: Emitter<ModelInjectedTextChangedEvent> = this._register(new Emitter<ModelInjectedTextChangedEvent>());\n\n\tprivate readonly _onDidChangeLineHeight: Emitter<ModelLineHeightChangedEvent> = this._register(new Emitter<ModelLineHeightChangedEvent>());\n\tpublic get onDidChangeLineHeight(): Event<ModelLineHeightChangedEvent> { return this._onDidChangeLineHeight.event; }\n\n\tprivate readonly _onDidChangeFont: Emitter<ModelFontChangedEvent> = this._register(new Emitter<ModelFontChangedEvent>());\n\tpublic get onDidChangeFont(): Event<ModelFontChangedEvent> { return this._onDidChangeFont.event; }\n\n\tprivate readonly _eventEmitter: DidChangeContentEmitter = this._register(new DidChangeContentEmitter());\n\tpublic onDidChangeContent(listener: (e: IModelContentChangedEvent) => void): IDisposable {\n\t\treturn this._eventEmitter.slowEvent((e: InternalModelContentChangeEvent) => listener(e.contentChangedEvent));\n\t}\n\tpublic onDidChangeContentOrInjectedText(listener: (e: InternalModelContentChangeEvent | ModelInjectedTextChangedEvent) => void): IDisposable {\n\t\treturn combinedDisposable(\n\t\t\tthis._eventEmitter.fastEvent(e => listener(e)),\n\t\t\tthis._onDidChangeInjectedText.event(e => listener(e))\n\t\t);\n\t}\n\t//#endregion\n\n\tpublic readonly id: string;\n\tpublic readonly isForSimpleWidget: boolean;\n\tprivate readonly _associatedResource: URI;\n\tprivate _attachedEditorCount: number;\n\tprivate _buffer: model.ITextBuffer;\n\tprivate _bufferDisposable: IDisposable;\n\tprivate _options: model.TextModelResolvedOptions;\n\tprivate readonly _languageSelectionListener = this._register(new MutableDisposable<IDisposable>());\n\n\tprivate _isDisposed: boolean;\n\tprivate __isDisposing: boolean;\n\tpublic _isDisposing(): boolean { return this.__isDisposing; }\n\tprivate _versionId: number;\n\t/**\n\t * Unlike, versionId, this can go down (via undo) or go to previous values (via redo)\n\t */\n\tprivate _alternativeVersionId: number;\n\tprivate _initialUndoRedoSnapshot: ResourceEditStackSnapshot | null;\n\tprivate readonly _isTooLargeForSyncing: boolean;\n\tprivate readonly _isTooLargeForTokenization: boolean;\n\tprivate readonly _isTooLargeForHeapOperation: boolean;\n\n\t//#region Editing\n\tprivate readonly _commandManager: EditStack;\n\tprivate _isUndoing: boolean;\n\tprivate _isRedoing: boolean;\n\tprivate _trimAutoWhitespaceLines: number[] | null;\n\t//#endregion\n\n\t//#region Decorations\n\t/**\n\t * Used to workaround broken clients that might attempt using a decoration id generated by a different model.\n\t * It is not globally unique in order to limit it to one character.\n\t */\n\tprivate readonly _instanceId: string;\n\tprivate _deltaDecorationCallCnt: number = 0;\n\tprivate _lastDecorationId: number;\n\tprivate _decorations: { [decorationId: string]: IntervalNode };\n\tprivate _decorationsTree: DecorationsTrees;\n\tprivate readonly _decorationProvider: ColorizedBracketPairsDecorationProvider;\n\t//#endregion\n\n\tprivate readonly _tokenizationTextModelPart: TokenizationTextModelPart;\n\tpublic get tokenization(): ITokenizationTextModelPart { return this._tokenizationTextModelPart; }\n\n\tprivate readonly _bracketPairs: BracketPairsTextModelPart;\n\tpublic get bracketPairs(): IBracketPairsTextModelPart { return this._bracketPairs; }\n\n\tprivate readonly _guidesTextModelPart: GuidesTextModelPart;\n\tpublic get guides(): IGuidesTextModelPart { return this._guidesTextModelPart; }\n\n\tprivate readonly _attachedViews = new AttachedViews();\n\n\tconstructor(\n\t\tsource: string | model.ITextBufferFactory,\n\t\tlanguageIdOrSelection: string | ILanguageSelection,\n\t\tcreationOptions: model.ITextModelCreationOptions,\n\t\tassociatedResource: URI | null = null,\n\t\t@IUndoRedoService private readonly _undoRedoService: IUndoRedoService,\n\t\t@ILanguageService private readonly _languageService: ILanguageService,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\t// Generate a new unique model id\n\t\tMODEL_ID++;\n\t\tthis.id = '$model' + MODEL_ID;\n\t\tthis.isForSimpleWidget = creationOptions.isForSimpleWidget;\n\t\tif (typeof associatedResource === 'undefined' || associatedResource === null) {\n\t\t\tthis._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n\t\t} else {\n\t\t\tthis._associatedResource = associatedResource;\n\t\t}\n\t\tthis._attachedEditorCount = 0;\n\n\t\tconst { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n\t\tthis._buffer = textBuffer;\n\t\tthis._bufferDisposable = disposable;\n\n\t\tconst bufferLineCount = this._buffer.getLineCount();\n\t\tconst bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), model.EndOfLinePreference.TextDefined);\n\n\t\t// !!! Make a decision in the ctor and permanently respect this decision !!!\n\t\t// If a model is too large at construction time, it will never get tokenized,\n\t\t// under no circumstances.\n\t\tif (creationOptions.largeFileOptimizations) {\n\t\t\tthis._isTooLargeForTokenization = (\n\t\t\t\t(bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n\t\t\t\t|| (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD)\n\t\t\t);\n\n\t\t\tthis._isTooLargeForHeapOperation = bufferTextLength > TextModel.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n\t\t} else {\n\t\t\tthis._isTooLargeForTokenization = false;\n\t\t\tthis._isTooLargeForHeapOperation = false;\n\t\t}\n\n\t\tthis._options = TextModel.resolveOptions(this._buffer, creationOptions);\n\n\t\tconst languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n\t\tif (typeof languageIdOrSelection !== 'string') {\n\t\t\tthis._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n\t\t}\n\n\t\tthis._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n\t\tthis._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n\t\tthis._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n\t\tthis._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart,\n\t\t\tthis,\n\t\t\tthis._bracketPairs,\n\t\t\tlanguageId,\n\t\t\tthis._attachedViews\n\t\t);\n\n\t\tthis._isTooLargeForSyncing = (bufferTextLength > TextModel._MODEL_SYNC_LIMIT);\n\n\t\tthis._versionId = 1;\n\t\tthis._alternativeVersionId = 1;\n\t\tthis._initialUndoRedoSnapshot = null;\n\n\t\tthis._isDisposed = false;\n\t\tthis.__isDisposing = false;\n\n\t\tthis._instanceId = strings.singleLetterHash(MODEL_ID);\n\t\tthis._lastDecorationId = 0;\n\t\tthis._decorations = Object.create(null);\n\t\tthis._decorationsTree = new DecorationsTrees();\n\n\t\tthis._commandManager = new EditStack(this, this._undoRedoService);\n\t\tthis._isUndoing = false;\n\t\tthis._isRedoing = false;\n\t\tthis._trimAutoWhitespaceLines = null;\n\n\n\t\tthis._register(this._decorationProvider.onDidChange(() => {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.fire();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}));\n\n\t\tthis._languageService.requestRichLanguageFeatures(languageId);\n\n\t\tthis._register(this._languageConfigurationService.onDidChange(e => {\n\t\t\tthis._bracketPairs.handleLanguageConfigurationServiceChange(e);\n\t\t\tthis._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n\t\t}));\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis.__isDisposing = true;\n\t\tthis._onWillDispose.fire();\n\t\tthis._tokenizationTextModelPart.dispose();\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t\tthis._bufferDisposable.dispose();\n\t\tthis.__isDisposing = false;\n\t\t// Manually release reference to previous text buffer to avoid large leaks\n\t\t// in case someone leaks a TextModel reference\n\t\tconst emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n\t\temptyDisposedTextBuffer.dispose();\n\t\tthis._buffer = emptyDisposedTextBuffer;\n\t\tthis._bufferDisposable = Disposable.None;\n\t}\n\n\tprivate _assertNotDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError('Model is disposed!');\n\t\t}\n\t}\n\n\tpublic getTextBuffer(): model.ITextBuffer {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer;\n\t}\n\n\tprivate _emitContentChangedEvent(rawChange: ModelRawContentChangedEvent, change: IModelContentChangedEvent): void {\n\t\tif (this.__isDisposing) {\n\t\t\t// Do not confuse listeners by emitting any event after disposing\n\t\t\treturn;\n\t\t}\n\t\tthis._tokenizationTextModelPart.handleDidChangeContent(change);\n\t\tthis._bracketPairs.handleDidChangeContent(change);\n\t\tthis._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n\t}\n\n\tpublic setValue(value: string | model.ITextSnapshot, reason = EditSources.setValue()): void {\n\t\tthis._assertNotDisposed();\n\n\t\tif (value === null || value === undefined) {\n\t\t\tthrow illegalArgument();\n\t\t}\n\n\t\tconst { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n\t\tthis._setValueFromTextBuffer(textBuffer, disposable, reason);\n\t}\n\n\tprivate _createContentChanged2(range: Range, rangeOffset: number, rangeLength: number, rangeEndPosition: Position, text: string, isUndoing: boolean, isRedoing: boolean, isFlush: boolean, isEolChange: boolean, reason: TextModelEditSource): IModelContentChangedEvent {\n\t\treturn {\n\t\t\tchanges: [{\n\t\t\t\trange: range,\n\t\t\t\trangeOffset: rangeOffset,\n\t\t\t\trangeLength: rangeLength,\n\t\t\t\ttext: text,\n\t\t\t}],\n\t\t\teol: this._buffer.getEOL(),\n\t\t\tisEolChange: isEolChange,\n\t\t\tversionId: this.getVersionId(),\n\t\t\tisUndoing: isUndoing,\n\t\t\tisRedoing: isRedoing,\n\t\t\tisFlush: isFlush,\n\t\t\tdetailedReasons: [reason],\n\t\t\tdetailedReasonsChangeLengths: [1],\n\t\t};\n\t}\n\n\tprivate _setValueFromTextBuffer(textBuffer: model.ITextBuffer, textBufferDisposable: IDisposable, reason: TextModelEditSource): void {\n\t\tthis._assertNotDisposed();\n\t\tconst oldFullModelRange = this.getFullModelRange();\n\t\tconst oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n\t\tconst endLineNumber = this.getLineCount();\n\t\tconst endColumn = this.getLineMaxColumn(endLineNumber);\n\n\t\tthis._buffer = textBuffer;\n\t\tthis._bufferDisposable.dispose();\n\t\tthis._bufferDisposable = textBufferDisposable;\n\t\tthis._increaseVersionId();\n\n\t\t// Destroy all my decorations\n\t\tthis._decorations = Object.create(null);\n\t\tthis._decorationsTree = new DecorationsTrees();\n\n\t\t// Destroy my edit history and settings\n\t\tthis._commandManager.clear();\n\t\tthis._trimAutoWhitespaceLines = null;\n\n\t\tthis._emitContentChangedEvent(\n\t\t\tnew ModelRawContentChangedEvent(\n\t\t\t\t[\n\t\t\t\t\tnew ModelRawFlush()\n\t\t\t\t],\n\t\t\t\tthis._versionId,\n\t\t\t\tfalse,\n\t\t\t\tfalse\n\t\t\t),\n\t\t\tthis._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, new Position(endLineNumber, endColumn), this.getValue(), false, false, true, false, reason)\n\t\t);\n\t}\n\n\tpublic setEOL(eol: model.EndOfLineSequence): void {\n\t\tthis._assertNotDisposed();\n\t\tconst newEOL = (eol === model.EndOfLineSequence.CRLF ? '\\r\\n' : '\\n');\n\t\tif (this._buffer.getEOL() === newEOL) {\n\t\t\t// Nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldFullModelRange = this.getFullModelRange();\n\t\tconst oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n\t\tconst endLineNumber = this.getLineCount();\n\t\tconst endColumn = this.getLineMaxColumn(endLineNumber);\n\n\t\tthis._onBeforeEOLChange();\n\t\tthis._buffer.setEOL(newEOL);\n\t\tthis._increaseVersionId();\n\t\tthis._onAfterEOLChange();\n\n\t\tthis._emitContentChangedEvent(\n\t\t\tnew ModelRawContentChangedEvent(\n\t\t\t\t[\n\t\t\t\t\tnew ModelRawEOLChanged()\n\t\t\t\t],\n\t\t\t\tthis._versionId,\n\t\t\t\tfalse,\n\t\t\t\tfalse\n\t\t\t),\n\t\t\tthis._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, new Position(endLineNumber, endColumn), this.getValue(), false, false, false, true, EditSources.eolChange())\n\t\t);\n\t}\n\n\tprivate _onBeforeEOLChange(): void {\n\t\t// Ensure all decorations get their `range` set.\n\t\tthis._decorationsTree.ensureAllNodesHaveRanges(this);\n\t}\n\n\tprivate _onAfterEOLChange(): void {\n\t\t// Transform back `range` to offsets\n\t\tconst versionId = this.getVersionId();\n\t\tconst allDecorations = this._decorationsTree.collectNodesPostOrder();\n\t\tfor (let i = 0, len = allDecorations.length; i < len; i++) {\n\t\t\tconst node = allDecorations[i];\n\t\t\tconst range = node.range!; // the range is defined due to `_onBeforeEOLChange`\n\n\t\t\tconst delta = node.cachedAbsoluteStart - node.start;\n\n\t\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t\tnode.cachedAbsoluteStart = startOffset;\n\t\t\tnode.cachedAbsoluteEnd = endOffset;\n\t\t\tnode.cachedVersionId = versionId;\n\n\t\t\tnode.start = startOffset - delta;\n\t\t\tnode.end = endOffset - delta;\n\n\t\t\trecomputeMaxEnd(node);\n\t\t}\n\t}\n\n\tpublic onBeforeAttached(): model.IAttachedView {\n\t\tthis._attachedEditorCount++;\n\t\tif (this._attachedEditorCount === 1) {\n\t\t\tthis._tokenizationTextModelPart.handleDidChangeAttached();\n\t\t\tthis._onDidChangeAttached.fire(undefined);\n\t\t}\n\t\treturn this._attachedViews.attachView();\n\t}\n\n\tpublic onBeforeDetached(view: model.IAttachedView): void {\n\t\tthis._attachedEditorCount--;\n\t\tif (this._attachedEditorCount === 0) {\n\t\t\tthis._tokenizationTextModelPart.handleDidChangeAttached();\n\t\t\tthis._onDidChangeAttached.fire(undefined);\n\t\t}\n\t\tthis._attachedViews.detachView(view);\n\t}\n\n\tpublic isAttachedToEditor(): boolean {\n\t\treturn this._attachedEditorCount > 0;\n\t}\n\n\tpublic getAttachedEditorCount(): number {\n\t\treturn this._attachedEditorCount;\n\t}\n\n\tpublic isTooLargeForSyncing(): boolean {\n\t\treturn this._isTooLargeForSyncing;\n\t}\n\n\tpublic isTooLargeForTokenization(): boolean {\n\t\treturn this._isTooLargeForTokenization;\n\t}\n\n\tpublic isTooLargeForHeapOperation(): boolean {\n\t\treturn this._isTooLargeForHeapOperation;\n\t}\n\n\tpublic isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\tpublic isDominatedByLongLines(): boolean {\n\t\tthis._assertNotDisposed();\n\t\tif (this.isTooLargeForTokenization()) {\n\t\t\t// Cannot word wrap huge files anyways, so it doesn't really matter\n\t\t\treturn false;\n\t\t}\n\t\tlet smallLineCharCount = 0;\n\t\tlet longLineCharCount = 0;\n\n\t\tconst lineCount = this._buffer.getLineCount();\n\t\tfor (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineLength = this._buffer.getLineLength(lineNumber);\n\t\t\tif (lineLength >= LONG_LINE_BOUNDARY) {\n\t\t\t\tlongLineCharCount += lineLength;\n\t\t\t} else {\n\t\t\t\tsmallLineCharCount += lineLength;\n\t\t\t}\n\t\t}\n\n\t\treturn (longLineCharCount > smallLineCharCount);\n\t}\n\n\tpublic get uri(): URI {\n\t\treturn this._associatedResource;\n\t}\n\n\t//#region Options\n\n\tpublic getOptions(): model.TextModelResolvedOptions {\n\t\tthis._assertNotDisposed();\n\t\treturn this._options;\n\t}\n\n\tpublic getFormattingOptions(): FormattingOptions {\n\t\treturn {\n\t\t\ttabSize: this._options.indentSize,\n\t\t\tinsertSpaces: this._options.insertSpaces\n\t\t};\n\t}\n\n\tpublic updateOptions(_newOpts: model.ITextModelUpdateOptions): void {\n\t\tthis._assertNotDisposed();\n\t\tconst tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n\t\tconst indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n\t\tconst insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n\t\tconst trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n\t\tconst bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n\n\t\tconst newOpts = new model.TextModelResolvedOptions({\n\t\t\ttabSize: tabSize,\n\t\t\tindentSize: indentSize,\n\t\t\tinsertSpaces: insertSpaces,\n\t\t\tdefaultEOL: this._options.defaultEOL,\n\t\t\ttrimAutoWhitespace: trimAutoWhitespace,\n\t\t\tbracketPairColorizationOptions,\n\t\t});\n\n\t\tif (this._options.equals(newOpts)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst e = this._options.createChangeEvent(newOpts);\n\t\tthis._options = newOpts;\n\n\t\tthis._bracketPairs.handleDidChangeOptions(e);\n\t\tthis._decorationProvider.handleDidChangeOptions(e);\n\t\tthis._onDidChangeOptions.fire(e);\n\t}\n\n\tpublic detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void {\n\t\tthis._assertNotDisposed();\n\t\tconst guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n\t\tthis.updateOptions({\n\t\t\tinsertSpaces: guessedIndentation.insertSpaces,\n\t\t\ttabSize: guessedIndentation.tabSize,\n\t\t\tindentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n\t\t});\n\t}\n\n\tpublic normalizeIndentation(str: string): string {\n\t\tthis._assertNotDisposed();\n\t\treturn normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n\t}\n\n\t//#endregion\n\n\t//#region Reading\n\n\tpublic getVersionId(): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._versionId;\n\t}\n\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._buffer.mightContainRTL();\n\t}\n\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._buffer.mightContainUnusualLineTerminators();\n\t}\n\n\tpublic removeUnusualLineTerminators(selections: Selection[] | null = null): void {\n\t\tconst matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, Constants.MAX_SAFE_SMALL_INTEGER);\n\t\tthis._buffer.resetMightContainUnusualLineTerminators();\n\t\tthis.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n\t}\n\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._buffer.mightContainNonBasicASCII();\n\t}\n\n\tpublic getAlternativeVersionId(): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._alternativeVersionId;\n\t}\n\n\tpublic getInitialUndoRedoSnapshot(): ResourceEditStackSnapshot | null {\n\t\tthis._assertNotDisposed();\n\t\treturn this._initialUndoRedoSnapshot;\n\t}\n\n\tpublic getOffsetAt(rawPosition: IPosition): number {\n\t\tthis._assertNotDisposed();\n\t\tconst position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, StringOffsetValidationType.Relaxed);\n\t\treturn this._buffer.getOffsetAt(position.lineNumber, position.column);\n\t}\n\n\tpublic getPositionAt(rawOffset: number): Position {\n\t\tthis._assertNotDisposed();\n\t\tconst offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n\t\treturn this._buffer.getPositionAt(offset);\n\t}\n\n\tprivate _increaseVersionId(): void {\n\t\tthis._versionId = this._versionId + 1;\n\t\tthis._alternativeVersionId = this._versionId;\n\t}\n\n\tpublic _overwriteVersionId(versionId: number): void {\n\t\tthis._versionId = versionId;\n\t}\n\n\tpublic _overwriteAlternativeVersionId(newAlternativeVersionId: number): void {\n\t\tthis._alternativeVersionId = newAlternativeVersionId;\n\t}\n\n\tpublic _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot: ResourceEditStackSnapshot | null): void {\n\t\tthis._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n\t}\n\n\tpublic getValue(eol?: model.EndOfLinePreference, preserveBOM: boolean = false): string {\n\t\tthis._assertNotDisposed();\n\t\tif (this.isTooLargeForHeapOperation()) {\n\t\t\tthrow new BugIndicatingError('Operation would exceed heap memory limits');\n\t\t}\n\n\t\tconst fullModelRange = this.getFullModelRange();\n\t\tconst fullModelValue = this.getValueInRange(fullModelRange, eol);\n\n\t\tif (preserveBOM) {\n\t\t\treturn this._buffer.getBOM() + fullModelValue;\n\t\t}\n\n\t\treturn fullModelValue;\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean = false): model.ITextSnapshot {\n\t\treturn new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n\t}\n\n\tpublic getValueLength(eol?: model.EndOfLinePreference, preserveBOM: boolean = false): number {\n\t\tthis._assertNotDisposed();\n\t\tconst fullModelRange = this.getFullModelRange();\n\t\tconst fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n\n\t\tif (preserveBOM) {\n\t\t\treturn this._buffer.getBOM().length + fullModelValue;\n\t\t}\n\n\t\treturn fullModelValue;\n\t}\n\n\tpublic getValueInRange(rawRange: IRange, eol: model.EndOfLinePreference = model.EndOfLinePreference.TextDefined): string {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n\t}\n\n\tpublic getValueLengthInRange(rawRange: IRange, eol: model.EndOfLinePreference = model.EndOfLinePreference.TextDefined): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n\t}\n\n\tpublic getCharacterCountInRange(rawRange: IRange, eol: model.EndOfLinePreference = model.EndOfLinePreference.TextDefined): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n\t}\n\n\tpublic getLineCount(): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getLineCount();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\n\t\treturn this._buffer.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\n\t\treturn this._buffer.getLineLength(lineNumber);\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\tthis._assertNotDisposed();\n\t\tif (this.isTooLargeForHeapOperation()) {\n\t\t\tthrow new BugIndicatingError('Operation would exceed heap memory limits');\n\t\t}\n\n\t\treturn this._buffer.getLinesContent();\n\t}\n\n\tpublic getEOL(): string {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getEOL();\n\t}\n\n\tpublic getEndOfLineSequence(): model.EndOfLineSequence {\n\t\tthis._assertNotDisposed();\n\t\treturn (\n\t\t\tthis._buffer.getEOL() === '\\n'\n\t\t\t\t? model.EndOfLineSequence.LF\n\t\t\t\t: model.EndOfLineSequence.CRLF\n\t\t);\n\t}\n\n\tpublic getLineMinColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\treturn 1;\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._buffer.getLineLength(lineNumber) + 1;\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n\t}\n\n\t/**\n\t * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n\t * Will try to not allocate if possible.\n\t */\n\tpublic _validateRangeRelaxedNoAllocations(range: IRange): Range {\n\t\tconst linesCount = this._buffer.getLineCount();\n\n\t\tconst initialStartLineNumber = range.startLineNumber;\n\t\tconst initialStartColumn = range.startColumn;\n\t\tlet startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n\t\tlet startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n\n\t\tif (startLineNumber < 1) {\n\t\t\tstartLineNumber = 1;\n\t\t\tstartColumn = 1;\n\t\t} else if (startLineNumber > linesCount) {\n\t\t\tstartLineNumber = linesCount;\n\t\t\tstartColumn = this.getLineMaxColumn(startLineNumber);\n\t\t} else {\n\t\t\tif (startColumn <= 1) {\n\t\t\t\tstartColumn = 1;\n\t\t\t} else {\n\t\t\t\tconst maxColumn = this.getLineMaxColumn(startLineNumber);\n\t\t\t\tif (startColumn >= maxColumn) {\n\t\t\t\t\tstartColumn = maxColumn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst initialEndLineNumber = range.endLineNumber;\n\t\tconst initialEndColumn = range.endColumn;\n\t\tlet endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n\t\tlet endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n\n\t\tif (endLineNumber < 1) {\n\t\t\tendLineNumber = 1;\n\t\t\tendColumn = 1;\n\t\t} else if (endLineNumber > linesCount) {\n\t\t\tendLineNumber = linesCount;\n\t\t\tendColumn = this.getLineMaxColumn(endLineNumber);\n\t\t} else {\n\t\t\tif (endColumn <= 1) {\n\t\t\t\tendColumn = 1;\n\t\t\t} else {\n\t\t\t\tconst maxColumn = this.getLineMaxColumn(endLineNumber);\n\t\t\t\tif (endColumn >= maxColumn) {\n\t\t\t\t\tendColumn = maxColumn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tinitialStartLineNumber === startLineNumber\n\t\t\t&& initialStartColumn === startColumn\n\t\t\t&& initialEndLineNumber === endLineNumber\n\t\t\t&& initialEndColumn === endColumn\n\t\t\t&& range instanceof Range\n\t\t\t&& !(range instanceof Selection)\n\t\t) {\n\t\t\treturn range;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\tprivate _isValidPosition(lineNumber: number, column: number, validationType: StringOffsetValidationType): boolean {\n\t\tif (typeof lineNumber !== 'number' || typeof column !== 'number') {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isNaN(lineNumber) || isNaN(column)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (lineNumber < 1 || column < 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst lineCount = this._buffer.getLineCount();\n\t\tif (lineNumber > lineCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (column === 1) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst maxColumn = this.getLineMaxColumn(lineNumber);\n\t\tif (column > maxColumn) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (validationType === StringOffsetValidationType.SurrogatePairs) {\n\t\t\t// !!At this point, column > 1\n\t\t\tconst charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate _validatePosition(_lineNumber: number, _column: number, validationType: StringOffsetValidationType): Position {\n\t\tconst lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n\t\tconst column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n\t\tconst lineCount = this._buffer.getLineCount();\n\n\t\tif (lineNumber < 1) {\n\t\t\treturn new Position(1, 1);\n\t\t}\n\n\t\tif (lineNumber > lineCount) {\n\t\t\treturn new Position(lineCount, this.getLineMaxColumn(lineCount));\n\t\t}\n\n\t\tif (column <= 1) {\n\t\t\treturn new Position(lineNumber, 1);\n\t\t}\n\n\t\tconst maxColumn = this.getLineMaxColumn(lineNumber);\n\t\tif (column >= maxColumn) {\n\t\t\treturn new Position(lineNumber, maxColumn);\n\t\t}\n\n\t\tif (validationType === StringOffsetValidationType.SurrogatePairs) {\n\t\t\t// If the position would end up in the middle of a high-low surrogate pair,\n\t\t\t// we move it to before the pair\n\t\t\t// !!At this point, column > 1\n\t\t\tconst charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\treturn new Position(lineNumber, column - 1);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic validatePosition(position: IPosition): Position {\n\t\tconst validationType = StringOffsetValidationType.SurrogatePairs;\n\t\tthis._assertNotDisposed();\n\n\t\t// Avoid object allocation and cover most likely case\n\t\tif (position instanceof Position) {\n\t\t\tif (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n\t\t\t\treturn position;\n\t\t\t}\n\t\t}\n\n\t\treturn this._validatePosition(position.lineNumber, position.column, validationType);\n\t}\n\n\tpublic isValidRange(range: Range): boolean {\n\t\treturn this._isValidRange(range, StringOffsetValidationType.SurrogatePairs);\n\t}\n\n\tprivate _isValidRange(range: Range, validationType: StringOffsetValidationType): boolean {\n\t\tconst startLineNumber = range.startLineNumber;\n\t\tconst startColumn = range.startColumn;\n\t\tconst endLineNumber = range.endLineNumber;\n\t\tconst endColumn = range.endColumn;\n\n\t\tif (!this._isValidPosition(startLineNumber, startColumn, StringOffsetValidationType.Relaxed)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this._isValidPosition(endLineNumber, endColumn, StringOffsetValidationType.Relaxed)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (validationType === StringOffsetValidationType.SurrogatePairs) {\n\t\t\tconst charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n\t\t\tconst charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n\n\t\t\tconst startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n\t\t\tconst endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n\t\t\tif (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic validateRange(_range: IRange): Range {\n\t\tconst validationType = StringOffsetValidationType.SurrogatePairs;\n\t\tthis._assertNotDisposed();\n\n\t\t// Avoid object allocation and cover most likely case\n\t\tif ((_range instanceof Range) && !(_range instanceof Selection)) {\n\t\t\tif (this._isValidRange(_range, validationType)) {\n\t\t\t\treturn _range;\n\t\t\t}\n\t\t}\n\n\t\tconst start = this._validatePosition(_range.startLineNumber, _range.startColumn, StringOffsetValidationType.Relaxed);\n\t\tconst end = this._validatePosition(_range.endLineNumber, _range.endColumn, StringOffsetValidationType.Relaxed);\n\n\t\tconst startLineNumber = start.lineNumber;\n\t\tconst startColumn = start.column;\n\t\tconst endLineNumber = end.lineNumber;\n\t\tconst endColumn = end.column;\n\n\t\tif (validationType === StringOffsetValidationType.SurrogatePairs) {\n\t\t\tconst charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n\t\t\tconst charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n\n\t\t\tconst startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n\t\t\tconst endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n\t\t\tif (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n\t\t\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\t}\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn) {\n\t\t\t\t// do not expand a collapsed range, simply move it to a valid location\n\t\t\t\treturn new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n\t\t\t}\n\n\t\t\tif (startInsideSurrogatePair && endInsideSurrogatePair) {\n\t\t\t\t// expand range at both ends\n\t\t\t\treturn new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n\t\t\t}\n\n\t\t\tif (startInsideSurrogatePair) {\n\t\t\t\t// only expand range at the start\n\t\t\t\treturn new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n\t\t\t}\n\n\t\t\t// only expand range at the end\n\t\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\tpublic modifyPosition(rawPosition: IPosition, offset: number): Position {\n\t\tthis._assertNotDisposed();\n\t\tconst candidate = this.getOffsetAt(rawPosition) + offset;\n\t\treturn this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n\t}\n\n\tpublic getFullModelRange(): Range {\n\t\tthis._assertNotDisposed();\n\t\tconst lineCount = this.getLineCount();\n\t\treturn new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n\t}\n\n\tprivate findMatchesLineByLine(searchRange: Range, searchData: model.SearchData, captureMatches: boolean, limitResultCount: number): model.FindMatch[] {\n\t\treturn this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\tpublic findMatches(searchString: string, rawSearchScope: any, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount: number = LIMIT_FIND_COUNT): model.FindMatch[] {\n\t\tthis._assertNotDisposed();\n\n\t\tlet searchRanges: Range[] | null = null;\n\n\t\tif (rawSearchScope !== null) {\n\t\t\tif (!Array.isArray(rawSearchScope)) {\n\t\t\t\trawSearchScope = [rawSearchScope];\n\t\t\t}\n\n\t\t\tif (rawSearchScope.every((searchScope: Range) => Range.isIRange(searchScope))) {\n\t\t\t\tsearchRanges = rawSearchScope.map((searchScope: Range) => this.validateRange(searchScope));\n\t\t\t}\n\t\t}\n\n\t\tif (searchRanges === null) {\n\t\t\tsearchRanges = [this.getFullModelRange()];\n\t\t}\n\n\t\tsearchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n\n\t\tconst uniqueSearchRanges: Range[] = [];\n\t\tuniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n\t\t\tif (Range.areIntersecting(prev, curr)) {\n\t\t\t\treturn prev.plusRange(curr);\n\t\t\t}\n\n\t\t\tuniqueSearchRanges.push(prev);\n\t\t\treturn curr;\n\t\t}));\n\n\t\tlet matchMapper: (value: Range, index: number, array: Range[]) => model.FindMatch[];\n\t\tif (!isRegex && searchString.indexOf('\\n') < 0) {\n\t\t\t// not regex, not multi line\n\t\t\tconst searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n\t\t\tconst searchData = searchParams.parseSearchRequest();\n\n\t\t\tif (!searchData) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tmatchMapper = (searchRange: Range) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t\t} else {\n\t\t\tmatchMapper = (searchRange: Range) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn uniqueSearchRanges.map(matchMapper).reduce((arr, matches: model.FindMatch[]) => arr.concat(matches), []);\n\t}\n\n\tpublic findNextMatch(searchString: string, rawSearchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string, captureMatches: boolean): model.FindMatch | null {\n\t\tthis._assertNotDisposed();\n\t\tconst searchStart = this.validatePosition(rawSearchStart);\n\n\t\tif (!isRegex && searchString.indexOf('\\n') < 0) {\n\t\t\tconst searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n\t\t\tconst searchData = searchParams.parseSearchRequest();\n\t\t\tif (!searchData) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst lineCount = this.getLineCount();\n\t\t\tlet searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n\t\t\tlet ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\t\t\tTextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\t\t\tif (ret.length > 0) {\n\t\t\t\treturn ret[0];\n\t\t\t}\n\n\t\t\tsearchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n\t\t\tret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\n\t\t\tif (ret.length > 0) {\n\t\t\t\treturn ret[0];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\t}\n\n\tpublic findPreviousMatch(searchString: string, rawSearchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string, captureMatches: boolean): model.FindMatch | null {\n\t\tthis._assertNotDisposed();\n\t\tconst searchStart = this.validatePosition(rawSearchStart);\n\t\treturn TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\t}\n\n\t//#endregion\n\n\t//#region Editing\n\n\tpublic pushStackElement(): void {\n\t\tthis._commandManager.pushStackElement();\n\t}\n\n\tpublic popStackElement(): void {\n\t\tthis._commandManager.popStackElement();\n\t}\n\n\tpublic pushEOL(eol: model.EndOfLineSequence): void {\n\t\tconst currentEOL = (this.getEOL() === '\\n' ? model.EndOfLineSequence.LF : model.EndOfLineSequence.CRLF);\n\t\tif (currentEOL === eol) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\tif (this._initialUndoRedoSnapshot === null) {\n\t\t\t\tthis._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n\t\t\t}\n\t\t\tthis._commandManager.pushEOL(eol);\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _validateEditOperation(rawOperation: model.IIdentifiedSingleEditOperation): model.ValidAnnotatedEditOperation {\n\t\tif (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n\t\t\treturn rawOperation;\n\t\t}\n\t\treturn new model.ValidAnnotatedEditOperation(\n\t\t\trawOperation.identifier || null,\n\t\t\tthis.validateRange(rawOperation.range),\n\t\t\trawOperation.text,\n\t\t\trawOperation.forceMoveMarkers || false,\n\t\t\trawOperation.isAutoWhitespaceEdit || false,\n\t\t\trawOperation._isTracked || false\n\t\t);\n\t}\n\n\tprivate _validateEditOperations(rawOperations: readonly model.IIdentifiedSingleEditOperation[]): model.ValidAnnotatedEditOperation[] {\n\t\tconst result: model.ValidAnnotatedEditOperation[] = [];\n\t\tfor (let i = 0, len = rawOperations.length; i < len; i++) {\n\t\t\tresult[i] = this._validateEditOperation(rawOperations[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic pushEditOperations(beforeCursorState: Selection[] | null, editOperations: model.IIdentifiedSingleEditOperation[], cursorStateComputer: model.ICursorStateComputer | null, group?: UndoRedoGroup, reason?: TextModelEditSource): Selection[] | null {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\treturn this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group, reason);\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _pushEditOperations(beforeCursorState: Selection[] | null, editOperations: model.ValidAnnotatedEditOperation[], cursorStateComputer: model.ICursorStateComputer | null, group?: UndoRedoGroup, reason?: TextModelEditSource): Selection[] | null {\n\t\tif (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n\t\t\t// Go through each saved line number and insert a trim whitespace edit\n\t\t\t// if it is safe to do so (no conflicts with other edits).\n\n\t\t\tconst incomingEdits = editOperations.map((op) => {\n\t\t\t\treturn {\n\t\t\t\t\trange: this.validateRange(op.range),\n\t\t\t\t\ttext: op.text\n\t\t\t\t};\n\t\t\t});\n\n\t\t\t// Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n\t\t\t// We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n\t\t\tlet editsAreNearCursors = true;\n\t\t\tif (beforeCursorState) {\n\t\t\t\tfor (let i = 0, len = beforeCursorState.length; i < len; i++) {\n\t\t\t\t\tconst sel = beforeCursorState[i];\n\t\t\t\t\tlet foundEditNearSel = false;\n\t\t\t\t\tfor (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n\t\t\t\t\t\tconst editRange = incomingEdits[j].range;\n\t\t\t\t\t\tconst selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n\t\t\t\t\t\tconst selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n\t\t\t\t\t\tif (!selIsAbove && !selIsBelow) {\n\t\t\t\t\t\t\tfoundEditNearSel = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!foundEditNearSel) {\n\t\t\t\t\t\teditsAreNearCursors = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (editsAreNearCursors) {\n\t\t\t\tfor (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n\t\t\t\t\tconst trimLineNumber = this._trimAutoWhitespaceLines[i];\n\t\t\t\t\tconst maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n\n\t\t\t\t\tlet allowTrimLine = true;\n\t\t\t\t\tfor (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n\t\t\t\t\t\tconst editRange = incomingEdits[j].range;\n\t\t\t\t\t\tconst editText = incomingEdits[j].text;\n\n\t\t\t\t\t\tif (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n\t\t\t\t\t\t\t// `trimLine` is completely outside this edit\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// At this point:\n\t\t\t\t\t\t//   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttrimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n\t\t\t\t\t\t\t&& editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// This edit inserts a new line (and maybe other text) after `trimLine`\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttrimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n\t\t\t\t\t\t\t&& editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// This edit inserts a new line (and maybe other text) before `trimLine`\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Looks like we can't trim this line as it would interfere with an incoming edit\n\t\t\t\t\t\tallowTrimLine = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (allowTrimLine) {\n\t\t\t\t\t\tconst trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n\t\t\t\t\t\teditOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._trimAutoWhitespaceLines = null;\n\t\t}\n\t\tif (this._initialUndoRedoSnapshot === null) {\n\t\t\tthis._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n\t\t}\n\t\treturn this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group, reason);\n\t}\n\n\t_applyUndo(changes: TextChange[], eol: model.EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void {\n\t\tconst edits = changes.map<ISingleEditOperation>((change) => {\n\t\t\tconst rangeStart = this.getPositionAt(change.newPosition);\n\t\t\tconst rangeEnd = this.getPositionAt(change.newEnd);\n\t\t\treturn {\n\t\t\t\trange: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n\t\t\t\ttext: change.oldText\n\t\t\t};\n\t\t});\n\t\tthis._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n\t}\n\n\t_applyRedo(changes: TextChange[], eol: model.EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void {\n\t\tconst edits = changes.map<ISingleEditOperation>((change) => {\n\t\t\tconst rangeStart = this.getPositionAt(change.oldPosition);\n\t\t\tconst rangeEnd = this.getPositionAt(change.oldEnd);\n\t\t\treturn {\n\t\t\t\trange: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n\t\t\t\ttext: change.newText\n\t\t\t};\n\t\t});\n\t\tthis._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n\t}\n\n\tprivate _applyUndoRedoEdits(edits: ISingleEditOperation[], eol: model.EndOfLineSequence, isUndoing: boolean, isRedoing: boolean, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\tthis._isUndoing = isUndoing;\n\t\t\tthis._isRedoing = isRedoing;\n\t\t\tthis.applyEdits(edits, false);\n\t\t\tthis.setEOL(eol);\n\t\t\tthis._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n\t\t} finally {\n\t\t\tthis._isUndoing = false;\n\t\t\tthis._isRedoing = false;\n\t\t\tthis._eventEmitter.endDeferredEmit(resultingSelection);\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[]): void;\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits: false): void;\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits: true): model.IValidEditOperation[];\n\t/** @internal */\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits: false, reason: TextModelEditSource): void;\n\t/** @internal */\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits: true, reason: TextModelEditSource): model.IValidEditOperation[];\n\tpublic applyEdits(rawOperations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits?: boolean, reason?: TextModelEditSource): void | model.IValidEditOperation[] {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\tconst operations = this._validateEditOperations(rawOperations);\n\n\t\t\treturn this._doApplyEdits(operations, computeUndoEdits ?? false, reason ?? EditSources.applyEdits());\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _doApplyEdits(rawOperations: model.ValidAnnotatedEditOperation[], computeUndoEdits: boolean, reason: TextModelEditSource): void | model.IValidEditOperation[] {\n\n\t\tconst oldLineCount = this._buffer.getLineCount();\n\t\tconst result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n\t\tconst newLineCount = this._buffer.getLineCount();\n\n\t\tconst contentChanges = result.changes;\n\t\tthis._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n\n\t\tif (contentChanges.length !== 0) {\n\t\t\t// We do a first pass to update decorations\n\t\t\t// because we want to read decorations in the second pass\n\t\t\t// where we will emit content change events\n\t\t\t// and we want to read the final decorations\n\t\t\tfor (let i = 0, len = contentChanges.length; i < len; i++) {\n\t\t\t\tconst change = contentChanges[i];\n\t\t\t\tthis._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n\t\t\t}\n\n\t\t\tconst rawContentChanges: ModelRawChange[] = [];\n\n\t\t\tthis._increaseVersionId();\n\n\t\t\tlet lineCount = oldLineCount;\n\t\t\tfor (let i = 0, len = contentChanges.length; i < len; i++) {\n\t\t\t\tconst change = contentChanges[i];\n\t\t\t\tconst [eolCount] = countEOL(change.text);\n\t\t\t\tthis._onDidChangeDecorations.fire();\n\n\t\t\t\tconst startLineNumber = change.range.startLineNumber;\n\t\t\t\tconst endLineNumber = change.range.endLineNumber;\n\n\t\t\t\tconst deletingLinesCnt = endLineNumber - startLineNumber;\n\t\t\t\tconst insertingLinesCnt = eolCount;\n\t\t\t\tconst editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n\n\t\t\t\tconst changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n\n\t\t\t\tconst currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n\t\t\t\tconst firstEditLineNumber = currentEditStartLineNumber;\n\t\t\t\tconst lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n\n\t\t\t\tconst decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(\n\t\t\t\t\tthis,\n\t\t\t\t\tthis.getOffsetAt(new Position(firstEditLineNumber, 1)),\n\t\t\t\t\tthis.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))),\n\t\t\t\t\t0\n\t\t\t\t);\n\n\n\t\t\t\tconst injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n\t\t\t\tconst injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n\n\t\t\t\tfor (let j = editingLinesCnt; j >= 0; j--) {\n\t\t\t\t\tconst editLineNumber = startLineNumber + j;\n\t\t\t\t\tconst currentEditLineNumber = currentEditStartLineNumber + j;\n\n\t\t\t\t\tinjectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n\t\t\t\t\tconst decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n\n\t\t\t\t\trawContentChanges.push(\n\t\t\t\t\t\tnew ModelRawLineChanged(\n\t\t\t\t\t\t\teditLineNumber,\n\t\t\t\t\t\t\tthis.getLineContent(currentEditLineNumber),\n\t\t\t\t\t\t\tdecorationsInCurrentLine\n\t\t\t\t\t\t));\n\t\t\t\t}\n\n\t\t\t\tif (editingLinesCnt < deletingLinesCnt) {\n\t\t\t\t\t// Must delete some lines\n\t\t\t\t\tconst spliceStartLineNumber = startLineNumber + editingLinesCnt;\n\t\t\t\t\trawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n\t\t\t\t}\n\n\t\t\t\tif (editingLinesCnt < insertingLinesCnt) {\n\t\t\t\t\tconst injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n\t\t\t\t\t// Must insert some lines\n\t\t\t\t\tconst spliceLineNumber = startLineNumber + editingLinesCnt;\n\t\t\t\t\tconst cnt = insertingLinesCnt - editingLinesCnt;\n\t\t\t\t\tconst fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n\t\t\t\t\tconst injectedTexts: (LineInjectedText[] | null)[] = [];\n\t\t\t\t\tconst newLines: string[] = [];\n\t\t\t\t\tfor (let i = 0; i < cnt; i++) {\n\t\t\t\t\t\tconst lineNumber = fromLineNumber + i;\n\t\t\t\t\t\tnewLines[i] = this.getLineContent(lineNumber);\n\n\t\t\t\t\t\tinjectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n\t\t\t\t\t\tinjectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n\t\t\t\t\t}\n\n\t\t\t\t\trawContentChanges.push(\n\t\t\t\t\t\tnew ModelRawLinesInserted(\n\t\t\t\t\t\t\tspliceLineNumber + 1,\n\t\t\t\t\t\t\tstartLineNumber + insertingLinesCnt,\n\t\t\t\t\t\t\tnewLines,\n\t\t\t\t\t\t\tinjectedTexts\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlineCount += changeLineCountDelta;\n\t\t\t}\n\n\t\t\tthis._emitContentChangedEvent(\n\t\t\t\tnew ModelRawContentChangedEvent(\n\t\t\t\t\trawContentChanges,\n\t\t\t\t\tthis.getVersionId(),\n\t\t\t\t\tthis._isUndoing,\n\t\t\t\t\tthis._isRedoing\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tchanges: contentChanges,\n\t\t\t\t\teol: this._buffer.getEOL(),\n\t\t\t\t\tisEolChange: false,\n\t\t\t\t\tversionId: this.getVersionId(),\n\t\t\t\t\tisUndoing: this._isUndoing,\n\t\t\t\t\tisRedoing: this._isRedoing,\n\t\t\t\t\tisFlush: false,\n\t\t\t\t\tdetailedReasons: [reason],\n\t\t\t\t\tdetailedReasonsChangeLengths: [contentChanges.length],\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn (result.reverseEdits === null ? undefined : result.reverseEdits);\n\t}\n\n\tpublic undo(): void | Promise<void> {\n\t\treturn this._undoRedoService.undo(this.uri);\n\t}\n\n\tpublic canUndo(): boolean {\n\t\treturn this._undoRedoService.canUndo(this.uri);\n\t}\n\n\tpublic redo(): void | Promise<void> {\n\t\treturn this._undoRedoService.redo(this.uri);\n\t}\n\n\tpublic canRedo(): boolean {\n\t\treturn this._undoRedoService.canRedo(this.uri);\n\t}\n\n\t//#endregion\n\n\t//#region Decorations\n\n\tprivate handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines: Set<number> | null, affectedLineHeights: Set<LineHeightChangingDecoration> | null, affectedFontLines: Set<LineFontChangingDecoration> | null): void {\n\t\t// This is called before the decoration changed event is fired.\n\n\t\tif (affectedInjectedTextLines && affectedInjectedTextLines.size > 0) {\n\t\t\tconst affectedLines = Array.from(affectedInjectedTextLines);\n\t\t\tconst lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n\t\t\tthis._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n\t\t}\n\t\tif (affectedLineHeights && affectedLineHeights.size > 0) {\n\t\t\tconst affectedLines = Array.from(affectedLineHeights);\n\t\t\tconst lineHeightChangeEvent = affectedLines.map(specialLineHeightChange => new ModelLineHeightChanged(specialLineHeightChange.ownerId, specialLineHeightChange.decorationId, specialLineHeightChange.lineNumber, specialLineHeightChange.lineHeight));\n\t\t\tthis._onDidChangeLineHeight.fire(new ModelLineHeightChangedEvent(lineHeightChangeEvent));\n\t\t}\n\t\tif (affectedFontLines && affectedFontLines.size > 0) {\n\t\t\tconst affectedLines = Array.from(affectedFontLines);\n\t\t\tconst fontChangeEvent = affectedLines.map(fontChange => new ModelFontChanged(fontChange.ownerId, fontChange.lineNumber));\n\t\t\tthis._onDidChangeFont.fire(new ModelFontChangedEvent(fontChangeEvent));\n\t\t}\n\t}\n\n\tpublic changeDecorations<T>(callback: (changeAccessor: model.IModelDecorationsChangeAccessor) => T, ownerId: number = 0): T | null {\n\t\tthis._assertNotDisposed();\n\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\treturn this._changeDecorations(ownerId, callback);\n\t\t} finally {\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _changeDecorations<T>(ownerId: number, callback: (changeAccessor: model.IModelDecorationsChangeAccessor) => T): T | null {\n\t\tconst changeAccessor: model.IModelDecorationsChangeAccessor = {\n\t\t\taddDecoration: (range: IRange, options: model.IModelDecorationOptions): string => {\n\t\t\t\treturn this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n\t\t\t},\n\t\t\tchangeDecoration: (id: string, newRange: IRange): void => {\n\t\t\t\tthis._changeDecorationImpl(ownerId, id, newRange);\n\t\t\t},\n\t\t\tchangeDecorationOptions: (id: string, options: model.IModelDecorationOptions) => {\n\t\t\t\tthis._changeDecorationOptionsImpl(ownerId, id, _normalizeOptions(options));\n\t\t\t},\n\t\t\tremoveDecoration: (id: string): void => {\n\t\t\t\tthis._deltaDecorationsImpl(ownerId, [id], []);\n\t\t\t},\n\t\t\tdeltaDecorations: (oldDecorations: string[], newDecorations: model.IModelDeltaDecoration[]): string[] => {\n\t\t\t\tif (oldDecorations.length === 0 && newDecorations.length === 0) {\n\t\t\t\t\t// nothing to do\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t\treturn this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n\t\t\t}\n\t\t};\n\t\tlet result: T | null = null;\n\t\ttry {\n\t\t\tresult = callback(changeAccessor);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t\t// Invalidate change accessor\n\t\tchangeAccessor.addDecoration = invalidFunc;\n\t\tchangeAccessor.changeDecoration = invalidFunc;\n\t\tchangeAccessor.changeDecorationOptions = invalidFunc;\n\t\tchangeAccessor.removeDecoration = invalidFunc;\n\t\tchangeAccessor.deltaDecorations = invalidFunc;\n\t\treturn result;\n\t}\n\n\tpublic deltaDecorations(oldDecorations: string[], newDecorations: model.IModelDeltaDecoration[], ownerId: number = 0): string[] {\n\t\tthis._assertNotDisposed();\n\t\tif (!oldDecorations) {\n\t\t\toldDecorations = [];\n\t\t}\n\t\tif (oldDecorations.length === 0 && newDecorations.length === 0) {\n\t\t\t// nothing to do\n\t\t\treturn [];\n\t\t}\n\n\t\ttry {\n\t\t\tthis._deltaDecorationCallCnt++;\n\t\t\tif (this._deltaDecorationCallCnt > 1) {\n\t\t\t\tconsole.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n\t\t\t\tonUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n\t\t\t}\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\treturn this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n\t\t} finally {\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t\tthis._deltaDecorationCallCnt--;\n\t\t}\n\t}\n\n\t_getTrackedRange(id: string): Range | null {\n\t\treturn this.getDecorationRange(id);\n\t}\n\n\t_setTrackedRange(id: string | null, newRange: null, newStickiness: model.TrackedRangeStickiness): null;\n\t_setTrackedRange(id: string | null, newRange: Range, newStickiness: model.TrackedRangeStickiness): string;\n\t_setTrackedRange(id: string | null, newRange: Range | null, newStickiness: model.TrackedRangeStickiness): string | null {\n\t\tconst node = (id ? this._decorations[id] : null);\n\n\t\tif (!node) {\n\t\t\tif (!newRange) {\n\t\t\t\t// node doesn't exist, the request is to delete => nothing to do\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// node doesn't exist, the request is to set => add the tracked range\n\t\t\treturn this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n\t\t}\n\n\t\tif (!newRange) {\n\t\t\t// node exists, the request is to delete => delete node\n\t\t\tthis._decorationsTree.delete(node);\n\t\t\tdelete this._decorations[node.id];\n\t\t\treturn null;\n\t\t}\n\n\t\t// node exists, the request is to set => change the tracked range and its options\n\t\tconst range = this._validateRangeRelaxedNoAllocations(newRange);\n\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\t\tthis._decorationsTree.delete(node);\n\t\tnode.reset(this.getVersionId(), startOffset, endOffset, range);\n\t\tnode.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n\t\tthis._decorationsTree.insert(node);\n\t\treturn node.id;\n\t}\n\n\tpublic removeAllDecorationsWithOwnerId(ownerId: number): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n\t\tfor (let i = 0, len = nodes.length; i < len; i++) {\n\t\t\tconst node = nodes[i];\n\n\t\t\tthis._decorationsTree.delete(node);\n\t\t\tdelete this._decorations[node.id];\n\t\t}\n\t}\n\n\tpublic getDecorationOptions(decorationId: string): model.IModelDecorationOptions | null {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\t\treturn node.options;\n\t}\n\n\tpublic getDecorationRange(decorationId: string): Range | null {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._decorationsTree.getNodeRange(this, node);\n\t}\n\n\tpublic getLineDecorations(lineNumber: number, ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false): model.IModelDecoration[] {\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\treturn [];\n\t\t}\n\t\treturn this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation, filterFontDecorations);\n\t}\n\n\tpublic getLinesDecorations(_startLineNumber: number, _endLineNumber: number, ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false, onlyMarginDecorations: boolean = false): model.IModelDecoration[] {\n\t\tconst lineCount = this.getLineCount();\n\t\tconst startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n\t\tconst endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n\t\tconst endColumn = this.getLineMaxColumn(endLineNumber);\n\t\tconst range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n\n\t\tconst decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations);\n\t\tpushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n\t\treturn decorations;\n\t}\n\n\tpublic getDecorationsInRange(range: IRange, ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false, onlyMinimapDecorations: boolean = false, onlyMarginDecorations: boolean = false): model.IModelDecoration[] {\n\t\tconst validatedRange = this.validateRange(range);\n\n\t\tconst decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations);\n\t\tpushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n\t\treturn decorations;\n\t}\n\n\tpublic getOverviewRulerDecorations(ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false): model.IModelDecoration[] {\n\t\treturn this._decorationsTree.getAll(this, ownerId, filterOutValidation, filterFontDecorations, true, false);\n\t}\n\n\tpublic getInjectedTextDecorations(ownerId: number = 0): model.IModelDecoration[] {\n\t\treturn this._decorationsTree.getAllInjectedText(this, ownerId);\n\t}\n\n\tpublic getCustomLineHeightsDecorations(ownerId: number = 0): model.IModelDecoration[] {\n\t\treturn this._decorationsTree.getAllCustomLineHeights(this, ownerId);\n\t}\n\n\tprivate _getInjectedTextInLine(lineNumber: number): LineInjectedText[] {\n\t\tconst startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n\t\tconst endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n\n\t\tconst result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n\t\treturn LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n\t}\n\n\tpublic getFontDecorationsInRange(range: IRange, ownerId: number = 0): model.IModelDecoration[] {\n\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\t\treturn this._decorationsTree.getFontDecorationsInInterval(this, startOffset, endOffset, ownerId);\n\t}\n\n\tpublic getAllDecorations(ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false): model.IModelDecoration[] {\n\t\tlet result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, filterFontDecorations, false, false);\n\t\tresult = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n\t\treturn result;\n\t}\n\n\tpublic getAllMarginDecorations(ownerId: number = 0): model.IModelDecoration[] {\n\t\treturn this._decorationsTree.getAll(this, ownerId, false, false, false, true);\n\t}\n\n\tprivate _getDecorationsInRange(filterRange: Range, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMarginDecorations: boolean): model.IModelDecoration[] {\n\t\tconst startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n\t\treturn this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations);\n\t}\n\n\tpublic getRangeAt(start: number, end: number): Range {\n\t\treturn this._buffer.getRangeAt(start, end - start);\n\t}\n\n\tprivate _changeDecorationImpl(ownerId: number, decorationId: string, _range: IRange): void {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.options.after) {\n\t\t\tconst oldRange = this.getDecorationRange(decorationId);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange!.endLineNumber);\n\t\t}\n\t\tif (node.options.before) {\n\t\t\tconst oldRange = this.getDecorationRange(decorationId);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange!.startLineNumber);\n\t\t}\n\t\tif (node.options.lineHeight !== null) {\n\t\t\tconst oldRange = this.getDecorationRange(decorationId);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, oldRange!.startLineNumber, null);\n\t\t}\n\t\tif (node.options.affectsFont) {\n\t\t\tconst oldRange = this.getDecorationRange(decorationId);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, node.id, oldRange!.startLineNumber);\n\t\t}\n\n\t\tconst range = this._validateRangeRelaxedNoAllocations(_range);\n\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\tthis._decorationsTree.delete(node);\n\t\tnode.reset(this.getVersionId(), startOffset, endOffset, range);\n\t\tthis._decorationsTree.insert(node);\n\t\tthis._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\n\t\tif (node.options.after) {\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n\t\t}\n\t\tif (node.options.before) {\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n\t\t}\n\t\tif (node.options.lineHeight !== null) {\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, range.startLineNumber, node.options.lineHeight);\n\t\t}\n\t\tif (node.options.affectsFont) {\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, node.id, range.startLineNumber);\n\t\t}\n\t}\n\n\tprivate _changeDecorationOptionsImpl(ownerId: number, decorationId: string, options: ModelDecorationOptions): void {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n\t\tconst nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n\n\t\tthis._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\t\tthis._onDidChangeDecorations.checkAffectedAndFire(options);\n\n\t\tif (node.options.after || options.after) {\n\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n\t\t}\n\t\tif (node.options.before || options.before) {\n\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n\t\t}\n\t\tif (node.options.lineHeight !== null || options.lineHeight !== null) {\n\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, nodeRange.startLineNumber, options.lineHeight);\n\t\t}\n\t\tif (node.options.affectsFont || options.affectsFont) {\n\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, decorationId, nodeRange.startLineNumber);\n\t\t}\n\n\t\tconst movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n\t\tconst changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n\t\tif (movedInOverviewRuler || changedWhetherInjectedText) {\n\t\t\tthis._decorationsTree.delete(node);\n\t\t\tnode.setOptions(options);\n\t\t\tthis._decorationsTree.insert(node);\n\t\t} else {\n\t\t\tnode.setOptions(options);\n\t\t}\n\t}\n\n\tprivate _deltaDecorationsImpl(ownerId: number, oldDecorationsIds: string[], newDecorations: model.IModelDeltaDecoration[], suppressEvents: boolean = false): string[] {\n\t\tconst versionId = this.getVersionId();\n\n\t\tconst oldDecorationsLen = oldDecorationsIds.length;\n\t\tlet oldDecorationIndex = 0;\n\n\t\tconst newDecorationsLen = newDecorations.length;\n\t\tlet newDecorationIndex = 0;\n\n\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\ttry {\n\t\t\tconst result = new Array<string>(newDecorationsLen);\n\t\t\twhile (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n\n\t\t\t\tlet node: IntervalNode | null = null;\n\n\t\t\t\tif (oldDecorationIndex < oldDecorationsLen) {\n\t\t\t\t\t// (1) get ourselves an old node\n\t\t\t\t\tlet decorationId: string;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tdecorationId = oldDecorationsIds[oldDecorationIndex++];\n\t\t\t\t\t\tnode = this._decorations[decorationId];\n\t\t\t\t\t} while (!node && oldDecorationIndex < oldDecorationsLen);\n\n\t\t\t\t\t// (2) remove the node from the tree (if it exists)\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tif (node.options.after) {\n\t\t\t\t\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (node.options.before) {\n\t\t\t\t\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (node.options.lineHeight !== null) {\n\t\t\t\t\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, nodeRange.startLineNumber, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (node.options.affectsFont) {\n\t\t\t\t\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, decorationId, nodeRange.startLineNumber);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._decorationsTree.delete(node);\n\n\t\t\t\t\t\tif (!suppressEvents) {\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (newDecorationIndex < newDecorationsLen) {\n\t\t\t\t\t// (3) create a new node if necessary\n\t\t\t\t\tif (!node) {\n\t\t\t\t\t\tconst internalDecorationId = (++this._lastDecorationId);\n\t\t\t\t\t\tconst decorationId = `${this._instanceId};${internalDecorationId}`;\n\t\t\t\t\t\tnode = new IntervalNode(decorationId, 0, 0);\n\t\t\t\t\t\tthis._decorations[decorationId] = node;\n\t\t\t\t\t}\n\n\t\t\t\t\t// (4) initialize node\n\t\t\t\t\tconst newDecoration = newDecorations[newDecorationIndex];\n\t\t\t\t\tconst range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n\t\t\t\t\tconst options = _normalizeOptions(newDecoration.options);\n\t\t\t\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\t\t\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t\t\t\tnode.ownerId = ownerId;\n\t\t\t\t\tnode.reset(versionId, startOffset, endOffset, range);\n\t\t\t\t\tnode.setOptions(options);\n\n\t\t\t\t\tif (node.options.after) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n\t\t\t\t\t}\n\t\t\t\t\tif (node.options.before) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n\t\t\t\t\t}\n\t\t\t\t\tif (node.options.lineHeight !== null) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, node.id, range.startLineNumber, node.options.lineHeight);\n\t\t\t\t\t}\n\t\t\t\t\tif (node.options.affectsFont) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, node.id, range.startLineNumber);\n\t\t\t\t\t}\n\t\t\t\t\tif (!suppressEvents) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.checkAffectedAndFire(options);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._decorationsTree.insert(node);\n\n\t\t\t\t\tresult[newDecorationIndex] = node.id;\n\n\t\t\t\t\tnewDecorationIndex++;\n\t\t\t\t} else {\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tdelete this._decorations[node.id];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Tokenization\n\n\t// TODO move them to the tokenization part.\n\tpublic getLanguageId(): string {\n\t\treturn this.tokenization.getLanguageId();\n\t}\n\n\tpublic setLanguage(languageIdOrSelection: string | ILanguageSelection, source?: string): void {\n\t\tif (typeof languageIdOrSelection === 'string') {\n\t\t\tthis._languageSelectionListener.clear();\n\t\t\tthis._setLanguage(languageIdOrSelection, source);\n\t\t} else {\n\t\t\tthis._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n\t\t\tthis._setLanguage(languageIdOrSelection.languageId, source);\n\t\t}\n\t}\n\n\tprivate _setLanguage(languageId: string, source?: string): void {\n\t\tthis.tokenization.setLanguageId(languageId, source);\n\t\tthis._languageService.requestRichLanguageFeatures(languageId);\n\t}\n\n\tpublic getLanguageIdAtPosition(lineNumber: number, column: number): string {\n\t\treturn this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n\t}\n\n\tpublic getWordAtPosition(position: IPosition): IWordAtPosition | null {\n\t\treturn this._tokenizationTextModelPart.getWordAtPosition(position);\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition): IWordAtPosition {\n\t\treturn this._tokenizationTextModelPart.getWordUntilPosition(position);\n\t}\n\n\t//#endregion\n\tnormalizePosition(position: Position, affinity: model.PositionAffinity): Position {\n\t\treturn position;\n\t}\n\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t*/\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\t// Columns start with 1.\n\t\treturn indentOfLine(this.getLineContent(lineNumber)) + 1;\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `TextModel(${this.uri.toString()})`;\n\t}\n}\n\nexport function indentOfLine(line: string): number {\n\tlet indent = 0;\n\tfor (const c of line) {\n\t\tif (c === ' ' || c === '\\t') {\n\t\t\tindent++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn indent;\n}\n\n//#region Decorations\n\nfunction isNodeInOverviewRuler(node: IntervalNode): boolean {\n\treturn (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\n\nfunction isOptionsInjectedText(options: ModelDecorationOptions): boolean {\n\treturn !!options.after || !!options.before;\n}\n\nfunction isNodeInjectedText(node: IntervalNode): boolean {\n\treturn !!node.options.after || !!node.options.before;\n}\n\nexport interface IDecorationsTreesHost {\n\tgetVersionId(): number;\n\tgetRangeAt(start: number, end: number): Range;\n}\n\nclass DecorationsTrees {\n\n\t/**\n\t * This tree holds decorations that do not show up in the overview ruler.\n\t */\n\tprivate readonly _decorationsTree0: IntervalTree;\n\n\t/**\n\t * This tree holds decorations that show up in the overview ruler.\n\t */\n\tprivate readonly _decorationsTree1: IntervalTree;\n\n\t/**\n\t * This tree holds decorations that contain injected text.\n\t */\n\tprivate readonly _injectedTextDecorationsTree: IntervalTree;\n\n\tconstructor() {\n\t\tthis._decorationsTree0 = new IntervalTree();\n\t\tthis._decorationsTree1 = new IntervalTree();\n\t\tthis._injectedTextDecorationsTree = new IntervalTree();\n\t}\n\n\tpublic ensureAllNodesHaveRanges(host: IDecorationsTreesHost): void {\n\t\tthis.getAll(host, 0, false, false, false, false);\n\t}\n\n\tprivate _ensureNodesHaveRanges(host: IDecorationsTreesHost, nodes: IntervalNode[]): model.IModelDecoration[] {\n\t\tfor (const node of nodes) {\n\t\t\tif (node.range === null) {\n\t\t\t\tnode.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n\t\t\t}\n\t\t}\n\t\treturn <model.IModelDecoration[]>nodes;\n\t}\n\n\tpublic getAllInInterval(host: IDecorationsTreesHost, start: number, end: number, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMarginDecorations: boolean): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, versionId, onlyMarginDecorations);\n\t\treturn this._ensureNodesHaveRanges(host, result);\n\t}\n\n\tprivate _intervalSearch(start: number, end: number, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tconst r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\tconst r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\tconst r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\treturn r0.concat(r1).concat(r2);\n\t}\n\n\tpublic getInjectedTextInInterval(host: IDecorationsTreesHost, start: number, end: number, filterOwnerId: number): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, false, versionId, false);\n\t\treturn this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n\t}\n\n\tpublic getFontDecorationsInInterval(host: IDecorationsTreesHost, start: number, end: number, filterOwnerId: number): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst decorations = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, false, false, versionId, false);\n\t\treturn this._ensureNodesHaveRanges(host, decorations).filter((i) => i.options.affectsFont);\n\t}\n\n\tpublic getAllInjectedText(host: IDecorationsTreesHost, filterOwnerId: number): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._injectedTextDecorationsTree.search(filterOwnerId, false, false, versionId, false);\n\t\treturn this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n\t}\n\n\tpublic getAllCustomLineHeights(host: IDecorationsTreesHost, filterOwnerId: number): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._search(filterOwnerId, false, false, false, versionId, false);\n\t\treturn this._ensureNodesHaveRanges(host, result).filter((i) => typeof i.options.lineHeight === 'number');\n\t}\n\n\tpublic getAll(host: IDecorationsTreesHost, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, overviewRulerOnly: boolean, onlyMarginDecorations: boolean): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._search(filterOwnerId, filterOutValidation, filterFontDecorations, overviewRulerOnly, versionId, onlyMarginDecorations);\n\t\treturn this._ensureNodesHaveRanges(host, result);\n\t}\n\n\tprivate _search(filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, overviewRulerOnly: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tif (overviewRulerOnly) {\n\t\t\treturn this._decorationsTree1.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\t} else {\n\t\t\tconst r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\t\tconst r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\t\tconst r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\t\treturn r0.concat(r1).concat(r2);\n\t\t}\n\t}\n\n\tpublic collectNodesFromOwner(ownerId: number): IntervalNode[] {\n\t\tconst r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n\t\tconst r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n\t\tconst r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n\t\treturn r0.concat(r1).concat(r2);\n\t}\n\n\tpublic collectNodesPostOrder(): IntervalNode[] {\n\t\tconst r0 = this._decorationsTree0.collectNodesPostOrder();\n\t\tconst r1 = this._decorationsTree1.collectNodesPostOrder();\n\t\tconst r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n\t\treturn r0.concat(r1).concat(r2);\n\t}\n\n\tpublic insert(node: IntervalNode): void {\n\t\tif (isNodeInjectedText(node)) {\n\t\t\tthis._injectedTextDecorationsTree.insert(node);\n\t\t} else if (isNodeInOverviewRuler(node)) {\n\t\t\tthis._decorationsTree1.insert(node);\n\t\t} else {\n\t\t\tthis._decorationsTree0.insert(node);\n\t\t}\n\t}\n\n\tpublic delete(node: IntervalNode): void {\n\t\tif (isNodeInjectedText(node)) {\n\t\t\tthis._injectedTextDecorationsTree.delete(node);\n\t\t} else if (isNodeInOverviewRuler(node)) {\n\t\t\tthis._decorationsTree1.delete(node);\n\t\t} else {\n\t\t\tthis._decorationsTree0.delete(node);\n\t\t}\n\t}\n\n\tpublic getNodeRange(host: IDecorationsTreesHost, node: IntervalNode): Range {\n\t\tconst versionId = host.getVersionId();\n\t\tif (node.cachedVersionId !== versionId) {\n\t\t\tthis._resolveNode(node, versionId);\n\t\t}\n\t\tif (node.range === null) {\n\t\t\tnode.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n\t\t}\n\t\treturn node.range;\n\t}\n\n\tprivate _resolveNode(node: IntervalNode, cachedVersionId: number): void {\n\t\tif (isNodeInjectedText(node)) {\n\t\t\tthis._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n\t\t} else if (isNodeInOverviewRuler(node)) {\n\t\t\tthis._decorationsTree1.resolveNode(node, cachedVersionId);\n\t\t} else {\n\t\t\tthis._decorationsTree0.resolveNode(node, cachedVersionId);\n\t\t}\n\t}\n\n\tpublic acceptReplace(offset: number, length: number, textLength: number, forceMoveMarkers: boolean): void {\n\t\tthis._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\t\tthis._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\t\tthis._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\t}\n}\n\nfunction cleanClassName(className: string): string {\n\treturn className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\n\nclass DecorationOptions implements model.IDecorationOptions {\n\treadonly color: string | ThemeColor;\n\treadonly darkColor: string | ThemeColor;\n\n\tconstructor(options: model.IDecorationOptions) {\n\t\tthis.color = options.color || '';\n\t\tthis.darkColor = options.darkColor || '';\n\n\t}\n}\n\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n\treadonly position: model.OverviewRulerLane;\n\tprivate _resolvedColor: string | null;\n\n\tconstructor(options: model.IModelDecorationOverviewRulerOptions) {\n\t\tsuper(options);\n\t\tthis._resolvedColor = null;\n\t\tthis.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n\t}\n\n\tpublic getColor(theme: IColorTheme): string {\n\t\tif (!this._resolvedColor) {\n\t\t\tif (theme.type !== 'light' && this.darkColor) {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.darkColor, theme);\n\t\t\t} else {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.color, theme);\n\t\t\t}\n\t\t}\n\t\treturn this._resolvedColor;\n\t}\n\n\tpublic invalidateCachedColor(): void {\n\t\tthis._resolvedColor = null;\n\t}\n\n\tprivate _resolveColor(color: string | ThemeColor, theme: IColorTheme): string {\n\t\tif (typeof color === 'string') {\n\t\t\treturn color;\n\t\t}\n\t\tconst c = color ? theme.getColor(color.id) : null;\n\t\tif (!c) {\n\t\t\treturn '';\n\t\t}\n\t\treturn c.toString();\n\t}\n}\n\nexport class ModelDecorationGlyphMarginOptions {\n\treadonly position: model.GlyphMarginLane;\n\treadonly persistLane: boolean | undefined;\n\n\tconstructor(options: model.IModelDecorationGlyphMarginOptions | null | undefined) {\n\t\tthis.position = options?.position ?? model.GlyphMarginLane.Center;\n\t\tthis.persistLane = options?.persistLane;\n\t}\n}\n\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n\treadonly position: model.MinimapPosition;\n\treadonly sectionHeaderStyle: model.MinimapSectionHeaderStyle | null;\n\treadonly sectionHeaderText: string | null;\n\tprivate _resolvedColor: Color | undefined;\n\n\tconstructor(options: model.IModelDecorationMinimapOptions) {\n\t\tsuper(options);\n\t\tthis.position = options.position;\n\t\tthis.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n\t\tthis.sectionHeaderText = options.sectionHeaderText ?? null;\n\t}\n\n\tpublic getColor(theme: IColorTheme): Color | undefined {\n\t\tif (!this._resolvedColor) {\n\t\t\tif (theme.type !== 'light' && this.darkColor) {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.darkColor, theme);\n\t\t\t} else {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.color, theme);\n\t\t\t}\n\t\t}\n\n\t\treturn this._resolvedColor;\n\t}\n\n\tpublic invalidateCachedColor(): void {\n\t\tthis._resolvedColor = undefined;\n\t}\n\n\tprivate _resolveColor(color: string | ThemeColor, theme: IColorTheme): Color | undefined {\n\t\tif (typeof color === 'string') {\n\t\t\treturn Color.fromHex(color);\n\t\t}\n\t\treturn theme.getColor(color.id);\n\t}\n}\n\nexport class ModelDecorationInjectedTextOptions implements model.InjectedTextOptions {\n\tpublic static from(options: model.InjectedTextOptions): ModelDecorationInjectedTextOptions {\n\t\tif (options instanceof ModelDecorationInjectedTextOptions) {\n\t\t\treturn options;\n\t\t}\n\t\treturn new ModelDecorationInjectedTextOptions(options);\n\t}\n\n\tpublic readonly content: string;\n\tpublic readonly tokens: TokenArray | null;\n\treadonly inlineClassName: string | null;\n\treadonly inlineClassNameAffectsLetterSpacing: boolean;\n\treadonly attachedData: unknown | null;\n\treadonly cursorStops: model.InjectedTextCursorStops | null;\n\n\tprivate constructor(options: model.InjectedTextOptions) {\n\t\tthis.content = options.content || '';\n\t\tthis.tokens = options.tokens ?? null;\n\t\tthis.inlineClassName = options.inlineClassName || null;\n\t\tthis.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n\t\tthis.attachedData = options.attachedData || null;\n\t\tthis.cursorStops = options.cursorStops || null;\n\t}\n}\n\nexport class ModelDecorationOptions implements model.IModelDecorationOptions {\n\n\tpublic static EMPTY: ModelDecorationOptions;\n\n\tpublic static register(options: model.IModelDecorationOptions): ModelDecorationOptions {\n\t\treturn new ModelDecorationOptions(options);\n\t}\n\n\tpublic static createDynamic(options: model.IModelDecorationOptions): ModelDecorationOptions {\n\t\treturn new ModelDecorationOptions(options);\n\t}\n\treadonly description: string;\n\treadonly blockClassName: string | null;\n\treadonly blockIsAfterEnd: boolean | null;\n\treadonly blockDoesNotCollapse?: boolean | null;\n\treadonly blockPadding: [top: number, right: number, bottom: number, left: number] | null;\n\treadonly stickiness: model.TrackedRangeStickiness;\n\treadonly zIndex: number;\n\treadonly className: string | null;\n\treadonly shouldFillLineOnLineBreak: boolean | null;\n\treadonly hoverMessage: IMarkdownString | IMarkdownString[] | null;\n\treadonly glyphMarginHoverMessage: IMarkdownString | IMarkdownString[] | null;\n\treadonly isWholeLine: boolean;\n\treadonly lineHeight: number | null;\n\treadonly fontSize: string | null;\n\treadonly showIfCollapsed: boolean;\n\treadonly collapseOnReplaceEdit: boolean;\n\treadonly overviewRuler: ModelDecorationOverviewRulerOptions | null;\n\treadonly minimap: ModelDecorationMinimapOptions | null;\n\treadonly glyphMargin?: model.IModelDecorationGlyphMarginOptions | null | undefined;\n\treadonly glyphMarginClassName: string | null;\n\treadonly linesDecorationsClassName: string | null;\n\treadonly lineNumberClassName: string | null;\n\treadonly lineNumberHoverMessage: IMarkdownString | IMarkdownString[] | null;\n\treadonly linesDecorationsTooltip: string | null;\n\treadonly firstLineDecorationClassName: string | null;\n\treadonly marginClassName: string | null;\n\treadonly inlineClassName: string | null;\n\treadonly inlineClassNameAffectsLetterSpacing: boolean;\n\treadonly beforeContentClassName: string | null;\n\treadonly afterContentClassName: string | null;\n\treadonly after: ModelDecorationInjectedTextOptions | null;\n\treadonly before: ModelDecorationInjectedTextOptions | null;\n\treadonly hideInCommentTokens: boolean | null;\n\treadonly hideInStringTokens: boolean | null;\n\treadonly affectsFont: boolean | null;\n\treadonly textDirection?: model.TextDirection | null | undefined;\n\n\tprivate constructor(options: model.IModelDecorationOptions) {\n\t\tthis.description = options.description;\n\t\tthis.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n\t\tthis.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n\t\tthis.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n\t\tthis.blockPadding = options.blockPadding ?? null;\n\t\tthis.stickiness = options.stickiness || model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;\n\t\tthis.zIndex = options.zIndex || 0;\n\t\tthis.className = options.className ? cleanClassName(options.className) : null;\n\t\tthis.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n\t\tthis.hoverMessage = options.hoverMessage || null;\n\t\tthis.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n\t\tthis.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n\t\tthis.isWholeLine = options.isWholeLine || false;\n\t\tthis.lineHeight = options.lineHeight ? Math.min(options.lineHeight, LINE_HEIGHT_CEILING) : null;\n\t\tthis.fontSize = options.fontSize || null;\n\t\tthis.affectsFont = !!options.fontSize || !!options.fontFamily || !!options.fontWeight || !!options.fontStyle;\n\t\tthis.showIfCollapsed = options.showIfCollapsed || false;\n\t\tthis.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n\t\tthis.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n\t\tthis.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n\t\tthis.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n\t\tthis.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n\t\tthis.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n\t\tthis.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n\t\tthis.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n\t\tthis.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n\t\tthis.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n\t\tthis.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n\t\tthis.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n\t\tthis.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n\t\tthis.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n\t\tthis.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n\t\tthis.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n\t\tthis.hideInCommentTokens = options.hideInCommentTokens ?? false;\n\t\tthis.hideInStringTokens = options.hideInStringTokens ?? false;\n\t\tthis.textDirection = options.textDirection ?? null;\n\t}\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n\tModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges }),\n\tModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges }),\n\tModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore }),\n\tModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter }),\n];\n\nfunction _normalizeOptions(options: model.IModelDecorationOptions): ModelDecorationOptions {\n\tif (options instanceof ModelDecorationOptions) {\n\t\treturn options;\n\t}\n\treturn ModelDecorationOptions.createDynamic(options);\n}\n\nclass LineHeightChangingDecoration {\n\n\tpublic static toKey(obj: LineHeightChangingDecoration): string {\n\t\treturn `${obj.ownerId};${obj.decorationId};${obj.lineNumber}`;\n\t}\n\n\tconstructor(\n\t\tpublic readonly ownerId: number,\n\t\tpublic readonly decorationId: string,\n\t\tpublic readonly lineNumber: number,\n\t\tpublic readonly lineHeight: number | null\n\t) { }\n}\n\nclass LineFontChangingDecoration {\n\n\tpublic static toKey(obj: LineFontChangingDecoration): string {\n\t\treturn `${obj.ownerId};${obj.decorationId};${obj.lineNumber}`;\n\t}\n\n\tconstructor(\n\t\tpublic readonly ownerId: number,\n\t\tpublic readonly decorationId: string,\n\t\tpublic readonly lineNumber: number\n\t) { }\n}\n\nclass DidChangeDecorationsEmitter extends Disposable {\n\n\tprivate readonly _actual: Emitter<IModelDecorationsChangedEvent> = this._register(new Emitter<IModelDecorationsChangedEvent>());\n\tpublic readonly event: Event<IModelDecorationsChangedEvent> = this._actual.event;\n\n\tprivate _deferredCnt: number;\n\tprivate _shouldFireDeferred: boolean;\n\tprivate _affectsMinimap: boolean;\n\tprivate _affectsOverviewRuler: boolean;\n\tprivate _affectedInjectedTextLines: Set<number> | null = null;\n\tprivate _affectedLineHeights: SetWithKey<LineHeightChangingDecoration> | null = null;\n\tprivate _affectedFontLines: SetWithKey<LineFontChangingDecoration> | null = null;\n\tprivate _affectsGlyphMargin: boolean;\n\tprivate _affectsLineNumber: boolean;\n\n\tconstructor(private readonly handleBeforeFire: (affectedInjectedTextLines: Set<number> | null, affectedLineHeights: SetWithKey<LineHeightChangingDecoration> | null, affectedFontLines: SetWithKey<LineFontChangingDecoration> | null) => void) {\n\t\tsuper();\n\t\tthis._deferredCnt = 0;\n\t\tthis._shouldFireDeferred = false;\n\t\tthis._affectsMinimap = false;\n\t\tthis._affectsOverviewRuler = false;\n\t\tthis._affectsGlyphMargin = false;\n\t\tthis._affectsLineNumber = false;\n\t}\n\n\tpublic beginDeferredEmit(): void {\n\t\tthis._deferredCnt++;\n\t}\n\n\tpublic endDeferredEmit(): void {\n\t\tthis._deferredCnt--;\n\t\tif (this._deferredCnt === 0) {\n\t\t\tif (this._shouldFireDeferred) {\n\t\t\t\tthis.doFire();\n\t\t\t}\n\n\t\t\tthis._affectedInjectedTextLines?.clear();\n\t\t\tthis._affectedInjectedTextLines = null;\n\t\t\tthis._affectedLineHeights?.clear();\n\t\t\tthis._affectedLineHeights = null;\n\t\t\tthis._affectedFontLines?.clear();\n\t\t\tthis._affectedFontLines = null;\n\t\t}\n\t}\n\n\tpublic recordLineAffectedByInjectedText(lineNumber: number): void {\n\t\tif (!this._affectedInjectedTextLines) {\n\t\t\tthis._affectedInjectedTextLines = new Set();\n\t\t}\n\t\tthis._affectedInjectedTextLines.add(lineNumber);\n\t}\n\n\tpublic recordLineAffectedByLineHeightChange(ownerId: number, decorationId: string, lineNumber: number, lineHeight: number | null): void {\n\t\tif (!this._affectedLineHeights) {\n\t\t\tthis._affectedLineHeights = new SetWithKey<LineHeightChangingDecoration>([], LineHeightChangingDecoration.toKey);\n\t\t}\n\t\tthis._affectedLineHeights.add(new LineHeightChangingDecoration(ownerId, decorationId, lineNumber, lineHeight));\n\t}\n\n\tpublic recordLineAffectedByFontChange(ownerId: number, decorationId: string, lineNumber: number): void {\n\t\tif (!this._affectedFontLines) {\n\t\t\tthis._affectedFontLines = new SetWithKey<LineFontChangingDecoration>([], LineFontChangingDecoration.toKey);\n\t\t}\n\t\tthis._affectedFontLines.add(new LineFontChangingDecoration(ownerId, decorationId, lineNumber));\n\t}\n\n\tpublic checkAffectedAndFire(options: ModelDecorationOptions): void {\n\t\tthis._affectsMinimap ||= !!options.minimap?.position;\n\t\tthis._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n\t\tthis._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n\t\tthis._affectsLineNumber ||= !!options.lineNumberClassName;\n\t\tthis.tryFire();\n\t}\n\n\tpublic fire(): void {\n\t\tthis._affectsMinimap = true;\n\t\tthis._affectsOverviewRuler = true;\n\t\tthis._affectsGlyphMargin = true;\n\t\tthis.tryFire();\n\t}\n\n\tprivate tryFire() {\n\t\tif (this._deferredCnt === 0) {\n\t\t\tthis.doFire();\n\t\t} else {\n\t\t\tthis._shouldFireDeferred = true;\n\t\t}\n\t}\n\n\tprivate doFire() {\n\t\tthis.handleBeforeFire(this._affectedInjectedTextLines, this._affectedLineHeights, this._affectedFontLines);\n\n\t\tconst event: IModelDecorationsChangedEvent = {\n\t\t\taffectsMinimap: this._affectsMinimap,\n\t\t\taffectsOverviewRuler: this._affectsOverviewRuler,\n\t\t\taffectsGlyphMargin: this._affectsGlyphMargin,\n\t\t\taffectsLineNumber: this._affectsLineNumber,\n\t\t};\n\t\tthis._shouldFireDeferred = false;\n\t\tthis._affectsMinimap = false;\n\t\tthis._affectsOverviewRuler = false;\n\t\tthis._affectsGlyphMargin = false;\n\t\tthis._actual.fire(event);\n\t}\n}\n\n//#endregion\n\nclass DidChangeContentEmitter extends Disposable {\n\n\t/**\n\t * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n\t */\n\tprivate readonly _fastEmitter: Emitter<InternalModelContentChangeEvent> = this._register(new Emitter<InternalModelContentChangeEvent>());\n\tpublic readonly fastEvent: Event<InternalModelContentChangeEvent> = this._fastEmitter.event;\n\tprivate readonly _slowEmitter: Emitter<InternalModelContentChangeEvent> = this._register(new Emitter<InternalModelContentChangeEvent>());\n\tpublic readonly slowEvent: Event<InternalModelContentChangeEvent> = this._slowEmitter.event;\n\n\tprivate _deferredCnt: number;\n\tprivate _deferredEvent: InternalModelContentChangeEvent | null;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._deferredCnt = 0;\n\t\tthis._deferredEvent = null;\n\t}\n\n\tpublic beginDeferredEmit(): void {\n\t\tthis._deferredCnt++;\n\t}\n\n\tpublic endDeferredEmit(resultingSelection: Selection[] | null = null): void {\n\t\tthis._deferredCnt--;\n\t\tif (this._deferredCnt === 0) {\n\t\t\tif (this._deferredEvent !== null) {\n\t\t\t\tthis._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n\t\t\t\tconst e = this._deferredEvent;\n\t\t\t\tthis._deferredEvent = null;\n\t\t\t\tthis._fastEmitter.fire(e);\n\t\t\t\tthis._slowEmitter.fire(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic fire(e: InternalModelContentChangeEvent): void {\n\t\tif (this._deferredCnt > 0) {\n\t\t\tif (this._deferredEvent) {\n\t\t\t\tthis._deferredEvent = this._deferredEvent.merge(e);\n\t\t\t} else {\n\t\t\t\tthis._deferredEvent = e;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._fastEmitter.fire(e);\n\t\tthis._slowEmitter.fire(e);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IMarkdownString } from '../../../base/common/htmlContent.js';\nimport { Disposable, IDisposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ThemeColor } from '../../../base/common/themables.js';\nimport { Constants } from '../../../base/common/uint.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { ISingleEditOperation } from '../core/editOperation.js';\nimport { countEOL } from '../core/misc/eolCounter.js';\nimport { normalizeIndentation } from '../core/misc/indentation.js';\nimport { IPosition, Position } from '../core/position.js';\nimport { IRange, Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { TextChange } from '../core/textChange.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/misc/textModelDefaults.js';\nimport { IWordAtPosition } from '../core/wordHelper.js';\nimport { FormattingOptions } from '../languages.js';\nimport { ILanguageSelection, ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokens/tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens/abstractSyntaxTokenBackend.js';\nimport { IBracketPairsTextModelPart } from '../textModelBracketPairs.js';\nimport { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelOptionsChangedEvent, InternalModelContentChangeEvent, ModelInjectedTextChangedEvent, ModelRawChange, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted, ModelLineHeightChangedEvent, ModelLineHeightChanged, ModelFontChangedEvent, ModelFontChanged, LineInjectedText } from '../textModelEvents.js';\nimport { IGuidesTextModelPart } from '../textModelGuides.js';\nimport { ITokenizationTextModelPart } from '../tokenizationTextModelPart.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IColorTheme } from '../../../platform/theme/common/themeService.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { TokenArray } from '../tokens/lineTokens.js';\nimport { SetWithKey } from '../../../base/common/collections.js';\nimport { EditSources, TextModelEditSource } from '../textModelEditSource.js';\n\nexport function createTextBufferFactory(text: string): model.ITextBufferFactory {\n\tconst builder = new PieceTreeTextBufferBuilder();\n\tbuilder.acceptChunk(text);\n\treturn builder.finish();\n}\n\nexport function createTextBufferFactoryFromSnapshot(snapshot: model.ITextSnapshot): model.ITextBufferFactory {\n\tconst builder = new PieceTreeTextBufferBuilder();\n\n\tlet chunk: string | null;\n\twhile (typeof (chunk = snapshot.read()) === 'string') {\n\t\tbuilder.acceptChunk(chunk);\n\t}\n\n\treturn builder.finish();\n}\n\nexport function createTextBuffer(value: string | model.ITextBufferFactory | model.ITextSnapshot, defaultEOL: model.DefaultEndOfLine): { textBuffer: model.ITextBuffer; disposable: IDisposable } {\n\tlet factory: model.ITextBufferFactory;\n\tif (typeof value === 'string') {\n\t\tfactory = createTextBufferFactory(value);\n\t} else if (model.isITextSnapshot(value)) {\n\t\tfactory = createTextBufferFactoryFromSnapshot(value);\n\t} else {\n\t\tfactory = value;\n\t}\n\treturn factory.create(defaultEOL);\n}\n\nlet MODEL_ID = 0;\n\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nconst LINE_HEIGHT_CEILING = 300;\n\nclass TextModelSnapshot implements model.ITextSnapshot {\n\n\tprivate readonly _source: model.ITextSnapshot;\n\tprivate _eos: boolean;\n\n\tconstructor(source: model.ITextSnapshot) {\n\t\tthis._source = source;\n\t\tthis._eos = false;\n\t}\n\n\tpublic read(): string | null {\n\t\tif (this._eos) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst result: string[] = [];\n\t\tlet resultCnt = 0;\n\t\tlet resultLength = 0;\n\n\t\tdo {\n\t\t\tconst tmp = this._source.read();\n\n\t\t\tif (tmp === null) {\n\t\t\t\t// end-of-stream\n\t\t\t\tthis._eos = true;\n\t\t\t\tif (resultCnt === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\treturn result.join('');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tmp.length > 0) {\n\t\t\t\tresult[resultCnt++] = tmp;\n\t\t\t\tresultLength += tmp.length;\n\t\t\t}\n\n\t\t\tif (resultLength >= 64 * 1024) {\n\t\t\t\treturn result.join('');\n\t\t\t}\n\t\t} while (true);\n\t}\n}\n\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\n\nconst enum StringOffsetValidationType {\n\t/**\n\t * Even allowed in surrogate pairs\n\t */\n\tRelaxed = 0,\n\t/**\n\t * Not allowed in surrogate pairs\n\t */\n\tSurrogatePairs = 1,\n}\n\nexport class TextModel extends Disposable implements model.ITextModel, IDecorationsTreesHost {\n\n\tstatic _MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB,  // used in tests\n\tprivate static readonly LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\n\tprivate static readonly LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\n\tprivate static readonly LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; // 256M characters, usually ~> 512MB memory usage\n\n\tpublic static DEFAULT_CREATION_OPTIONS: model.ITextModelCreationOptions = {\n\t\tisForSimpleWidget: false,\n\t\ttabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n\t\tindentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n\t\tinsertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n\t\tdetectIndentation: false,\n\t\tdefaultEOL: model.DefaultEndOfLine.LF,\n\t\ttrimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n\t\tlargeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n\t\tbracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n\t};\n\n\tpublic static resolveOptions(textBuffer: model.ITextBuffer, options: model.ITextModelCreationOptions): model.TextModelResolvedOptions {\n\t\tif (options.detectIndentation) {\n\t\t\tconst guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n\t\t\treturn new model.TextModelResolvedOptions({\n\t\t\t\ttabSize: guessedIndentation.tabSize,\n\t\t\t\tindentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n\t\t\t\tinsertSpaces: guessedIndentation.insertSpaces,\n\t\t\t\ttrimAutoWhitespace: options.trimAutoWhitespace,\n\t\t\t\tdefaultEOL: options.defaultEOL,\n\t\t\t\tbracketPairColorizationOptions: options.bracketPairColorizationOptions,\n\t\t\t});\n\t\t}\n\n\t\treturn new model.TextModelResolvedOptions(options);\n\t}\n\n\t//#region Events\n\tprivate readonly _onWillDispose: Emitter<void> = this._register(new Emitter<void>());\n\tpublic readonly onWillDispose: Event<void> = this._onWillDispose.event;\n\n\tprivate readonly _onDidChangeDecorations: DidChangeDecorationsEmitter = this._register(new DidChangeDecorationsEmitter((affectedInjectedTextLines, affectedLineHeights, affectedFontLines) => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines, affectedLineHeights, affectedFontLines)));\n\tpublic readonly onDidChangeDecorations: Event<IModelDecorationsChangedEvent> = this._onDidChangeDecorations.event;\n\n\tpublic get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n\tpublic get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n\tpublic get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n\n\tprivate readonly _onDidChangeOptions: Emitter<IModelOptionsChangedEvent> = this._register(new Emitter<IModelOptionsChangedEvent>());\n\tpublic get onDidChangeOptions(): Event<IModelOptionsChangedEvent> { return this._onDidChangeOptions.event; }\n\n\tprivate readonly _onDidChangeAttached: Emitter<void> = this._register(new Emitter<void>());\n\tpublic get onDidChangeAttached(): Event<void> { return this._onDidChangeAttached.event; }\n\n\tprivate readonly _onDidChangeInjectedText: Emitter<ModelInjectedTextChangedEvent> = this._register(new Emitter<ModelInjectedTextChangedEvent>());\n\n\tprivate readonly _onDidChangeLineHeight: Emitter<ModelLineHeightChangedEvent> = this._register(new Emitter<ModelLineHeightChangedEvent>());\n\tpublic get onDidChangeLineHeight(): Event<ModelLineHeightChangedEvent> { return this._onDidChangeLineHeight.event; }\n\n\tprivate readonly _onDidChangeFont: Emitter<ModelFontChangedEvent> = this._register(new Emitter<ModelFontChangedEvent>());\n\tpublic get onDidChangeFont(): Event<ModelFontChangedEvent> { return this._onDidChangeFont.event; }\n\n\tprivate readonly _eventEmitter: DidChangeContentEmitter = this._register(new DidChangeContentEmitter());\n\tpublic onDidChangeContent(listener: (e: IModelContentChangedEvent) => void): IDisposable {\n\t\treturn this._eventEmitter.slowEvent((e: InternalModelContentChangeEvent) => listener(e.contentChangedEvent));\n\t}\n\tpublic onDidChangeContentOrInjectedText(listener: (e: InternalModelContentChangeEvent | ModelInjectedTextChangedEvent) => void): IDisposable {\n\t\treturn combinedDisposable(\n\t\t\tthis._eventEmitter.fastEvent(e => listener(e)),\n\t\t\tthis._onDidChangeInjectedText.event(e => listener(e))\n\t\t);\n\t}\n\t//#endregion\n\n\tpublic readonly id: string;\n\tpublic readonly isForSimpleWidget: boolean;\n\tprivate readonly _associatedResource: URI;\n\tprivate _attachedEditorCount: number;\n\tprivate _buffer: model.ITextBuffer;\n\tprivate _bufferDisposable: IDisposable;\n\tprivate _options: model.TextModelResolvedOptions;\n\tprivate readonly _languageSelectionListener = this._register(new MutableDisposable<IDisposable>());\n\n\tprivate _isDisposed: boolean;\n\tprivate __isDisposing: boolean;\n\tpublic _isDisposing(): boolean { return this.__isDisposing; }\n\tprivate _versionId: number;\n\t/**\n\t * Unlike, versionId, this can go down (via undo) or go to previous values (via redo)\n\t */\n\tprivate _alternativeVersionId: number;\n\tprivate _initialUndoRedoSnapshot: ResourceEditStackSnapshot | null;\n\tprivate readonly _isTooLargeForSyncing: boolean;\n\tprivate readonly _isTooLargeForTokenization: boolean;\n\tprivate readonly _isTooLargeForHeapOperation: boolean;\n\n\t//#region Editing\n\tprivate readonly _commandManager: EditStack;\n\tprivate _isUndoing: boolean;\n\tprivate _isRedoing: boolean;\n\tprivate _trimAutoWhitespaceLines: number[] | null;\n\t//#endregion\n\n\t//#region Decorations\n\t/**\n\t * Used to workaround broken clients that might attempt using a decoration id generated by a different model.\n\t * It is not globally unique in order to limit it to one character.\n\t */\n\tprivate readonly _instanceId: string;\n\tprivate _deltaDecorationCallCnt: number = 0;\n\tprivate _lastDecorationId: number;\n\tprivate _decorations: { [decorationId: string]: IntervalNode };\n\tprivate _decorationsTree: DecorationsTrees;\n\tprivate readonly _decorationProvider: ColorizedBracketPairsDecorationProvider;\n\t//#endregion\n\n\tprivate readonly _tokenizationTextModelPart: TokenizationTextModelPart;\n\tpublic get tokenization(): ITokenizationTextModelPart { return this._tokenizationTextModelPart; }\n\n\tprivate readonly _bracketPairs: BracketPairsTextModelPart;\n\tpublic get bracketPairs(): IBracketPairsTextModelPart { return this._bracketPairs; }\n\n\tprivate readonly _guidesTextModelPart: GuidesTextModelPart;\n\tpublic get guides(): IGuidesTextModelPart { return this._guidesTextModelPart; }\n\n\tprivate readonly _attachedViews = new AttachedViews();\n\n\tconstructor(\n\t\tsource: string | model.ITextBufferFactory,\n\t\tlanguageIdOrSelection: string | ILanguageSelection,\n\t\tcreationOptions: model.ITextModelCreationOptions,\n\t\tassociatedResource: URI | null = null,\n\t\t@IUndoRedoService private readonly _undoRedoService: IUndoRedoService,\n\t\t@ILanguageService private readonly _languageService: ILanguageService,\n\t\t@ILanguageConfigurationService private readonly _languageConfigurationService: ILanguageConfigurationService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService\n\t) {\n\t\tsuper();\n\n\t\t// Generate a new unique model id\n\t\tMODEL_ID++;\n\t\tthis.id = '$model' + MODEL_ID;\n\t\tthis.isForSimpleWidget = creationOptions.isForSimpleWidget;\n\t\tif (typeof associatedResource === 'undefined' || associatedResource === null) {\n\t\t\tthis._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n\t\t} else {\n\t\t\tthis._associatedResource = associatedResource;\n\t\t}\n\t\tthis._attachedEditorCount = 0;\n\n\t\tconst { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n\t\tthis._buffer = textBuffer;\n\t\tthis._bufferDisposable = disposable;\n\n\t\tconst bufferLineCount = this._buffer.getLineCount();\n\t\tconst bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), model.EndOfLinePreference.TextDefined);\n\n\t\t// !!! Make a decision in the ctor and permanently respect this decision !!!\n\t\t// If a model is too large at construction time, it will never get tokenized,\n\t\t// under no circumstances.\n\t\tif (creationOptions.largeFileOptimizations) {\n\t\t\tthis._isTooLargeForTokenization = (\n\t\t\t\t(bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n\t\t\t\t|| (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD)\n\t\t\t);\n\n\t\t\tthis._isTooLargeForHeapOperation = bufferTextLength > TextModel.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n\t\t} else {\n\t\t\tthis._isTooLargeForTokenization = false;\n\t\t\tthis._isTooLargeForHeapOperation = false;\n\t\t}\n\n\t\tthis._options = TextModel.resolveOptions(this._buffer, creationOptions);\n\n\t\tconst languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n\t\tif (typeof languageIdOrSelection !== 'string') {\n\t\t\tthis._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n\t\t}\n\n\t\tthis._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n\t\tthis._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n\t\tthis._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n\t\tthis._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart,\n\t\t\tthis,\n\t\t\tthis._bracketPairs,\n\t\t\tlanguageId,\n\t\t\tthis._attachedViews\n\t\t);\n\n\t\tthis._isTooLargeForSyncing = (bufferTextLength > TextModel._MODEL_SYNC_LIMIT);\n\n\t\tthis._versionId = 1;\n\t\tthis._alternativeVersionId = 1;\n\t\tthis._initialUndoRedoSnapshot = null;\n\n\t\tthis._isDisposed = false;\n\t\tthis.__isDisposing = false;\n\n\t\tthis._instanceId = strings.singleLetterHash(MODEL_ID);\n\t\tthis._lastDecorationId = 0;\n\t\tthis._decorations = Object.create(null);\n\t\tthis._decorationsTree = new DecorationsTrees();\n\n\t\tthis._commandManager = new EditStack(this, this._undoRedoService);\n\t\tthis._isUndoing = false;\n\t\tthis._isRedoing = false;\n\t\tthis._trimAutoWhitespaceLines = null;\n\n\n\t\tthis._register(this._decorationProvider.onDidChange(() => {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.fire();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}));\n\n\t\tthis._languageService.requestRichLanguageFeatures(languageId);\n\n\t\tthis._register(this._languageConfigurationService.onDidChange(e => {\n\t\t\tthis._bracketPairs.handleLanguageConfigurationServiceChange(e);\n\t\t\tthis._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n\t\t}));\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis.__isDisposing = true;\n\t\tthis._onWillDispose.fire();\n\t\tthis._tokenizationTextModelPart.dispose();\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t\tthis._bufferDisposable.dispose();\n\t\tthis.__isDisposing = false;\n\t\t// Manually release reference to previous text buffer to avoid large leaks\n\t\t// in case someone leaks a TextModel reference\n\t\tconst emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n\t\temptyDisposedTextBuffer.dispose();\n\t\tthis._buffer = emptyDisposedTextBuffer;\n\t\tthis._bufferDisposable = Disposable.None;\n\t}\n\n\tprivate _assertNotDisposed(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError('Model is disposed!');\n\t\t}\n\t}\n\n\tpublic getTextBuffer(): model.ITextBuffer {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer;\n\t}\n\n\tprivate _emitContentChangedEvent(rawChange: ModelRawContentChangedEvent, change: IModelContentChangedEvent): void {\n\t\tif (this.__isDisposing) {\n\t\t\t// Do not confuse listeners by emitting any event after disposing\n\t\t\treturn;\n\t\t}\n\t\tthis._tokenizationTextModelPart.handleDidChangeContent(change);\n\t\tthis._bracketPairs.handleDidChangeContent(change);\n\t\tthis._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n\t}\n\n\tpublic setValue(value: string | model.ITextSnapshot, reason = EditSources.setValue()): void {\n\t\tthis._assertNotDisposed();\n\n\t\tif (value === null || value === undefined) {\n\t\t\tthrow illegalArgument();\n\t\t}\n\n\t\tconst { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n\t\tthis._setValueFromTextBuffer(textBuffer, disposable, reason);\n\t}\n\n\tprivate _createContentChanged2(range: Range, rangeOffset: number, rangeLength: number, rangeEndPosition: Position, text: string, isUndoing: boolean, isRedoing: boolean, isFlush: boolean, isEolChange: boolean, reason: TextModelEditSource): IModelContentChangedEvent {\n\t\treturn {\n\t\t\tchanges: [{\n\t\t\t\trange: range,\n\t\t\t\trangeOffset: rangeOffset,\n\t\t\t\trangeLength: rangeLength,\n\t\t\t\ttext: text,\n\t\t\t}],\n\t\t\teol: this._buffer.getEOL(),\n\t\t\tisEolChange: isEolChange,\n\t\t\tversionId: this.getVersionId(),\n\t\t\tisUndoing: isUndoing,\n\t\t\tisRedoing: isRedoing,\n\t\t\tisFlush: isFlush,\n\t\t\tdetailedReasons: [reason],\n\t\t\tdetailedReasonsChangeLengths: [1],\n\t\t};\n\t}\n\n\tprivate _setValueFromTextBuffer(textBuffer: model.ITextBuffer, textBufferDisposable: IDisposable, reason: TextModelEditSource): void {\n\t\tthis._assertNotDisposed();\n\t\tconst oldFullModelRange = this.getFullModelRange();\n\t\tconst oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n\t\tconst endLineNumber = this.getLineCount();\n\t\tconst endColumn = this.getLineMaxColumn(endLineNumber);\n\n\t\tthis._buffer = textBuffer;\n\t\tthis._bufferDisposable.dispose();\n\t\tthis._bufferDisposable = textBufferDisposable;\n\t\tthis._increaseVersionId();\n\n\t\t// Destroy all my decorations\n\t\tthis._decorations = Object.create(null);\n\t\tthis._decorationsTree = new DecorationsTrees();\n\n\t\t// Destroy my edit history and settings\n\t\tthis._commandManager.clear();\n\t\tthis._trimAutoWhitespaceLines = null;\n\n\t\tthis._emitContentChangedEvent(\n\t\t\tnew ModelRawContentChangedEvent(\n\t\t\t\t[\n\t\t\t\t\tnew ModelRawFlush()\n\t\t\t\t],\n\t\t\t\tthis._versionId,\n\t\t\t\tfalse,\n\t\t\t\tfalse\n\t\t\t),\n\t\t\tthis._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, new Position(endLineNumber, endColumn), this.getValue(), false, false, true, false, reason)\n\t\t);\n\t}\n\n\tpublic setEOL(eol: model.EndOfLineSequence): void {\n\t\tthis._assertNotDisposed();\n\t\tconst newEOL = (eol === model.EndOfLineSequence.CRLF ? '\\r\\n' : '\\n');\n\t\tif (this._buffer.getEOL() === newEOL) {\n\t\t\t// Nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldFullModelRange = this.getFullModelRange();\n\t\tconst oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n\t\tconst endLineNumber = this.getLineCount();\n\t\tconst endColumn = this.getLineMaxColumn(endLineNumber);\n\n\t\tthis._onBeforeEOLChange();\n\t\tthis._buffer.setEOL(newEOL);\n\t\tthis._increaseVersionId();\n\t\tthis._onAfterEOLChange();\n\n\t\tthis._emitContentChangedEvent(\n\t\t\tnew ModelRawContentChangedEvent(\n\t\t\t\t[\n\t\t\t\t\tnew ModelRawEOLChanged()\n\t\t\t\t],\n\t\t\t\tthis._versionId,\n\t\t\t\tfalse,\n\t\t\t\tfalse\n\t\t\t),\n\t\t\tthis._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, new Position(endLineNumber, endColumn), this.getValue(), false, false, false, true, EditSources.eolChange())\n\t\t);\n\t}\n\n\tprivate _onBeforeEOLChange(): void {\n\t\t// Ensure all decorations get their `range` set.\n\t\tthis._decorationsTree.ensureAllNodesHaveRanges(this);\n\t}\n\n\tprivate _onAfterEOLChange(): void {\n\t\t// Transform back `range` to offsets\n\t\tconst versionId = this.getVersionId();\n\t\tconst allDecorations = this._decorationsTree.collectNodesPostOrder();\n\t\tfor (let i = 0, len = allDecorations.length; i < len; i++) {\n\t\t\tconst node = allDecorations[i];\n\t\t\tconst range = node.range!; // the range is defined due to `_onBeforeEOLChange`\n\n\t\t\tconst delta = node.cachedAbsoluteStart - node.start;\n\n\t\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t\tnode.cachedAbsoluteStart = startOffset;\n\t\t\tnode.cachedAbsoluteEnd = endOffset;\n\t\t\tnode.cachedVersionId = versionId;\n\n\t\t\tnode.start = startOffset - delta;\n\t\t\tnode.end = endOffset - delta;\n\n\t\t\trecomputeMaxEnd(node);\n\t\t}\n\t}\n\n\tpublic onBeforeAttached(): model.IAttachedView {\n\t\tthis._attachedEditorCount++;\n\t\tif (this._attachedEditorCount === 1) {\n\t\t\tthis._tokenizationTextModelPart.handleDidChangeAttached();\n\t\t\tthis._onDidChangeAttached.fire(undefined);\n\t\t}\n\t\treturn this._attachedViews.attachView();\n\t}\n\n\tpublic onBeforeDetached(view: model.IAttachedView): void {\n\t\tthis._attachedEditorCount--;\n\t\tif (this._attachedEditorCount === 0) {\n\t\t\tthis._tokenizationTextModelPart.handleDidChangeAttached();\n\t\t\tthis._onDidChangeAttached.fire(undefined);\n\t\t}\n\t\tthis._attachedViews.detachView(view);\n\t}\n\n\tpublic isAttachedToEditor(): boolean {\n\t\treturn this._attachedEditorCount > 0;\n\t}\n\n\tpublic getAttachedEditorCount(): number {\n\t\treturn this._attachedEditorCount;\n\t}\n\n\tpublic isTooLargeForSyncing(): boolean {\n\t\treturn this._isTooLargeForSyncing;\n\t}\n\n\tpublic isTooLargeForTokenization(): boolean {\n\t\treturn this._isTooLargeForTokenization;\n\t}\n\n\tpublic isTooLargeForHeapOperation(): boolean {\n\t\treturn this._isTooLargeForHeapOperation;\n\t}\n\n\tpublic isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\tpublic isDominatedByLongLines(): boolean {\n\t\tthis._assertNotDisposed();\n\t\tif (this.isTooLargeForTokenization()) {\n\t\t\t// Cannot word wrap huge files anyways, so it doesn't really matter\n\t\t\treturn false;\n\t\t}\n\t\tlet smallLineCharCount = 0;\n\t\tlet longLineCharCount = 0;\n\n\t\tconst lineCount = this._buffer.getLineCount();\n\t\tfor (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n\t\t\tconst lineLength = this._buffer.getLineLength(lineNumber);\n\t\t\tif (lineLength >= LONG_LINE_BOUNDARY) {\n\t\t\t\tlongLineCharCount += lineLength;\n\t\t\t} else {\n\t\t\t\tsmallLineCharCount += lineLength;\n\t\t\t}\n\t\t}\n\n\t\treturn (longLineCharCount > smallLineCharCount);\n\t}\n\n\tpublic get uri(): URI {\n\t\treturn this._associatedResource;\n\t}\n\n\t//#region Options\n\n\tpublic getOptions(): model.TextModelResolvedOptions {\n\t\tthis._assertNotDisposed();\n\t\treturn this._options;\n\t}\n\n\tpublic getFormattingOptions(): FormattingOptions {\n\t\treturn {\n\t\t\ttabSize: this._options.indentSize,\n\t\t\tinsertSpaces: this._options.insertSpaces\n\t\t};\n\t}\n\n\tpublic updateOptions(_newOpts: model.ITextModelUpdateOptions): void {\n\t\tthis._assertNotDisposed();\n\t\tconst tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n\t\tconst indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n\t\tconst insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n\t\tconst trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n\t\tconst bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n\n\t\tconst newOpts = new model.TextModelResolvedOptions({\n\t\t\ttabSize: tabSize,\n\t\t\tindentSize: indentSize,\n\t\t\tinsertSpaces: insertSpaces,\n\t\t\tdefaultEOL: this._options.defaultEOL,\n\t\t\ttrimAutoWhitespace: trimAutoWhitespace,\n\t\t\tbracketPairColorizationOptions,\n\t\t});\n\n\t\tif (this._options.equals(newOpts)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst e = this._options.createChangeEvent(newOpts);\n\t\tthis._options = newOpts;\n\n\t\tthis._bracketPairs.handleDidChangeOptions(e);\n\t\tthis._decorationProvider.handleDidChangeOptions(e);\n\t\tthis._onDidChangeOptions.fire(e);\n\t}\n\n\tpublic detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void {\n\t\tthis._assertNotDisposed();\n\t\tconst guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n\t\tthis.updateOptions({\n\t\t\tinsertSpaces: guessedIndentation.insertSpaces,\n\t\t\ttabSize: guessedIndentation.tabSize,\n\t\t\tindentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n\t\t});\n\t}\n\n\tpublic normalizeIndentation(str: string): string {\n\t\tthis._assertNotDisposed();\n\t\treturn normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n\t}\n\n\t//#endregion\n\n\t//#region Reading\n\n\tpublic getVersionId(): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._versionId;\n\t}\n\n\tpublic mightContainRTL(): boolean {\n\t\treturn this._buffer.mightContainRTL();\n\t}\n\n\tpublic mightContainUnusualLineTerminators(): boolean {\n\t\treturn this._buffer.mightContainUnusualLineTerminators();\n\t}\n\n\tpublic removeUnusualLineTerminators(selections: Selection[] | null = null): void {\n\t\tconst matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, Constants.MAX_SAFE_SMALL_INTEGER);\n\t\tthis._buffer.resetMightContainUnusualLineTerminators();\n\t\tthis.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n\t}\n\n\tpublic mightContainNonBasicASCII(): boolean {\n\t\treturn this._buffer.mightContainNonBasicASCII();\n\t}\n\n\tpublic getAlternativeVersionId(): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._alternativeVersionId;\n\t}\n\n\tpublic getInitialUndoRedoSnapshot(): ResourceEditStackSnapshot | null {\n\t\tthis._assertNotDisposed();\n\t\treturn this._initialUndoRedoSnapshot;\n\t}\n\n\tpublic getOffsetAt(rawPosition: IPosition): number {\n\t\tthis._assertNotDisposed();\n\t\tconst position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, StringOffsetValidationType.Relaxed);\n\t\treturn this._buffer.getOffsetAt(position.lineNumber, position.column);\n\t}\n\n\tpublic getPositionAt(rawOffset: number): Position {\n\t\tthis._assertNotDisposed();\n\t\tconst offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n\t\treturn this._buffer.getPositionAt(offset);\n\t}\n\n\tprivate _increaseVersionId(): void {\n\t\tthis._versionId = this._versionId + 1;\n\t\tthis._alternativeVersionId = this._versionId;\n\t}\n\n\tpublic _overwriteVersionId(versionId: number): void {\n\t\tthis._versionId = versionId;\n\t}\n\n\tpublic _overwriteAlternativeVersionId(newAlternativeVersionId: number): void {\n\t\tthis._alternativeVersionId = newAlternativeVersionId;\n\t}\n\n\tpublic _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot: ResourceEditStackSnapshot | null): void {\n\t\tthis._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n\t}\n\n\tpublic getValue(eol?: model.EndOfLinePreference, preserveBOM: boolean = false): string {\n\t\tthis._assertNotDisposed();\n\t\tif (this.isTooLargeForHeapOperation()) {\n\t\t\tthrow new BugIndicatingError('Operation would exceed heap memory limits');\n\t\t}\n\n\t\tconst fullModelRange = this.getFullModelRange();\n\t\tconst fullModelValue = this.getValueInRange(fullModelRange, eol);\n\n\t\tif (preserveBOM) {\n\t\t\treturn this._buffer.getBOM() + fullModelValue;\n\t\t}\n\n\t\treturn fullModelValue;\n\t}\n\n\tpublic createSnapshot(preserveBOM: boolean = false): model.ITextSnapshot {\n\t\treturn new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n\t}\n\n\tpublic getValueLength(eol?: model.EndOfLinePreference, preserveBOM: boolean = false): number {\n\t\tthis._assertNotDisposed();\n\t\tconst fullModelRange = this.getFullModelRange();\n\t\tconst fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n\n\t\tif (preserveBOM) {\n\t\t\treturn this._buffer.getBOM().length + fullModelValue;\n\t\t}\n\n\t\treturn fullModelValue;\n\t}\n\n\tpublic getValueInRange(rawRange: IRange, eol: model.EndOfLinePreference = model.EndOfLinePreference.TextDefined): string {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n\t}\n\n\tpublic getValueLengthInRange(rawRange: IRange, eol: model.EndOfLinePreference = model.EndOfLinePreference.TextDefined): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n\t}\n\n\tpublic getCharacterCountInRange(rawRange: IRange, eol: model.EndOfLinePreference = model.EndOfLinePreference.TextDefined): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n\t}\n\n\tpublic getLineCount(): number {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getLineCount();\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\n\t\treturn this._buffer.getLineContent(lineNumber);\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\n\t\treturn this._buffer.getLineLength(lineNumber);\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\tthis._assertNotDisposed();\n\t\tif (this.isTooLargeForHeapOperation()) {\n\t\t\tthrow new BugIndicatingError('Operation would exceed heap memory limits');\n\t\t}\n\n\t\treturn this._buffer.getLinesContent();\n\t}\n\n\tpublic getEOL(): string {\n\t\tthis._assertNotDisposed();\n\t\treturn this._buffer.getEOL();\n\t}\n\n\tpublic getEndOfLineSequence(): model.EndOfLineSequence {\n\t\tthis._assertNotDisposed();\n\t\treturn (\n\t\t\tthis._buffer.getEOL() === '\\n'\n\t\t\t\t? model.EndOfLineSequence.LF\n\t\t\t\t: model.EndOfLineSequence.CRLF\n\t\t);\n\t}\n\n\tpublic getLineMinColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\treturn 1;\n\t}\n\n\tpublic getLineMaxColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._buffer.getLineLength(lineNumber) + 1;\n\t}\n\n\tpublic getLineFirstNonWhitespaceColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n\t}\n\n\tpublic getLineLastNonWhitespaceColumn(lineNumber: number): number {\n\t\tthis._assertNotDisposed();\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\tthrow new BugIndicatingError('Illegal value for lineNumber');\n\t\t}\n\t\treturn this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n\t}\n\n\t/**\n\t * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n\t * Will try to not allocate if possible.\n\t */\n\tpublic _validateRangeRelaxedNoAllocations(range: IRange): Range {\n\t\tconst linesCount = this._buffer.getLineCount();\n\n\t\tconst initialStartLineNumber = range.startLineNumber;\n\t\tconst initialStartColumn = range.startColumn;\n\t\tlet startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n\t\tlet startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n\n\t\tif (startLineNumber < 1) {\n\t\t\tstartLineNumber = 1;\n\t\t\tstartColumn = 1;\n\t\t} else if (startLineNumber > linesCount) {\n\t\t\tstartLineNumber = linesCount;\n\t\t\tstartColumn = this.getLineMaxColumn(startLineNumber);\n\t\t} else {\n\t\t\tif (startColumn <= 1) {\n\t\t\t\tstartColumn = 1;\n\t\t\t} else {\n\t\t\t\tconst maxColumn = this.getLineMaxColumn(startLineNumber);\n\t\t\t\tif (startColumn >= maxColumn) {\n\t\t\t\t\tstartColumn = maxColumn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst initialEndLineNumber = range.endLineNumber;\n\t\tconst initialEndColumn = range.endColumn;\n\t\tlet endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n\t\tlet endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n\n\t\tif (endLineNumber < 1) {\n\t\t\tendLineNumber = 1;\n\t\t\tendColumn = 1;\n\t\t} else if (endLineNumber > linesCount) {\n\t\t\tendLineNumber = linesCount;\n\t\t\tendColumn = this.getLineMaxColumn(endLineNumber);\n\t\t} else {\n\t\t\tif (endColumn <= 1) {\n\t\t\t\tendColumn = 1;\n\t\t\t} else {\n\t\t\t\tconst maxColumn = this.getLineMaxColumn(endLineNumber);\n\t\t\t\tif (endColumn >= maxColumn) {\n\t\t\t\t\tendColumn = maxColumn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tinitialStartLineNumber === startLineNumber\n\t\t\t&& initialStartColumn === startColumn\n\t\t\t&& initialEndLineNumber === endLineNumber\n\t\t\t&& initialEndColumn === endColumn\n\t\t\t&& range instanceof Range\n\t\t\t&& !(range instanceof Selection)\n\t\t) {\n\t\t\treturn range;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\tprivate _isValidPosition(lineNumber: number, column: number, validationType: StringOffsetValidationType): boolean {\n\t\tif (typeof lineNumber !== 'number' || typeof column !== 'number') {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (isNaN(lineNumber) || isNaN(column)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (lineNumber < 1 || column < 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst lineCount = this._buffer.getLineCount();\n\t\tif (lineNumber > lineCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (column === 1) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst maxColumn = this.getLineMaxColumn(lineNumber);\n\t\tif (column > maxColumn) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (validationType === StringOffsetValidationType.SurrogatePairs) {\n\t\t\t// !!At this point, column > 1\n\t\t\tconst charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate _validatePosition(_lineNumber: number, _column: number, validationType: StringOffsetValidationType): Position {\n\t\tconst lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n\t\tconst column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n\t\tconst lineCount = this._buffer.getLineCount();\n\n\t\tif (lineNumber < 1) {\n\t\t\treturn new Position(1, 1);\n\t\t}\n\n\t\tif (lineNumber > lineCount) {\n\t\t\treturn new Position(lineCount, this.getLineMaxColumn(lineCount));\n\t\t}\n\n\t\tif (column <= 1) {\n\t\t\treturn new Position(lineNumber, 1);\n\t\t}\n\n\t\tconst maxColumn = this.getLineMaxColumn(lineNumber);\n\t\tif (column >= maxColumn) {\n\t\t\treturn new Position(lineNumber, maxColumn);\n\t\t}\n\n\t\tif (validationType === StringOffsetValidationType.SurrogatePairs) {\n\t\t\t// If the position would end up in the middle of a high-low surrogate pair,\n\t\t\t// we move it to before the pair\n\t\t\t// !!At this point, column > 1\n\t\t\tconst charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\t\t\tif (strings.isHighSurrogate(charCodeBefore)) {\n\t\t\t\treturn new Position(lineNumber, column - 1);\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(lineNumber, column);\n\t}\n\n\tpublic validatePosition(position: IPosition): Position {\n\t\tconst validationType = StringOffsetValidationType.SurrogatePairs;\n\t\tthis._assertNotDisposed();\n\n\t\t// Avoid object allocation and cover most likely case\n\t\tif (position instanceof Position) {\n\t\t\tif (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n\t\t\t\treturn position;\n\t\t\t}\n\t\t}\n\n\t\treturn this._validatePosition(position.lineNumber, position.column, validationType);\n\t}\n\n\tpublic isValidRange(range: Range): boolean {\n\t\treturn this._isValidRange(range, StringOffsetValidationType.SurrogatePairs);\n\t}\n\n\tprivate _isValidRange(range: Range, validationType: StringOffsetValidationType): boolean {\n\t\tconst startLineNumber = range.startLineNumber;\n\t\tconst startColumn = range.startColumn;\n\t\tconst endLineNumber = range.endLineNumber;\n\t\tconst endColumn = range.endColumn;\n\n\t\tif (!this._isValidPosition(startLineNumber, startColumn, StringOffsetValidationType.Relaxed)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!this._isValidPosition(endLineNumber, endColumn, StringOffsetValidationType.Relaxed)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (validationType === StringOffsetValidationType.SurrogatePairs) {\n\t\t\tconst charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n\t\t\tconst charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n\n\t\t\tconst startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n\t\t\tconst endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n\t\t\tif (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic validateRange(_range: IRange): Range {\n\t\tconst validationType = StringOffsetValidationType.SurrogatePairs;\n\t\tthis._assertNotDisposed();\n\n\t\t// Avoid object allocation and cover most likely case\n\t\tif ((_range instanceof Range) && !(_range instanceof Selection)) {\n\t\t\tif (this._isValidRange(_range, validationType)) {\n\t\t\t\treturn _range;\n\t\t\t}\n\t\t}\n\n\t\tconst start = this._validatePosition(_range.startLineNumber, _range.startColumn, StringOffsetValidationType.Relaxed);\n\t\tconst end = this._validatePosition(_range.endLineNumber, _range.endColumn, StringOffsetValidationType.Relaxed);\n\n\t\tconst startLineNumber = start.lineNumber;\n\t\tconst startColumn = start.column;\n\t\tconst endLineNumber = end.lineNumber;\n\t\tconst endColumn = end.column;\n\n\t\tif (validationType === StringOffsetValidationType.SurrogatePairs) {\n\t\t\tconst charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n\t\t\tconst charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n\n\t\t\tconst startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n\t\t\tconst endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n\t\t\tif (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n\t\t\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t\t\t}\n\n\t\t\tif (startLineNumber === endLineNumber && startColumn === endColumn) {\n\t\t\t\t// do not expand a collapsed range, simply move it to a valid location\n\t\t\t\treturn new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n\t\t\t}\n\n\t\t\tif (startInsideSurrogatePair && endInsideSurrogatePair) {\n\t\t\t\t// expand range at both ends\n\t\t\t\treturn new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n\t\t\t}\n\n\t\t\tif (startInsideSurrogatePair) {\n\t\t\t\t// only expand range at the start\n\t\t\t\treturn new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n\t\t\t}\n\n\t\t\t// only expand range at the end\n\t\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\tpublic modifyPosition(rawPosition: IPosition, offset: number): Position {\n\t\tthis._assertNotDisposed();\n\t\tconst candidate = this.getOffsetAt(rawPosition) + offset;\n\t\treturn this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n\t}\n\n\tpublic getFullModelRange(): Range {\n\t\tthis._assertNotDisposed();\n\t\tconst lineCount = this.getLineCount();\n\t\treturn new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n\t}\n\n\tprivate findMatchesLineByLine(searchRange: Range, searchData: model.SearchData, captureMatches: boolean, limitResultCount: number): model.FindMatch[] {\n\t\treturn this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t}\n\n\tpublic findMatches(searchString: string, rawSearchScope: any, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount: number = LIMIT_FIND_COUNT): model.FindMatch[] {\n\t\tthis._assertNotDisposed();\n\n\t\tlet searchRanges: Range[] | null = null;\n\n\t\tif (rawSearchScope !== null) {\n\t\t\tif (!Array.isArray(rawSearchScope)) {\n\t\t\t\trawSearchScope = [rawSearchScope];\n\t\t\t}\n\n\t\t\tif (rawSearchScope.every((searchScope: Range) => Range.isIRange(searchScope))) {\n\t\t\t\tsearchRanges = rawSearchScope.map((searchScope: Range) => this.validateRange(searchScope));\n\t\t\t}\n\t\t}\n\n\t\tif (searchRanges === null) {\n\t\t\tsearchRanges = [this.getFullModelRange()];\n\t\t}\n\n\t\tsearchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n\n\t\tconst uniqueSearchRanges: Range[] = [];\n\t\tuniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n\t\t\tif (Range.areIntersecting(prev, curr)) {\n\t\t\t\treturn prev.plusRange(curr);\n\t\t\t}\n\n\t\t\tuniqueSearchRanges.push(prev);\n\t\t\treturn curr;\n\t\t}));\n\n\t\tlet matchMapper: (value: Range, index: number, array: Range[]) => model.FindMatch[];\n\t\tif (!isRegex && searchString.indexOf('\\n') < 0) {\n\t\t\t// not regex, not multi line\n\t\t\tconst searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n\t\t\tconst searchData = searchParams.parseSearchRequest();\n\n\t\t\tif (!searchData) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tmatchMapper = (searchRange: Range) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n\t\t} else {\n\t\t\tmatchMapper = (searchRange: Range) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n\t\t}\n\n\t\treturn uniqueSearchRanges.map(matchMapper).reduce((arr, matches: model.FindMatch[]) => arr.concat(matches), []);\n\t}\n\n\tpublic findNextMatch(searchString: string, rawSearchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string, captureMatches: boolean): model.FindMatch | null {\n\t\tthis._assertNotDisposed();\n\t\tconst searchStart = this.validatePosition(rawSearchStart);\n\n\t\tif (!isRegex && searchString.indexOf('\\n') < 0) {\n\t\t\tconst searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n\t\t\tconst searchData = searchParams.parseSearchRequest();\n\t\t\tif (!searchData) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst lineCount = this.getLineCount();\n\t\t\tlet searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n\t\t\tlet ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\t\t\tTextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\t\t\tif (ret.length > 0) {\n\t\t\t\treturn ret[0];\n\t\t\t}\n\n\t\t\tsearchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n\t\t\tret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\n\t\t\tif (ret.length > 0) {\n\t\t\t\treturn ret[0];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\t}\n\n\tpublic findPreviousMatch(searchString: string, rawSearchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string, captureMatches: boolean): model.FindMatch | null {\n\t\tthis._assertNotDisposed();\n\t\tconst searchStart = this.validatePosition(rawSearchStart);\n\t\treturn TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\t}\n\n\t//#endregion\n\n\t//#region Editing\n\n\tpublic pushStackElement(): void {\n\t\tthis._commandManager.pushStackElement();\n\t}\n\n\tpublic popStackElement(): void {\n\t\tthis._commandManager.popStackElement();\n\t}\n\n\tpublic pushEOL(eol: model.EndOfLineSequence): void {\n\t\tconst currentEOL = (this.getEOL() === '\\n' ? model.EndOfLineSequence.LF : model.EndOfLineSequence.CRLF);\n\t\tif (currentEOL === eol) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\tif (this._initialUndoRedoSnapshot === null) {\n\t\t\t\tthis._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n\t\t\t}\n\t\t\tthis._commandManager.pushEOL(eol);\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _validateEditOperation(rawOperation: model.IIdentifiedSingleEditOperation): model.ValidAnnotatedEditOperation {\n\t\tif (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n\t\t\treturn rawOperation;\n\t\t}\n\t\treturn new model.ValidAnnotatedEditOperation(\n\t\t\trawOperation.identifier || null,\n\t\t\tthis.validateRange(rawOperation.range),\n\t\t\trawOperation.text,\n\t\t\trawOperation.forceMoveMarkers || false,\n\t\t\trawOperation.isAutoWhitespaceEdit || false,\n\t\t\trawOperation._isTracked || false\n\t\t);\n\t}\n\n\tprivate _validateEditOperations(rawOperations: readonly model.IIdentifiedSingleEditOperation[]): model.ValidAnnotatedEditOperation[] {\n\t\tconst result: model.ValidAnnotatedEditOperation[] = [];\n\t\tfor (let i = 0, len = rawOperations.length; i < len; i++) {\n\t\t\tresult[i] = this._validateEditOperation(rawOperations[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic pushEditOperations(beforeCursorState: Selection[] | null, editOperations: model.IIdentifiedSingleEditOperation[], cursorStateComputer: model.ICursorStateComputer | null, group?: UndoRedoGroup, reason?: TextModelEditSource): Selection[] | null {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\treturn this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group, reason);\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _pushEditOperations(beforeCursorState: Selection[] | null, editOperations: model.ValidAnnotatedEditOperation[], cursorStateComputer: model.ICursorStateComputer | null, group?: UndoRedoGroup, reason?: TextModelEditSource): Selection[] | null {\n\t\tif (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n\t\t\t// Go through each saved line number and insert a trim whitespace edit\n\t\t\t// if it is safe to do so (no conflicts with other edits).\n\n\t\t\tconst incomingEdits = editOperations.map((op) => {\n\t\t\t\treturn {\n\t\t\t\t\trange: this.validateRange(op.range),\n\t\t\t\t\ttext: op.text\n\t\t\t\t};\n\t\t\t});\n\n\t\t\t// Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n\t\t\t// We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n\t\t\tlet editsAreNearCursors = true;\n\t\t\tif (beforeCursorState) {\n\t\t\t\tfor (let i = 0, len = beforeCursorState.length; i < len; i++) {\n\t\t\t\t\tconst sel = beforeCursorState[i];\n\t\t\t\t\tlet foundEditNearSel = false;\n\t\t\t\t\tfor (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n\t\t\t\t\t\tconst editRange = incomingEdits[j].range;\n\t\t\t\t\t\tconst selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n\t\t\t\t\t\tconst selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n\t\t\t\t\t\tif (!selIsAbove && !selIsBelow) {\n\t\t\t\t\t\t\tfoundEditNearSel = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!foundEditNearSel) {\n\t\t\t\t\t\teditsAreNearCursors = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (editsAreNearCursors) {\n\t\t\t\tfor (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n\t\t\t\t\tconst trimLineNumber = this._trimAutoWhitespaceLines[i];\n\t\t\t\t\tconst maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n\n\t\t\t\t\tlet allowTrimLine = true;\n\t\t\t\t\tfor (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n\t\t\t\t\t\tconst editRange = incomingEdits[j].range;\n\t\t\t\t\t\tconst editText = incomingEdits[j].text;\n\n\t\t\t\t\t\tif (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n\t\t\t\t\t\t\t// `trimLine` is completely outside this edit\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// At this point:\n\t\t\t\t\t\t//   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttrimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n\t\t\t\t\t\t\t&& editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// This edit inserts a new line (and maybe other text) after `trimLine`\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttrimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n\t\t\t\t\t\t\t&& editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// This edit inserts a new line (and maybe other text) before `trimLine`\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Looks like we can't trim this line as it would interfere with an incoming edit\n\t\t\t\t\t\tallowTrimLine = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (allowTrimLine) {\n\t\t\t\t\t\tconst trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n\t\t\t\t\t\teditOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._trimAutoWhitespaceLines = null;\n\t\t}\n\t\tif (this._initialUndoRedoSnapshot === null) {\n\t\t\tthis._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n\t\t}\n\t\treturn this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group, reason);\n\t}\n\n\t_applyUndo(changes: TextChange[], eol: model.EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void {\n\t\tconst edits = changes.map<ISingleEditOperation>((change) => {\n\t\t\tconst rangeStart = this.getPositionAt(change.newPosition);\n\t\t\tconst rangeEnd = this.getPositionAt(change.newEnd);\n\t\t\treturn {\n\t\t\t\trange: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n\t\t\t\ttext: change.oldText\n\t\t\t};\n\t\t});\n\t\tthis._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n\t}\n\n\t_applyRedo(changes: TextChange[], eol: model.EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void {\n\t\tconst edits = changes.map<ISingleEditOperation>((change) => {\n\t\t\tconst rangeStart = this.getPositionAt(change.oldPosition);\n\t\t\tconst rangeEnd = this.getPositionAt(change.oldEnd);\n\t\t\treturn {\n\t\t\t\trange: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n\t\t\t\ttext: change.newText\n\t\t\t};\n\t\t});\n\t\tthis._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n\t}\n\n\tprivate _applyUndoRedoEdits(edits: ISingleEditOperation[], eol: model.EndOfLineSequence, isUndoing: boolean, isRedoing: boolean, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\tthis._isUndoing = isUndoing;\n\t\t\tthis._isRedoing = isRedoing;\n\t\t\tthis.applyEdits(edits, false);\n\t\t\tthis.setEOL(eol);\n\t\t\tthis._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n\t\t} finally {\n\t\t\tthis._isUndoing = false;\n\t\t\tthis._isRedoing = false;\n\t\t\tthis._eventEmitter.endDeferredEmit(resultingSelection);\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[]): void;\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits: false): void;\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits: true): model.IValidEditOperation[];\n\t/** @internal */\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits: false, reason: TextModelEditSource): void;\n\t/** @internal */\n\tpublic applyEdits(operations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits: true, reason: TextModelEditSource): model.IValidEditOperation[];\n\tpublic applyEdits(rawOperations: readonly model.IIdentifiedSingleEditOperation[], computeUndoEdits?: boolean, reason?: TextModelEditSource): void | model.IValidEditOperation[] {\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\tthis._eventEmitter.beginDeferredEmit();\n\t\t\tconst operations = this._validateEditOperations(rawOperations);\n\n\t\t\treturn this._doApplyEdits(operations, computeUndoEdits ?? false, reason ?? EditSources.applyEdits());\n\t\t} finally {\n\t\t\tthis._eventEmitter.endDeferredEmit();\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _doApplyEdits(rawOperations: model.ValidAnnotatedEditOperation[], computeUndoEdits: boolean, reason: TextModelEditSource): void | model.IValidEditOperation[] {\n\n\t\tconst oldLineCount = this._buffer.getLineCount();\n\t\tconst result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n\t\tconst newLineCount = this._buffer.getLineCount();\n\n\t\tconst contentChanges = result.changes;\n\t\tthis._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n\n\t\tif (contentChanges.length !== 0) {\n\t\t\t// We do a first pass to update decorations\n\t\t\t// because we want to read decorations in the second pass\n\t\t\t// where we will emit content change events\n\t\t\t// and we want to read the final decorations\n\t\t\tfor (let i = 0, len = contentChanges.length; i < len; i++) {\n\t\t\t\tconst change = contentChanges[i];\n\t\t\t\tthis._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n\t\t\t}\n\n\t\t\tconst rawContentChanges: ModelRawChange[] = [];\n\n\t\t\tthis._increaseVersionId();\n\n\t\t\tlet lineCount = oldLineCount;\n\t\t\tfor (let i = 0, len = contentChanges.length; i < len; i++) {\n\t\t\t\tconst change = contentChanges[i];\n\t\t\t\tconst [eolCount] = countEOL(change.text);\n\t\t\t\tthis._onDidChangeDecorations.fire();\n\n\t\t\t\tconst startLineNumber = change.range.startLineNumber;\n\t\t\t\tconst endLineNumber = change.range.endLineNumber;\n\n\t\t\t\tconst deletingLinesCnt = endLineNumber - startLineNumber;\n\t\t\t\tconst insertingLinesCnt = eolCount;\n\t\t\t\tconst editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n\n\t\t\t\tconst changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n\n\t\t\t\tconst currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n\t\t\t\tconst firstEditLineNumber = currentEditStartLineNumber;\n\t\t\t\tconst lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n\n\t\t\t\tconst decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(\n\t\t\t\t\tthis,\n\t\t\t\t\tthis.getOffsetAt(new Position(firstEditLineNumber, 1)),\n\t\t\t\t\tthis.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))),\n\t\t\t\t\t0\n\t\t\t\t);\n\n\n\t\t\t\tconst injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n\t\t\t\tconst injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n\n\t\t\t\tfor (let j = editingLinesCnt; j >= 0; j--) {\n\t\t\t\t\tconst editLineNumber = startLineNumber + j;\n\t\t\t\t\tconst currentEditLineNumber = currentEditStartLineNumber + j;\n\n\t\t\t\t\tinjectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n\t\t\t\t\tconst decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n\n\t\t\t\t\trawContentChanges.push(\n\t\t\t\t\t\tnew ModelRawLineChanged(\n\t\t\t\t\t\t\teditLineNumber,\n\t\t\t\t\t\t\tthis.getLineContent(currentEditLineNumber),\n\t\t\t\t\t\t\tdecorationsInCurrentLine\n\t\t\t\t\t\t));\n\t\t\t\t}\n\n\t\t\t\tif (editingLinesCnt < deletingLinesCnt) {\n\t\t\t\t\t// Must delete some lines\n\t\t\t\t\tconst spliceStartLineNumber = startLineNumber + editingLinesCnt;\n\t\t\t\t\trawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n\t\t\t\t}\n\n\t\t\t\tif (editingLinesCnt < insertingLinesCnt) {\n\t\t\t\t\tconst injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n\t\t\t\t\t// Must insert some lines\n\t\t\t\t\tconst spliceLineNumber = startLineNumber + editingLinesCnt;\n\t\t\t\t\tconst cnt = insertingLinesCnt - editingLinesCnt;\n\t\t\t\t\tconst fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n\t\t\t\t\tconst injectedTexts: (LineInjectedText[] | null)[] = [];\n\t\t\t\t\tconst newLines: string[] = [];\n\t\t\t\t\tfor (let i = 0; i < cnt; i++) {\n\t\t\t\t\t\tconst lineNumber = fromLineNumber + i;\n\t\t\t\t\t\tnewLines[i] = this.getLineContent(lineNumber);\n\n\t\t\t\t\t\tinjectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n\t\t\t\t\t\tinjectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n\t\t\t\t\t}\n\n\t\t\t\t\trawContentChanges.push(\n\t\t\t\t\t\tnew ModelRawLinesInserted(\n\t\t\t\t\t\t\tspliceLineNumber + 1,\n\t\t\t\t\t\t\tstartLineNumber + insertingLinesCnt,\n\t\t\t\t\t\t\tnewLines,\n\t\t\t\t\t\t\tinjectedTexts\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlineCount += changeLineCountDelta;\n\t\t\t}\n\n\t\t\tthis._emitContentChangedEvent(\n\t\t\t\tnew ModelRawContentChangedEvent(\n\t\t\t\t\trawContentChanges,\n\t\t\t\t\tthis.getVersionId(),\n\t\t\t\t\tthis._isUndoing,\n\t\t\t\t\tthis._isRedoing\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tchanges: contentChanges,\n\t\t\t\t\teol: this._buffer.getEOL(),\n\t\t\t\t\tisEolChange: false,\n\t\t\t\t\tversionId: this.getVersionId(),\n\t\t\t\t\tisUndoing: this._isUndoing,\n\t\t\t\t\tisRedoing: this._isRedoing,\n\t\t\t\t\tisFlush: false,\n\t\t\t\t\tdetailedReasons: [reason],\n\t\t\t\t\tdetailedReasonsChangeLengths: [contentChanges.length],\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn (result.reverseEdits === null ? undefined : result.reverseEdits);\n\t}\n\n\tpublic undo(): void | Promise<void> {\n\t\treturn this._undoRedoService.undo(this.uri);\n\t}\n\n\tpublic canUndo(): boolean {\n\t\treturn this._undoRedoService.canUndo(this.uri);\n\t}\n\n\tpublic redo(): void | Promise<void> {\n\t\treturn this._undoRedoService.redo(this.uri);\n\t}\n\n\tpublic canRedo(): boolean {\n\t\treturn this._undoRedoService.canRedo(this.uri);\n\t}\n\n\t//#endregion\n\n\t//#region Decorations\n\n\tprivate handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines: Set<number> | null, affectedLineHeights: Set<LineHeightChangingDecoration> | null, affectedFontLines: Set<LineFontChangingDecoration> | null): void {\n\t\t// This is called before the decoration changed event is fired.\n\n\t\tif (affectedInjectedTextLines && affectedInjectedTextLines.size > 0) {\n\t\t\tconst affectedLines = Array.from(affectedInjectedTextLines);\n\t\t\tconst lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n\t\t\tthis._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n\t\t}\n\t\tif (affectedLineHeights && affectedLineHeights.size > 0) {\n\t\t\tconst affectedLines = Array.from(affectedLineHeights);\n\t\t\tconst lineHeightChangeEvent = affectedLines.map(specialLineHeightChange => new ModelLineHeightChanged(specialLineHeightChange.ownerId, specialLineHeightChange.decorationId, specialLineHeightChange.lineNumber, specialLineHeightChange.lineHeight));\n\t\t\tthis._onDidChangeLineHeight.fire(new ModelLineHeightChangedEvent(lineHeightChangeEvent));\n\t\t}\n\t\tif (affectedFontLines && affectedFontLines.size > 0) {\n\t\t\tconst affectedLines = Array.from(affectedFontLines);\n\t\t\tconst fontChangeEvent = affectedLines.map(fontChange => new ModelFontChanged(fontChange.ownerId, fontChange.lineNumber));\n\t\t\tthis._onDidChangeFont.fire(new ModelFontChangedEvent(fontChangeEvent));\n\t\t}\n\t}\n\n\tpublic changeDecorations<T>(callback: (changeAccessor: model.IModelDecorationsChangeAccessor) => T, ownerId: number = 0): T | null {\n\t\tthis._assertNotDisposed();\n\n\t\ttry {\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\treturn this._changeDecorations(ownerId, callback);\n\t\t} finally {\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\tprivate _changeDecorations<T>(ownerId: number, callback: (changeAccessor: model.IModelDecorationsChangeAccessor) => T): T | null {\n\t\tconst changeAccessor: model.IModelDecorationsChangeAccessor = {\n\t\t\taddDecoration: (range: IRange, options: model.IModelDecorationOptions): string => {\n\t\t\t\treturn this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n\t\t\t},\n\t\t\tchangeDecoration: (id: string, newRange: IRange): void => {\n\t\t\t\tthis._changeDecorationImpl(ownerId, id, newRange);\n\t\t\t},\n\t\t\tchangeDecorationOptions: (id: string, options: model.IModelDecorationOptions) => {\n\t\t\t\tthis._changeDecorationOptionsImpl(ownerId, id, _normalizeOptions(options));\n\t\t\t},\n\t\t\tremoveDecoration: (id: string): void => {\n\t\t\t\tthis._deltaDecorationsImpl(ownerId, [id], []);\n\t\t\t},\n\t\t\tdeltaDecorations: (oldDecorations: string[], newDecorations: model.IModelDeltaDecoration[]): string[] => {\n\t\t\t\tif (oldDecorations.length === 0 && newDecorations.length === 0) {\n\t\t\t\t\t// nothing to do\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t\treturn this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n\t\t\t}\n\t\t};\n\t\tlet result: T | null = null;\n\t\ttry {\n\t\t\tresult = callback(changeAccessor);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t\t// Invalidate change accessor\n\t\tchangeAccessor.addDecoration = invalidFunc;\n\t\tchangeAccessor.changeDecoration = invalidFunc;\n\t\tchangeAccessor.changeDecorationOptions = invalidFunc;\n\t\tchangeAccessor.removeDecoration = invalidFunc;\n\t\tchangeAccessor.deltaDecorations = invalidFunc;\n\t\treturn result;\n\t}\n\n\tpublic deltaDecorations(oldDecorations: string[], newDecorations: model.IModelDeltaDecoration[], ownerId: number = 0): string[] {\n\t\tthis._assertNotDisposed();\n\t\tif (!oldDecorations) {\n\t\t\toldDecorations = [];\n\t\t}\n\t\tif (oldDecorations.length === 0 && newDecorations.length === 0) {\n\t\t\t// nothing to do\n\t\t\treturn [];\n\t\t}\n\n\t\ttry {\n\t\t\tthis._deltaDecorationCallCnt++;\n\t\t\tif (this._deltaDecorationCallCnt > 1) {\n\t\t\t\tconsole.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n\t\t\t\tonUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n\t\t\t}\n\t\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\t\treturn this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n\t\t} finally {\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t\tthis._deltaDecorationCallCnt--;\n\t\t}\n\t}\n\n\t_getTrackedRange(id: string): Range | null {\n\t\treturn this.getDecorationRange(id);\n\t}\n\n\t_setTrackedRange(id: string | null, newRange: null, newStickiness: model.TrackedRangeStickiness): null;\n\t_setTrackedRange(id: string | null, newRange: Range, newStickiness: model.TrackedRangeStickiness): string;\n\t_setTrackedRange(id: string | null, newRange: Range | null, newStickiness: model.TrackedRangeStickiness): string | null {\n\t\tconst node = (id ? this._decorations[id] : null);\n\n\t\tif (!node) {\n\t\t\tif (!newRange) {\n\t\t\t\t// node doesn't exist, the request is to delete => nothing to do\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// node doesn't exist, the request is to set => add the tracked range\n\t\t\treturn this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n\t\t}\n\n\t\tif (!newRange) {\n\t\t\t// node exists, the request is to delete => delete node\n\t\t\tthis._decorationsTree.delete(node);\n\t\t\tdelete this._decorations[node.id];\n\t\t\treturn null;\n\t\t}\n\n\t\t// node exists, the request is to set => change the tracked range and its options\n\t\tconst range = this._validateRangeRelaxedNoAllocations(newRange);\n\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\t\tthis._decorationsTree.delete(node);\n\t\tnode.reset(this.getVersionId(), startOffset, endOffset, range);\n\t\tnode.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n\t\tthis._decorationsTree.insert(node);\n\t\treturn node.id;\n\t}\n\n\tpublic removeAllDecorationsWithOwnerId(ownerId: number): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n\t\tfor (let i = 0, len = nodes.length; i < len; i++) {\n\t\t\tconst node = nodes[i];\n\n\t\t\tthis._decorationsTree.delete(node);\n\t\t\tdelete this._decorations[node.id];\n\t\t}\n\t}\n\n\tpublic getDecorationOptions(decorationId: string): model.IModelDecorationOptions | null {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\t\treturn node.options;\n\t}\n\n\tpublic getDecorationRange(decorationId: string): Range | null {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._decorationsTree.getNodeRange(this, node);\n\t}\n\n\tpublic getLineDecorations(lineNumber: number, ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false): model.IModelDecoration[] {\n\t\tif (lineNumber < 1 || lineNumber > this.getLineCount()) {\n\t\t\treturn [];\n\t\t}\n\t\treturn this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation, filterFontDecorations);\n\t}\n\n\tpublic getLinesDecorations(_startLineNumber: number, _endLineNumber: number, ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false, onlyMarginDecorations: boolean = false): model.IModelDecoration[] {\n\t\tconst lineCount = this.getLineCount();\n\t\tconst startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n\t\tconst endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n\t\tconst endColumn = this.getLineMaxColumn(endLineNumber);\n\t\tconst range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n\n\t\tconst decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations);\n\t\tpushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n\t\treturn decorations;\n\t}\n\n\tpublic getDecorationsInRange(range: IRange, ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false, onlyMinimapDecorations: boolean = false, onlyMarginDecorations: boolean = false): model.IModelDecoration[] {\n\t\tconst validatedRange = this.validateRange(range);\n\n\t\tconst decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations);\n\t\tpushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n\t\treturn decorations;\n\t}\n\n\tpublic getOverviewRulerDecorations(ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false): model.IModelDecoration[] {\n\t\treturn this._decorationsTree.getAll(this, ownerId, filterOutValidation, filterFontDecorations, true, false);\n\t}\n\n\tpublic getInjectedTextDecorations(ownerId: number = 0): model.IModelDecoration[] {\n\t\treturn this._decorationsTree.getAllInjectedText(this, ownerId);\n\t}\n\n\tpublic getCustomLineHeightsDecorations(ownerId: number = 0): model.IModelDecoration[] {\n\t\treturn this._decorationsTree.getAllCustomLineHeights(this, ownerId);\n\t}\n\n\tprivate _getInjectedTextInLine(lineNumber: number): LineInjectedText[] {\n\t\tconst startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n\t\tconst endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n\n\t\tconst result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n\t\treturn LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n\t}\n\n\tpublic getFontDecorationsInRange(range: IRange, ownerId: number = 0): model.IModelDecoration[] {\n\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\t\treturn this._decorationsTree.getFontDecorationsInInterval(this, startOffset, endOffset, ownerId);\n\t}\n\n\tpublic getAllDecorations(ownerId: number = 0, filterOutValidation: boolean = false, filterFontDecorations: boolean = false): model.IModelDecoration[] {\n\t\tlet result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, filterFontDecorations, false, false);\n\t\tresult = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n\t\treturn result;\n\t}\n\n\tpublic getAllMarginDecorations(ownerId: number = 0): model.IModelDecoration[] {\n\t\treturn this._decorationsTree.getAll(this, ownerId, false, false, false, true);\n\t}\n\n\tprivate _getDecorationsInRange(filterRange: Range, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMarginDecorations: boolean): model.IModelDecoration[] {\n\t\tconst startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n\t\treturn this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, filterFontDecorations, onlyMarginDecorations);\n\t}\n\n\tpublic getRangeAt(start: number, end: number): Range {\n\t\treturn this._buffer.getRangeAt(start, end - start);\n\t}\n\n\tprivate _changeDecorationImpl(ownerId: number, decorationId: string, _range: IRange): void {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.options.after) {\n\t\t\tconst oldRange = this.getDecorationRange(decorationId);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange!.endLineNumber);\n\t\t}\n\t\tif (node.options.before) {\n\t\t\tconst oldRange = this.getDecorationRange(decorationId);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange!.startLineNumber);\n\t\t}\n\t\tif (node.options.lineHeight !== null) {\n\t\t\tconst oldRange = this.getDecorationRange(decorationId);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, oldRange!.startLineNumber, null);\n\t\t}\n\t\tif (node.options.affectsFont) {\n\t\t\tconst oldRange = this.getDecorationRange(decorationId);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, node.id, oldRange!.startLineNumber);\n\t\t}\n\n\t\tconst range = this._validateRangeRelaxedNoAllocations(_range);\n\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\tthis._decorationsTree.delete(node);\n\t\tnode.reset(this.getVersionId(), startOffset, endOffset, range);\n\t\tthis._decorationsTree.insert(node);\n\t\tthis._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\n\t\tif (node.options.after) {\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n\t\t}\n\t\tif (node.options.before) {\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n\t\t}\n\t\tif (node.options.lineHeight !== null) {\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, range.startLineNumber, node.options.lineHeight);\n\t\t}\n\t\tif (node.options.affectsFont) {\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, node.id, range.startLineNumber);\n\t\t}\n\t}\n\n\tprivate _changeDecorationOptionsImpl(ownerId: number, decorationId: string, options: ModelDecorationOptions): void {\n\t\tconst node = this._decorations[decorationId];\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n\t\tconst nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n\n\t\tthis._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\t\tthis._onDidChangeDecorations.checkAffectedAndFire(options);\n\n\t\tif (node.options.after || options.after) {\n\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n\t\t}\n\t\tif (node.options.before || options.before) {\n\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n\t\t}\n\t\tif (node.options.lineHeight !== null || options.lineHeight !== null) {\n\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, nodeRange.startLineNumber, options.lineHeight);\n\t\t}\n\t\tif (node.options.affectsFont || options.affectsFont) {\n\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, decorationId, nodeRange.startLineNumber);\n\t\t}\n\n\t\tconst movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n\t\tconst changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n\t\tif (movedInOverviewRuler || changedWhetherInjectedText) {\n\t\t\tthis._decorationsTree.delete(node);\n\t\t\tnode.setOptions(options);\n\t\t\tthis._decorationsTree.insert(node);\n\t\t} else {\n\t\t\tnode.setOptions(options);\n\t\t}\n\t}\n\n\tprivate _deltaDecorationsImpl(ownerId: number, oldDecorationsIds: string[], newDecorations: model.IModelDeltaDecoration[], suppressEvents: boolean = false): string[] {\n\t\tconst versionId = this.getVersionId();\n\n\t\tconst oldDecorationsLen = oldDecorationsIds.length;\n\t\tlet oldDecorationIndex = 0;\n\n\t\tconst newDecorationsLen = newDecorations.length;\n\t\tlet newDecorationIndex = 0;\n\n\t\tthis._onDidChangeDecorations.beginDeferredEmit();\n\t\ttry {\n\t\t\tconst result = new Array<string>(newDecorationsLen);\n\t\t\twhile (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n\n\t\t\t\tlet node: IntervalNode | null = null;\n\n\t\t\t\tif (oldDecorationIndex < oldDecorationsLen) {\n\t\t\t\t\t// (1) get ourselves an old node\n\t\t\t\t\tlet decorationId: string;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tdecorationId = oldDecorationsIds[oldDecorationIndex++];\n\t\t\t\t\t\tnode = this._decorations[decorationId];\n\t\t\t\t\t} while (!node && oldDecorationIndex < oldDecorationsLen);\n\n\t\t\t\t\t// (2) remove the node from the tree (if it exists)\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tif (node.options.after) {\n\t\t\t\t\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (node.options.before) {\n\t\t\t\t\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (node.options.lineHeight !== null) {\n\t\t\t\t\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, decorationId, nodeRange.startLineNumber, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (node.options.affectsFont) {\n\t\t\t\t\t\t\tconst nodeRange = this._decorationsTree.getNodeRange(this, node);\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, decorationId, nodeRange.startLineNumber);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._decorationsTree.delete(node);\n\n\t\t\t\t\t\tif (!suppressEvents) {\n\t\t\t\t\t\t\tthis._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (newDecorationIndex < newDecorationsLen) {\n\t\t\t\t\t// (3) create a new node if necessary\n\t\t\t\t\tif (!node) {\n\t\t\t\t\t\tconst internalDecorationId = (++this._lastDecorationId);\n\t\t\t\t\t\tconst decorationId = `${this._instanceId};${internalDecorationId}`;\n\t\t\t\t\t\tnode = new IntervalNode(decorationId, 0, 0);\n\t\t\t\t\t\tthis._decorations[decorationId] = node;\n\t\t\t\t\t}\n\n\t\t\t\t\t// (4) initialize node\n\t\t\t\t\tconst newDecoration = newDecorations[newDecorationIndex];\n\t\t\t\t\tconst range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n\t\t\t\t\tconst options = _normalizeOptions(newDecoration.options);\n\t\t\t\t\tconst startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\t\t\t\t\tconst endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n\t\t\t\t\tnode.ownerId = ownerId;\n\t\t\t\t\tnode.reset(versionId, startOffset, endOffset, range);\n\t\t\t\t\tnode.setOptions(options);\n\n\t\t\t\t\tif (node.options.after) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n\t\t\t\t\t}\n\t\t\t\t\tif (node.options.before) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n\t\t\t\t\t}\n\t\t\t\t\tif (node.options.lineHeight !== null) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByLineHeightChange(ownerId, node.id, range.startLineNumber, node.options.lineHeight);\n\t\t\t\t\t}\n\t\t\t\t\tif (node.options.affectsFont) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.recordLineAffectedByFontChange(ownerId, node.id, range.startLineNumber);\n\t\t\t\t\t}\n\t\t\t\t\tif (!suppressEvents) {\n\t\t\t\t\t\tthis._onDidChangeDecorations.checkAffectedAndFire(options);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._decorationsTree.insert(node);\n\n\t\t\t\t\tresult[newDecorationIndex] = node.id;\n\n\t\t\t\t\tnewDecorationIndex++;\n\t\t\t\t} else {\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tdelete this._decorations[node.id];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tthis._onDidChangeDecorations.endDeferredEmit();\n\t\t}\n\t}\n\n\t//#endregion\n\n\t//#region Tokenization\n\n\t// TODO move them to the tokenization part.\n\tpublic getLanguageId(): string {\n\t\treturn this.tokenization.getLanguageId();\n\t}\n\n\tpublic setLanguage(languageIdOrSelection: string | ILanguageSelection, source?: string): void {\n\t\tif (typeof languageIdOrSelection === 'string') {\n\t\t\tthis._languageSelectionListener.clear();\n\t\t\tthis._setLanguage(languageIdOrSelection, source);\n\t\t} else {\n\t\t\tthis._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n\t\t\tthis._setLanguage(languageIdOrSelection.languageId, source);\n\t\t}\n\t}\n\n\tprivate _setLanguage(languageId: string, source?: string): void {\n\t\tthis.tokenization.setLanguageId(languageId, source);\n\t\tthis._languageService.requestRichLanguageFeatures(languageId);\n\t}\n\n\tpublic getLanguageIdAtPosition(lineNumber: number, column: number): string {\n\t\treturn this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n\t}\n\n\tpublic getWordAtPosition(position: IPosition): IWordAtPosition | null {\n\t\treturn this._tokenizationTextModelPart.getWordAtPosition(position);\n\t}\n\n\tpublic getWordUntilPosition(position: IPosition): IWordAtPosition {\n\t\treturn this._tokenizationTextModelPart.getWordUntilPosition(position);\n\t}\n\n\t//#endregion\n\tnormalizePosition(position: Position, affinity: model.PositionAffinity): Position {\n\t\treturn position;\n\t}\n\n\t/**\n\t * Gets the column at which indentation stops at a given line.\n\t * @internal\n\t*/\n\tpublic getLineIndentColumn(lineNumber: number): number {\n\t\t// Columns start with 1.\n\t\treturn indentOfLine(this.getLineContent(lineNumber)) + 1;\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `TextModel(${this.uri.toString()})`;\n\t}\n}\n\nexport function indentOfLine(line: string): number {\n\tlet indent = 0;\n\tfor (const c of line) {\n\t\tif (c === ' ' || c === '\\t') {\n\t\t\tindent++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn indent;\n}\n\n//#region Decorations\n\nfunction isNodeInOverviewRuler(node: IntervalNode): boolean {\n\treturn (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\n\nfunction isOptionsInjectedText(options: ModelDecorationOptions): boolean {\n\treturn !!options.after || !!options.before;\n}\n\nfunction isNodeInjectedText(node: IntervalNode): boolean {\n\treturn !!node.options.after || !!node.options.before;\n}\n\nexport interface IDecorationsTreesHost {\n\tgetVersionId(): number;\n\tgetRangeAt(start: number, end: number): Range;\n}\n\nclass DecorationsTrees {\n\n\t/**\n\t * This tree holds decorations that do not show up in the overview ruler.\n\t */\n\tprivate readonly _decorationsTree0: IntervalTree;\n\n\t/**\n\t * This tree holds decorations that show up in the overview ruler.\n\t */\n\tprivate readonly _decorationsTree1: IntervalTree;\n\n\t/**\n\t * This tree holds decorations that contain injected text.\n\t */\n\tprivate readonly _injectedTextDecorationsTree: IntervalTree;\n\n\tconstructor() {\n\t\tthis._decorationsTree0 = new IntervalTree();\n\t\tthis._decorationsTree1 = new IntervalTree();\n\t\tthis._injectedTextDecorationsTree = new IntervalTree();\n\t}\n\n\tpublic ensureAllNodesHaveRanges(host: IDecorationsTreesHost): void {\n\t\tthis.getAll(host, 0, false, false, false, false);\n\t}\n\n\tprivate _ensureNodesHaveRanges(host: IDecorationsTreesHost, nodes: IntervalNode[]): model.IModelDecoration[] {\n\t\tfor (const node of nodes) {\n\t\t\tif (node.range === null) {\n\t\t\t\tnode.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n\t\t\t}\n\t\t}\n\t\treturn <model.IModelDecoration[]>nodes;\n\t}\n\n\tpublic getAllInInterval(host: IDecorationsTreesHost, start: number, end: number, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, onlyMarginDecorations: boolean): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, versionId, onlyMarginDecorations);\n\t\treturn this._ensureNodesHaveRanges(host, result);\n\t}\n\n\tprivate _intervalSearch(start: number, end: number, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tconst r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\tconst r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\tconst r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\treturn r0.concat(r1).concat(r2);\n\t}\n\n\tpublic getInjectedTextInInterval(host: IDecorationsTreesHost, start: number, end: number, filterOwnerId: number): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, false, versionId, false);\n\t\treturn this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n\t}\n\n\tpublic getFontDecorationsInInterval(host: IDecorationsTreesHost, start: number, end: number, filterOwnerId: number): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst decorations = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, false, false, versionId, false);\n\t\treturn this._ensureNodesHaveRanges(host, decorations).filter((i) => i.options.affectsFont);\n\t}\n\n\tpublic getAllInjectedText(host: IDecorationsTreesHost, filterOwnerId: number): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._injectedTextDecorationsTree.search(filterOwnerId, false, false, versionId, false);\n\t\treturn this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n\t}\n\n\tpublic getAllCustomLineHeights(host: IDecorationsTreesHost, filterOwnerId: number): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._search(filterOwnerId, false, false, false, versionId, false);\n\t\treturn this._ensureNodesHaveRanges(host, result).filter((i) => typeof i.options.lineHeight === 'number');\n\t}\n\n\tpublic getAll(host: IDecorationsTreesHost, filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, overviewRulerOnly: boolean, onlyMarginDecorations: boolean): model.IModelDecoration[] {\n\t\tconst versionId = host.getVersionId();\n\t\tconst result = this._search(filterOwnerId, filterOutValidation, filterFontDecorations, overviewRulerOnly, versionId, onlyMarginDecorations);\n\t\treturn this._ensureNodesHaveRanges(host, result);\n\t}\n\n\tprivate _search(filterOwnerId: number, filterOutValidation: boolean, filterFontDecorations: boolean, overviewRulerOnly: boolean, cachedVersionId: number, onlyMarginDecorations: boolean): IntervalNode[] {\n\t\tif (overviewRulerOnly) {\n\t\t\treturn this._decorationsTree1.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\t} else {\n\t\t\tconst r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\t\tconst r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\t\tconst r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, filterFontDecorations, cachedVersionId, onlyMarginDecorations);\n\t\t\treturn r0.concat(r1).concat(r2);\n\t\t}\n\t}\n\n\tpublic collectNodesFromOwner(ownerId: number): IntervalNode[] {\n\t\tconst r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n\t\tconst r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n\t\tconst r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n\t\treturn r0.concat(r1).concat(r2);\n\t}\n\n\tpublic collectNodesPostOrder(): IntervalNode[] {\n\t\tconst r0 = this._decorationsTree0.collectNodesPostOrder();\n\t\tconst r1 = this._decorationsTree1.collectNodesPostOrder();\n\t\tconst r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n\t\treturn r0.concat(r1).concat(r2);\n\t}\n\n\tpublic insert(node: IntervalNode): void {\n\t\tif (isNodeInjectedText(node)) {\n\t\t\tthis._injectedTextDecorationsTree.insert(node);\n\t\t} else if (isNodeInOverviewRuler(node)) {\n\t\t\tthis._decorationsTree1.insert(node);\n\t\t} else {\n\t\t\tthis._decorationsTree0.insert(node);\n\t\t}\n\t}\n\n\tpublic delete(node: IntervalNode): void {\n\t\tif (isNodeInjectedText(node)) {\n\t\t\tthis._injectedTextDecorationsTree.delete(node);\n\t\t} else if (isNodeInOverviewRuler(node)) {\n\t\t\tthis._decorationsTree1.delete(node);\n\t\t} else {\n\t\t\tthis._decorationsTree0.delete(node);\n\t\t}\n\t}\n\n\tpublic getNodeRange(host: IDecorationsTreesHost, node: IntervalNode): Range {\n\t\tconst versionId = host.getVersionId();\n\t\tif (node.cachedVersionId !== versionId) {\n\t\t\tthis._resolveNode(node, versionId);\n\t\t}\n\t\tif (node.range === null) {\n\t\t\tnode.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n\t\t}\n\t\treturn node.range;\n\t}\n\n\tprivate _resolveNode(node: IntervalNode, cachedVersionId: number): void {\n\t\tif (isNodeInjectedText(node)) {\n\t\t\tthis._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n\t\t} else if (isNodeInOverviewRuler(node)) {\n\t\t\tthis._decorationsTree1.resolveNode(node, cachedVersionId);\n\t\t} else {\n\t\t\tthis._decorationsTree0.resolveNode(node, cachedVersionId);\n\t\t}\n\t}\n\n\tpublic acceptReplace(offset: number, length: number, textLength: number, forceMoveMarkers: boolean): void {\n\t\tthis._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\t\tthis._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\t\tthis._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\t}\n}\n\nfunction cleanClassName(className: string): string {\n\treturn className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\n\nclass DecorationOptions implements model.IDecorationOptions {\n\treadonly color: string | ThemeColor;\n\treadonly darkColor: string | ThemeColor;\n\n\tconstructor(options: model.IDecorationOptions) {\n\t\tthis.color = options.color || '';\n\t\tthis.darkColor = options.darkColor || '';\n\n\t}\n}\n\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n\treadonly position: model.OverviewRulerLane;\n\tprivate _resolvedColor: string | null;\n\n\tconstructor(options: model.IModelDecorationOverviewRulerOptions) {\n\t\tsuper(options);\n\t\tthis._resolvedColor = null;\n\t\tthis.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n\t}\n\n\tpublic getColor(theme: IColorTheme): string {\n\t\tif (!this._resolvedColor) {\n\t\t\tif (theme.type !== 'light' && this.darkColor) {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.darkColor, theme);\n\t\t\t} else {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.color, theme);\n\t\t\t}\n\t\t}\n\t\treturn this._resolvedColor;\n\t}\n\n\tpublic invalidateCachedColor(): void {\n\t\tthis._resolvedColor = null;\n\t}\n\n\tprivate _resolveColor(color: string | ThemeColor, theme: IColorTheme): string {\n\t\tif (typeof color === 'string') {\n\t\t\treturn color;\n\t\t}\n\t\tconst c = color ? theme.getColor(color.id) : null;\n\t\tif (!c) {\n\t\t\treturn '';\n\t\t}\n\t\treturn c.toString();\n\t}\n}\n\nexport class ModelDecorationGlyphMarginOptions {\n\treadonly position: model.GlyphMarginLane;\n\treadonly persistLane: boolean | undefined;\n\n\tconstructor(options: model.IModelDecorationGlyphMarginOptions | null | undefined) {\n\t\tthis.position = options?.position ?? model.GlyphMarginLane.Center;\n\t\tthis.persistLane = options?.persistLane;\n\t}\n}\n\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n\treadonly position: model.MinimapPosition;\n\treadonly sectionHeaderStyle: model.MinimapSectionHeaderStyle | null;\n\treadonly sectionHeaderText: string | null;\n\tprivate _resolvedColor: Color | undefined;\n\n\tconstructor(options: model.IModelDecorationMinimapOptions) {\n\t\tsuper(options);\n\t\tthis.position = options.position;\n\t\tthis.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n\t\tthis.sectionHeaderText = options.sectionHeaderText ?? null;\n\t}\n\n\tpublic getColor(theme: IColorTheme): Color | undefined {\n\t\tif (!this._resolvedColor) {\n\t\t\tif (theme.type !== 'light' && this.darkColor) {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.darkColor, theme);\n\t\t\t} else {\n\t\t\t\tthis._resolvedColor = this._resolveColor(this.color, theme);\n\t\t\t}\n\t\t}\n\n\t\treturn this._resolvedColor;\n\t}\n\n\tpublic invalidateCachedColor(): void {\n\t\tthis._resolvedColor = undefined;\n\t}\n\n\tprivate _resolveColor(color: string | ThemeColor, theme: IColorTheme): Color | undefined {\n\t\tif (typeof color === 'string') {\n\t\t\treturn Color.fromHex(color);\n\t\t}\n\t\treturn theme.getColor(color.id);\n\t}\n}\n\nexport class ModelDecorationInjectedTextOptions implements model.InjectedTextOptions {\n\tpublic static from(options: model.InjectedTextOptions): ModelDecorationInjectedTextOptions {\n\t\tif (options instanceof ModelDecorationInjectedTextOptions) {\n\t\t\treturn options;\n\t\t}\n\t\treturn new ModelDecorationInjectedTextOptions(options);\n\t}\n\n\tpublic readonly content: string;\n\tpublic readonly tokens: TokenArray | null;\n\treadonly inlineClassName: string | null;\n\treadonly inlineClassNameAffectsLetterSpacing: boolean;\n\treadonly attachedData: unknown | null;\n\treadonly cursorStops: model.InjectedTextCursorStops | null;\n\n\tprivate constructor(options: model.InjectedTextOptions) {\n\t\tthis.content = options.content || '';\n\t\tthis.tokens = options.tokens ?? null;\n\t\tthis.inlineClassName = options.inlineClassName || null;\n\t\tthis.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n\t\tthis.attachedData = options.attachedData || null;\n\t\tthis.cursorStops = options.cursorStops || null;\n\t}\n}\n\nexport class ModelDecorationOptions implements model.IModelDecorationOptions {\n\n\tpublic static EMPTY: ModelDecorationOptions;\n\n\tpublic static register(options: model.IModelDecorationOptions): ModelDecorationOptions {\n\t\treturn new ModelDecorationOptions(options);\n\t}\n\n\tpublic static createDynamic(options: model.IModelDecorationOptions): ModelDecorationOptions {\n\t\treturn new ModelDecorationOptions(options);\n\t}\n\treadonly description: string;\n\treadonly blockClassName: string | null;\n\treadonly blockIsAfterEnd: boolean | null;\n\treadonly blockDoesNotCollapse?: boolean | null;\n\treadonly blockPadding: [top: number, right: number, bottom: number, left: number] | null;\n\treadonly stickiness: model.TrackedRangeStickiness;\n\treadonly zIndex: number;\n\treadonly className: string | null;\n\treadonly shouldFillLineOnLineBreak: boolean | null;\n\treadonly hoverMessage: IMarkdownString | IMarkdownString[] | null;\n\treadonly glyphMarginHoverMessage: IMarkdownString | IMarkdownString[] | null;\n\treadonly isWholeLine: boolean;\n\treadonly lineHeight: number | null;\n\treadonly fontSize: string | null;\n\treadonly showIfCollapsed: boolean;\n\treadonly collapseOnReplaceEdit: boolean;\n\treadonly overviewRuler: ModelDecorationOverviewRulerOptions | null;\n\treadonly minimap: ModelDecorationMinimapOptions | null;\n\treadonly glyphMargin?: model.IModelDecorationGlyphMarginOptions | null | undefined;\n\treadonly glyphMarginClassName: string | null;\n\treadonly linesDecorationsClassName: string | null;\n\treadonly lineNumberClassName: string | null;\n\treadonly lineNumberHoverMessage: IMarkdownString | IMarkdownString[] | null;\n\treadonly linesDecorationsTooltip: string | null;\n\treadonly firstLineDecorationClassName: string | null;\n\treadonly marginClassName: string | null;\n\treadonly inlineClassName: string | null;\n\treadonly inlineClassNameAffectsLetterSpacing: boolean;\n\treadonly beforeContentClassName: string | null;\n\treadonly afterContentClassName: string | null;\n\treadonly after: ModelDecorationInjectedTextOptions | null;\n\treadonly before: ModelDecorationInjectedTextOptions | null;\n\treadonly hideInCommentTokens: boolean | null;\n\treadonly hideInStringTokens: boolean | null;\n\treadonly affectsFont: boolean | null;\n\treadonly textDirection?: model.TextDirection | null | undefined;\n\n\tprivate constructor(options: model.IModelDecorationOptions) {\n\t\tthis.description = options.description;\n\t\tthis.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n\t\tthis.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n\t\tthis.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n\t\tthis.blockPadding = options.blockPadding ?? null;\n\t\tthis.stickiness = options.stickiness || model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;\n\t\tthis.zIndex = options.zIndex || 0;\n\t\tthis.className = options.className ? cleanClassName(options.className) : null;\n\t\tthis.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n\t\tthis.hoverMessage = options.hoverMessage || null;\n\t\tthis.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n\t\tthis.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n\t\tthis.isWholeLine = options.isWholeLine || false;\n\t\tthis.lineHeight = options.lineHeight ? Math.min(options.lineHeight, LINE_HEIGHT_CEILING) : null;\n\t\tthis.fontSize = options.fontSize || null;\n\t\tthis.affectsFont = !!options.fontSize || !!options.fontFamily || !!options.fontWeight || !!options.fontStyle;\n\t\tthis.showIfCollapsed = options.showIfCollapsed || false;\n\t\tthis.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n\t\tthis.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n\t\tthis.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n\t\tthis.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n\t\tthis.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n\t\tthis.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n\t\tthis.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n\t\tthis.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n\t\tthis.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n\t\tthis.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n\t\tthis.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n\t\tthis.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n\t\tthis.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n\t\tthis.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n\t\tthis.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n\t\tthis.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n\t\tthis.hideInCommentTokens = options.hideInCommentTokens ?? false;\n\t\tthis.hideInStringTokens = options.hideInStringTokens ?? false;\n\t\tthis.textDirection = options.textDirection ?? null;\n\t}\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n\tModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges }),\n\tModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges }),\n\tModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore }),\n\tModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter }),\n];\n\nfunction _normalizeOptions(options: model.IModelDecorationOptions): ModelDecorationOptions {\n\tif (options instanceof ModelDecorationOptions) {\n\t\treturn options;\n\t}\n\treturn ModelDecorationOptions.createDynamic(options);\n}\n\nclass LineHeightChangingDecoration {\n\n\tpublic static toKey(obj: LineHeightChangingDecoration): string {\n\t\treturn `${obj.ownerId};${obj.decorationId};${obj.lineNumber}`;\n\t}\n\n\tconstructor(\n\t\tpublic readonly ownerId: number,\n\t\tpublic readonly decorationId: string,\n\t\tpublic readonly lineNumber: number,\n\t\tpublic readonly lineHeight: number | null\n\t) { }\n}\n\nclass LineFontChangingDecoration {\n\n\tpublic static toKey(obj: LineFontChangingDecoration): string {\n\t\treturn `${obj.ownerId};${obj.decorationId};${obj.lineNumber}`;\n\t}\n\n\tconstructor(\n\t\tpublic readonly ownerId: number,\n\t\tpublic readonly decorationId: string,\n\t\tpublic readonly lineNumber: number\n\t) { }\n}\n\nclass DidChangeDecorationsEmitter extends Disposable {\n\n\tprivate readonly _actual: Emitter<IModelDecorationsChangedEvent> = this._register(new Emitter<IModelDecorationsChangedEvent>());\n\tpublic readonly event: Event<IModelDecorationsChangedEvent> = this._actual.event;\n\n\tprivate _deferredCnt: number;\n\tprivate _shouldFireDeferred: boolean;\n\tprivate _affectsMinimap: boolean;\n\tprivate _affectsOverviewRuler: boolean;\n\tprivate _affectedInjectedTextLines: Set<number> | null = null;\n\tprivate _affectedLineHeights: SetWithKey<LineHeightChangingDecoration> | null = null;\n\tprivate _affectedFontLines: SetWithKey<LineFontChangingDecoration> | null = null;\n\tprivate _affectsGlyphMargin: boolean;\n\tprivate _affectsLineNumber: boolean;\n\n\tconstructor(private readonly handleBeforeFire: (affectedInjectedTextLines: Set<number> | null, affectedLineHeights: SetWithKey<LineHeightChangingDecoration> | null, affectedFontLines: SetWithKey<LineFontChangingDecoration> | null) => void) {\n\t\tsuper();\n\t\tthis._deferredCnt = 0;\n\t\tthis._shouldFireDeferred = false;\n\t\tthis._affectsMinimap = false;\n\t\tthis._affectsOverviewRuler = false;\n\t\tthis._affectsGlyphMargin = false;\n\t\tthis._affectsLineNumber = false;\n\t}\n\n\tpublic beginDeferredEmit(): void {\n\t\tthis._deferredCnt++;\n\t}\n\n\tpublic endDeferredEmit(): void {\n\t\tthis._deferredCnt--;\n\t\tif (this._deferredCnt === 0) {\n\t\t\tif (this._shouldFireDeferred) {\n\t\t\t\tthis.doFire();\n\t\t\t}\n\n\t\t\tthis._affectedInjectedTextLines?.clear();\n\t\t\tthis._affectedInjectedTextLines = null;\n\t\t\tthis._affectedLineHeights?.clear();\n\t\t\tthis._affectedLineHeights = null;\n\t\t\tthis._affectedFontLines?.clear();\n\t\t\tthis._affectedFontLines = null;\n\t\t}\n\t}\n\n\tpublic recordLineAffectedByInjectedText(lineNumber: number): void {\n\t\tif (!this._affectedInjectedTextLines) {\n\t\t\tthis._affectedInjectedTextLines = new Set();\n\t\t}\n\t\tthis._affectedInjectedTextLines.add(lineNumber);\n\t}\n\n\tpublic recordLineAffectedByLineHeightChange(ownerId: number, decorationId: string, lineNumber: number, lineHeight: number | null): void {\n\t\tif (!this._affectedLineHeights) {\n\t\t\tthis._affectedLineHeights = new SetWithKey<LineHeightChangingDecoration>([], LineHeightChangingDecoration.toKey);\n\t\t}\n\t\tthis._affectedLineHeights.add(new LineHeightChangingDecoration(ownerId, decorationId, lineNumber, lineHeight));\n\t}\n\n\tpublic recordLineAffectedByFontChange(ownerId: number, decorationId: string, lineNumber: number): void {\n\t\tif (!this._affectedFontLines) {\n\t\t\tthis._affectedFontLines = new SetWithKey<LineFontChangingDecoration>([], LineFontChangingDecoration.toKey);\n\t\t}\n\t\tthis._affectedFontLines.add(new LineFontChangingDecoration(ownerId, decorationId, lineNumber));\n\t}\n\n\tpublic checkAffectedAndFire(options: ModelDecorationOptions): void {\n\t\tthis._affectsMinimap ||= !!options.minimap?.position;\n\t\tthis._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n\t\tthis._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n\t\tthis._affectsLineNumber ||= !!options.lineNumberClassName;\n\t\tthis.tryFire();\n\t}\n\n\tpublic fire(): void {\n\t\tthis._affectsMinimap = true;\n\t\tthis._affectsOverviewRuler = true;\n\t\tthis._affectsGlyphMargin = true;\n\t\tthis.tryFire();\n\t}\n\n\tprivate tryFire() {\n\t\tif (this._deferredCnt === 0) {\n\t\t\tthis.doFire();\n\t\t} else {\n\t\t\tthis._shouldFireDeferred = true;\n\t\t}\n\t}\n\n\tprivate doFire() {\n\t\tthis.handleBeforeFire(this._affectedInjectedTextLines, this._affectedLineHeights, this._affectedFontLines);\n\n\t\tconst event: IModelDecorationsChangedEvent = {\n\t\t\taffectsMinimap: this._affectsMinimap,\n\t\t\taffectsOverviewRuler: this._affectsOverviewRuler,\n\t\t\taffectsGlyphMargin: this._affectsGlyphMargin,\n\t\t\taffectsLineNumber: this._affectsLineNumber,\n\t\t};\n\t\tthis._shouldFireDeferred = false;\n\t\tthis._affectsMinimap = false;\n\t\tthis._affectsOverviewRuler = false;\n\t\tthis._affectsGlyphMargin = false;\n\t\tthis._actual.fire(event);\n\t}\n}\n\n//#endregion\n\nclass DidChangeContentEmitter extends Disposable {\n\n\t/**\n\t * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n\t */\n\tprivate readonly _fastEmitter: Emitter<InternalModelContentChangeEvent> = this._register(new Emitter<InternalModelContentChangeEvent>());\n\tpublic readonly fastEvent: Event<InternalModelContentChangeEvent> = this._fastEmitter.event;\n\tprivate readonly _slowEmitter: Emitter<InternalModelContentChangeEvent> = this._register(new Emitter<InternalModelContentChangeEvent>());\n\tpublic readonly slowEvent: Event<InternalModelContentChangeEvent> = this._slowEmitter.event;\n\n\tprivate _deferredCnt: number;\n\tprivate _deferredEvent: InternalModelContentChangeEvent | null;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._deferredCnt = 0;\n\t\tthis._deferredEvent = null;\n\t}\n\n\tpublic beginDeferredEmit(): void {\n\t\tthis._deferredCnt++;\n\t}\n\n\tpublic endDeferredEmit(resultingSelection: Selection[] | null = null): void {\n\t\tthis._deferredCnt--;\n\t\tif (this._deferredCnt === 0) {\n\t\t\tif (this._deferredEvent !== null) {\n\t\t\t\tthis._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n\t\t\t\tconst e = this._deferredEvent;\n\t\t\t\tthis._deferredEvent = null;\n\t\t\t\tthis._fastEmitter.fire(e);\n\t\t\t\tthis._slowEmitter.fire(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic fire(e: InternalModelContentChangeEvent): void {\n\t\tif (this._deferredCnt > 0) {\n\t\t\tif (this._deferredEvent) {\n\t\t\t\tthis._deferredEvent = this._deferredEvent.merge(e);\n\t\t\t} else {\n\t\t\t\tthis._deferredEvent = e;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._fastEmitter.fire(e);\n\t\tthis._slowEmitter.fire(e);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 13442, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/prefixSumComputer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/prefixSumComputer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\n\nexport class PrefixSumComputer {\n\n\t/**\n\t * values[i] is the value at index i\n\t */\n\tprivate values: Uint32Array;\n\n\t/**\n\t * prefixSum[i] = SUM(heights[j]), 0 <= j <= i\n\t */\n\tprivate prefixSum: Uint32Array;\n\n\t/**\n\t * prefixSum[i], 0 <= i <= prefixSumValidIndex can be trusted\n\t */\n\tprivate readonly prefixSumValidIndex: Int32Array;\n\n\tconstructor(values: Uint32Array) {\n\t\tthis.values = values;\n\t\tthis.prefixSum = new Uint32Array(values.length);\n\t\tthis.prefixSumValidIndex = new Int32Array(1);\n\t\tthis.prefixSumValidIndex[0] = -1;\n\t}\n\n\tpublic insertValues(insertIndex: number, insertValues: Uint32Array): boolean {\n\t\tinsertIndex = toUint32(insertIndex);\n\t\tconst oldValues = this.values;\n\t\tconst oldPrefixSum = this.prefixSum;\n\t\tconst insertValuesLen = insertValues.length;\n\n\t\tif (insertValuesLen === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.values = new Uint32Array(oldValues.length + insertValuesLen);\n\t\tthis.values.set(oldValues.subarray(0, insertIndex), 0);\n\t\tthis.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n\t\tthis.values.set(insertValues, insertIndex);\n\n\t\tif (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = insertIndex - 1;\n\t\t}\n\n\t\tthis.prefixSum = new Uint32Array(this.values.length);\n\t\tif (this.prefixSumValidIndex[0] >= 0) {\n\t\t\tthis.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic setValue(index: number, value: number): boolean {\n\t\tindex = toUint32(index);\n\t\tvalue = toUint32(value);\n\n\t\tif (this.values[index] === value) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.values[index] = value;\n\t\tif (index - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = index - 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic removeValues(startIndex: number, count: number): boolean {\n\t\tstartIndex = toUint32(startIndex);\n\t\tcount = toUint32(count);\n\n\t\tconst oldValues = this.values;\n\t\tconst oldPrefixSum = this.prefixSum;\n\n\t\tif (startIndex >= oldValues.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst maxCount = oldValues.length - startIndex;\n\t\tif (count >= maxCount) {\n\t\t\tcount = maxCount;\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.values = new Uint32Array(oldValues.length - count);\n\t\tthis.values.set(oldValues.subarray(0, startIndex), 0);\n\t\tthis.values.set(oldValues.subarray(startIndex + count), startIndex);\n\n\t\tthis.prefixSum = new Uint32Array(this.values.length);\n\t\tif (startIndex - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = startIndex - 1;\n\t\t}\n\t\tif (this.prefixSumValidIndex[0] >= 0) {\n\t\t\tthis.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getTotalSum(): number {\n\t\tif (this.values.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._getPrefixSum(this.values.length - 1);\n\t}\n\n\t/**\n\t * Returns the sum of the first `index + 1` many items.\n\t * @returns `SUM(0 <= j <= index, values[j])`.\n\t */\n\tpublic getPrefixSum(index: number): number {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tindex = toUint32(index);\n\t\treturn this._getPrefixSum(index);\n\t}\n\n\tprivate _getPrefixSum(index: number): number {\n\t\tif (index <= this.prefixSumValidIndex[0]) {\n\t\t\treturn this.prefixSum[index];\n\t\t}\n\n\t\tlet startIndex = this.prefixSumValidIndex[0] + 1;\n\t\tif (startIndex === 0) {\n\t\t\tthis.prefixSum[0] = this.values[0];\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tif (index >= this.values.length) {\n\t\t\tindex = this.values.length - 1;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n\t\t}\n\t\tthis.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n\t\treturn this.prefixSum[index];\n\t}\n\n\tpublic getIndexOf(sum: number): PrefixSumIndexOfResult {\n\t\tsum = Math.floor(sum);\n\n\t\t// Compute all sums (to get a fully valid prefixSum)\n\t\tthis.getTotalSum();\n\n\t\tlet low = 0;\n\t\tlet high = this.values.length - 1;\n\t\tlet mid = 0;\n\t\tlet midStop = 0;\n\t\tlet midStart = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\n\t\t\tmidStop = this.prefixSum[mid];\n\t\t\tmidStart = midStop - this.values[mid];\n\n\t\t\tif (sum < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (sum >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new PrefixSumIndexOfResult(mid, sum - midStart);\n\t}\n}\n\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n\tprivate _values: number[];\n\tprivate _isValid: boolean;\n\tprivate _validEndIndex: number;\n\n\t/**\n\t * _prefixSum[i] = SUM(values[j]), 0 <= j <= i\n\t */\n\tprivate _prefixSum: number[];\n\n\t/**\n\t * _indexBySum[sum] = idx => _prefixSum[idx - 1] <= sum < _prefixSum[idx]\n\t*/\n\tprivate _indexBySum: number[];\n\n\tconstructor(values: number[]) {\n\t\tthis._values = values;\n\t\tthis._isValid = false;\n\t\tthis._validEndIndex = -1;\n\t\tthis._prefixSum = [];\n\t\tthis._indexBySum = [];\n\t}\n\n\t/**\n\t * @returns SUM(0 <= j < values.length, values[j])\n\t */\n\tpublic getTotalSum(): number {\n\t\tthis._ensureValid();\n\t\treturn this._indexBySum.length;\n\t}\n\n\t/**\n\t * Returns the sum of the first `count` many items.\n\t * @returns `SUM(0 <= j < count, values[j])`.\n\t */\n\tpublic getPrefixSum(count: number): number {\n\t\tthis._ensureValid();\n\t\tif (count === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._prefixSum[count - 1];\n\t}\n\n\t/**\n\t * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n\t */\n\tpublic getIndexOf(sum: number): PrefixSumIndexOfResult {\n\t\tthis._ensureValid();\n\t\tconst idx = this._indexBySum[sum];\n\t\tconst viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n\t\treturn new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n\t}\n\n\tpublic removeValues(start: number, deleteCount: number): void {\n\t\tthis._values.splice(start, deleteCount);\n\t\tthis._invalidate(start);\n\t}\n\n\tpublic insertValues(insertIndex: number, insertArr: number[]): void {\n\t\tthis._values = arrayInsert(this._values, insertIndex, insertArr);\n\t\tthis._invalidate(insertIndex);\n\t}\n\n\tprivate _invalidate(index: number): void {\n\t\tthis._isValid = false;\n\t\tthis._validEndIndex = Math.min(this._validEndIndex, index - 1);\n\t}\n\n\tprivate _ensureValid(): void {\n\t\tif (this._isValid) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n\t\t\tconst value = this._values[i];\n\t\t\tconst sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n\n\t\t\tthis._prefixSum[i] = sumAbove + value;\n\t\t\tfor (let j = 0; j < value; j++) {\n\t\t\t\tthis._indexBySum[sumAbove + j] = i;\n\t\t\t}\n\t\t}\n\n\t\t// trim things\n\t\tthis._prefixSum.length = this._values.length;\n\t\tthis._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n\n\t\t// mark as valid\n\t\tthis._isValid = true;\n\t\tthis._validEndIndex = this._values.length - 1;\n\t}\n\n\tpublic setValue(index: number, value: number): void {\n\t\tif (this._values[index] === value) {\n\t\t\t// no change\n\t\t\treturn;\n\t\t}\n\t\tthis._values[index] = value;\n\t\tthis._invalidate(index);\n\t}\n}\n\n\nexport class PrefixSumIndexOfResult {\n\t_prefixSumIndexOfResultBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly index: number,\n\t\tpublic readonly remainder: number\n\t) {\n\t\tthis.index = index;\n\t\tthis.remainder = remainder;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\n\nexport class PrefixSumComputer {\n\n\t/**\n\t * values[i] is the value at index i\n\t */\n\tprivate values: Uint32Array;\n\n\t/**\n\t * prefixSum[i] = SUM(heights[j]), 0 <= j <= i\n\t */\n\tprivate prefixSum: Uint32Array;\n\n\t/**\n\t * prefixSum[i], 0 <= i <= prefixSumValidIndex can be trusted\n\t */\n\tprivate readonly prefixSumValidIndex: Int32Array;\n\n\tconstructor(values: Uint32Array) {\n\t\tthis.values = values;\n\t\tthis.prefixSum = new Uint32Array(values.length);\n\t\tthis.prefixSumValidIndex = new Int32Array(1);\n\t\tthis.prefixSumValidIndex[0] = -1;\n\t}\n\n\tpublic insertValues(insertIndex: number, insertValues: Uint32Array): boolean {\n\t\tinsertIndex = toUint32(insertIndex);\n\t\tconst oldValues = this.values;\n\t\tconst oldPrefixSum = this.prefixSum;\n\t\tconst insertValuesLen = insertValues.length;\n\n\t\tif (insertValuesLen === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.values = new Uint32Array(oldValues.length + insertValuesLen);\n\t\tthis.values.set(oldValues.subarray(0, insertIndex), 0);\n\t\tthis.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n\t\tthis.values.set(insertValues, insertIndex);\n\n\t\tif (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = insertIndex - 1;\n\t\t}\n\n\t\tthis.prefixSum = new Uint32Array(this.values.length);\n\t\tif (this.prefixSumValidIndex[0] >= 0) {\n\t\t\tthis.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic setValue(index: number, value: number): boolean {\n\t\tindex = toUint32(index);\n\t\tvalue = toUint32(value);\n\n\t\tif (this.values[index] === value) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.values[index] = value;\n\t\tif (index - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = index - 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic removeValues(startIndex: number, count: number): boolean {\n\t\tstartIndex = toUint32(startIndex);\n\t\tcount = toUint32(count);\n\n\t\tconst oldValues = this.values;\n\t\tconst oldPrefixSum = this.prefixSum;\n\n\t\tif (startIndex >= oldValues.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst maxCount = oldValues.length - startIndex;\n\t\tif (count >= maxCount) {\n\t\t\tcount = maxCount;\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.values = new Uint32Array(oldValues.length - count);\n\t\tthis.values.set(oldValues.subarray(0, startIndex), 0);\n\t\tthis.values.set(oldValues.subarray(startIndex + count), startIndex);\n\n\t\tthis.prefixSum = new Uint32Array(this.values.length);\n\t\tif (startIndex - 1 < this.prefixSumValidIndex[0]) {\n\t\t\tthis.prefixSumValidIndex[0] = startIndex - 1;\n\t\t}\n\t\tif (this.prefixSumValidIndex[0] >= 0) {\n\t\t\tthis.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getTotalSum(): number {\n\t\tif (this.values.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._getPrefixSum(this.values.length - 1);\n\t}\n\n\t/**\n\t * Returns the sum of the first `index + 1` many items.\n\t * @returns `SUM(0 <= j <= index, values[j])`.\n\t */\n\tpublic getPrefixSum(index: number): number {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tindex = toUint32(index);\n\t\treturn this._getPrefixSum(index);\n\t}\n\n\tprivate _getPrefixSum(index: number): number {\n\t\tif (index <= this.prefixSumValidIndex[0]) {\n\t\t\treturn this.prefixSum[index];\n\t\t}\n\n\t\tlet startIndex = this.prefixSumValidIndex[0] + 1;\n\t\tif (startIndex === 0) {\n\t\t\tthis.prefixSum[0] = this.values[0];\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tif (index >= this.values.length) {\n\t\t\tindex = this.values.length - 1;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n\t\t}\n\t\tthis.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n\t\treturn this.prefixSum[index];\n\t}\n\n\tpublic getIndexOf(sum: number): PrefixSumIndexOfResult {\n\t\tsum = Math.floor(sum);\n\n\t\t// Compute all sums (to get a fully valid prefixSum)\n\t\tthis.getTotalSum();\n\n\t\tlet low = 0;\n\t\tlet high = this.values.length - 1;\n\t\tlet mid = 0;\n\t\tlet midStop = 0;\n\t\tlet midStart = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\n\t\t\tmidStop = this.prefixSum[mid];\n\t\t\tmidStart = midStop - this.values[mid];\n\n\t\t\tif (sum < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (sum >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new PrefixSumIndexOfResult(mid, sum - midStart);\n\t}\n}\n\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n\tprivate _values: number[];\n\tprivate _isValid: boolean;\n\tprivate _validEndIndex: number;\n\n\t/**\n\t * _prefixSum[i] = SUM(values[j]), 0 <= j <= i\n\t */\n\tprivate _prefixSum: number[];\n\n\t/**\n\t * _indexBySum[sum] = idx => _prefixSum[idx - 1] <= sum < _prefixSum[idx]\n\t*/\n\tprivate _indexBySum: number[];\n\n\tconstructor(values: number[]) {\n\t\tthis._values = values;\n\t\tthis._isValid = false;\n\t\tthis._validEndIndex = -1;\n\t\tthis._prefixSum = [];\n\t\tthis._indexBySum = [];\n\t}\n\n\t/**\n\t * @returns SUM(0 <= j < values.length, values[j])\n\t */\n\tpublic getTotalSum(): number {\n\t\tthis._ensureValid();\n\t\treturn this._indexBySum.length;\n\t}\n\n\t/**\n\t * Returns the sum of the first `count` many items.\n\t * @returns `SUM(0 <= j < count, values[j])`.\n\t */\n\tpublic getPrefixSum(count: number): number {\n\t\tthis._ensureValid();\n\t\tif (count === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this._prefixSum[count - 1];\n\t}\n\n\t/**\n\t * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n\t */\n\tpublic getIndexOf(sum: number): PrefixSumIndexOfResult {\n\t\tthis._ensureValid();\n\t\tconst idx = this._indexBySum[sum];\n\t\tconst viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n\t\treturn new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n\t}\n\n\tpublic removeValues(start: number, deleteCount: number): void {\n\t\tthis._values.splice(start, deleteCount);\n\t\tthis._invalidate(start);\n\t}\n\n\tpublic insertValues(insertIndex: number, insertArr: number[]): void {\n\t\tthis._values = arrayInsert(this._values, insertIndex, insertArr);\n\t\tthis._invalidate(insertIndex);\n\t}\n\n\tprivate _invalidate(index: number): void {\n\t\tthis._isValid = false;\n\t\tthis._validEndIndex = Math.min(this._validEndIndex, index - 1);\n\t}\n\n\tprivate _ensureValid(): void {\n\t\tif (this._isValid) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n\t\t\tconst value = this._values[i];\n\t\t\tconst sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n\n\t\t\tthis._prefixSum[i] = sumAbove + value;\n\t\t\tfor (let j = 0; j < value; j++) {\n\t\t\t\tthis._indexBySum[sumAbove + j] = i;\n\t\t\t}\n\t\t}\n\n\t\t// trim things\n\t\tthis._prefixSum.length = this._values.length;\n\t\tthis._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n\n\t\t// mark as valid\n\t\tthis._isValid = true;\n\t\tthis._validEndIndex = this._values.length - 1;\n\t}\n\n\tpublic setValue(index: number, value: number): void {\n\t\tif (this._values[index] === value) {\n\t\t\t// no change\n\t\t\treturn;\n\t\t}\n\t\tthis._values[index] = value;\n\t\tthis._invalidate(index);\n\t}\n}\n\n\nexport class PrefixSumIndexOfResult {\n\t_prefixSumIndexOfResultBrand: void = undefined;\n\n\tconstructor(\n\t\tpublic readonly index: number,\n\t\tpublic readonly remainder: number\n\t) {\n\t\tthis.index = index;\n\t\tthis.remainder = remainder;\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 13667, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/textModelText.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/textModelText.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/textModelText.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../core/range.js';\nimport { AbstractText } from '../core/text/abstractText.js';\nimport { TextLength } from '../core/text/textLength.js';\nimport { ITextModel } from '../model.js';\n\nexport class TextModelText extends AbstractText {\n\tconstructor(private readonly _textModel: ITextModel) {\n\t\tsuper();\n\t}\n\n\toverride getValueOfRange(range: Range): string {\n\t\treturn this._textModel.getValueInRange(range);\n\t}\n\n\toverride getLineLength(lineNumber: number): number {\n\t\treturn this._textModel.getLineLength(lineNumber);\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLineNumber = this._textModel.getLineCount();\n\t\tconst lastLineLen = this._textModel.getLineLength(lastLineNumber);\n\t\treturn new TextLength(lastLineNumber - 1, lastLineLen);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Range } from '../core/range.js';\nimport { AbstractText } from '../core/text/abstractText.js';\nimport { TextLength } from '../core/text/textLength.js';\nimport { ITextModel } from '../model.js';\n\nexport class TextModelText extends AbstractText {\n\tconstructor(private readonly _textModel: ITextModel) {\n\t\tsuper();\n\t}\n\n\toverride getValueOfRange(range: Range): string {\n\t\treturn this._textModel.getValueInRange(range);\n\t}\n\n\toverride getLineLength(lineNumber: number): number {\n\t\treturn this._textModel.getLineLength(lineNumber);\n\t}\n\n\tget length(): TextLength {\n\t\tconst lastLineNumber = this._textModel.getLineCount();\n\t\tconst lastLineLen = this._textModel.getLineLength(lastLineNumber);\n\t\treturn new TextLength(lastLineNumber - 1, lastLineLen);\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAGhG,OAAO,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAC5D,OAAO,EAAE,UAAU,EAAE,MAAM,4BAA4B,CAAC;;;AAGlD,MAAO,aAAc,SAAQ,oNAAY;IAKrC,eAAe,CAAC,KAAY,EAAA;QACpC,OAAO,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;IAC/C,CAAC;IAEQ,aAAa,CAAC,UAAkB,EAAA;QACxC,OAAO,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;IAClD,CAAC;IAED,IAAI,MAAM,GAAA;QACT,MAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,YAAY,EAAE,CAAC;QACtD,MAAM,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC;QAClE,OAAO,IAAI,gNAAU,CAAC,cAAc,GAAG,CAAC,EAAE,WAAW,CAAC,CAAC;IACxD,CAAC;IAhBD,YAA6B,UAAsB,CAAA;QAClD,KAAK,EAAE,CAAC;QADoB,IAAA,CAAA,UAAU,GAAV,UAAU,CAAY;IAEnD,CAAC;CAeD","debugId":null}},
    {"offset": {"line": 13699, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/textModelStringEdit.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/textModelStringEdit.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/textModelStringEdit.ts"],"sourcesContent":["\nimport { StringEdit, StringReplacement } from '../core/edits/stringEdit.js';\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { IModelContentChange } from './mirrorTextModel.js';\n\nexport function offsetEditFromContentChanges(contentChanges: readonly IModelContentChange[]) {\n\tconst editsArr = contentChanges.map(c => new StringReplacement(OffsetRange.ofStartAndLength(c.rangeOffset, c.rangeLength), c.text));\n\teditsArr.reverse();\n\tconst edits = new StringEdit(editsArr);\n\treturn edits;\n}\n","\nimport { StringEdit, StringReplacement } from '../core/edits/stringEdit.js';\nimport { OffsetRange } from '../core/ranges/offsetRange.js';\nimport { IModelContentChange } from './mirrorTextModel.js';\n\nexport function offsetEditFromContentChanges(contentChanges: readonly IModelContentChange[]) {\n\tconst editsArr = contentChanges.map(c => new StringReplacement(OffsetRange.ofStartAndLength(c.rangeOffset, c.rangeLength), c.text));\n\teditsArr.reverse();\n\tconst edits = new StringEdit(editsArr);\n\treturn edits;\n}\n"],"names":[],"mappings":";;;;AACA,OAAO,EAAE,UAAU,EAAE,iBAAiB,EAAE,MAAM,6BAA6B,CAAC;AAC5E,OAAO,EAAE,WAAW,EAAE,MAAM,+BAA+B,CAAC;;;AAGtD,SAAU,4BAA4B,CAAC,cAA8C;IAC1F,MAAM,QAAQ,GAAG,cAAc,CAAC,GAAG,EAAC,CAAC,CAAC,EAAE,AAAC,IAAI,wNAAiB,CAAC,oNAAW,CAAC,gBAAgB,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;IACpI,QAAQ,CAAC,OAAO,EAAE,CAAC;IACnB,MAAM,KAAK,GAAG,IAAI,iNAAU,CAAC,QAAQ,CAAC,CAAC;IACvC,OAAO,KAAK,CAAC;AACd,CAAC","debugId":null}},
    {"offset": {"line": 13717, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILanguageConfigurationService } from '../../languages/languageConfigurationRegistry.js';\nimport { AstNode, AstNodeKind } from './bracketPairsTree/ast.js';\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { Length, lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { ITokenizerSource, TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nimport { IViewLineTokens } from '../../tokens/lineTokens.js';\n\nexport function fixBracketsInLine(tokens: IViewLineTokens, languageConfigurationService: ILanguageConfigurationService): string {\n\tconst denseKeyProvider = new DenseKeyProvider<string>();\n\tconst bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) =>\n\t\tlanguageConfigurationService.getLanguageConfiguration(languageId)\n\t);\n\tconst tokenizer = new TextBufferTokenizer(\n\t\tnew StaticTokenizerSource([tokens]),\n\t\tbracketTokens\n\t);\n\tconst node = parseDocument(tokenizer, [], undefined, true);\n\n\tlet str = '';\n\tconst line = tokens.getLineContent();\n\n\tfunction processNode(node: AstNode, offset: Length) {\n\t\tif (node.kind === AstNodeKind.Pair) {\n\t\t\tprocessNode(node.openingBracket, offset);\n\t\t\toffset = lengthAdd(offset, node.openingBracket.length);\n\n\t\t\tif (node.child) {\n\t\t\t\tprocessNode(node.child, offset);\n\t\t\t\toffset = lengthAdd(offset, node.child.length);\n\t\t\t}\n\t\t\tif (node.closingBracket) {\n\t\t\t\tprocessNode(node.closingBracket, offset);\n\t\t\t\toffset = lengthAdd(offset, node.closingBracket.length);\n\t\t\t} else {\n\t\t\t\tconst singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n\n\t\t\t\tconst closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n\t\t\t\tstr += closingTokenText;\n\t\t\t}\n\t\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\t\t// remove the bracket\n\t\t} else if (node.kind === AstNodeKind.Text || node.kind === AstNodeKind.Bracket) {\n\t\t\tstr += line.substring(\n\t\t\t\tlengthGetColumnCountIfZeroLineCount(offset),\n\t\t\t\tlengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length))\n\t\t\t);\n\t\t} else if (node.kind === AstNodeKind.List) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tprocessNode(child, offset);\n\t\t\t\toffset = lengthAdd(offset, child.length);\n\t\t\t}\n\t\t}\n\t}\n\n\tprocessNode(node, lengthZero);\n\n\treturn str;\n}\n\nclass StaticTokenizerSource implements ITokenizerSource {\n\tconstructor(private readonly lines: IViewLineTokens[]) { }\n\tgetLineCount(): number {\n\t\treturn this.lines.length;\n\t}\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.lines[lineNumber - 1].getLineContent().length;\n\t}\n\n\ttokenization = {\n\t\tgetLineTokens: (lineNumber: number): IViewLineTokens => {\n\t\t\treturn this.lines[lineNumber - 1];\n\t\t}\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILanguageConfigurationService } from '../../languages/languageConfigurationRegistry.js';\nimport { AstNode, AstNodeKind } from './bracketPairsTree/ast.js';\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { Length, lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { ITokenizerSource, TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nimport { IViewLineTokens } from '../../tokens/lineTokens.js';\n\nexport function fixBracketsInLine(tokens: IViewLineTokens, languageConfigurationService: ILanguageConfigurationService): string {\n\tconst denseKeyProvider = new DenseKeyProvider<string>();\n\tconst bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) =>\n\t\tlanguageConfigurationService.getLanguageConfiguration(languageId)\n\t);\n\tconst tokenizer = new TextBufferTokenizer(\n\t\tnew StaticTokenizerSource([tokens]),\n\t\tbracketTokens\n\t);\n\tconst node = parseDocument(tokenizer, [], undefined, true);\n\n\tlet str = '';\n\tconst line = tokens.getLineContent();\n\n\tfunction processNode(node: AstNode, offset: Length) {\n\t\tif (node.kind === AstNodeKind.Pair) {\n\t\t\tprocessNode(node.openingBracket, offset);\n\t\t\toffset = lengthAdd(offset, node.openingBracket.length);\n\n\t\t\tif (node.child) {\n\t\t\t\tprocessNode(node.child, offset);\n\t\t\t\toffset = lengthAdd(offset, node.child.length);\n\t\t\t}\n\t\t\tif (node.closingBracket) {\n\t\t\t\tprocessNode(node.closingBracket, offset);\n\t\t\t\toffset = lengthAdd(offset, node.closingBracket.length);\n\t\t\t} else {\n\t\t\t\tconst singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n\n\t\t\t\tconst closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n\t\t\t\tstr += closingTokenText;\n\t\t\t}\n\t\t} else if (node.kind === AstNodeKind.UnexpectedClosingBracket) {\n\t\t\t// remove the bracket\n\t\t} else if (node.kind === AstNodeKind.Text || node.kind === AstNodeKind.Bracket) {\n\t\t\tstr += line.substring(\n\t\t\t\tlengthGetColumnCountIfZeroLineCount(offset),\n\t\t\t\tlengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length))\n\t\t\t);\n\t\t} else if (node.kind === AstNodeKind.List) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\tprocessNode(child, offset);\n\t\t\t\toffset = lengthAdd(offset, child.length);\n\t\t\t}\n\t\t}\n\t}\n\n\tprocessNode(node, lengthZero);\n\n\treturn str;\n}\n\nclass StaticTokenizerSource implements ITokenizerSource {\n\tconstructor(private readonly lines: IViewLineTokens[]) { }\n\tgetLineCount(): number {\n\t\treturn this.lines.length;\n\t}\n\tgetLineLength(lineNumber: number): number {\n\t\treturn this.lines[lineNumber - 1].getLineContent().length;\n\t}\n\n\ttokenization = {\n\t\tgetLineTokens: (lineNumber: number): IViewLineTokens => {\n\t\t\treturn this.lines[lineNumber - 1];\n\t\t}\n\t};\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 13793, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/model/mirrorTextModel.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/model/vs/editor/common/model/mirrorTextModel.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splitLines } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { IRange } from '../core/range.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\n\nexport interface IModelContentChange {\n\t/**\n\t * The old range that got replaced.\n\t */\n\treadonly range: IRange;\n\t/**\n\t * The offset of the range that got replaced.\n\t */\n\treadonly rangeOffset: number;\n\t/**\n\t * The length of the range that got replaced.\n\t */\n\treadonly rangeLength: number;\n\t/**\n\t * The new text for the range.\n\t */\n\treadonly text: string;\n}\n\nexport interface IModelChangedEvent {\n\t/**\n\t * The actual changes.\n\t */\n\treadonly changes: IModelContentChange[];\n\t/**\n\t * The (new) end-of-line character.\n\t */\n\treadonly eol: string;\n\t/**\n\t * The new version id the model has transitioned to.\n\t */\n\treadonly versionId: number;\n}\n\nexport interface IMirrorTextModel {\n\treadonly version: number;\n}\n\nexport class MirrorTextModel implements IMirrorTextModel {\n\n\tprotected _uri: URI;\n\tprotected _lines: string[];\n\tprotected _eol: string;\n\tprotected _versionId: number;\n\tprotected _lineStarts: PrefixSumComputer | null;\n\tprivate _cachedTextValue: string | null;\n\n\tconstructor(uri: URI, lines: string[], eol: string, versionId: number) {\n\t\tthis._uri = uri;\n\t\tthis._lines = lines;\n\t\tthis._eol = eol;\n\t\tthis._versionId = versionId;\n\t\tthis._lineStarts = null;\n\t\tthis._cachedTextValue = null;\n\t}\n\n\tdispose(): void {\n\t\tthis._lines.length = 0;\n\t}\n\n\tget version(): number {\n\t\treturn this._versionId;\n\t}\n\n\tgetText(): string {\n\t\tif (this._cachedTextValue === null) {\n\t\t\tthis._cachedTextValue = this._lines.join(this._eol);\n\t\t}\n\t\treturn this._cachedTextValue;\n\t}\n\n\tonEvents(e: IModelChangedEvent): void {\n\t\tif (e.eol && e.eol !== this._eol) {\n\t\t\tthis._eol = e.eol;\n\t\t\tthis._lineStarts = null;\n\t\t}\n\n\t\t// Update my lines\n\t\tconst changes = e.changes;\n\t\tfor (const change of changes) {\n\t\t\tthis._acceptDeleteRange(change.range);\n\t\t\tthis._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n\t\t}\n\n\t\tthis._versionId = e.versionId;\n\t\tthis._cachedTextValue = null;\n\t}\n\n\tprotected _ensureLineStarts(): void {\n\t\tif (!this._lineStarts) {\n\t\t\tconst eolLength = this._eol.length;\n\t\t\tconst linesLength = this._lines.length;\n\t\t\tconst lineStartValues = new Uint32Array(linesLength);\n\t\t\tfor (let i = 0; i < linesLength; i++) {\n\t\t\t\tlineStartValues[i] = this._lines[i].length + eolLength;\n\t\t\t}\n\t\t\tthis._lineStarts = new PrefixSumComputer(lineStartValues);\n\t\t}\n\t}\n\n\t/**\n\t * All changes to a line's text go through this method\n\t */\n\tprivate _setLineText(lineIndex: number, newValue: string): void {\n\t\tthis._lines[lineIndex] = newValue;\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n\t\t}\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Delete text on the affected line\n\t\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t\t+ this._lines[range.startLineNumber - 1].substring(range.endColumn - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t+ this._lines[range.endLineNumber - 1].substring(range.endColumn - 1)\n\t\t);\n\n\t\t// Delete middle lines\n\t\tthis._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, insertText: string): void {\n\t\tif (insertText.length === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\t\tconst insertLines = splitLines(insertText);\n\t\tif (insertLines.length === 1) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t\t+ insertLines[0]\n\t\t\t\t+ this._lines[position.lineNumber - 1].substring(position.column - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Append overflowing text from first line to the end of text to insert\n\t\tinsertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n\n\t\t// Delete overflowing text from first line and insert text on first line\n\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t+ insertLines[0]\n\t\t);\n\n\t\t// Insert new lines & store lengths\n\t\tconst newLengths = new Uint32Array(insertLines.length - 1);\n\t\tfor (let i = 1; i < insertLines.length; i++) {\n\t\t\tthis._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n\t\t\tnewLengths[i - 1] = insertLines[i].length + this._eol.length;\n\t\t}\n\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.insertValues(position.lineNumber, newLengths);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { splitLines } from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { IRange } from '../core/range.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\n\nexport interface IModelContentChange {\n\t/**\n\t * The old range that got replaced.\n\t */\n\treadonly range: IRange;\n\t/**\n\t * The offset of the range that got replaced.\n\t */\n\treadonly rangeOffset: number;\n\t/**\n\t * The length of the range that got replaced.\n\t */\n\treadonly rangeLength: number;\n\t/**\n\t * The new text for the range.\n\t */\n\treadonly text: string;\n}\n\nexport interface IModelChangedEvent {\n\t/**\n\t * The actual changes.\n\t */\n\treadonly changes: IModelContentChange[];\n\t/**\n\t * The (new) end-of-line character.\n\t */\n\treadonly eol: string;\n\t/**\n\t * The new version id the model has transitioned to.\n\t */\n\treadonly versionId: number;\n}\n\nexport interface IMirrorTextModel {\n\treadonly version: number;\n}\n\nexport class MirrorTextModel implements IMirrorTextModel {\n\n\tprotected _uri: URI;\n\tprotected _lines: string[];\n\tprotected _eol: string;\n\tprotected _versionId: number;\n\tprotected _lineStarts: PrefixSumComputer | null;\n\tprivate _cachedTextValue: string | null;\n\n\tconstructor(uri: URI, lines: string[], eol: string, versionId: number) {\n\t\tthis._uri = uri;\n\t\tthis._lines = lines;\n\t\tthis._eol = eol;\n\t\tthis._versionId = versionId;\n\t\tthis._lineStarts = null;\n\t\tthis._cachedTextValue = null;\n\t}\n\n\tdispose(): void {\n\t\tthis._lines.length = 0;\n\t}\n\n\tget version(): number {\n\t\treturn this._versionId;\n\t}\n\n\tgetText(): string {\n\t\tif (this._cachedTextValue === null) {\n\t\t\tthis._cachedTextValue = this._lines.join(this._eol);\n\t\t}\n\t\treturn this._cachedTextValue;\n\t}\n\n\tonEvents(e: IModelChangedEvent): void {\n\t\tif (e.eol && e.eol !== this._eol) {\n\t\t\tthis._eol = e.eol;\n\t\t\tthis._lineStarts = null;\n\t\t}\n\n\t\t// Update my lines\n\t\tconst changes = e.changes;\n\t\tfor (const change of changes) {\n\t\t\tthis._acceptDeleteRange(change.range);\n\t\t\tthis._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n\t\t}\n\n\t\tthis._versionId = e.versionId;\n\t\tthis._cachedTextValue = null;\n\t}\n\n\tprotected _ensureLineStarts(): void {\n\t\tif (!this._lineStarts) {\n\t\t\tconst eolLength = this._eol.length;\n\t\t\tconst linesLength = this._lines.length;\n\t\t\tconst lineStartValues = new Uint32Array(linesLength);\n\t\t\tfor (let i = 0; i < linesLength; i++) {\n\t\t\t\tlineStartValues[i] = this._lines[i].length + eolLength;\n\t\t\t}\n\t\t\tthis._lineStarts = new PrefixSumComputer(lineStartValues);\n\t\t}\n\t}\n\n\t/**\n\t * All changes to a line's text go through this method\n\t */\n\tprivate _setLineText(lineIndex: number, newValue: string): void {\n\t\tthis._lines[lineIndex] = newValue;\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n\t\t}\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Delete text on the affected line\n\t\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t\t+ this._lines[range.startLineNumber - 1].substring(range.endColumn - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t+ this._lines[range.endLineNumber - 1].substring(range.endColumn - 1)\n\t\t);\n\n\t\t// Delete middle lines\n\t\tthis._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, insertText: string): void {\n\t\tif (insertText.length === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\t\tconst insertLines = splitLines(insertText);\n\t\tif (insertLines.length === 1) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t\t+ insertLines[0]\n\t\t\t\t+ this._lines[position.lineNumber - 1].substring(position.column - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Append overflowing text from first line to the end of text to insert\n\t\tinsertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n\n\t\t// Delete overflowing text from first line and insert text on first line\n\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t+ insertLines[0]\n\t\t);\n\n\t\t// Insert new lines & store lengths\n\t\tconst newLengths = new Uint32Array(insertLines.length - 1);\n\t\tfor (let i = 1; i < insertLines.length; i++) {\n\t\t\tthis._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n\t\t\tnewLengths[i - 1] = insertLines[i].length + this._eol.length;\n\t\t}\n\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.insertValues(position.lineNumber, newLengths);\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}