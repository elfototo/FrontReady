{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/rangeMapping.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/vs/editor/common/diff/rangeMapping.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { groupAdjacentBy } from '../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TextReplacement, TextEdit } from '../core/edits/textEdit.js';\nimport { AbstractText } from '../core/text/abstractText.js';\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n\tpublic static inverse(mapping: readonly LineRangeMapping[], originalLineCount: number, modifiedLineCount: number): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tlet lastOriginalEndLineNumber = 1;\n\t\tlet lastModifiedEndLineNumber = 1;\n\n\t\tfor (const m of mapping) {\n\t\t\tconst r = new LineRangeMapping(\n\t\t\t\tnew LineRange(lastOriginalEndLineNumber, m.original.startLineNumber),\n\t\t\t\tnew LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber),\n\t\t\t);\n\t\t\tif (!r.modified.isEmpty) {\n\t\t\t\tresult.push(r);\n\t\t\t}\n\t\t\tlastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n\t\t\tlastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n\t\t}\n\t\tconst r = new LineRangeMapping(\n\t\t\tnew LineRange(lastOriginalEndLineNumber, originalLineCount + 1),\n\t\t\tnew LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1),\n\t\t);\n\t\tif (!r.modified.isEmpty) {\n\t\t\tresult.push(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static clip(mapping: readonly LineRangeMapping[], originalRange: LineRange, modifiedRange: LineRange): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tconst original = m.original.intersect(originalRange);\n\t\t\tconst modified = m.modified.intersect(modifiedRange);\n\t\t\tif (original && !original.isEmpty && modified && !modified.isEmpty) {\n\t\t\t\tresult.push(new LineRangeMapping(original, modified));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The line range in the original text model.\n\t */\n\tpublic readonly original: LineRange;\n\n\t/**\n\t * The line range in the modified text model.\n\t */\n\tpublic readonly modified: LineRange;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange\n\t) {\n\t\tthis.original = originalRange;\n\t\tthis.modified = modifiedRange;\n\t}\n\n\n\tpublic toString(): string {\n\t\treturn `{${this.original.toString()}->${this.modified.toString()}}`;\n\t}\n\n\tpublic flip(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.modified, this.original);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.original.join(other.original),\n\t\t\tthis.modified.join(other.modified)\n\t\t);\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping(): RangeMapping {\n\t\tconst origInclusiveRange = this.original.toInclusiveRange();\n\t\tconst modInclusiveRange = this.modified.toInclusiveRange();\n\t\tif (origInclusiveRange && modInclusiveRange) {\n\t\t\treturn new RangeMapping(origInclusiveRange, modInclusiveRange);\n\t\t} else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n\t\t\tif (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n\t\t\t\t// If one line range starts at 1, the other one must start at 1 as well.\n\t\t\t\tthrow new BugIndicatingError('not a valid diff');\n\t\t\t}\n\n\t\t\t// Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n\t\t\t// Thus, `endLineNumberExclusive` is a valid line number.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t} else {\n\t\t\t// We can assume here that both startLineNumbers are greater than 1.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t\tnew Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping2(original: string[], modified: string[]): RangeMapping {\n\t\tif (isValidLineNumber(this.original.endLineNumberExclusive, original)\n\t\t\t&& isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t}\n\n\t\tif (!this.original.isEmpty && !this.modified.isEmpty) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.original.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.modified.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n\t\t// I don't think this can happen.\n\n\t\tthrow new BugIndicatingError();\n\t}\n}\n\nfunction normalizePosition(position: Position, content: string[]): Position {\n\tif (position.lineNumber < 1) {\n\t\treturn new Position(1, 1);\n\t}\n\tif (position.lineNumber > content.length) {\n\t\treturn new Position(content.length, content[content.length - 1].length + 1);\n\t}\n\tconst line = content[position.lineNumber - 1];\n\tif (position.column > line.length + 1) {\n\t\treturn new Position(position.lineNumber, line.length + 1);\n\t}\n\treturn position;\n}\n\nfunction isValidLineNumber(lineNumber: number, lines: string[]): boolean {\n\treturn lineNumber >= 1 && lineNumber <= lines.length;\n}\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\n\tpublic static fromRangeMappings(rangeMappings: RangeMapping[]): DetailedLineRangeMapping {\n\t\tconst originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n\t\tconst modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n\t\treturn new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n\t}\n\n\t/**\n\t * If inner changes have not been computed, this is set to undefined.\n\t * Otherwise, it represents the character-level diff in this line range.\n\t * The original range of each range mapping should be contained in the original line range (same for modified), exceptions are new-lines.\n\t * Must not be an empty array.\n\t */\n\tpublic readonly innerChanges: RangeMapping[] | undefined;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange,\n\t\tinnerChanges: RangeMapping[] | undefined\n\t) {\n\t\tsuper(originalRange, modifiedRange);\n\t\tthis.innerChanges = innerChanges;\n\t}\n\n\tpublic override flip(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n\t}\n\n\tpublic withInnerChangesFromLineRanges(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n\t}\n}\n\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n\tpublic static fromEdit(edit: TextEdit): RangeMapping[] {\n\t\tconst newRanges = edit.getNewRanges();\n\t\tconst result = edit.replacements.map((e, idx) => new RangeMapping(e.range, newRanges[idx]));\n\t\treturn result;\n\t}\n\n\tpublic static assertSorted(rangeMappings: RangeMapping[]): void {\n\t\tfor (let i = 1; i < rangeMappings.length; i++) {\n\t\t\tconst previous = rangeMappings[i - 1];\n\t\t\tconst current = rangeMappings[i];\n\t\t\tif (!(\n\t\t\t\tprevious.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n\t\t\t\t&& previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition())\n\t\t\t)) {\n\t\t\t\tthrow new BugIndicatingError('Range mappings must be sorted');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The original range.\n\t */\n\treadonly originalRange: Range;\n\n\t/**\n\t * The modified range.\n\t */\n\treadonly modifiedRange: Range;\n\n\tconstructor(\n\t\toriginalRange: Range,\n\t\tmodifiedRange: Range\n\t) {\n\t\tthis.originalRange = originalRange;\n\t\tthis.modifiedRange = modifiedRange;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n\t}\n\n\tpublic flip(): RangeMapping {\n\t\treturn new RangeMapping(this.modifiedRange, this.originalRange);\n\t}\n\n\t/**\n\t * Creates a single text edit that describes the change from the original to the modified text.\n\t*/\n\tpublic toTextEdit(modified: AbstractText): TextReplacement {\n\t\tconst newText = modified.getValueOfRange(this.modifiedRange);\n\t\treturn new TextReplacement(this.originalRange, newText);\n\t}\n}\n\nexport function lineRangeMappingFromRangeMappings(alignments: readonly RangeMapping[], originalLines: AbstractText, modifiedLines: AbstractText, dontAssertStartLine: boolean = false): DetailedLineRangeMapping[] {\n\tconst changes: DetailedLineRangeMapping[] = [];\n\tfor (const g of groupAdjacentBy(\n\t\talignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)),\n\t\t(a1, a2) =>\n\t\t\ta1.original.intersectsOrTouches(a2.original)\n\t\t\t|| a1.modified.intersectsOrTouches(a2.modified)\n\t)) {\n\t\tconst first = g[0];\n\t\tconst last = g[g.length - 1];\n\n\t\tchanges.push(new DetailedLineRangeMapping(\n\t\t\tfirst.original.join(last.original),\n\t\t\tfirst.modified.join(last.modified),\n\t\t\tg.map(a => a.innerChanges![0]),\n\t\t));\n\t}\n\n\tassertFn(() => {\n\t\tif (!dontAssertStartLine && changes.length > 0) {\n\t\t\tif (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (modifiedLines.length.lineCount - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length.lineCount - changes[changes.length - 1].original.endLineNumberExclusive) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn checkAdjacentItems(changes,\n\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t);\n\t});\n\n\treturn changes;\n}\n\nexport function getLineRangeMapping(rangeMapping: RangeMapping, originalLines: AbstractText, modifiedLines: AbstractText): DetailedLineRangeMapping {\n\tlet lineStartDelta = 0;\n\tlet lineEndDelta = 0;\n\n\t// rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n\n\t// original: ]xxx \\n <- this line is not modified\n\t// modified: ]xx  \\n\n\tif (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n\t\t&& rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n\t\t&& rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineEndDelta = -1;\n\t}\n\n\t// original: xxx[ \\n <- this line is not modified\n\t// modified: xxx[ \\n\n\tif (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines.getLineLength(rangeMapping.modifiedRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startColumn - 1 >= originalLines.getLineLength(rangeMapping.originalRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n\t\t&& rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineStartDelta = 1;\n\t}\n\n\tconst originalLineRange = new LineRange(\n\t\trangeMapping.originalRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.originalRange.endLineNumber + 1 + lineEndDelta\n\t);\n\tconst modifiedLineRange = new LineRange(\n\t\trangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta\n\t);\n\n\treturn new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { groupAdjacentBy } from '../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TextReplacement, TextEdit } from '../core/edits/textEdit.js';\nimport { AbstractText } from '../core/text/abstractText.js';\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n\tpublic static inverse(mapping: readonly LineRangeMapping[], originalLineCount: number, modifiedLineCount: number): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tlet lastOriginalEndLineNumber = 1;\n\t\tlet lastModifiedEndLineNumber = 1;\n\n\t\tfor (const m of mapping) {\n\t\t\tconst r = new LineRangeMapping(\n\t\t\t\tnew LineRange(lastOriginalEndLineNumber, m.original.startLineNumber),\n\t\t\t\tnew LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber),\n\t\t\t);\n\t\t\tif (!r.modified.isEmpty) {\n\t\t\t\tresult.push(r);\n\t\t\t}\n\t\t\tlastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n\t\t\tlastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n\t\t}\n\t\tconst r = new LineRangeMapping(\n\t\t\tnew LineRange(lastOriginalEndLineNumber, originalLineCount + 1),\n\t\t\tnew LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1),\n\t\t);\n\t\tif (!r.modified.isEmpty) {\n\t\t\tresult.push(r);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static clip(mapping: readonly LineRangeMapping[], originalRange: LineRange, modifiedRange: LineRange): LineRangeMapping[] {\n\t\tconst result: LineRangeMapping[] = [];\n\t\tfor (const m of mapping) {\n\t\t\tconst original = m.original.intersect(originalRange);\n\t\t\tconst modified = m.modified.intersect(modifiedRange);\n\t\t\tif (original && !original.isEmpty && modified && !modified.isEmpty) {\n\t\t\t\tresult.push(new LineRangeMapping(original, modified));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * The line range in the original text model.\n\t */\n\tpublic readonly original: LineRange;\n\n\t/**\n\t * The line range in the modified text model.\n\t */\n\tpublic readonly modified: LineRange;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange\n\t) {\n\t\tthis.original = originalRange;\n\t\tthis.modified = modifiedRange;\n\t}\n\n\n\tpublic toString(): string {\n\t\treturn `{${this.original.toString()}->${this.modified.toString()}}`;\n\t}\n\n\tpublic flip(): LineRangeMapping {\n\t\treturn new LineRangeMapping(this.modified, this.original);\n\t}\n\n\tpublic join(other: LineRangeMapping): LineRangeMapping {\n\t\treturn new LineRangeMapping(\n\t\t\tthis.original.join(other.original),\n\t\t\tthis.modified.join(other.modified)\n\t\t);\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping(): RangeMapping {\n\t\tconst origInclusiveRange = this.original.toInclusiveRange();\n\t\tconst modInclusiveRange = this.modified.toInclusiveRange();\n\t\tif (origInclusiveRange && modInclusiveRange) {\n\t\t\treturn new RangeMapping(origInclusiveRange, modInclusiveRange);\n\t\t} else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n\t\t\tif (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n\t\t\t\t// If one line range starts at 1, the other one must start at 1 as well.\n\t\t\t\tthrow new BugIndicatingError('not a valid diff');\n\t\t\t}\n\n\t\t\t// Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n\t\t\t// Thus, `endLineNumberExclusive` is a valid line number.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t} else {\n\t\t\t// We can assume here that both startLineNumbers are greater than 1.\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t\tnew Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER),\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * This method assumes that the LineRangeMapping describes a valid diff!\n\t * I.e. if one range is empty, the other range cannot be the entire document.\n\t * It avoids various problems when the line range points to non-existing line-numbers.\n\t*/\n\tpublic toRangeMapping2(original: string[], modified: string[]): RangeMapping {\n\t\tif (isValidLineNumber(this.original.endLineNumberExclusive, original)\n\t\t\t&& isValidLineNumber(this.modified.endLineNumberExclusive, modified)) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tnew Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1),\n\t\t\t\tnew Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1),\n\t\t\t);\n\t\t}\n\n\t\tif (!this.original.isEmpty && !this.modified.isEmpty) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.original.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnew Position(this.modified.startLineNumber, 1),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\tif (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1) {\n\t\t\treturn new RangeMapping(\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), original),\n\t\t\t\t\tnormalizePosition(new Position(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), original)\n\t\t\t\t),\n\t\t\t\tRange.fromPositions(\n\t\t\t\t\tnormalizePosition(new Position(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), modified),\n\t\t\t\t\tnormalizePosition(new Position(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), modified)\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Situation now: one range is empty and one range touches the last line and one range starts at line 1.\n\t\t// I don't think this can happen.\n\n\t\tthrow new BugIndicatingError();\n\t}\n}\n\nfunction normalizePosition(position: Position, content: string[]): Position {\n\tif (position.lineNumber < 1) {\n\t\treturn new Position(1, 1);\n\t}\n\tif (position.lineNumber > content.length) {\n\t\treturn new Position(content.length, content[content.length - 1].length + 1);\n\t}\n\tconst line = content[position.lineNumber - 1];\n\tif (position.column > line.length + 1) {\n\t\treturn new Position(position.lineNumber, line.length + 1);\n\t}\n\treturn position;\n}\n\nfunction isValidLineNumber(lineNumber: number, lines: string[]): boolean {\n\treturn lineNumber >= 1 && lineNumber <= lines.length;\n}\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nexport class DetailedLineRangeMapping extends LineRangeMapping {\n\n\tpublic static fromRangeMappings(rangeMappings: RangeMapping[]): DetailedLineRangeMapping {\n\t\tconst originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n\t\tconst modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n\t\treturn new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n\t}\n\n\t/**\n\t * If inner changes have not been computed, this is set to undefined.\n\t * Otherwise, it represents the character-level diff in this line range.\n\t * The original range of each range mapping should be contained in the original line range (same for modified), exceptions are new-lines.\n\t * Must not be an empty array.\n\t */\n\tpublic readonly innerChanges: RangeMapping[] | undefined;\n\n\tconstructor(\n\t\toriginalRange: LineRange,\n\t\tmodifiedRange: LineRange,\n\t\tinnerChanges: RangeMapping[] | undefined\n\t) {\n\t\tsuper(originalRange, modifiedRange);\n\t\tthis.innerChanges = innerChanges;\n\t}\n\n\tpublic override flip(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip()));\n\t}\n\n\tpublic withInnerChangesFromLineRanges(): DetailedLineRangeMapping {\n\t\treturn new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n\t}\n}\n\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n\tpublic static fromEdit(edit: TextEdit): RangeMapping[] {\n\t\tconst newRanges = edit.getNewRanges();\n\t\tconst result = edit.replacements.map((e, idx) => new RangeMapping(e.range, newRanges[idx]));\n\t\treturn result;\n\t}\n\n\tpublic static assertSorted(rangeMappings: RangeMapping[]): void {\n\t\tfor (let i = 1; i < rangeMappings.length; i++) {\n\t\t\tconst previous = rangeMappings[i - 1];\n\t\t\tconst current = rangeMappings[i];\n\t\t\tif (!(\n\t\t\t\tprevious.originalRange.getEndPosition().isBeforeOrEqual(current.originalRange.getStartPosition())\n\t\t\t\t&& previous.modifiedRange.getEndPosition().isBeforeOrEqual(current.modifiedRange.getStartPosition())\n\t\t\t)) {\n\t\t\t\tthrow new BugIndicatingError('Range mappings must be sorted');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The original range.\n\t */\n\treadonly originalRange: Range;\n\n\t/**\n\t * The modified range.\n\t */\n\treadonly modifiedRange: Range;\n\n\tconstructor(\n\t\toriginalRange: Range,\n\t\tmodifiedRange: Range\n\t) {\n\t\tthis.originalRange = originalRange;\n\t\tthis.modifiedRange = modifiedRange;\n\t}\n\n\tpublic toString(): string {\n\t\treturn `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n\t}\n\n\tpublic flip(): RangeMapping {\n\t\treturn new RangeMapping(this.modifiedRange, this.originalRange);\n\t}\n\n\t/**\n\t * Creates a single text edit that describes the change from the original to the modified text.\n\t*/\n\tpublic toTextEdit(modified: AbstractText): TextReplacement {\n\t\tconst newText = modified.getValueOfRange(this.modifiedRange);\n\t\treturn new TextReplacement(this.originalRange, newText);\n\t}\n}\n\nexport function lineRangeMappingFromRangeMappings(alignments: readonly RangeMapping[], originalLines: AbstractText, modifiedLines: AbstractText, dontAssertStartLine: boolean = false): DetailedLineRangeMapping[] {\n\tconst changes: DetailedLineRangeMapping[] = [];\n\tfor (const g of groupAdjacentBy(\n\t\talignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)),\n\t\t(a1, a2) =>\n\t\t\ta1.original.intersectsOrTouches(a2.original)\n\t\t\t|| a1.modified.intersectsOrTouches(a2.modified)\n\t)) {\n\t\tconst first = g[0];\n\t\tconst last = g[g.length - 1];\n\n\t\tchanges.push(new DetailedLineRangeMapping(\n\t\t\tfirst.original.join(last.original),\n\t\t\tfirst.modified.join(last.modified),\n\t\t\tg.map(a => a.innerChanges![0]),\n\t\t));\n\t}\n\n\tassertFn(() => {\n\t\tif (!dontAssertStartLine && changes.length > 0) {\n\t\t\tif (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (modifiedLines.length.lineCount - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length.lineCount - changes[changes.length - 1].original.endLineNumberExclusive) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn checkAdjacentItems(changes,\n\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t);\n\t});\n\n\treturn changes;\n}\n\nexport function getLineRangeMapping(rangeMapping: RangeMapping, originalLines: AbstractText, modifiedLines: AbstractText): DetailedLineRangeMapping {\n\tlet lineStartDelta = 0;\n\tlet lineEndDelta = 0;\n\n\t// rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n\n\t// original: ]xxx \\n <- this line is not modified\n\t// modified: ]xx  \\n\n\tif (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n\t\t&& rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n\t\t&& rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineEndDelta = -1;\n\t}\n\n\t// original: xxx[ \\n <- this line is not modified\n\t// modified: xxx[ \\n\n\tif (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines.getLineLength(rangeMapping.modifiedRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startColumn - 1 >= originalLines.getLineLength(rangeMapping.originalRange.startLineNumber)\n\t\t&& rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n\t\t&& rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n\t\t// We can only do this if the range is not empty yet\n\t\tlineStartDelta = 1;\n\t}\n\n\tconst originalLineRange = new LineRange(\n\t\trangeMapping.originalRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.originalRange.endLineNumber + 1 + lineEndDelta\n\t);\n\tconst modifiedLineRange = new LineRange(\n\t\trangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n\t\trangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta\n\t);\n\n\treturn new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/linesDiffComputer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/vs/editor/common/diff/linesDiffComputer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DetailedLineRangeMapping, LineRangeMapping } from './rangeMapping.js';\n\nexport interface ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff;\n}\n\nexport interface ILinesDiffComputerOptions {\n\treadonly ignoreTrimWhitespace: boolean;\n\treadonly maxComputationTimeMs: number;\n\treadonly computeMoves: boolean;\n\treadonly extendToSubwords?: boolean;\n}\n\nexport class LinesDiff {\n\tconstructor(\n\t\treadonly changes: readonly DetailedLineRangeMapping[],\n\n\t\t/**\n\t\t * Sorted by original line ranges.\n\t\t * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n\t\t */\n\t\treadonly moves: readonly MovedText[],\n\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\treadonly hitTimeout: boolean,\n\t) {\n\t}\n}\n\nexport class MovedText {\n\tpublic readonly lineRangeMapping: LineRangeMapping;\n\n\t/**\n\t * The diff from the original text to the moved text.\n\t * Must be contained in the original/modified line range.\n\t * Can be empty if the text didn't change (only moved).\n\t */\n\tpublic readonly changes: readonly DetailedLineRangeMapping[];\n\n\tconstructor(\n\t\tlineRangeMapping: LineRangeMapping,\n\t\tchanges: readonly DetailedLineRangeMapping[],\n\t) {\n\t\tthis.lineRangeMapping = lineRangeMapping;\n\t\tthis.changes = changes;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DetailedLineRangeMapping, LineRangeMapping } from './rangeMapping.js';\n\nexport interface ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff;\n}\n\nexport interface ILinesDiffComputerOptions {\n\treadonly ignoreTrimWhitespace: boolean;\n\treadonly maxComputationTimeMs: number;\n\treadonly computeMoves: boolean;\n\treadonly extendToSubwords?: boolean;\n}\n\nexport class LinesDiff {\n\tconstructor(\n\t\treadonly changes: readonly DetailedLineRangeMapping[],\n\n\t\t/**\n\t\t * Sorted by original line ranges.\n\t\t * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n\t\t */\n\t\treadonly moves: readonly MovedText[],\n\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\treadonly hitTimeout: boolean,\n\t) {\n\t}\n}\n\nexport class MovedText {\n\tpublic readonly lineRangeMapping: LineRangeMapping;\n\n\t/**\n\t * The diff from the original text to the moved text.\n\t * Must be contained in the original/modified line range.\n\t * Can be empty if the text didn't change (only moved).\n\t */\n\tpublic readonly changes: readonly DetailedLineRangeMapping[];\n\n\tconstructor(\n\t\tlineRangeMapping: LineRangeMapping,\n\t\tchanges: readonly DetailedLineRangeMapping[],\n\t) {\n\t\tthis.lineRangeMapping = lineRangeMapping;\n\t\tthis.changes = changes;\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;AAe1F,MAAO,SAAS;IACrB,YACU,OAA4C,EAErD;;;OAGG,CACM,KAA2B,EAEpC;;;OAGG,CACM,UAAmB,CAAA;QAZnB,IAAA,CAAA,OAAO,GAAP,OAAO,CAAqC;QAM5C,IAAA,CAAA,KAAK,GAAL,KAAK,CAAsB;QAM3B,IAAA,CAAA,UAAU,GAAV,UAAU,CAAS;IAE7B,CAAC;CACD;AAEK,MAAO,SAAS;IAUrB,YACC,gBAAkC,EAClC,OAA4C,CAAA;QAE5C,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACxB,CAAC;CACD","debugId":null}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\n\n/**\n * Represents a synchronous diff algorithm. Should be executed in a worker.\n*/\nexport interface IDiffAlgorithm {\n}\n\nexport class DiffAlgorithmResult {\n\tstatic trivial(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n\t}\n\n\tstatic trivialTimedOut(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n\t}\n\n\tconstructor(\n\t\tpublic readonly diffs: SequenceDiff[],\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\tpublic readonly hitTimeout: boolean,\n\t) { }\n}\n\nexport class SequenceDiff {\n\tpublic static invert(sequenceDiffs: SequenceDiff[], doc1Length: number): SequenceDiff[] {\n\t\tconst result: SequenceDiff[] = [];\n\t\tforEachAdjacent(sequenceDiffs, (a, b) => {\n\t\t\tresult.push(SequenceDiff.fromOffsetPairs(\n\t\t\t\ta ? a.getEndExclusives() : OffsetPair.zero,\n\t\t\t\tb ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)\n\t\t\t));\n\t\t});\n\t\treturn result;\n\t}\n\n\tpublic static fromOffsetPairs(start: OffsetPair, endExclusive: OffsetPair): SequenceDiff {\n\t\treturn new SequenceDiff(\n\t\t\tnew OffsetRange(start.offset1, endExclusive.offset1),\n\t\t\tnew OffsetRange(start.offset2, endExclusive.offset2),\n\t\t);\n\t}\n\n\tpublic static assertSorted(sequenceDiffs: SequenceDiff[]): void {\n\t\tlet last: SequenceDiff | undefined = undefined;\n\t\tfor (const cur of sequenceDiffs) {\n\t\t\tif (last) {\n\t\t\t\tif (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {\n\t\t\t\t\tthrow new BugIndicatingError('Sequence diffs must be sorted');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = cur;\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly seq1Range: OffsetRange,\n\t\tpublic readonly seq2Range: OffsetRange,\n\t) { }\n\n\tpublic swap(): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq2Range, this.seq1Range);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.seq1Range} <-> ${this.seq2Range}`;\n\t}\n\n\tpublic join(other: SequenceDiff): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n\t}\n\n\tpublic delta(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n\t}\n\n\tpublic deltaStart(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n\t}\n\n\tpublic deltaEnd(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n\t}\n\n\tpublic intersect(other: SequenceDiff): SequenceDiff | undefined {\n\t\tconst i1 = this.seq1Range.intersect(other.seq1Range);\n\t\tconst i2 = this.seq2Range.intersect(other.seq2Range);\n\t\tif (!i1 || !i2) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new SequenceDiff(i1, i2);\n\t}\n\n\tpublic getStarts(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n\t}\n\n\tpublic getEndExclusives(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n\t}\n}\n\nexport class OffsetPair {\n\tpublic static readonly zero = new OffsetPair(0, 0);\n\tpublic static readonly max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n\n\tconstructor(\n\t\tpublic readonly offset1: number,\n\t\tpublic readonly offset2: number,\n\t) {\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.offset1} <-> ${this.offset2}`;\n\t}\n\n\tpublic delta(offset: number): OffsetPair {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n\t}\n\n\tpublic equals(other: OffsetPair): boolean {\n\t\treturn this.offset1 === other.offset1 && this.offset2 === other.offset2;\n\t}\n}\n\nexport interface ISequence {\n\tgetElement(offset: number): number;\n\tget length(): number;\n\n\t/**\n\t * The higher the score, the better that offset can be used to split the sequence.\n\t * Is used to optimize insertions.\n\t * Must not be negative.\n\t*/\n\tgetBoundaryScore?(length: number): number;\n\n\t/**\n\t * For line sequences, getElement returns a number representing trimmed lines.\n\t * This however checks equality for the original lines.\n\t * It prevents shifting to less matching lines.\n\t */\n\tisStronglyEqual(offset1: number, offset2: number): boolean;\n}\n\nexport interface ITimeout {\n\tisValid(): boolean;\n}\n\nexport class InfiniteTimeout implements ITimeout {\n\tpublic static instance = new InfiniteTimeout();\n\n\tisValid(): boolean {\n\t\treturn true;\n\t}\n}\n\nexport class DateTimeout implements ITimeout {\n\tprivate readonly startTime = Date.now();\n\tprivate valid = true;\n\n\tconstructor(private timeout: number) {\n\t\tif (timeout <= 0) {\n\t\t\tthrow new BugIndicatingError('timeout must be positive');\n\t\t}\n\t}\n\n\t// Recommendation: Set a log-point `{this.disable()}` in the body\n\tpublic isValid(): boolean {\n\t\tconst valid = Date.now() - this.startTime < this.timeout;\n\t\tif (!valid && this.valid) {\n\t\t\tthis.valid = false; // timeout reached\n\t\t}\n\t\treturn this.valid;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\n\n/**\n * Represents a synchronous diff algorithm. Should be executed in a worker.\n*/\nexport interface IDiffAlgorithm {\n}\n\nexport class DiffAlgorithmResult {\n\tstatic trivial(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n\t}\n\n\tstatic trivialTimedOut(seq1: ISequence, seq2: ISequence): DiffAlgorithmResult {\n\t\treturn new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n\t}\n\n\tconstructor(\n\t\tpublic readonly diffs: SequenceDiff[],\n\t\t/**\n\t\t * Indicates if the time out was reached.\n\t\t * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n\t\t */\n\t\tpublic readonly hitTimeout: boolean,\n\t) { }\n}\n\nexport class SequenceDiff {\n\tpublic static invert(sequenceDiffs: SequenceDiff[], doc1Length: number): SequenceDiff[] {\n\t\tconst result: SequenceDiff[] = [];\n\t\tforEachAdjacent(sequenceDiffs, (a, b) => {\n\t\t\tresult.push(SequenceDiff.fromOffsetPairs(\n\t\t\t\ta ? a.getEndExclusives() : OffsetPair.zero,\n\t\t\t\tb ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)\n\t\t\t));\n\t\t});\n\t\treturn result;\n\t}\n\n\tpublic static fromOffsetPairs(start: OffsetPair, endExclusive: OffsetPair): SequenceDiff {\n\t\treturn new SequenceDiff(\n\t\t\tnew OffsetRange(start.offset1, endExclusive.offset1),\n\t\t\tnew OffsetRange(start.offset2, endExclusive.offset2),\n\t\t);\n\t}\n\n\tpublic static assertSorted(sequenceDiffs: SequenceDiff[]): void {\n\t\tlet last: SequenceDiff | undefined = undefined;\n\t\tfor (const cur of sequenceDiffs) {\n\t\t\tif (last) {\n\t\t\t\tif (!(last.seq1Range.endExclusive <= cur.seq1Range.start && last.seq2Range.endExclusive <= cur.seq2Range.start)) {\n\t\t\t\t\tthrow new BugIndicatingError('Sequence diffs must be sorted');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = cur;\n\t\t}\n\t}\n\n\tconstructor(\n\t\tpublic readonly seq1Range: OffsetRange,\n\t\tpublic readonly seq2Range: OffsetRange,\n\t) { }\n\n\tpublic swap(): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq2Range, this.seq1Range);\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.seq1Range} <-> ${this.seq2Range}`;\n\t}\n\n\tpublic join(other: SequenceDiff): SequenceDiff {\n\t\treturn new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n\t}\n\n\tpublic delta(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n\t}\n\n\tpublic deltaStart(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n\t}\n\n\tpublic deltaEnd(offset: number): SequenceDiff {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n\t}\n\n\tpublic intersect(other: SequenceDiff): SequenceDiff | undefined {\n\t\tconst i1 = this.seq1Range.intersect(other.seq1Range);\n\t\tconst i2 = this.seq2Range.intersect(other.seq2Range);\n\t\tif (!i1 || !i2) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn new SequenceDiff(i1, i2);\n\t}\n\n\tpublic getStarts(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n\t}\n\n\tpublic getEndExclusives(): OffsetPair {\n\t\treturn new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n\t}\n}\n\nexport class OffsetPair {\n\tpublic static readonly zero = new OffsetPair(0, 0);\n\tpublic static readonly max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n\n\tconstructor(\n\t\tpublic readonly offset1: number,\n\t\tpublic readonly offset2: number,\n\t) {\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.offset1} <-> ${this.offset2}`;\n\t}\n\n\tpublic delta(offset: number): OffsetPair {\n\t\tif (offset === 0) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n\t}\n\n\tpublic equals(other: OffsetPair): boolean {\n\t\treturn this.offset1 === other.offset1 && this.offset2 === other.offset2;\n\t}\n}\n\nexport interface ISequence {\n\tgetElement(offset: number): number;\n\tget length(): number;\n\n\t/**\n\t * The higher the score, the better that offset can be used to split the sequence.\n\t * Is used to optimize insertions.\n\t * Must not be negative.\n\t*/\n\tgetBoundaryScore?(length: number): number;\n\n\t/**\n\t * For line sequences, getElement returns a number representing trimmed lines.\n\t * This however checks equality for the original lines.\n\t * It prevents shifting to less matching lines.\n\t */\n\tisStronglyEqual(offset1: number, offset2: number): boolean;\n}\n\nexport interface ITimeout {\n\tisValid(): boolean;\n}\n\nexport class InfiniteTimeout implements ITimeout {\n\tpublic static instance = new InfiniteTimeout();\n\n\tisValid(): boolean {\n\t\treturn true;\n\t}\n}\n\nexport class DateTimeout implements ITimeout {\n\tprivate readonly startTime = Date.now();\n\tprivate valid = true;\n\n\tconstructor(private timeout: number) {\n\t\tif (timeout <= 0) {\n\t\t\tthrow new BugIndicatingError('timeout must be positive');\n\t\t}\n\t}\n\n\t// Recommendation: Set a log-point `{this.disable()}` in the body\n\tpublic isValid(): boolean {\n\t\tconst valid = Date.now() - this.startTime < this.timeout;\n\t\tif (!valid && this.valid) {\n\t\t\tthis.valid = false; // timeout reached\n\t\t}\n\t\treturn this.valid;\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;;;;;;;;AAEhG,OAAO,EAAE,eAAe,EAAE,MAAM,sCAAsC,CAAC;AACvE,OAAO,EAAE,kBAAkB,EAAE,MAAM,sCAAsC,CAAC;AAC1E,OAAO,EAAE,WAAW,EAAE,MAAM,qCAAqC,CAAC;;;;AAQ5D,MAAO,mBAAmB;IAC/B,MAAM,CAAC,OAAO,CAAC,IAAe,EAAE,IAAe,EAAA;QAC9C,OAAO,IAAI,mBAAmB,CAAC;YAAC,IAAI,YAAY,CAAC,oNAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,oNAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAAC,EAAE,KAAK,CAAC,CAAC;IACjI,CAAC;IAED,MAAM,CAAC,eAAe,CAAC,IAAe,EAAE,IAAe,EAAA;QACtD,OAAO,IAAI,mBAAmB,CAAC;YAAC,IAAI,YAAY,CAAC,oNAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,oNAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAAC,EAAE,IAAI,CAAC,CAAC;IAChI,CAAC;IAED,YACiB,KAAqB,EACrC;;;OAGG,CACa,UAAmB,CAAA;QALnB,IAAA,CAAA,KAAK,GAAL,KAAK,CAAgB;QAKrB,IAAA,CAAA,UAAU,GAAV,UAAU,CAAS;IAChC,CAAC;CACL;AAEK,MAAO,YAAY;IACjB,MAAM,CAAC,MAAM,CAAC,aAA6B,EAAE,UAAkB,EAAA;QACrE,MAAM,MAAM,GAAmB,EAAE,CAAC;YAClC,+LAAe,EAAC,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;YACvC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,eAAe,CACvC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,gBAAgB,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,EAC1C,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,IAAI,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,GAAG,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAC1H,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IACf,CAAC;IAEM,MAAM,CAAC,eAAe,CAAC,KAAiB,EAAE,YAAwB,EAAA;QACxE,OAAO,IAAI,YAAY,CACtB,IAAI,oNAAW,CAAC,KAAK,CAAC,OAAO,EAAE,YAAY,CAAC,OAAO,CAAC,EACpD,IAAI,oNAAW,CAAC,KAAK,CAAC,OAAO,EAAE,YAAY,CAAC,OAAO,CAAC,CACpD,CAAC;IACH,CAAC;IAEM,MAAM,CAAC,YAAY,CAAC,aAA6B,EAAA;QACvD,IAAI,IAAI,GAA6B,SAAS,CAAC;QAC/C,KAAK,MAAM,GAAG,IAAI,aAAa,CAAE,CAAC;YACjC,IAAI,IAAI,EAAE,CAAC;gBACV,IAAI,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,GAAG,CAAC,SAAS,CAAC,KAAK,IAAI,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC;oBACjH,MAAM,IAAI,kMAAkB,CAAC,+BAA+B,CAAC,CAAC;gBAC/D,CAAC;YACF,CAAC;YACD,IAAI,GAAG,GAAG,CAAC;QACZ,CAAC;IACF,CAAC;IAOM,IAAI,GAAA;QACV,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;IACzD,CAAC;IAEM,QAAQ,GAAA;QACd,OAAO,GAAyB,OAAtB,IAAI,CAAC,SAAS,EAAA,SAAsB,CAAE,CAAC,SAAb,CAAC,SAAS;IAC/C,CAAC;IAEM,IAAI,CAAC,KAAmB,EAAA;QAC9B,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC;IACrG,CAAC;IAEM,KAAK,CAAC,MAAc,EAAA;QAC1B,IAAI,MAAM,KAAK,CAAC,EAAE,CAAC;YAClB,OAAO,IAAI,CAAC;QACb,CAAC;QACD,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;IACrF,CAAC;IAEM,UAAU,CAAC,MAAc,EAAA;QAC/B,IAAI,MAAM,KAAK,CAAC,EAAE,CAAC;YAClB,OAAO,IAAI,CAAC;QACb,CAAC;QACD,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;IAC/F,CAAC;IAEM,QAAQ,CAAC,MAAc,EAAA;QAC7B,IAAI,MAAM,KAAK,CAAC,EAAE,CAAC;YAClB,OAAO,IAAI,CAAC;QACb,CAAC;QACD,OAAO,IAAI,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;IAC3F,CAAC;IAEM,SAAS,CAAC,KAAmB,EAAA;QACnC,MAAM,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACrD,MAAM,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACrD,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,EAAE,CAAC;YAChB,OAAO,SAAS,CAAC;QAClB,CAAC;QACD,OAAO,IAAI,YAAY,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IACjC,CAAC;IAEM,SAAS,GAAA;QACf,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACnE,CAAC;IAEM,gBAAgB,GAAA;QACtB,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;IACjF,CAAC;IArDD,YACiB,SAAsB,EACtB,SAAsB,CAAA;QADtB,IAAA,CAAA,SAAS,GAAT,SAAS,CAAa;QACtB,IAAA,CAAA,SAAS,GAAT,SAAS,CAAa;IACnC,CAAC;CAmDL;AAEK;IAUE,QAAQ,GAAA;QACd,OAAO,UAAG,IAAI,CAAC,OAAO,EAAA,SAAoB,CAAE,CAAC,KAAf,IAAI,CAAC,OAAO;IAC3C,CAAC;IAEM,KAAK,CAAC,MAAc,EAAA;QAC1B,IAAI,MAAM,KAAK,CAAC,EAAE,CAAC;YAClB,OAAO,IAAI,CAAC;QACb,CAAC;QACD,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,OAAO,GAAG,MAAM,EAAE,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,CAAC;IACrE,CAAC;IAEM,MAAM,CAAC,KAAiB,EAAA;QAC9B,OAAO,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,CAAC;IACzE,CAAC;IAnBD,YACiB,OAAe,EACf,OAAe,CAAA;QADf,IAAA,CAAA,OAAO,GAAP,OAAO,CAAQ;QACf,IAAA,CAAA,OAAO,GAAP,OAAO,CAAQ;IAEhC,CAAC;;WAPsB,IAAI,GAAG,IAAI,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AADvC,UAAU,CAEC,GAAG,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,gBAAgB,CAAC,CAAC;AA+CzF;IAGL,OAAO,GAAA;QACN,OAAO,IAAI,CAAC;IACb,CAAC;;AALW,eAAe,CACb,QAAQ,GAAG,IAAI,eAAe,EAAE,CAAC;AAO1C,MAAO,WAAW;IAUvB,iEAAiE;IAC1D,OAAO,GAAA;QACb,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC;QACzD,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;YAC1B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,kBAAkB;QACvC,CAAC;QACD,OAAO,IAAI,CAAC,KAAK,CAAC;IACnB,CAAC;IAbD,YAAoB,OAAe,CAAA;QAAf,IAAA,CAAA,OAAO,GAAP,OAAO,CAAQ;QAHlB,IAAA,CAAA,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAChC,IAAA,CAAA,KAAK,GAAG,IAAI,CAAC;QAGpB,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC;YAClB,MAAM,IAAI,kMAAkB,CAAC,0BAA0B,CAAC,CAAC;QAC1D,CAAC;IACF,CAAC;CAUD","debugId":null}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/utils.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/vs/editor/common/diff/defaultLinesDiffComputer/utils.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { DetailedLineRangeMapping } from '../rangeMapping.js';\n\nexport class Array2D<T> {\n\tprivate readonly array: T[] = [];\n\n\tconstructor(public readonly width: number, public readonly height: number) {\n\t\tthis.array = new Array<T>(width * height);\n\t}\n\n\tget(x: number, y: number): T {\n\t\treturn this.array[x + y * this.width];\n\t}\n\n\tset(x: number, y: number, value: T): void {\n\t\tthis.array[x + y * this.width] = value;\n\t}\n}\n\nexport function isSpace(charCode: number): boolean {\n\treturn charCode === CharCode.Space || charCode === CharCode.Tab;\n}\n\nexport class LineRangeFragment {\n\tprivate static chrKeys = new Map<string, number>();\n\n\tprivate static getKey(chr: string): number {\n\t\tlet key = this.chrKeys.get(chr);\n\t\tif (key === undefined) {\n\t\t\tkey = this.chrKeys.size;\n\t\t\tthis.chrKeys.set(chr, key);\n\t\t}\n\t\treturn key;\n\t}\n\n\tprivate readonly totalCount: number;\n\tprivate readonly histogram: number[] = [];\n\tconstructor(\n\t\tpublic readonly range: LineRange,\n\t\tpublic readonly lines: string[],\n\t\tpublic readonly source: DetailedLineRangeMapping,\n\t) {\n\t\tlet counter = 0;\n\t\tfor (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tfor (let j = 0; j < line.length; j++) {\n\t\t\t\tcounter++;\n\t\t\t\tconst chr = line[j];\n\t\t\t\tconst key = LineRangeFragment.getKey(chr);\n\t\t\t\tthis.histogram[key] = (this.histogram[key] || 0) + 1;\n\t\t\t}\n\t\t\tcounter++;\n\t\t\tconst key = LineRangeFragment.getKey('\\n');\n\t\t\tthis.histogram[key] = (this.histogram[key] || 0) + 1;\n\t\t}\n\n\t\tthis.totalCount = counter;\n\t}\n\n\tpublic computeSimilarity(other: LineRangeFragment): number {\n\t\tlet sumDifferences = 0;\n\t\tconst maxLength = Math.max(this.histogram.length, other.histogram.length);\n\t\tfor (let i = 0; i < maxLength; i++) {\n\t\t\tsumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n\t\t}\n\t\treturn 1 - (sumDifferences / (this.totalCount + other.totalCount));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { DetailedLineRangeMapping } from '../rangeMapping.js';\n\nexport class Array2D<T> {\n\tprivate readonly array: T[] = [];\n\n\tconstructor(public readonly width: number, public readonly height: number) {\n\t\tthis.array = new Array<T>(width * height);\n\t}\n\n\tget(x: number, y: number): T {\n\t\treturn this.array[x + y * this.width];\n\t}\n\n\tset(x: number, y: number, value: T): void {\n\t\tthis.array[x + y * this.width] = value;\n\t}\n}\n\nexport function isSpace(charCode: number): boolean {\n\treturn charCode === CharCode.Space || charCode === CharCode.Tab;\n}\n\nexport class LineRangeFragment {\n\tprivate static chrKeys = new Map<string, number>();\n\n\tprivate static getKey(chr: string): number {\n\t\tlet key = this.chrKeys.get(chr);\n\t\tif (key === undefined) {\n\t\t\tkey = this.chrKeys.size;\n\t\t\tthis.chrKeys.set(chr, key);\n\t\t}\n\t\treturn key;\n\t}\n\n\tprivate readonly totalCount: number;\n\tprivate readonly histogram: number[] = [];\n\tconstructor(\n\t\tpublic readonly range: LineRange,\n\t\tpublic readonly lines: string[],\n\t\tpublic readonly source: DetailedLineRangeMapping,\n\t) {\n\t\tlet counter = 0;\n\t\tfor (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tfor (let j = 0; j < line.length; j++) {\n\t\t\t\tcounter++;\n\t\t\t\tconst chr = line[j];\n\t\t\t\tconst key = LineRangeFragment.getKey(chr);\n\t\t\t\tthis.histogram[key] = (this.histogram[key] || 0) + 1;\n\t\t\t}\n\t\t\tcounter++;\n\t\t\tconst key = LineRangeFragment.getKey('\\n');\n\t\t\tthis.histogram[key] = (this.histogram[key] || 0) + 1;\n\t\t}\n\n\t\tthis.totalCount = counter;\n\t}\n\n\tpublic computeSimilarity(other: LineRangeFragment): number {\n\t\tlet sumDifferences = 0;\n\t\tconst maxLength = Math.max(this.histogram.length, other.histogram.length);\n\t\tfor (let i = 0; i < maxLength; i++) {\n\t\t\tsumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n\t\t}\n\t\treturn 1 - (sumDifferences / (this.totalCount + other.totalCount));\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 493, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { IDiffAlgorithm, SequenceDiff, ISequence, ITimeout, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing implements IDiffAlgorithm {\n\tcompute(sequence1: ISequence, sequence2: ISequence, timeout: ITimeout = InfiniteTimeout.instance, equalityScore?: (offset1: number, offset2: number) => number): DiffAlgorithmResult {\n\t\tif (sequence1.length === 0 || sequence2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(sequence1, sequence2);\n\t\t}\n\n\t\t/**\n\t\t * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n\t\t */\n\t\tconst lcsLengths = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst directions = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst lengths = new Array2D<number>(sequence1.length, sequence2.length);\n\n\t\t// ==== Initializing lcsLengths ====\n\t\tfor (let s1 = 0; s1 < sequence1.length; s1++) {\n\t\t\tfor (let s2 = 0; s2 < sequence2.length; s2++) {\n\t\t\t\tif (!timeout.isValid()) {\n\t\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n\t\t\t\t}\n\n\t\t\t\tconst horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n\t\t\t\tconst verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n\n\t\t\t\tlet extendedSeqScore: number;\n\t\t\t\tif (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n\t\t\t\t\tif (s1 === 0 || s2 === 0) {\n\t\t\t\t\t\textendedSeqScore = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\textendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n\t\t\t\t\t\t// Prefer consecutive diagonals\n\t\t\t\t\t\textendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\textendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n\t\t\t\t} else {\n\t\t\t\t\textendedSeqScore = -1;\n\t\t\t\t}\n\n\t\t\t\tconst newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n\n\t\t\t\tif (newValue === extendedSeqScore) {\n\t\t\t\t\t// Prefer diagonals\n\t\t\t\t\tconst prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n\t\t\t\t\tlengths.set(s1, s2, prevLen + 1);\n\t\t\t\t\tdirections.set(s1, s2, 3);\n\t\t\t\t} else if (newValue === horizontalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 1);\n\t\t\t\t} else if (newValue === verticalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 2);\n\t\t\t\t}\n\n\t\t\t\tlcsLengths.set(s1, s2, newValue);\n\t\t\t}\n\t\t}\n\n\t\t// ==== Backtracking ====\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = sequence1.length;\n\t\tlet lastAligningPosS2: number = sequence2.length;\n\n\t\tfunction reportDecreasingAligningPositions(s1: number, s2: number): void {\n\t\t\tif (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(s1 + 1, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(s2 + 1, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tlastAligningPosS1 = s1;\n\t\t\tlastAligningPosS2 = s2;\n\t\t}\n\n\t\tlet s1 = sequence1.length - 1;\n\t\tlet s2 = sequence2.length - 1;\n\t\twhile (s1 >= 0 && s2 >= 0) {\n\t\t\tif (directions.get(s1, s2) === 3) {\n\t\t\t\treportDecreasingAligningPositions(s1, s2);\n\t\t\t\ts1--;\n\t\t\t\ts2--;\n\t\t\t} else {\n\t\t\t\tif (directions.get(s1, s2) === 1) {\n\t\t\t\t\ts1--;\n\t\t\t\t} else {\n\t\t\t\t\ts2--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treportDecreasingAligningPositions(-1, -1);\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { IDiffAlgorithm, SequenceDiff, ISequence, ITimeout, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing implements IDiffAlgorithm {\n\tcompute(sequence1: ISequence, sequence2: ISequence, timeout: ITimeout = InfiniteTimeout.instance, equalityScore?: (offset1: number, offset2: number) => number): DiffAlgorithmResult {\n\t\tif (sequence1.length === 0 || sequence2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(sequence1, sequence2);\n\t\t}\n\n\t\t/**\n\t\t * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n\t\t */\n\t\tconst lcsLengths = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst directions = new Array2D<number>(sequence1.length, sequence2.length);\n\t\tconst lengths = new Array2D<number>(sequence1.length, sequence2.length);\n\n\t\t// ==== Initializing lcsLengths ====\n\t\tfor (let s1 = 0; s1 < sequence1.length; s1++) {\n\t\t\tfor (let s2 = 0; s2 < sequence2.length; s2++) {\n\t\t\t\tif (!timeout.isValid()) {\n\t\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n\t\t\t\t}\n\n\t\t\t\tconst horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n\t\t\t\tconst verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n\n\t\t\t\tlet extendedSeqScore: number;\n\t\t\t\tif (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n\t\t\t\t\tif (s1 === 0 || s2 === 0) {\n\t\t\t\t\t\textendedSeqScore = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\textendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n\t\t\t\t\t\t// Prefer consecutive diagonals\n\t\t\t\t\t\textendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n\t\t\t\t\t}\n\t\t\t\t\textendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n\t\t\t\t} else {\n\t\t\t\t\textendedSeqScore = -1;\n\t\t\t\t}\n\n\t\t\t\tconst newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n\n\t\t\t\tif (newValue === extendedSeqScore) {\n\t\t\t\t\t// Prefer diagonals\n\t\t\t\t\tconst prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n\t\t\t\t\tlengths.set(s1, s2, prevLen + 1);\n\t\t\t\t\tdirections.set(s1, s2, 3);\n\t\t\t\t} else if (newValue === horizontalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 1);\n\t\t\t\t} else if (newValue === verticalLen) {\n\t\t\t\t\tlengths.set(s1, s2, 0);\n\t\t\t\t\tdirections.set(s1, s2, 2);\n\t\t\t\t}\n\n\t\t\t\tlcsLengths.set(s1, s2, newValue);\n\t\t\t}\n\t\t}\n\n\t\t// ==== Backtracking ====\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = sequence1.length;\n\t\tlet lastAligningPosS2: number = sequence2.length;\n\n\t\tfunction reportDecreasingAligningPositions(s1: number, s2: number): void {\n\t\t\tif (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(s1 + 1, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(s2 + 1, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tlastAligningPosS1 = s1;\n\t\t\tlastAligningPosS2 = s2;\n\t\t}\n\n\t\tlet s1 = sequence1.length - 1;\n\t\tlet s2 = sequence2.length - 1;\n\t\twhile (s1 >= 0 && s2 >= 0) {\n\t\t\tif (directions.get(s1, s2) === 3) {\n\t\t\t\treportDecreasingAligningPositions(s1, s2);\n\t\t\t\ts1--;\n\t\t\t\ts2--;\n\t\t\t} else {\n\t\t\t\tif (directions.get(s1, s2) === 1) {\n\t\t\t\t\ts1--;\n\t\t\t\t} else {\n\t\t\t\t\ts2--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treportDecreasingAligningPositions(-1, -1);\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 591, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { DiffAlgorithmResult, IDiffAlgorithm, ISequence, ITimeout, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm implements IDiffAlgorithm {\n\tcompute(seq1: ISequence, seq2: ISequence, timeout: ITimeout = InfiniteTimeout.instance): DiffAlgorithmResult {\n\t\t// These are common special cases.\n\t\t// The early return improves performance dramatically.\n\t\tif (seq1.length === 0 || seq2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(seq1, seq2);\n\t\t}\n\n\t\tconst seqX = seq1; // Text on the x axis\n\t\tconst seqY = seq2; // Text on the y axis\n\n\t\tfunction getXAfterSnake(x: number, y: number): number {\n\t\t\twhile (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n\t\t\t\tx++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\n\t\tlet d = 0;\n\t\t// V[k]: X value of longest d-line that ends in diagonal k.\n\t\t// d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n\t\t// diagonal k: Set of points (x,y) with x-y = k.\n\t\t// k=1 -> (1,0),(2,1)\n\t\tconst V = new FastInt32Array();\n\t\tV.set(0, getXAfterSnake(0, 0));\n\n\t\tconst paths = new FastArrayNegativeIndices<SnakePath | null>();\n\t\tpaths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n\n\t\tlet k = 0;\n\n\t\tloop: while (true) {\n\t\t\td++;\n\t\t\tif (!timeout.isValid()) {\n\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n\t\t\t}\n\t\t\t// The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n\t\t\tconst lowerBound = -Math.min(d, seqY.length + (d % 2));\n\t\t\tconst upperBound = Math.min(d, seqX.length + (d % 2));\n\t\t\tfor (k = lowerBound; k <= upperBound; k += 2) {\n\t\t\t\tlet step = 0;\n\t\t\t\t// We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n\t\t\t\tconst maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n\t\t\t\tconst maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n\t\t\t\tstep++;\n\t\t\t\tconst x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n\t\t\t\tconst y = x - k;\n\t\t\t\tstep++;\n\t\t\t\tif (x > seqX.length || y > seqY.length) {\n\t\t\t\t\t// This diagonal is irrelevant for the result.\n\t\t\t\t\t// TODO: Don't pay the cost for this in the next iteration.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst newMaxX = getXAfterSnake(x, y);\n\t\t\t\tV.set(k, newMaxX);\n\t\t\t\tconst lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n\t\t\t\tpaths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n\n\t\t\t\tif (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet path = paths.get(k);\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = seqX.length;\n\t\tlet lastAligningPosS2: number = seqY.length;\n\n\t\twhile (true) {\n\t\t\tconst endX = path ? path.x + path.length : 0;\n\t\t\tconst endY = path ? path.y + path.length : 0;\n\n\t\t\tif (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(endX, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(endY, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tif (!path) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastAligningPosS1 = path.x;\n\t\t\tlastAligningPosS2 = path.y;\n\n\t\t\tpath = path.prev;\n\t\t}\n\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n\nclass SnakePath {\n\tconstructor(\n\t\tpublic readonly prev: SnakePath | null,\n\t\tpublic readonly x: number,\n\t\tpublic readonly y: number,\n\t\tpublic readonly length: number\n\t) {\n\t}\n}\n\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n\tprivate positiveArr: Int32Array = new Int32Array(10);\n\tprivate negativeArr: Int32Array = new Int32Array(10);\n\n\tget(idx: number): number {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: number): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tif (idx >= this.negativeArr.length) {\n\t\t\t\tconst arr = this.negativeArr;\n\t\t\t\tthis.negativeArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.negativeArr.set(arr);\n\t\t\t}\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tif (idx >= this.positiveArr.length) {\n\t\t\t\tconst arr = this.positiveArr;\n\t\t\t\tthis.positiveArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.positiveArr.set(arr);\n\t\t\t}\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices<T> {\n\tprivate readonly positiveArr: T[] = [];\n\tprivate readonly negativeArr: T[] = [];\n\n\tget(idx: number): T {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: T): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { OffsetRange } from '../../../core/ranges/offsetRange.js';\nimport { DiffAlgorithmResult, IDiffAlgorithm, ISequence, ITimeout, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm implements IDiffAlgorithm {\n\tcompute(seq1: ISequence, seq2: ISequence, timeout: ITimeout = InfiniteTimeout.instance): DiffAlgorithmResult {\n\t\t// These are common special cases.\n\t\t// The early return improves performance dramatically.\n\t\tif (seq1.length === 0 || seq2.length === 0) {\n\t\t\treturn DiffAlgorithmResult.trivial(seq1, seq2);\n\t\t}\n\n\t\tconst seqX = seq1; // Text on the x axis\n\t\tconst seqY = seq2; // Text on the y axis\n\n\t\tfunction getXAfterSnake(x: number, y: number): number {\n\t\t\twhile (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n\t\t\t\tx++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\n\t\tlet d = 0;\n\t\t// V[k]: X value of longest d-line that ends in diagonal k.\n\t\t// d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n\t\t// diagonal k: Set of points (x,y) with x-y = k.\n\t\t// k=1 -> (1,0),(2,1)\n\t\tconst V = new FastInt32Array();\n\t\tV.set(0, getXAfterSnake(0, 0));\n\n\t\tconst paths = new FastArrayNegativeIndices<SnakePath | null>();\n\t\tpaths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n\n\t\tlet k = 0;\n\n\t\tloop: while (true) {\n\t\t\td++;\n\t\t\tif (!timeout.isValid()) {\n\t\t\t\treturn DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n\t\t\t}\n\t\t\t// The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n\t\t\tconst lowerBound = -Math.min(d, seqY.length + (d % 2));\n\t\t\tconst upperBound = Math.min(d, seqX.length + (d % 2));\n\t\t\tfor (k = lowerBound; k <= upperBound; k += 2) {\n\t\t\t\tlet step = 0;\n\t\t\t\t// We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n\t\t\t\tconst maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n\t\t\t\tconst maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n\t\t\t\tstep++;\n\t\t\t\tconst x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n\t\t\t\tconst y = x - k;\n\t\t\t\tstep++;\n\t\t\t\tif (x > seqX.length || y > seqY.length) {\n\t\t\t\t\t// This diagonal is irrelevant for the result.\n\t\t\t\t\t// TODO: Don't pay the cost for this in the next iteration.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst newMaxX = getXAfterSnake(x, y);\n\t\t\t\tV.set(k, newMaxX);\n\t\t\t\tconst lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n\t\t\t\tpaths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n\n\t\t\t\tif (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet path = paths.get(k);\n\t\tconst result: SequenceDiff[] = [];\n\t\tlet lastAligningPosS1: number = seqX.length;\n\t\tlet lastAligningPosS2: number = seqY.length;\n\n\t\twhile (true) {\n\t\t\tconst endX = path ? path.x + path.length : 0;\n\t\t\tconst endY = path ? path.y + path.length : 0;\n\n\t\t\tif (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n\t\t\t\tresult.push(new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(endX, lastAligningPosS1),\n\t\t\t\t\tnew OffsetRange(endY, lastAligningPosS2),\n\t\t\t\t));\n\t\t\t}\n\t\t\tif (!path) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlastAligningPosS1 = path.x;\n\t\t\tlastAligningPosS2 = path.y;\n\n\t\t\tpath = path.prev;\n\t\t}\n\n\t\tresult.reverse();\n\t\treturn new DiffAlgorithmResult(result, false);\n\t}\n}\n\nclass SnakePath {\n\tconstructor(\n\t\tpublic readonly prev: SnakePath | null,\n\t\tpublic readonly x: number,\n\t\tpublic readonly y: number,\n\t\tpublic readonly length: number\n\t) {\n\t}\n}\n\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n\tprivate positiveArr: Int32Array = new Int32Array(10);\n\tprivate negativeArr: Int32Array = new Int32Array(10);\n\n\tget(idx: number): number {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: number): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tif (idx >= this.negativeArr.length) {\n\t\t\t\tconst arr = this.negativeArr;\n\t\t\t\tthis.negativeArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.negativeArr.set(arr);\n\t\t\t}\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tif (idx >= this.positiveArr.length) {\n\t\t\t\tconst arr = this.positiveArr;\n\t\t\t\tthis.positiveArr = new Int32Array(arr.length * 2);\n\t\t\t\tthis.positiveArr.set(arr);\n\t\t\t}\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices<T> {\n\tprivate readonly positiveArr: T[] = [];\n\tprivate readonly negativeArr: T[] = [];\n\n\tget(idx: number): T {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\treturn this.negativeArr[idx];\n\t\t} else {\n\t\t\treturn this.positiveArr[idx];\n\t\t}\n\t}\n\n\tset(idx: number, value: T): void {\n\t\tif (idx < 0) {\n\t\t\tidx = -idx - 1;\n\t\t\tthis.negativeArr[idx] = value;\n\t\t} else {\n\t\t\tthis.positiveArr[idx] = value;\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 749, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\nimport { isSpace } from './utils.js';\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstElementOffsetByLineIdx: number[] = [];\n\tprivate readonly lineStartOffsets: number[] = [];\n\tprivate readonly trimmedWsLengthsByLineIdx: number[] = [];\n\n\tconstructor(public readonly lines: string[], private readonly range: Range, public readonly considerWhitespaceChanges: boolean) {\n\t\tthis.firstElementOffsetByLineIdx.push(0);\n\t\tfor (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n\t\t\tlet line = lines[lineNumber - 1];\n\t\t\tlet lineStartOffset = 0;\n\t\t\tif (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n\t\t\t\tlineStartOffset = this.range.startColumn - 1;\n\t\t\t\tline = line.substring(lineStartOffset);\n\t\t\t}\n\t\t\tthis.lineStartOffsets.push(lineStartOffset);\n\n\t\t\tlet trimmedWsLength = 0;\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\ttrimmedWsLength = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\t\t\tthis.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n\n\t\t\tconst lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n\t\t\tfor (let i = 0; i < lineLength; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\tif (lineNumber < this.range.endLineNumber) {\n\t\t\t\tthis.elements.push('\\n'.charCodeAt(0));\n\t\t\t\tthis.firstElementOffsetByLineIdx.push(this.elements.length);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n\t\tconst nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// prefer the linebreak before the change\n\t\t\treturn 150;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(offset: number, preference: 'left' | 'right' = 'right'): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tconst i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n\t\tconst lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n\t\treturn new Position(\n\t\t\tthis.range.startLineNumber + i,\n\t\t\t1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i])\n\t\t);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\tconst pos1 = this.translateOffset(range.start, 'right');\n\t\tconst pos2 = this.translateOffset(range.endExclusive, 'left');\n\t\tif (pos2.isBefore(pos1)) {\n\t\t\treturn Range.fromPositions(pos2, pos2);\n\t\t}\n\t\treturn Range.fromPositions(pos1, pos2);\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\t/** fooBar has the two sub-words foo and bar */\n\tpublic findSubWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1]) && !isUpperCase(this.elements[start])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end]) && !isUpperCase(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start = findLastMonotonous(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;\n\t\tconst end = findFirstMonotonous(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn charCode >= CharCode.a && charCode <= CharCode.z\n\t\t|| charCode >= CharCode.A && charCode <= CharCode.Z\n\t\t|| charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\n\nfunction isUpperCase(charCode: number): boolean {\n\treturn charCode >= CharCode.A && charCode <= CharCode.Z;\n}\n\nconst enum CharBoundaryCategory {\n\tWordLower,\n\tWordUpper,\n\tWordNumber,\n\tEnd,\n\tOther,\n\tSeparator,\n\tSpace,\n\tLineBreakCR,\n\tLineBreakLF,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Separator]: 30,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n\t\treturn CharBoundaryCategory.Separator;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\nimport { isSpace } from './utils.js';\n\nexport class LinesSliceCharSequence implements ISequence {\n\tprivate readonly elements: number[] = [];\n\tprivate readonly firstElementOffsetByLineIdx: number[] = [];\n\tprivate readonly lineStartOffsets: number[] = [];\n\tprivate readonly trimmedWsLengthsByLineIdx: number[] = [];\n\n\tconstructor(public readonly lines: string[], private readonly range: Range, public readonly considerWhitespaceChanges: boolean) {\n\t\tthis.firstElementOffsetByLineIdx.push(0);\n\t\tfor (let lineNumber = this.range.startLineNumber; lineNumber <= this.range.endLineNumber; lineNumber++) {\n\t\t\tlet line = lines[lineNumber - 1];\n\t\t\tlet lineStartOffset = 0;\n\t\t\tif (lineNumber === this.range.startLineNumber && this.range.startColumn > 1) {\n\t\t\t\tlineStartOffset = this.range.startColumn - 1;\n\t\t\t\tline = line.substring(lineStartOffset);\n\t\t\t}\n\t\t\tthis.lineStartOffsets.push(lineStartOffset);\n\n\t\t\tlet trimmedWsLength = 0;\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\tconst trimmedStartLine = line.trimStart();\n\t\t\t\ttrimmedWsLength = line.length - trimmedStartLine.length;\n\t\t\t\tline = trimmedStartLine.trimEnd();\n\t\t\t}\n\t\t\tthis.trimmedWsLengthsByLineIdx.push(trimmedWsLength);\n\n\t\t\tconst lineLength = lineNumber === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - lineStartOffset - trimmedWsLength, line.length) : line.length;\n\t\t\tfor (let i = 0; i < lineLength; i++) {\n\t\t\t\tthis.elements.push(line.charCodeAt(i));\n\t\t\t}\n\n\t\t\tif (lineNumber < this.range.endLineNumber) {\n\t\t\t\tthis.elements.push('\\n'.charCodeAt(0));\n\t\t\t\tthis.firstElementOffsetByLineIdx.push(this.elements.length);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn `Slice: \"${this.text}\"`;\n\t}\n\n\tget text(): string {\n\t\treturn this.getText(new OffsetRange(0, this.length));\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n\t}\n\n\tgetElement(offset: number): number {\n\t\treturn this.elements[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.elements.length;\n\t}\n\n\tpublic getBoundaryScore(length: number): number {\n\t\t//   a   b   c   ,           d   e   f\n\t\t// 11  0   0   12  15  6   13  0   0   11\n\n\t\tconst prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n\t\tconst nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// don't break between \\r and \\n\n\t\t\treturn 0;\n\t\t}\n\t\tif (prevCategory === CharBoundaryCategory.LineBreakLF) {\n\t\t\t// prefer the linebreak before the change\n\t\t\treturn 150;\n\t\t}\n\n\t\tlet score = 0;\n\t\tif (prevCategory !== nextCategory) {\n\t\t\tscore += 10;\n\t\t\tif (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n\t\t\t\tscore += 1;\n\t\t\t}\n\t\t}\n\n\t\tscore += getCategoryBoundaryScore(prevCategory);\n\t\tscore += getCategoryBoundaryScore(nextCategory);\n\n\t\treturn score;\n\t}\n\n\tpublic translateOffset(offset: number, preference: 'left' | 'right' = 'right'): Position {\n\t\t// find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n\t\tconst i = findLastIdxMonotonous(this.firstElementOffsetByLineIdx, (value) => value <= offset);\n\t\tconst lineOffset = offset - this.firstElementOffsetByLineIdx[i];\n\t\treturn new Position(\n\t\t\tthis.range.startLineNumber + i,\n\t\t\t1 + this.lineStartOffsets[i] + lineOffset + ((lineOffset === 0 && preference === 'left') ? 0 : this.trimmedWsLengthsByLineIdx[i])\n\t\t);\n\t}\n\n\tpublic translateRange(range: OffsetRange): Range {\n\t\tconst pos1 = this.translateOffset(range.start, 'right');\n\t\tconst pos2 = this.translateOffset(range.endExclusive, 'left');\n\t\tif (pos2.isBefore(pos1)) {\n\t\t\treturn Range.fromPositions(pos2, pos2);\n\t\t}\n\t\treturn Range.fromPositions(pos1, pos2);\n\t}\n\n\t/**\n\t * Finds the word that contains the character at the given offset\n\t */\n\tpublic findWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\t/** fooBar has the two sub-words foo and bar */\n\tpublic findSubWordContaining(offset: number): OffsetRange | undefined {\n\t\tif (offset < 0 || offset >= this.elements.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!isWordChar(this.elements[offset])) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// find start\n\t\tlet start = offset;\n\t\twhile (start > 0 && isWordChar(this.elements[start - 1]) && !isUpperCase(this.elements[start])) {\n\t\t\tstart--;\n\t\t}\n\n\t\t// find end\n\t\tlet end = offset;\n\t\twhile (end < this.elements.length && isWordChar(this.elements[end]) && !isUpperCase(this.elements[end])) {\n\t\t\tend++;\n\t\t}\n\n\t\treturn new OffsetRange(start, end);\n\t}\n\n\tpublic countLinesIn(range: OffsetRange): number {\n\t\treturn this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n\t}\n\n\tpublic isStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.elements[offset1] === this.elements[offset2];\n\t}\n\n\tpublic extendToFullLines(range: OffsetRange): OffsetRange {\n\t\tconst start = findLastMonotonous(this.firstElementOffsetByLineIdx, x => x <= range.start) ?? 0;\n\t\tconst end = findFirstMonotonous(this.firstElementOffsetByLineIdx, x => range.endExclusive <= x) ?? this.elements.length;\n\t\treturn new OffsetRange(start, end);\n\t}\n}\n\nfunction isWordChar(charCode: number): boolean {\n\treturn charCode >= CharCode.a && charCode <= CharCode.z\n\t\t|| charCode >= CharCode.A && charCode <= CharCode.Z\n\t\t|| charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\n\nfunction isUpperCase(charCode: number): boolean {\n\treturn charCode >= CharCode.A && charCode <= CharCode.Z;\n}\n\nconst enum CharBoundaryCategory {\n\tWordLower,\n\tWordUpper,\n\tWordNumber,\n\tEnd,\n\tOther,\n\tSeparator,\n\tSpace,\n\tLineBreakCR,\n\tLineBreakLF,\n}\n\nconst score: Record<CharBoundaryCategory, number> = {\n\t[CharBoundaryCategory.WordLower]: 0,\n\t[CharBoundaryCategory.WordUpper]: 0,\n\t[CharBoundaryCategory.WordNumber]: 0,\n\t[CharBoundaryCategory.End]: 10,\n\t[CharBoundaryCategory.Other]: 2,\n\t[CharBoundaryCategory.Separator]: 30,\n\t[CharBoundaryCategory.Space]: 3,\n\t[CharBoundaryCategory.LineBreakCR]: 10,\n\t[CharBoundaryCategory.LineBreakLF]: 10,\n};\n\nfunction getCategoryBoundaryScore(category: CharBoundaryCategory): number {\n\treturn score[category];\n}\n\nfunction getCategory(charCode: number): CharBoundaryCategory {\n\tif (charCode === CharCode.LineFeed) {\n\t\treturn CharBoundaryCategory.LineBreakLF;\n\t} else if (charCode === CharCode.CarriageReturn) {\n\t\treturn CharBoundaryCategory.LineBreakCR;\n\t} else if (isSpace(charCode)) {\n\t\treturn CharBoundaryCategory.Space;\n\t} else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n\t\treturn CharBoundaryCategory.WordLower;\n\t} else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n\t\treturn CharBoundaryCategory.WordUpper;\n\t} else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n\t\treturn CharBoundaryCategory.WordNumber;\n\t} else if (charCode === -1) {\n\t\treturn CharBoundaryCategory.End;\n\t} else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n\t\treturn CharBoundaryCategory.Separator;\n\t} else {\n\t\treturn CharBoundaryCategory.Other;\n\t}\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 954, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DetailedLineRangeMapping, LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/ranges/lineRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { Range } from '../../core/range.js';\n\nexport function computeMovedLines(\n\tchanges: DetailedLineRangeMapping[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\thashedOriginalLines: number[],\n\thashedModifiedLines: number[],\n\ttimeout: ITimeout\n): LineRangeMapping[] {\n\tlet { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n\n\tif (!timeout.isValid()) { return []; }\n\n\tconst filteredChanges = changes.filter(c => !excludedChanges.has(c));\n\tconst unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n\tpushMany(moves, unchangedMoves);\n\n\tmoves = joinCloseConsecutiveMoves(moves);\n\t// Ignore too short moves\n\tmoves = moves.filter(current => {\n\t\tconst lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n\t\tconst originalText = lines.join('\\n');\n\t\treturn originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n\t});\n\tmoves = removeMovesInSameDiff(changes, moves);\n\n\treturn moves;\n}\n\nfunction countWhere<T>(arr: T[], predicate: (t: T) => boolean): number {\n\tlet count = 0;\n\tfor (const t of arr) {\n\t\tif (predicate(t)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(\n\tchanges: DetailedLineRangeMapping[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\ttimeout: ITimeout,\n) {\n\tconst moves: LineRangeMapping[] = [];\n\n\tconst deletions = changes\n\t\t.filter(c => c.modified.isEmpty && c.original.length >= 3)\n\t\t.map(d => new LineRangeFragment(d.original, originalLines, d));\n\tconst insertions = new Set(changes\n\t\t.filter(c => c.original.isEmpty && c.modified.length >= 3)\n\t\t.map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n\n\tconst excludedChanges = new Set<DetailedLineRangeMapping>();\n\n\tfor (const deletion of deletions) {\n\t\tlet highestSimilarity = -1;\n\t\tlet best: LineRangeFragment | undefined;\n\t\tfor (const insertion of insertions) {\n\t\t\tconst similarity = deletion.computeSimilarity(insertion);\n\t\t\tif (similarity > highestSimilarity) {\n\t\t\t\thighestSimilarity = similarity;\n\t\t\t\tbest = insertion;\n\t\t\t}\n\t\t}\n\n\t\tif (highestSimilarity > 0.90 && best) {\n\t\t\tinsertions.delete(best);\n\t\t\tmoves.push(new LineRangeMapping(deletion.range, best.range));\n\t\t\texcludedChanges.add(deletion.source);\n\t\t\texcludedChanges.add(best.source);\n\t\t}\n\n\t\tif (!timeout.isValid()) {\n\t\t\treturn { moves, excludedChanges };\n\t\t}\n\t}\n\n\treturn { moves, excludedChanges };\n}\n\nfunction computeUnchangedMoves(\n\tchanges: DetailedLineRangeMapping[],\n\thashedOriginalLines: number[],\n\thashedModifiedLines: number[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\ttimeout: ITimeout,\n) {\n\tconst moves: LineRangeMapping[] = [];\n\n\tconst original3LineHashes = new SetMap<string, { range: LineRange }>();\n\n\tfor (const change of changes) {\n\t\tfor (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n\t\t\tconst key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n\t\t\toriginal3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n\t\t}\n\t}\n\n\tinterface PossibleMapping {\n\t\tmodifiedLineRange: LineRange;\n\t\toriginalLineRange: LineRange;\n\t}\n\n\tconst possibleMappings: PossibleMapping[] = [];\n\n\tchanges.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n\n\tfor (const change of changes) {\n\t\tlet lastMappings: PossibleMapping[] = [];\n\t\tfor (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n\t\t\tconst key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n\t\t\tconst currentModifiedRange = new LineRange(i, i + 3);\n\n\t\t\tconst nextMappings: PossibleMapping[] = [];\n\t\t\toriginal3LineHashes.forEach(key, ({ range }) => {\n\t\t\t\tfor (const lastMapping of lastMappings) {\n\t\t\t\t\t// does this match extend some last match?\n\t\t\t\t\tif (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n\t\t\t\t\t\tlastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n\t\t\t\t\t\tlastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n\t\t\t\t\t\tlastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n\t\t\t\t\t\tnextMappings.push(lastMapping);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst mapping: PossibleMapping = {\n\t\t\t\t\tmodifiedLineRange: currentModifiedRange,\n\t\t\t\t\toriginalLineRange: range,\n\t\t\t\t};\n\t\t\t\tpossibleMappings.push(mapping);\n\t\t\t\tnextMappings.push(mapping);\n\t\t\t});\n\t\t\tlastMappings = nextMappings;\n\t\t}\n\n\t\tif (!timeout.isValid()) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tpossibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n\n\tconst modifiedSet = new LineRangeSet();\n\tconst originalSet = new LineRangeSet();\n\n\tfor (const mapping of possibleMappings) {\n\n\t\tconst diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n\t\tconst modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n\t\tconst originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n\n\t\tconst modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n\n\t\tfor (const s of modifiedIntersectedSections.ranges) {\n\t\t\tif (s.length < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst modifiedLineRange = s;\n\t\t\tconst originalLineRange = s.delta(-diffOrigToMod);\n\n\t\t\tmoves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n\n\t\t\tmodifiedSet.addRange(modifiedLineRange);\n\t\t\toriginalSet.addRange(originalLineRange);\n\t\t}\n\t}\n\n\tmoves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n\n\tconst monotonousChanges = new MonotonousArray(changes);\n\tfor (let i = 0; i < moves.length; i++) {\n\t\tconst move = moves[i];\n\t\tconst firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber)!;\n\t\tconst firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber)!;\n\t\tconst linesAbove = Math.max(\n\t\t\tmove.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber,\n\t\t\tmove.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber\n\t\t);\n\n\t\tconst lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive)!;\n\t\tconst lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive)!;\n\t\tconst linesBelow = Math.max(\n\t\t\tlastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive,\n\t\t\tlastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive\n\t\t);\n\n\t\tlet extendToTop: number;\n\t\tfor (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n\t\t\tconst origLine = move.original.startLineNumber - extendToTop - 1;\n\t\t\tconst modLine = move.modified.startLineNumber - extendToTop - 1;\n\t\t\tif (origLine > originalLines.length || modLine > modifiedLines.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (extendToTop > 0) {\n\t\t\toriginalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n\t\t\tmodifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n\t\t}\n\n\t\tlet extendToBottom: number;\n\t\tfor (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n\t\t\tconst origLine = move.original.endLineNumberExclusive + extendToBottom;\n\t\t\tconst modLine = move.modified.endLineNumberExclusive + extendToBottom;\n\t\t\tif (origLine > originalLines.length || modLine > modifiedLines.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (extendToBottom > 0) {\n\t\t\toriginalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n\t\t\tmodifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n\t\t}\n\n\t\tif (extendToTop > 0 || extendToBottom > 0) {\n\t\t\tmoves[i] = new LineRangeMapping(\n\t\t\t\tnew LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom),\n\t\t\t\tnew LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn moves;\n}\n\nfunction areLinesSimilar(line1: string, line2: string, timeout: ITimeout): boolean {\n\tif (line1.trim() === line2.trim()) { return true; }\n\tif (line1.length > 300 && line2.length > 300) { return false; }\n\n\tconst myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\tconst result = myersDiffingAlgorithm.compute(\n\t\tnew LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false),\n\t\tnew LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false),\n\t\ttimeout\n\t);\n\tlet commonNonSpaceCharCount = 0;\n\tconst inverted = SequenceDiff.invert(result.diffs, line1.length);\n\tfor (const seq of inverted) {\n\t\tseq.seq1Range.forEach(idx => {\n\t\t\tif (!isSpace(line1.charCodeAt(idx))) {\n\t\t\t\tcommonNonSpaceCharCount++;\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction countNonWsChars(str: string): number {\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < line1.length; i++) {\n\t\t\tif (!isSpace(str.charCodeAt(i))) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tconst longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n\tconst r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n\treturn r;\n}\n\nfunction joinCloseConsecutiveMoves(moves: LineRangeMapping[]): LineRangeMapping[] {\n\tif (moves.length === 0) {\n\t\treturn moves;\n\t}\n\n\tmoves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n\n\tconst result = [moves[0]];\n\tfor (let i = 1; i < moves.length; i++) {\n\t\tconst last = result[result.length - 1];\n\t\tconst current = moves[i];\n\n\t\tconst originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n\t\tconst modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n\t\tconst currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n\n\t\tif (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n\t\t\tresult[result.length - 1] = last.join(current);\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push(current);\n\t}\n\treturn result;\n}\n\nfunction removeMovesInSameDiff(changes: DetailedLineRangeMapping[], moves: LineRangeMapping[]) {\n\tconst changesMonotonous = new MonotonousArray(changes);\n\tmoves = moves.filter(m => {\n\t\tconst diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n\t\t\t|| new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n\t\tconst diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n\n\t\tconst differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n\t\treturn differentDiffs;\n\t});\n\treturn moves;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DetailedLineRangeMapping, LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/ranges/lineRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { Range } from '../../core/range.js';\n\nexport function computeMovedLines(\n\tchanges: DetailedLineRangeMapping[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\thashedOriginalLines: number[],\n\thashedModifiedLines: number[],\n\ttimeout: ITimeout\n): LineRangeMapping[] {\n\tlet { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n\n\tif (!timeout.isValid()) { return []; }\n\n\tconst filteredChanges = changes.filter(c => !excludedChanges.has(c));\n\tconst unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n\tpushMany(moves, unchangedMoves);\n\n\tmoves = joinCloseConsecutiveMoves(moves);\n\t// Ignore too short moves\n\tmoves = moves.filter(current => {\n\t\tconst lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n\t\tconst originalText = lines.join('\\n');\n\t\treturn originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n\t});\n\tmoves = removeMovesInSameDiff(changes, moves);\n\n\treturn moves;\n}\n\nfunction countWhere<T>(arr: T[], predicate: (t: T) => boolean): number {\n\tlet count = 0;\n\tfor (const t of arr) {\n\t\tif (predicate(t)) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(\n\tchanges: DetailedLineRangeMapping[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\ttimeout: ITimeout,\n) {\n\tconst moves: LineRangeMapping[] = [];\n\n\tconst deletions = changes\n\t\t.filter(c => c.modified.isEmpty && c.original.length >= 3)\n\t\t.map(d => new LineRangeFragment(d.original, originalLines, d));\n\tconst insertions = new Set(changes\n\t\t.filter(c => c.original.isEmpty && c.modified.length >= 3)\n\t\t.map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n\n\tconst excludedChanges = new Set<DetailedLineRangeMapping>();\n\n\tfor (const deletion of deletions) {\n\t\tlet highestSimilarity = -1;\n\t\tlet best: LineRangeFragment | undefined;\n\t\tfor (const insertion of insertions) {\n\t\t\tconst similarity = deletion.computeSimilarity(insertion);\n\t\t\tif (similarity > highestSimilarity) {\n\t\t\t\thighestSimilarity = similarity;\n\t\t\t\tbest = insertion;\n\t\t\t}\n\t\t}\n\n\t\tif (highestSimilarity > 0.90 && best) {\n\t\t\tinsertions.delete(best);\n\t\t\tmoves.push(new LineRangeMapping(deletion.range, best.range));\n\t\t\texcludedChanges.add(deletion.source);\n\t\t\texcludedChanges.add(best.source);\n\t\t}\n\n\t\tif (!timeout.isValid()) {\n\t\t\treturn { moves, excludedChanges };\n\t\t}\n\t}\n\n\treturn { moves, excludedChanges };\n}\n\nfunction computeUnchangedMoves(\n\tchanges: DetailedLineRangeMapping[],\n\thashedOriginalLines: number[],\n\thashedModifiedLines: number[],\n\toriginalLines: string[],\n\tmodifiedLines: string[],\n\ttimeout: ITimeout,\n) {\n\tconst moves: LineRangeMapping[] = [];\n\n\tconst original3LineHashes = new SetMap<string, { range: LineRange }>();\n\n\tfor (const change of changes) {\n\t\tfor (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n\t\t\tconst key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n\t\t\toriginal3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n\t\t}\n\t}\n\n\tinterface PossibleMapping {\n\t\tmodifiedLineRange: LineRange;\n\t\toriginalLineRange: LineRange;\n\t}\n\n\tconst possibleMappings: PossibleMapping[] = [];\n\n\tchanges.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n\n\tfor (const change of changes) {\n\t\tlet lastMappings: PossibleMapping[] = [];\n\t\tfor (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n\t\t\tconst key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n\t\t\tconst currentModifiedRange = new LineRange(i, i + 3);\n\n\t\t\tconst nextMappings: PossibleMapping[] = [];\n\t\t\toriginal3LineHashes.forEach(key, ({ range }) => {\n\t\t\t\tfor (const lastMapping of lastMappings) {\n\t\t\t\t\t// does this match extend some last match?\n\t\t\t\t\tif (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n\t\t\t\t\t\tlastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n\t\t\t\t\t\tlastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n\t\t\t\t\t\tlastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n\t\t\t\t\t\tnextMappings.push(lastMapping);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst mapping: PossibleMapping = {\n\t\t\t\t\tmodifiedLineRange: currentModifiedRange,\n\t\t\t\t\toriginalLineRange: range,\n\t\t\t\t};\n\t\t\t\tpossibleMappings.push(mapping);\n\t\t\t\tnextMappings.push(mapping);\n\t\t\t});\n\t\t\tlastMappings = nextMappings;\n\t\t}\n\n\t\tif (!timeout.isValid()) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tpossibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n\n\tconst modifiedSet = new LineRangeSet();\n\tconst originalSet = new LineRangeSet();\n\n\tfor (const mapping of possibleMappings) {\n\n\t\tconst diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n\t\tconst modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n\t\tconst originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n\n\t\tconst modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n\n\t\tfor (const s of modifiedIntersectedSections.ranges) {\n\t\t\tif (s.length < 3) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst modifiedLineRange = s;\n\t\t\tconst originalLineRange = s.delta(-diffOrigToMod);\n\n\t\t\tmoves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n\n\t\t\tmodifiedSet.addRange(modifiedLineRange);\n\t\t\toriginalSet.addRange(originalLineRange);\n\t\t}\n\t}\n\n\tmoves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n\n\tconst monotonousChanges = new MonotonousArray(changes);\n\tfor (let i = 0; i < moves.length; i++) {\n\t\tconst move = moves[i];\n\t\tconst firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber)!;\n\t\tconst firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber)!;\n\t\tconst linesAbove = Math.max(\n\t\t\tmove.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber,\n\t\t\tmove.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber\n\t\t);\n\n\t\tconst lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive)!;\n\t\tconst lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive)!;\n\t\tconst linesBelow = Math.max(\n\t\t\tlastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive,\n\t\t\tlastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive\n\t\t);\n\n\t\tlet extendToTop: number;\n\t\tfor (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n\t\t\tconst origLine = move.original.startLineNumber - extendToTop - 1;\n\t\t\tconst modLine = move.modified.startLineNumber - extendToTop - 1;\n\t\t\tif (origLine > originalLines.length || modLine > modifiedLines.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (extendToTop > 0) {\n\t\t\toriginalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n\t\t\tmodifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n\t\t}\n\n\t\tlet extendToBottom: number;\n\t\tfor (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n\t\t\tconst origLine = move.original.endLineNumberExclusive + extendToBottom;\n\t\t\tconst modLine = move.modified.endLineNumberExclusive + extendToBottom;\n\t\t\tif (origLine > originalLines.length || modLine > modifiedLines.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (extendToBottom > 0) {\n\t\t\toriginalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n\t\t\tmodifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n\t\t}\n\n\t\tif (extendToTop > 0 || extendToBottom > 0) {\n\t\t\tmoves[i] = new LineRangeMapping(\n\t\t\t\tnew LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom),\n\t\t\t\tnew LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn moves;\n}\n\nfunction areLinesSimilar(line1: string, line2: string, timeout: ITimeout): boolean {\n\tif (line1.trim() === line2.trim()) { return true; }\n\tif (line1.length > 300 && line2.length > 300) { return false; }\n\n\tconst myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\tconst result = myersDiffingAlgorithm.compute(\n\t\tnew LinesSliceCharSequence([line1], new Range(1, 1, 1, line1.length), false),\n\t\tnew LinesSliceCharSequence([line2], new Range(1, 1, 1, line2.length), false),\n\t\ttimeout\n\t);\n\tlet commonNonSpaceCharCount = 0;\n\tconst inverted = SequenceDiff.invert(result.diffs, line1.length);\n\tfor (const seq of inverted) {\n\t\tseq.seq1Range.forEach(idx => {\n\t\t\tif (!isSpace(line1.charCodeAt(idx))) {\n\t\t\t\tcommonNonSpaceCharCount++;\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction countNonWsChars(str: string): number {\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < line1.length; i++) {\n\t\t\tif (!isSpace(str.charCodeAt(i))) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tconst longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n\tconst r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n\treturn r;\n}\n\nfunction joinCloseConsecutiveMoves(moves: LineRangeMapping[]): LineRangeMapping[] {\n\tif (moves.length === 0) {\n\t\treturn moves;\n\t}\n\n\tmoves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n\n\tconst result = [moves[0]];\n\tfor (let i = 1; i < moves.length; i++) {\n\t\tconst last = result[result.length - 1];\n\t\tconst current = moves[i];\n\n\t\tconst originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n\t\tconst modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n\t\tconst currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n\n\t\tif (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n\t\t\tresult[result.length - 1] = last.join(current);\n\t\t\tcontinue;\n\t\t}\n\n\t\tresult.push(current);\n\t}\n\treturn result;\n}\n\nfunction removeMovesInSameDiff(changes: DetailedLineRangeMapping[], moves: LineRangeMapping[]) {\n\tconst changesMonotonous = new MonotonousArray(changes);\n\tmoves = moves.filter(m => {\n\t\tconst diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n\t\t\t|| new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n\t\tconst diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n\n\t\tconst differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n\t\treturn differentDiffs;\n\t});\n\treturn moves;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1226, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { ISequence, OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\n\nexport function optimizeSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet result = sequenceDiffs;\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\t// Sometimes, calling this function twice improves the result.\n\t// Uncomment the second invocation and run the tests to see the difference.\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\tresult = shiftSequenceDiffs(sequence1, sequence2, result);\n\treturn result;\n}\n\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (sequenceDiffs.length === 0) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tconst result: SequenceDiff[] = [];\n\tresult.push(sequenceDiffs[0]);\n\n\t// First move them all to the left as much as possible and join them if possible\n\tfor (let i = 1; i < sequenceDiffs.length; i++) {\n\t\tconst prevResult = result[result.length - 1];\n\t\tlet cur = sequenceDiffs[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 1; d <= length; d++) {\n\t\t\t\tif (\n\t\t\t\t\tsequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n\t\t\t\t\tsequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\td--;\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff\n\t\t\t\tresult[result.length - 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length),\n\t\t\t\t\tnew OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcur = cur.delta(-d);\n\t\t}\n\n\t\tresult.push(cur);\n\t}\n\n\tconst result2: SequenceDiff[] = [];\n\t// Then move them all to the right and join them again if possible\n\tfor (let i = 0; i < result.length - 1; i++) {\n\t\tconst nextResult = result[i + 1];\n\t\tlet cur = result[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 0; d < length; d++) {\n\t\t\t\tif (\n\t\t\t\t\t!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n\t\t\t\t\t!sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff, write to result!\n\t\t\t\tresult[i + 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive),\n\t\t\t\t\tnew OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (d > 0) {\n\t\t\t\tcur = cur.delta(d);\n\t\t\t}\n\t\t}\n\n\t\tresult2.push(cur);\n\t}\n\n\tif (result.length > 0) {\n\t\tresult2.push(result[result.length - 1]);\n\t}\n\n\treturn result2;\n}\n\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\n\nfunction shiftSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tfor (let i = 0; i < sequenceDiffs.length; i++) {\n\t\tconst prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n\t\tconst diff = sequenceDiffs[i];\n\t\tconst nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n\n\t\tconst seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n\t\tconst seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n\n\t\tif (diff.seq1Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n\t\t} else if (diff.seq2Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n\t\t}\n\t}\n\n\treturn sequenceDiffs;\n}\n\nfunction shiftDiffToBetterPosition(diff: SequenceDiff, sequence1: ISequence, sequence2: ISequence, seq1ValidRange: OffsetRange, seq2ValidRange: OffsetRange,) {\n\tconst maxShiftLimit = 100; // To prevent performance issues\n\n\t// don't touch previous or next!\n\tlet deltaBefore = 1;\n\twhile (\n\t\tdiff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n\t\tdiff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit\n\t) {\n\t\tdeltaBefore++;\n\t}\n\tdeltaBefore--;\n\n\tlet deltaAfter = 0;\n\twhile (\n\t\tdiff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n\t\tdiff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit\n\t) {\n\t\tdeltaAfter++;\n\t}\n\n\tif (deltaBefore === 0 && deltaAfter === 0) {\n\t\treturn diff;\n\t}\n\n\t// Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n\t// and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n\n\tlet bestDelta = 0;\n\tlet bestScore = -1;\n\t// find best scored delta\n\tfor (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n\t\tconst seq2OffsetStart = diff.seq2Range.start + delta;\n\t\tconst seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n\t\tconst seq1Offset = diff.seq1Range.start + delta;\n\n\t\tconst score = sequence1.getBoundaryScore!(seq1Offset) + sequence2.getBoundaryScore!(seq2OffsetStart) + sequence2.getBoundaryScore!(seq2OffsetEndExclusive);\n\t\tif (score > bestScore) {\n\t\t\tbestScore = score;\n\t\t\tbestDelta = delta;\n\t\t}\n\t}\n\n\treturn diff.delta(bestDelta);\n}\n\nexport function removeShortMatches(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\tfor (const s of sequenceDiffs) {\n\t\tconst last = result[result.length - 1];\n\t\tif (!last) {\n\t\t\tresult.push(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n\t\t\tresult[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n\t\t} else {\n\t\t\tresult.push(s);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function extendDiffsToEntireWordIfAppropriate(\n\tsequence1: LinesSliceCharSequence,\n\tsequence2: LinesSliceCharSequence,\n\tsequenceDiffs: SequenceDiff[],\n\tfindParent: (seq: LinesSliceCharSequence, idx: number) => OffsetRange | undefined,\n\tforce: boolean = false,\n): SequenceDiff[] {\n\tconst equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n\n\tconst additional: SequenceDiff[] = [];\n\n\tlet lastPoint = new OffsetPair(0, 0);\n\n\tfunction scanWord(pair: OffsetPair, equalMapping: SequenceDiff) {\n\t\tif (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst w1 = findParent(sequence1, pair.offset1);\n\t\tconst w2 = findParent(sequence2, pair.offset2);\n\t\tif (!w1 || !w2) {\n\t\t\treturn;\n\t\t}\n\t\tlet w = new SequenceDiff(w1, w2);\n\t\tconst equalPart = w.intersect(equalMapping)!;\n\n\t\tlet equalChars1 = equalPart.seq1Range.length;\n\t\tlet equalChars2 = equalPart.seq2Range.length;\n\n\t\t// The words do not touch previous equals mappings, as we would have processed them already.\n\t\t// But they might touch the next ones.\n\n\t\twhile (equalMappings.length > 0) {\n\t\t\tconst next = equalMappings[0];\n\t\t\tconst intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n\t\t\tif (!intersects) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst v1 = findParent(sequence1, next.seq1Range.start);\n\t\t\tconst v2 = findParent(sequence2, next.seq2Range.start);\n\t\t\t// Because there is an intersection, we know that the words are not empty.\n\t\t\tconst v = new SequenceDiff(v1!, v2!);\n\t\t\tconst equalPart = v.intersect(next)!;\n\n\t\t\tequalChars1 += equalPart.seq1Range.length;\n\t\t\tequalChars2 += equalPart.seq2Range.length;\n\n\t\t\tw = w.join(v);\n\n\t\t\tif (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n\t\t\t\t// The word extends beyond the next equal mapping.\n\t\t\t\tequalMappings.shift();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((force && equalChars1 + equalChars2 < w.seq1Range.length + w.seq2Range.length) || equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n\t\t\tadditional.push(w);\n\t\t}\n\n\t\tlastPoint = w.getEndExclusives();\n\t}\n\n\twhile (equalMappings.length > 0) {\n\t\tconst next = equalMappings.shift()!;\n\t\tif (next.seq1Range.isEmpty) {\n\t\t\tcontinue;\n\t\t}\n\t\tscanWord(next.getStarts(), next);\n\t\t// The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n\t\tscanWord(next.getEndExclusives().delta(-1), next);\n\t}\n\n\tconst merged = mergeSequenceDiffs(sequenceDiffs, additional);\n\treturn merged;\n}\n\nfunction mergeSequenceDiffs(sequenceDiffs1: SequenceDiff[], sequenceDiffs2: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\n\twhile (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n\t\tconst sd1 = sequenceDiffs1[0];\n\t\tconst sd2 = sequenceDiffs2[0];\n\n\t\tlet next: SequenceDiff;\n\t\tif (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n\t\t\tnext = sequenceDiffs1.shift()!;\n\t\t} else {\n\t\t\tnext = sequenceDiffs2.shift()!;\n\t\t}\n\n\t\tif (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n\t\t\tresult[result.length - 1] = result[result.length - 1].join(next);\n\t\t} else {\n\t\t\tresult.push(next);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1: LineSequence, _sequence2: LineSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange);\n\t\t\t\tconst unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n\t\t\t\tif (unchangedTextWithoutWs.length <= 4\n\t\t\t\t\t&& (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\treturn diffs;\n}\n\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1: LinesSliceCharSequence, sequence2: LinesSliceCharSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n\t\t\t\tif (unchangedLineCount > 5 || unchangedRange.length > 500) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange).trim();\n\t\t\t\tif (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n\t\t\t\tconst beforeSeq1Length = before.seq1Range.length;\n\t\t\t\tconst beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n\t\t\t\tconst beforeSeq2Length = before.seq2Range.length;\n\n\t\t\t\tconst afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n\t\t\t\tconst afterSeq1Length = after.seq1Range.length;\n\t\t\t\tconst afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n\t\t\t\tconst afterSeq2Length = after.seq2Range.length;\n\n\t\t\t\t// TODO: Maybe a neural net can be used to derive the result from these numbers\n\n\t\t\t\tconst max = 2 * 40 + 50;\n\t\t\t\tfunction cap(v: number): number {\n\t\t\t\t\treturn Math.min(v, max);\n\t\t\t\t}\n\n\t\t\t\tif (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n\t\t\t\t\t+ Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\tconst newDiffs: SequenceDiff[] = [];\n\n\t// Remove short suffixes/prefixes\n\tforEachWithNeighbors(diffs, (prev, cur, next) => {\n\t\tlet newDiff = cur;\n\n\t\tfunction shouldMarkAsChanged(text: string): boolean {\n\t\t\treturn text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n\t\t}\n\n\t\tconst fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n\t\tconst prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n\t\tif (shouldMarkAsChanged(prefix)) {\n\t\t\tnewDiff = newDiff.deltaStart(-prefix.length);\n\t\t}\n\t\tconst suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n\t\tif (shouldMarkAsChanged(suffix)) {\n\t\t\tnewDiff = newDiff.deltaEnd(suffix.length);\n\t\t}\n\n\t\tconst availableSpace = SequenceDiff.fromOffsetPairs(\n\t\t\tprev ? prev.getEndExclusives() : OffsetPair.zero,\n\t\t\tnext ? next.getStarts() : OffsetPair.max,\n\t\t);\n\t\tconst result = newDiff.intersect(availableSpace)!;\n\t\tif (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n\t\t\tnewDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n\t\t} else {\n\t\t\tnewDiffs.push(result);\n\t\t}\n\t});\n\n\treturn newDiffs;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { ISequence, OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\n\nexport function optimizeSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet result = sequenceDiffs;\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\t// Sometimes, calling this function twice improves the result.\n\t// Uncomment the second invocation and run the tests to see the difference.\n\tresult = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n\tresult = shiftSequenceDiffs(sequence1, sequence2, result);\n\treturn result;\n}\n\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (sequenceDiffs.length === 0) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tconst result: SequenceDiff[] = [];\n\tresult.push(sequenceDiffs[0]);\n\n\t// First move them all to the left as much as possible and join them if possible\n\tfor (let i = 1; i < sequenceDiffs.length; i++) {\n\t\tconst prevResult = result[result.length - 1];\n\t\tlet cur = sequenceDiffs[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 1; d <= length; d++) {\n\t\t\t\tif (\n\t\t\t\t\tsequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n\t\t\t\t\tsequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\td--;\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff\n\t\t\t\tresult[result.length - 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length),\n\t\t\t\t\tnew OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcur = cur.delta(-d);\n\t\t}\n\n\t\tresult.push(cur);\n\t}\n\n\tconst result2: SequenceDiff[] = [];\n\t// Then move them all to the right and join them again if possible\n\tfor (let i = 0; i < result.length - 1; i++) {\n\t\tconst nextResult = result[i + 1];\n\t\tlet cur = result[i];\n\n\t\tif (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n\t\t\tconst length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n\t\t\tlet d;\n\t\t\tfor (d = 0; d < length; d++) {\n\t\t\t\tif (\n\t\t\t\t\t!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n\t\t\t\t\t!sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (d === length) {\n\t\t\t\t// Merge previous and current diff, write to result!\n\t\t\t\tresult[i + 1] = new SequenceDiff(\n\t\t\t\t\tnew OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive),\n\t\t\t\t\tnew OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (d > 0) {\n\t\t\t\tcur = cur.delta(d);\n\t\t\t}\n\t\t}\n\n\t\tresult2.push(cur);\n\t}\n\n\tif (result.length > 0) {\n\t\tresult2.push(result[result.length - 1]);\n\t}\n\n\treturn result2;\n}\n\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\n\nfunction shiftSequenceDiffs(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tif (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n\t\treturn sequenceDiffs;\n\t}\n\n\tfor (let i = 0; i < sequenceDiffs.length; i++) {\n\t\tconst prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n\t\tconst diff = sequenceDiffs[i];\n\t\tconst nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n\n\t\tconst seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n\t\tconst seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n\n\t\tif (diff.seq1Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n\t\t} else if (diff.seq2Range.isEmpty) {\n\t\t\tsequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n\t\t}\n\t}\n\n\treturn sequenceDiffs;\n}\n\nfunction shiftDiffToBetterPosition(diff: SequenceDiff, sequence1: ISequence, sequence2: ISequence, seq1ValidRange: OffsetRange, seq2ValidRange: OffsetRange,) {\n\tconst maxShiftLimit = 100; // To prevent performance issues\n\n\t// don't touch previous or next!\n\tlet deltaBefore = 1;\n\twhile (\n\t\tdiff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n\t\tdiff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit\n\t) {\n\t\tdeltaBefore++;\n\t}\n\tdeltaBefore--;\n\n\tlet deltaAfter = 0;\n\twhile (\n\t\tdiff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n\t\tdiff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n\t\tsequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit\n\t) {\n\t\tdeltaAfter++;\n\t}\n\n\tif (deltaBefore === 0 && deltaAfter === 0) {\n\t\treturn diff;\n\t}\n\n\t// Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n\t// and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n\n\tlet bestDelta = 0;\n\tlet bestScore = -1;\n\t// find best scored delta\n\tfor (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n\t\tconst seq2OffsetStart = diff.seq2Range.start + delta;\n\t\tconst seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n\t\tconst seq1Offset = diff.seq1Range.start + delta;\n\n\t\tconst score = sequence1.getBoundaryScore!(seq1Offset) + sequence2.getBoundaryScore!(seq2OffsetStart) + sequence2.getBoundaryScore!(seq2OffsetEndExclusive);\n\t\tif (score > bestScore) {\n\t\t\tbestScore = score;\n\t\t\tbestDelta = delta;\n\t\t}\n\t}\n\n\treturn diff.delta(bestDelta);\n}\n\nexport function removeShortMatches(sequence1: ISequence, sequence2: ISequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\tfor (const s of sequenceDiffs) {\n\t\tconst last = result[result.length - 1];\n\t\tif (!last) {\n\t\t\tresult.push(s);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n\t\t\tresult[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n\t\t} else {\n\t\t\tresult.push(s);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function extendDiffsToEntireWordIfAppropriate(\n\tsequence1: LinesSliceCharSequence,\n\tsequence2: LinesSliceCharSequence,\n\tsequenceDiffs: SequenceDiff[],\n\tfindParent: (seq: LinesSliceCharSequence, idx: number) => OffsetRange | undefined,\n\tforce: boolean = false,\n): SequenceDiff[] {\n\tconst equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n\n\tconst additional: SequenceDiff[] = [];\n\n\tlet lastPoint = new OffsetPair(0, 0);\n\n\tfunction scanWord(pair: OffsetPair, equalMapping: SequenceDiff) {\n\t\tif (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst w1 = findParent(sequence1, pair.offset1);\n\t\tconst w2 = findParent(sequence2, pair.offset2);\n\t\tif (!w1 || !w2) {\n\t\t\treturn;\n\t\t}\n\t\tlet w = new SequenceDiff(w1, w2);\n\t\tconst equalPart = w.intersect(equalMapping)!;\n\n\t\tlet equalChars1 = equalPart.seq1Range.length;\n\t\tlet equalChars2 = equalPart.seq2Range.length;\n\n\t\t// The words do not touch previous equals mappings, as we would have processed them already.\n\t\t// But they might touch the next ones.\n\n\t\twhile (equalMappings.length > 0) {\n\t\t\tconst next = equalMappings[0];\n\t\t\tconst intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n\t\t\tif (!intersects) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst v1 = findParent(sequence1, next.seq1Range.start);\n\t\t\tconst v2 = findParent(sequence2, next.seq2Range.start);\n\t\t\t// Because there is an intersection, we know that the words are not empty.\n\t\t\tconst v = new SequenceDiff(v1!, v2!);\n\t\t\tconst equalPart = v.intersect(next)!;\n\n\t\t\tequalChars1 += equalPart.seq1Range.length;\n\t\t\tequalChars2 += equalPart.seq2Range.length;\n\n\t\t\tw = w.join(v);\n\n\t\t\tif (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n\t\t\t\t// The word extends beyond the next equal mapping.\n\t\t\t\tequalMappings.shift();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((force && equalChars1 + equalChars2 < w.seq1Range.length + w.seq2Range.length) || equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n\t\t\tadditional.push(w);\n\t\t}\n\n\t\tlastPoint = w.getEndExclusives();\n\t}\n\n\twhile (equalMappings.length > 0) {\n\t\tconst next = equalMappings.shift()!;\n\t\tif (next.seq1Range.isEmpty) {\n\t\t\tcontinue;\n\t\t}\n\t\tscanWord(next.getStarts(), next);\n\t\t// The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n\t\tscanWord(next.getEndExclusives().delta(-1), next);\n\t}\n\n\tconst merged = mergeSequenceDiffs(sequenceDiffs, additional);\n\treturn merged;\n}\n\nfunction mergeSequenceDiffs(sequenceDiffs1: SequenceDiff[], sequenceDiffs2: SequenceDiff[]): SequenceDiff[] {\n\tconst result: SequenceDiff[] = [];\n\n\twhile (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n\t\tconst sd1 = sequenceDiffs1[0];\n\t\tconst sd2 = sequenceDiffs2[0];\n\n\t\tlet next: SequenceDiff;\n\t\tif (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n\t\t\tnext = sequenceDiffs1.shift()!;\n\t\t} else {\n\t\t\tnext = sequenceDiffs2.shift()!;\n\t\t}\n\n\t\tif (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n\t\t\tresult[result.length - 1] = result[result.length - 1].join(next);\n\t\t} else {\n\t\t\tresult.push(next);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1: LineSequence, _sequence2: LineSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange);\n\t\t\t\tconst unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n\t\t\t\tif (unchangedTextWithoutWs.length <= 4\n\t\t\t\t\t&& (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\treturn diffs;\n}\n\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1: LinesSliceCharSequence, sequence2: LinesSliceCharSequence, sequenceDiffs: SequenceDiff[]): SequenceDiff[] {\n\tlet diffs = sequenceDiffs;\n\tif (diffs.length === 0) {\n\t\treturn diffs;\n\t}\n\n\tlet counter = 0;\n\tlet shouldRepeat: boolean;\n\tdo {\n\t\tshouldRepeat = false;\n\n\t\tconst result: SequenceDiff[] = [\n\t\t\tdiffs[0]\n\t\t];\n\n\t\tfor (let i = 1; i < diffs.length; i++) {\n\t\t\tconst cur = diffs[i];\n\t\t\tconst lastResult = result[result.length - 1];\n\n\t\t\tfunction shouldJoinDiffs(before: SequenceDiff, after: SequenceDiff): boolean {\n\t\t\t\tconst unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n\n\t\t\t\tconst unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n\t\t\t\tif (unchangedLineCount > 5 || unchangedRange.length > 500) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst unchangedText = sequence1.getText(unchangedRange).trim();\n\t\t\t\tif (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tconst beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n\t\t\t\tconst beforeSeq1Length = before.seq1Range.length;\n\t\t\t\tconst beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n\t\t\t\tconst beforeSeq2Length = before.seq2Range.length;\n\n\t\t\t\tconst afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n\t\t\t\tconst afterSeq1Length = after.seq1Range.length;\n\t\t\t\tconst afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n\t\t\t\tconst afterSeq2Length = after.seq2Range.length;\n\n\t\t\t\t// TODO: Maybe a neural net can be used to derive the result from these numbers\n\n\t\t\t\tconst max = 2 * 40 + 50;\n\t\t\t\tfunction cap(v: number): number {\n\t\t\t\t\treturn Math.min(v, max);\n\t\t\t\t}\n\n\t\t\t\tif (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n\t\t\t\t\t+ Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst shouldJoin = shouldJoinDiffs(lastResult, cur);\n\t\t\tif (shouldJoin) {\n\t\t\t\tshouldRepeat = true;\n\t\t\t\tresult[result.length - 1] = result[result.length - 1].join(cur);\n\t\t\t} else {\n\t\t\t\tresult.push(cur);\n\t\t\t}\n\t\t}\n\n\t\tdiffs = result;\n\t} while (counter++ < 10 && shouldRepeat);\n\n\tconst newDiffs: SequenceDiff[] = [];\n\n\t// Remove short suffixes/prefixes\n\tforEachWithNeighbors(diffs, (prev, cur, next) => {\n\t\tlet newDiff = cur;\n\n\t\tfunction shouldMarkAsChanged(text: string): boolean {\n\t\t\treturn text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n\t\t}\n\n\t\tconst fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n\t\tconst prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n\t\tif (shouldMarkAsChanged(prefix)) {\n\t\t\tnewDiff = newDiff.deltaStart(-prefix.length);\n\t\t}\n\t\tconst suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n\t\tif (shouldMarkAsChanged(suffix)) {\n\t\t\tnewDiff = newDiff.deltaEnd(suffix.length);\n\t\t}\n\n\t\tconst availableSpace = SequenceDiff.fromOffsetPairs(\n\t\t\tprev ? prev.getEndExclusives() : OffsetPair.zero,\n\t\t\tnext ? next.getStarts() : OffsetPair.max,\n\t\t);\n\t\tconst result = newDiff.intersect(availableSpace)!;\n\t\tif (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n\t\t\tnewDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n\t\t} else {\n\t\t\tnewDiffs.push(result);\n\t\t}\n\t});\n\n\treturn newDiffs;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1599, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\n\nexport class LineSequence implements ISequence {\n\tconstructor(\n\t\tprivate readonly trimmedHash: number[],\n\t\tprivate readonly lines: string[]\n\t) { }\n\n\tgetElement(offset: number): number {\n\t\treturn this.trimmedHash[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.trimmedHash.length;\n\t}\n\n\tgetBoundaryScore(length: number): number {\n\t\tconst indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n\t\tconst indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n\t\treturn 1000 - (indentationBefore + indentationAfter);\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.lines.slice(range.start, range.endExclusive).join('\\n');\n\t}\n\n\tisStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.lines[offset1] === this.lines[offset2];\n\t}\n}\n\nfunction getIndentation(str: string): number {\n\tlet i = 0;\n\twhile (i < str.length && (str.charCodeAt(i) === CharCode.Space || str.charCodeAt(i) === CharCode.Tab)) {\n\t\ti++;\n\t}\n\treturn i;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { ISequence } from './algorithms/diffAlgorithm.js';\n\nexport class LineSequence implements ISequence {\n\tconstructor(\n\t\tprivate readonly trimmedHash: number[],\n\t\tprivate readonly lines: string[]\n\t) { }\n\n\tgetElement(offset: number): number {\n\t\treturn this.trimmedHash[offset];\n\t}\n\n\tget length(): number {\n\t\treturn this.trimmedHash.length;\n\t}\n\n\tgetBoundaryScore(length: number): number {\n\t\tconst indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n\t\tconst indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n\t\treturn 1000 - (indentationBefore + indentationAfter);\n\t}\n\n\tgetText(range: OffsetRange): string {\n\t\treturn this.lines.slice(range.start, range.endExclusive).join('\\n');\n\t}\n\n\tisStronglyEqual(offset1: number, offset2: number): boolean {\n\t\treturn this.lines[offset1] === this.lines[offset2];\n\t}\n}\n\nfunction getIndentation(str: string): number {\n\tlet i = 0;\n\twhile (i < str.length && (str.charCodeAt(i) === CharCode.Space || str.charCodeAt(i) === CharCode.Tab)) {\n\t\ti++;\n\t}\n\treturn i;\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAM1F,MAAO,YAAY;IAMxB,UAAU,CAAC,MAAc,EAAA;QACxB,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;IACjC,CAAC;IAED,IAAI,MAAM,GAAA;QACT,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;IAChC,CAAC;IAED,gBAAgB,CAAC,MAAc,EAAA;QAC9B,MAAM,iBAAiB,GAAG,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QACpF,MAAM,gBAAgB,GAAG,MAAM,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;QAC/F,OAAO,IAAI,GAAG,CAAC,iBAAiB,GAAG,gBAAgB,CAAC,CAAC;IACtD,CAAC;IAED,OAAO,CAAC,KAAkB,EAAA;QACzB,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACrE,CAAC;IAED,eAAe,CAAC,OAAe,EAAE,OAAe,EAAA;QAC/C,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IACpD,CAAC;IAzBD,YACkB,WAAqB,EACrB,KAAe,CAAA;QADf,IAAA,CAAA,WAAW,GAAX,WAAW,CAAU;QACrB,IAAA,CAAA,KAAK,GAAL,KAAK,CAAU;IAC7B,CAAC;CAuBL;AAED,SAAS,cAAc,CAAC,GAAW;IAClC,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,MAAO,CAAC,GAAG,GAAG,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,KAAA,GAAA,kBAAA,EAAmB,KAAI,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,KAAA,EAAA,gBAAA,GAAiB,CAAC,CAAE,CAAC;QACvG,CAAC,EAAE,CAAC;IACL,CAAC;IACD,OAAO,CAAC,CAAC;AACV,CAAC","debugId":null}},
    {"offset": {"line": 1640, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../../base/common/arrays.js';\nimport { assertFn } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ArrayText } from '../../core/text/abstractText.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, lineRangeMappingFromRangeMappings, RangeMapping } from '../rangeMapping.js';\nimport { DateTimeout, InfiniteTimeout, ITimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\n\nexport class DefaultLinesDiffComputer implements ILinesDiffComputer {\n\tprivate readonly dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n\tprivate readonly myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tif (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n\t\t\treturn new LinesDiff([], [], false);\n\t\t}\n\n\t\tif (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n\t\t\treturn new LinesDiff([\n\t\t\t\tnew DetailedLineRangeMapping(\n\t\t\t\t\tnew LineRange(1, originalLines.length + 1),\n\t\t\t\t\tnew LineRange(1, modifiedLines.length + 1),\n\t\t\t\t\t[\n\t\t\t\t\t\tnew RangeMapping(\n\t\t\t\t\t\t\tnew Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1),\n\t\t\t\t\t\t\tnew Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1),\n\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t)\n\t\t\t], [], false);\n\t\t}\n\n\t\tconst timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n\t\tconst considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n\n\t\tconst perfectHashes = new Map<string, number>();\n\t\tfunction getOrCreateHash(text: string): number {\n\t\t\tlet hash = perfectHashes.get(text);\n\t\t\tif (hash === undefined) {\n\t\t\t\thash = perfectHashes.size;\n\t\t\t\tperfectHashes.set(text, hash);\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\n\t\tconst originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n\t\tconst modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n\n\t\tconst sequence1 = new LineSequence(originalLinesHashes, originalLines);\n\t\tconst sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n\n\t\tconst lineAlignmentResult = (() => {\n\t\t\tif (sequence1.length + sequence2.length < 1700) {\n\t\t\t\t// Use the improved algorithm for small files\n\t\t\t\treturn this.dynamicProgrammingDiffing.compute(\n\t\t\t\t\tsequence1,\n\t\t\t\t\tsequence2,\n\t\t\t\t\ttimeout,\n\t\t\t\t\t(offset1, offset2) =>\n\t\t\t\t\t\toriginalLines[offset1] === modifiedLines[offset2]\n\t\t\t\t\t\t\t? modifiedLines[offset2].length === 0\n\t\t\t\t\t\t\t\t? 0.1\n\t\t\t\t\t\t\t\t: 1 + Math.log(1 + modifiedLines[offset2].length)\n\t\t\t\t\t\t\t: 0.99\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.myersDiffingAlgorithm.compute(\n\t\t\t\tsequence1,\n\t\t\t\tsequence2,\n\t\t\t\ttimeout\n\t\t\t);\n\t\t})();\n\n\t\tlet lineAlignments = lineAlignmentResult.diffs;\n\t\tlet hitTimeout = lineAlignmentResult.hitTimeout;\n\t\tlineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n\t\tlineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n\n\t\tconst alignments: RangeMapping[] = [];\n\n\t\tconst scanForWhitespaceChanges = (equalLinesCount: number) => {\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < equalLinesCount; i++) {\n\t\t\t\tconst seq1Offset = seq1LastStart + i;\n\t\t\t\tconst seq2Offset = seq2LastStart + i;\n\t\t\t\tif (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n\t\t\t\t\t// This is because of whitespace changes, diff these lines\n\t\t\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\t\t\tnew OffsetRange(seq1Offset, seq1Offset + 1),\n\t\t\t\t\t\tnew OffsetRange(seq2Offset, seq2Offset + 1),\n\t\t\t\t\t), timeout, considerWhitespaceChanges, options);\n\t\t\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\t\t\talignments.push(a);\n\t\t\t\t\t}\n\t\t\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\t\t\thitTimeout = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet seq1LastStart = 0;\n\t\tlet seq2LastStart = 0;\n\n\t\tfor (const diff of lineAlignments) {\n\t\t\tassertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n\n\t\t\tconst equalLinesCount = diff.seq1Range.start - seq1LastStart;\n\n\t\t\tscanForWhitespaceChanges(equalLinesCount);\n\n\t\t\tseq1LastStart = diff.seq1Range.endExclusive;\n\t\t\tseq2LastStart = diff.seq2Range.endExclusive;\n\n\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges, options);\n\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\thitTimeout = true;\n\t\t\t}\n\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\talignments.push(a);\n\t\t\t}\n\t\t}\n\n\t\tscanForWhitespaceChanges(originalLines.length - seq1LastStart);\n\n\t\tconst original = new ArrayText(originalLines);\n\t\tconst modified = new ArrayText(modifiedLines);\n\n\t\tconst changes = lineRangeMappingFromRangeMappings(alignments, original, modified);\n\n\t\tlet moves: MovedText[] = [];\n\t\tif (options.computeMoves) {\n\t\t\tmoves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges, options);\n\t\t}\n\n\t\t// Make sure all ranges are valid\n\t\tassertFn(() => {\n\t\t\tfunction validatePosition(pos: Position, lines: string[]): boolean {\n\t\t\t\tif (pos.lineNumber < 1 || pos.lineNumber > lines.length) { return false; }\n\t\t\t\tconst line = lines[pos.lineNumber - 1];\n\t\t\t\tif (pos.column < 1 || pos.column > line.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction validateRange(range: LineRange, lines: string[]): boolean {\n\t\t\t\tif (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) { return false; }\n\t\t\t\tif (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (const c of changes) {\n\t\t\t\tif (!c.innerChanges) { return false; }\n\t\t\t\tfor (const ic of c.innerChanges) {\n\t\t\t\t\tconst valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n\t\t\t\t\t\tvalidatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\treturn new LinesDiff(changes, moves, hitTimeout);\n\t}\n\n\tprivate computeMoves(\n\t\tchanges: DetailedLineRangeMapping[],\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\thashedOriginalLines: number[],\n\t\thashedModifiedLines: number[],\n\t\ttimeout: ITimeout,\n\t\tconsiderWhitespaceChanges: boolean,\n\t\toptions: ILinesDiffComputerOptions,\n\t): MovedText[] {\n\t\tconst moves = computeMovedLines(\n\t\t\tchanges,\n\t\t\toriginalLines,\n\t\t\tmodifiedLines,\n\t\t\thashedOriginalLines,\n\t\t\thashedModifiedLines,\n\t\t\ttimeout,\n\t\t);\n\t\tconst movesWithDiffs = moves.map(m => {\n\t\t\tconst moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\tm.original.toOffsetRange(),\n\t\t\t\tm.modified.toOffsetRange(),\n\t\t\t), timeout, considerWhitespaceChanges, options);\n\t\t\tconst mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, new ArrayText(originalLines), new ArrayText(modifiedLines), true);\n\t\t\treturn new MovedText(m, mappings);\n\t\t});\n\t\treturn movesWithDiffs;\n\t}\n\n\tprivate refineDiff(originalLines: string[], modifiedLines: string[], diff: SequenceDiff, timeout: ITimeout, considerWhitespaceChanges: boolean, options: ILinesDiffComputerOptions): { mappings: RangeMapping[]; hitTimeout: boolean } {\n\t\tconst lineRangeMapping = toLineRangeMapping(diff);\n\t\tconst rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n\n\t\tconst slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n\t\tconst slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n\n\t\tconst diffResult = slice1.length + slice2.length < 500\n\t\t\t? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n\t\t\t: this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n\n\t\tconst check = false;\n\n\t\tlet diffs = diffResult.diffs;\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findWordContaining(idx));\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\n\t\tif (options.extendToSubwords) {\n\t\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findSubWordContaining(idx), true);\n\t\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\t}\n\n\t\tdiffs = removeShortMatches(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\n\t\tconst result = diffs.map(\n\t\t\t(d) =>\n\t\t\t\tnew RangeMapping(\n\t\t\t\t\tslice1.translateRange(d.seq1Range),\n\t\t\t\t\tslice2.translateRange(d.seq2Range)\n\t\t\t\t)\n\t\t);\n\n\t\tif (check) { RangeMapping.assertSorted(result); }\n\n\t\t// Assert: result applied on original should be the same as diff applied to original\n\n\t\treturn {\n\t\t\tmappings: result,\n\t\t\thitTimeout: diffResult.hitTimeout,\n\t\t};\n\t}\n}\n\nfunction toLineRangeMapping(sequenceDiff: SequenceDiff) {\n\treturn new LineRangeMapping(\n\t\tnew LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1),\n\t\tnew LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1),\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from '../../../../base/common/arrays.js';\nimport { assertFn } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/ranges/lineRange.js';\nimport { OffsetRange } from '../../core/ranges/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { ArrayText } from '../../core/text/abstractText.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, LineRangeMapping, lineRangeMappingFromRangeMappings, RangeMapping } from '../rangeMapping.js';\nimport { DateTimeout, InfiniteTimeout, ITimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\n\nexport class DefaultLinesDiffComputer implements ILinesDiffComputer {\n\tprivate readonly dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n\tprivate readonly myersDiffingAlgorithm = new MyersDiffAlgorithm();\n\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tif (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n\t\t\treturn new LinesDiff([], [], false);\n\t\t}\n\n\t\tif (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n\t\t\treturn new LinesDiff([\n\t\t\t\tnew DetailedLineRangeMapping(\n\t\t\t\t\tnew LineRange(1, originalLines.length + 1),\n\t\t\t\t\tnew LineRange(1, modifiedLines.length + 1),\n\t\t\t\t\t[\n\t\t\t\t\t\tnew RangeMapping(\n\t\t\t\t\t\t\tnew Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1),\n\t\t\t\t\t\t\tnew Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1),\n\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t)\n\t\t\t], [], false);\n\t\t}\n\n\t\tconst timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n\t\tconst considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n\n\t\tconst perfectHashes = new Map<string, number>();\n\t\tfunction getOrCreateHash(text: string): number {\n\t\t\tlet hash = perfectHashes.get(text);\n\t\t\tif (hash === undefined) {\n\t\t\t\thash = perfectHashes.size;\n\t\t\t\tperfectHashes.set(text, hash);\n\t\t\t}\n\t\t\treturn hash;\n\t\t}\n\n\t\tconst originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n\t\tconst modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n\n\t\tconst sequence1 = new LineSequence(originalLinesHashes, originalLines);\n\t\tconst sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n\n\t\tconst lineAlignmentResult = (() => {\n\t\t\tif (sequence1.length + sequence2.length < 1700) {\n\t\t\t\t// Use the improved algorithm for small files\n\t\t\t\treturn this.dynamicProgrammingDiffing.compute(\n\t\t\t\t\tsequence1,\n\t\t\t\t\tsequence2,\n\t\t\t\t\ttimeout,\n\t\t\t\t\t(offset1, offset2) =>\n\t\t\t\t\t\toriginalLines[offset1] === modifiedLines[offset2]\n\t\t\t\t\t\t\t? modifiedLines[offset2].length === 0\n\t\t\t\t\t\t\t\t? 0.1\n\t\t\t\t\t\t\t\t: 1 + Math.log(1 + modifiedLines[offset2].length)\n\t\t\t\t\t\t\t: 0.99\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.myersDiffingAlgorithm.compute(\n\t\t\t\tsequence1,\n\t\t\t\tsequence2,\n\t\t\t\ttimeout\n\t\t\t);\n\t\t})();\n\n\t\tlet lineAlignments = lineAlignmentResult.diffs;\n\t\tlet hitTimeout = lineAlignmentResult.hitTimeout;\n\t\tlineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n\t\tlineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n\n\t\tconst alignments: RangeMapping[] = [];\n\n\t\tconst scanForWhitespaceChanges = (equalLinesCount: number) => {\n\t\t\tif (!considerWhitespaceChanges) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < equalLinesCount; i++) {\n\t\t\t\tconst seq1Offset = seq1LastStart + i;\n\t\t\t\tconst seq2Offset = seq2LastStart + i;\n\t\t\t\tif (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n\t\t\t\t\t// This is because of whitespace changes, diff these lines\n\t\t\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\t\t\tnew OffsetRange(seq1Offset, seq1Offset + 1),\n\t\t\t\t\t\tnew OffsetRange(seq2Offset, seq2Offset + 1),\n\t\t\t\t\t), timeout, considerWhitespaceChanges, options);\n\t\t\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\t\t\talignments.push(a);\n\t\t\t\t\t}\n\t\t\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\t\t\thitTimeout = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet seq1LastStart = 0;\n\t\tlet seq2LastStart = 0;\n\n\t\tfor (const diff of lineAlignments) {\n\t\t\tassertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n\n\t\t\tconst equalLinesCount = diff.seq1Range.start - seq1LastStart;\n\n\t\t\tscanForWhitespaceChanges(equalLinesCount);\n\n\t\t\tseq1LastStart = diff.seq1Range.endExclusive;\n\t\t\tseq2LastStart = diff.seq2Range.endExclusive;\n\n\t\t\tconst characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges, options);\n\t\t\tif (characterDiffs.hitTimeout) {\n\t\t\t\thitTimeout = true;\n\t\t\t}\n\t\t\tfor (const a of characterDiffs.mappings) {\n\t\t\t\talignments.push(a);\n\t\t\t}\n\t\t}\n\n\t\tscanForWhitespaceChanges(originalLines.length - seq1LastStart);\n\n\t\tconst original = new ArrayText(originalLines);\n\t\tconst modified = new ArrayText(modifiedLines);\n\n\t\tconst changes = lineRangeMappingFromRangeMappings(alignments, original, modified);\n\n\t\tlet moves: MovedText[] = [];\n\t\tif (options.computeMoves) {\n\t\t\tmoves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges, options);\n\t\t}\n\n\t\t// Make sure all ranges are valid\n\t\tassertFn(() => {\n\t\t\tfunction validatePosition(pos: Position, lines: string[]): boolean {\n\t\t\t\tif (pos.lineNumber < 1 || pos.lineNumber > lines.length) { return false; }\n\t\t\t\tconst line = lines[pos.lineNumber - 1];\n\t\t\t\tif (pos.column < 1 || pos.column > line.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction validateRange(range: LineRange, lines: string[]): boolean {\n\t\t\t\tif (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) { return false; }\n\t\t\t\tif (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) { return false; }\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (const c of changes) {\n\t\t\t\tif (!c.innerChanges) { return false; }\n\t\t\t\tfor (const ic of c.innerChanges) {\n\t\t\t\t\tconst valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n\t\t\t\t\t\tvalidatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\treturn new LinesDiff(changes, moves, hitTimeout);\n\t}\n\n\tprivate computeMoves(\n\t\tchanges: DetailedLineRangeMapping[],\n\t\toriginalLines: string[],\n\t\tmodifiedLines: string[],\n\t\thashedOriginalLines: number[],\n\t\thashedModifiedLines: number[],\n\t\ttimeout: ITimeout,\n\t\tconsiderWhitespaceChanges: boolean,\n\t\toptions: ILinesDiffComputerOptions,\n\t): MovedText[] {\n\t\tconst moves = computeMovedLines(\n\t\t\tchanges,\n\t\t\toriginalLines,\n\t\t\tmodifiedLines,\n\t\t\thashedOriginalLines,\n\t\t\thashedModifiedLines,\n\t\t\ttimeout,\n\t\t);\n\t\tconst movesWithDiffs = moves.map(m => {\n\t\t\tconst moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(\n\t\t\t\tm.original.toOffsetRange(),\n\t\t\t\tm.modified.toOffsetRange(),\n\t\t\t), timeout, considerWhitespaceChanges, options);\n\t\t\tconst mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, new ArrayText(originalLines), new ArrayText(modifiedLines), true);\n\t\t\treturn new MovedText(m, mappings);\n\t\t});\n\t\treturn movesWithDiffs;\n\t}\n\n\tprivate refineDiff(originalLines: string[], modifiedLines: string[], diff: SequenceDiff, timeout: ITimeout, considerWhitespaceChanges: boolean, options: ILinesDiffComputerOptions): { mappings: RangeMapping[]; hitTimeout: boolean } {\n\t\tconst lineRangeMapping = toLineRangeMapping(diff);\n\t\tconst rangeMapping = lineRangeMapping.toRangeMapping2(originalLines, modifiedLines);\n\n\t\tconst slice1 = new LinesSliceCharSequence(originalLines, rangeMapping.originalRange, considerWhitespaceChanges);\n\t\tconst slice2 = new LinesSliceCharSequence(modifiedLines, rangeMapping.modifiedRange, considerWhitespaceChanges);\n\n\t\tconst diffResult = slice1.length + slice2.length < 500\n\t\t\t? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n\t\t\t: this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n\n\t\tconst check = false;\n\n\t\tlet diffs = diffResult.diffs;\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findWordContaining(idx));\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\n\t\tif (options.extendToSubwords) {\n\t\t\tdiffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs, (seq, idx) => seq.findSubWordContaining(idx), true);\n\t\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\t}\n\n\t\tdiffs = removeShortMatches(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\t\tdiffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n\t\tif (check) { SequenceDiff.assertSorted(diffs); }\n\n\t\tconst result = diffs.map(\n\t\t\t(d) =>\n\t\t\t\tnew RangeMapping(\n\t\t\t\t\tslice1.translateRange(d.seq1Range),\n\t\t\t\t\tslice2.translateRange(d.seq2Range)\n\t\t\t\t)\n\t\t);\n\n\t\tif (check) { RangeMapping.assertSorted(result); }\n\n\t\t// Assert: result applied on original should be the same as diff applied to original\n\n\t\treturn {\n\t\t\tmappings: result,\n\t\t\thitTimeout: diffResult.hitTimeout,\n\t\t};\n\t}\n}\n\nfunction toLineRangeMapping(sequenceDiff: SequenceDiff) {\n\treturn new LineRangeMapping(\n\t\tnew LineRange(sequenceDiff.seq1Range.start + 1, sequenceDiff.seq1Range.endExclusive + 1),\n\t\tnew LineRange(sequenceDiff.seq2Range.start + 1, sequenceDiff.seq2Range.endExclusive + 1),\n\t);\n}\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,MAAM,EAAE,MAAM,mCAAmC,CAAC;AAC3D,OAAO,EAAE,QAAQ,EAAE,MAAM,mCAAmC,CAAC;AAC7D,OAAO,EAAE,SAAS,EAAE,MAAM,gCAAgC,CAAC;AAC3D,OAAO,EAAE,WAAW,EAAE,MAAM,kCAAkC,CAAC;AAE/D,OAAO,EAAE,KAAK,EAAE,MAAM,qBAAqB,CAAC;AAC5C,OAAO,EAAE,SAAS,EAAE,MAAM,iCAAiC,CAAC;AAC5D,OAAO,EAAiD,SAAS,EAAE,SAAS,EAAE,MAAM,yBAAyB,CAAC;AAC9G,OAAO,EAAE,wBAAwB,EAAE,gBAAgB,EAAE,iCAAiC,EAAE,YAAY,EAAE,MAAM,oBAAoB,CAAC;AACjI,OAAO,EAAE,WAAW,EAAE,eAAe,EAAY,YAAY,EAAE,MAAM,+BAA+B,CAAC;AACrG,OAAO,EAAE,yBAAyB,EAAE,MAAM,2CAA2C,CAAC;AACtF,OAAO,EAAE,kBAAkB,EAAE,MAAM,oCAAoC,CAAC;AACxE,OAAO,EAAE,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;AAC3D,OAAO,EAAE,oCAAoC,EAAE,qBAAqB,EAAE,kBAAkB,EAAE,wCAAwC,EAAE,2CAA2C,EAAE,MAAM,qCAAqC,CAAC;AAC7N,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACjD,OAAO,EAAE,sBAAsB,EAAE,MAAM,6BAA6B,CAAC;;;;;;;;;;;;;;;;AAE/D,MAAO,wBAAwB;IAIpC,WAAW,CAAC,aAAuB,EAAE,aAAuB,EAAE,OAAkC,EAAA;QAC/F,IAAI,aAAa,CAAC,MAAM,IAAI,CAAC,IAAI,0LAAM,EAAC,aAAa,EAAE,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAG,CAAC,AAAF,KAAO,CAAC,CAAC,EAAE,CAAC;YAC1F,OAAO,IAAI,8MAAS,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;QACrC,CAAC;QAED,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,IAAI,aAAa,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,IAAI,aAAa,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAChI,OAAO,IAAI,8MAAS,CAAC;gBACpB,IAAI,wNAAwB,CAC3B,IAAI,gNAAS,CAAC,CAAC,EAAE,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,EAC1C,IAAI,gNAAS,CAAC,CAAC,EAAE,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,EAC1C;oBACC,IAAI,4MAAY,CACf,IAAI,8LAAK,CAAC,CAAC,EAAE,CAAC,EAAE,aAAa,CAAC,MAAM,EAAE,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,EACzF,IAAI,8LAAK,CAAC,CAAC,EAAE,CAAC,EAAE,aAAa,CAAC,MAAM,EAAE,aAAa,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CACzF;iBACD,CACD;aACD,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;QACf,CAAC;QAED,MAAM,OAAO,GAAG,OAAO,CAAC,oBAAoB,KAAK,CAAC,CAAC,CAAC,CAAC,0PAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,sPAAW,CAAC,OAAO,CAAC,oBAAoB,CAAC,CAAC;QAC9H,MAAM,yBAAyB,GAAG,CAAC,OAAO,CAAC,oBAAoB,CAAC;QAEhE,MAAM,aAAa,GAAG,IAAI,GAAG,EAAkB,CAAC;QAChD,SAAS,eAAe,CAAC,IAAY;YACpC,IAAI,IAAI,GAAG,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACnC,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;gBACxB,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC;gBAC1B,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YAC/B,CAAC;YACD,OAAO,IAAI,CAAC;QACb,CAAC;QAED,MAAM,mBAAmB,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,cAAgB,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAChF,MAAM,mBAAmB,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,cAAgB,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QAEhF,MAAM,SAAS,GAAG,IAAI,wOAAY,CAAC,mBAAmB,EAAE,aAAa,CAAC,CAAC;QACvE,MAAM,SAAS,GAAG,IAAI,wOAAY,CAAC,mBAAmB,EAAE,aAAa,CAAC,CAAC;QAEvE,MAAM,mBAAmB,GAAG,CAAC,GAAG,EAAE;YACjC,IAAI,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,GAAG,IAAI,EAAE,CAAC;gBAChD,6CAA6C;gBAC7C,OAAO,IAAI,CAAC,yBAAyB,CAAC,OAAO,CAC5C,SAAS,EACT,SAAS,EACT,OAAO,EACP,CAAC,OAAO,EAAE,OAAO,EAAE,CAClB,CADoB,YACP,CAAC,OAAO,CAAC,KAAK,aAAa,CAAC,OAAO,CAAC,GAC9C,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK,CAAC,GAClC,GAAG,GACH,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,GAChD,IAAI,CACR,CAAC;YACH,CAAC;YAED,OAAO,IAAI,CAAC,qBAAqB,CAAC,OAAO,CACxC,SAAS,EACT,SAAS,EACT,OAAO,CACP,CAAC;QACH,CAAC,CAAC,EAAE,CAAC;QAEL,IAAI,cAAc,GAAG,mBAAmB,CAAC,KAAK,CAAC;QAC/C,IAAI,UAAU,GAAG,mBAAmB,CAAC,UAAU,CAAC;QAChD,cAAc,OAAG,mQAAqB,EAAC,SAAS,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;QAC7E,cAAc,OAAG,sRAAwC,EAAC,SAAS,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;QAEhG,MAAM,UAAU,GAAmB,EAAE,CAAC;QAEtC,MAAM,wBAAwB,GAAG,CAAC,eAAuB,EAAE,EAAE;YAC5D,IAAI,CAAC,yBAAyB,EAAE,CAAC;gBAChC,OAAO;YACR,CAAC;YAED,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,EAAE,CAAC,EAAE,CAAE,CAAC;gBAC1C,MAAM,UAAU,GAAG,aAAa,GAAG,CAAC,CAAC;gBACrC,MAAM,UAAU,GAAG,aAAa,GAAG,CAAC,CAAC;gBACrC,IAAI,aAAa,CAAC,UAAU,CAAC,KAAK,aAAa,CAAC,UAAU,CAAC,EAAE,CAAC;oBAC7D,0DAA0D;oBAC1D,MAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,aAAa,EAAE,IAAI,uPAAY,CACpF,IAAI,oNAAW,CAAC,UAAU,EAAE,UAAU,GAAG,CAAC,CAAC,EAC3C,IAAI,oNAAW,CAAC,UAAU,EAAE,UAAU,GAAG,CAAC,CAAC,CAC3C,EAAE,OAAO,EAAE,yBAAyB,EAAE,OAAO,CAAC,CAAC;oBAChD,KAAK,MAAM,CAAC,IAAI,cAAc,CAAC,QAAQ,CAAE,CAAC;wBACzC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACpB,CAAC;oBACD,IAAI,cAAc,CAAC,UAAU,EAAE,CAAC;wBAC/B,UAAU,GAAG,IAAI,CAAC;oBACnB,CAAC;gBACF,CAAC;YACF,CAAC;QACF,CAAC,CAAC;QAEF,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,IAAI,aAAa,GAAG,CAAC,CAAC;QAEtB,KAAK,MAAM,IAAI,IAAI,cAAc,CAAE,CAAC;gBACnC,wLAAQ,EAAC,GAAG,CAAG,CAAD,GAAK,CAAC,SAAS,CAAC,KAAK,GAAG,aAAa,KAAK,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG,aAAa,CAAC,CAAC;YAE9F,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG,aAAa,CAAC;YAE7D,wBAAwB,CAAC,eAAe,CAAC,CAAC;YAE1C,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC;YAC5C,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC;YAE5C,MAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,aAAa,EAAE,IAAI,EAAE,OAAO,EAAE,yBAAyB,EAAE,OAAO,CAAC,CAAC;YACxH,IAAI,cAAc,CAAC,UAAU,EAAE,CAAC;gBAC/B,UAAU,GAAG,IAAI,CAAC;YACnB,CAAC;YACD,KAAK,MAAM,CAAC,IAAI,cAAc,CAAC,QAAQ,CAAE,CAAC;gBACzC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACpB,CAAC;QACF,CAAC;QAED,wBAAwB,CAAC,aAAa,CAAC,MAAM,GAAG,aAAa,CAAC,CAAC;QAE/D,MAAM,QAAQ,GAAG,IAAI,iNAAS,CAAC,aAAa,CAAC,CAAC;QAC9C,MAAM,QAAQ,GAAG,IAAI,iNAAS,CAAC,aAAa,CAAC,CAAC;QAE9C,MAAM,OAAO,OAAG,iOAAiC,EAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAElF,IAAI,KAAK,GAAgB,EAAE,CAAC;QAC5B,IAAI,OAAO,CAAC,YAAY,EAAE,CAAC;YAC1B,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,aAAa,EAAE,aAAa,EAAE,mBAAmB,EAAE,mBAAmB,EAAE,OAAO,EAAE,yBAAyB,EAAE,OAAO,CAAC,CAAC;QACzJ,CAAC;QAED,iCAAiC;YACjC,wLAAQ,EAAC,GAAG,EAAE;YACb,SAAS,gBAAgB,CAAC,GAAa,EAAE,KAAe;gBACvD,IAAI,GAAG,CAAC,UAAU,GAAG,CAAC,IAAI,GAAG,CAAC,UAAU,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC;oBAAC,OAAO,KAAK,CAAC;gBAAC,CAAC;gBAC1E,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;gBACvC,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBAAC,OAAO,KAAK,CAAC;gBAAC,CAAC;gBACrE,OAAO,IAAI,CAAC;YACb,CAAC;YAED,SAAS,aAAa,CAAC,KAAgB,EAAE,KAAe;gBACvD,IAAI,KAAK,CAAC,eAAe,GAAG,CAAC,IAAI,KAAK,CAAC,eAAe,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBAAC,OAAO,KAAK,CAAC;gBAAC,CAAC;gBAC5F,IAAI,KAAK,CAAC,sBAAsB,GAAG,CAAC,IAAI,KAAK,CAAC,sBAAsB,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBAAC,OAAO,KAAK,CAAC;gBAAC,CAAC;gBAC1G,OAAO,IAAI,CAAC;YACb,CAAC;YAED,KAAK,MAAM,CAAC,IAAI,OAAO,CAAE,CAAC;gBACzB,IAAI,CAAC,CAAC,CAAC,YAAY,EAAE,CAAC;oBAAC,OAAO,KAAK,CAAC;gBAAC,CAAC;gBACtC,KAAK,MAAM,EAAE,IAAI,CAAC,CAAC,YAAY,CAAE,CAAC;oBACjC,MAAM,KAAK,GAAG,gBAAgB,CAAC,EAAE,CAAC,aAAa,CAAC,gBAAgB,EAAE,EAAE,aAAa,CAAC,IAAI,gBAAgB,CAAC,EAAE,CAAC,aAAa,CAAC,cAAc,EAAE,EAAE,aAAa,CAAC,IACvJ,gBAAgB,CAAC,EAAE,CAAC,aAAa,CAAC,gBAAgB,EAAE,EAAE,aAAa,CAAC,IAAI,gBAAgB,CAAC,EAAE,CAAC,aAAa,CAAC,cAAc,EAAE,EAAE,aAAa,CAAC,CAAC;oBAC5I,IAAI,CAAC,KAAK,EAAE,CAAC;wBACZ,OAAO,KAAK,CAAC;oBACd,CAAC;gBACF,CAAC;gBACD,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,EAAE,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,EAAE,aAAa,CAAC,EAAE,CAAC;oBAC5F,OAAO,KAAK,CAAC;gBACd,CAAC;YACF,CAAC;YACD,OAAO,IAAI,CAAC;QACb,CAAC,CAAC,CAAC;QAEH,OAAO,IAAI,8MAAS,CAAC,OAAO,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;IAClD,CAAC;IAEO,YAAY,CACnB,OAAmC,EACnC,aAAuB,EACvB,aAAuB,EACvB,mBAA6B,EAC7B,mBAA6B,EAC7B,OAAiB,EACjB,yBAAkC,EAClC,OAAkC,EAAA;QAElC,MAAM,KAAK,OAAG,kPAAiB,EAC9B,OAAO,EACP,aAAa,EACb,aAAa,EACb,mBAAmB,EACnB,mBAAmB,EACnB,OAAO,CACP,CAAC;QACF,MAAM,cAAc,GAAG,KAAK,CAAC,GAAG,EAAC,CAAC,CAAC,EAAE;YACpC,MAAM,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,aAAa,EAAE,IAAI,uPAAY,CACjF,CAAC,CAAC,QAAQ,CAAC,aAAa,EAAE,EAC1B,CAAC,CAAC,QAAQ,CAAC,aAAa,EAAE,CAC1B,EAAE,OAAO,EAAE,yBAAyB,EAAE,OAAO,CAAC,CAAC;YAChD,MAAM,QAAQ,GAAG,qOAAiC,EAAC,WAAW,CAAC,QAAQ,EAAE,IAAI,iNAAS,CAAC,aAAa,CAAC,EAAE,IAAI,iNAAS,CAAC,aAAa,CAAC,EAAE,IAAI,CAAC,CAAC;YAC3I,OAAO,IAAI,8MAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;QACnC,CAAC,CAAC,CAAC;QACH,OAAO,cAAc,CAAC;IACvB,CAAC;IAEO,UAAU,CAAC,aAAuB,EAAE,aAAuB,EAAE,IAAkB,EAAE,OAAiB,EAAE,yBAAkC,EAAE,OAAkC,EAAA;QACjL,MAAM,gBAAgB,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;QAClD,MAAM,YAAY,GAAG,gBAAgB,CAAC,eAAe,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;QAEpF,MAAM,MAAM,GAAG,IAAI,4PAAsB,CAAC,aAAa,EAAE,YAAY,CAAC,aAAa,EAAE,yBAAyB,CAAC,CAAC;QAChH,MAAM,MAAM,GAAG,IAAI,4PAAsB,CAAC,aAAa,EAAE,YAAY,CAAC,aAAa,EAAE,yBAAyB,CAAC,CAAC;QAEhH,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,GAAG,GAAG,GACnD,IAAI,CAAC,yBAAyB,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,GAC/D,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;QAE/D,MAAM,KAAK,GAAG,KAAK,CAAC;QAEpB,IAAI,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;QAC7B,IAAI,KAAK,EAAE,CAAC;;QACZ,KAAK,GAAG,uQAAqB,EAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;QACrD,IAAI,KAAK,EAAE,CAAC;;QACZ,KAAK,OAAG,kRAAoC,EAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,CAAG,CAAD,EAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC;QAC/G,IAAI,KAAK,EAAE,CAAC;;QAEZ,IAAI,OAAO,CAAC,gBAAgB,EAAE,CAAC;YAC9B,KAAK,OAAG,kRAAoC,EAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,CAAG,CAAD,EAAI,CAAC,qBAAqB,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;YACxH,IAAI,KAAK,EAAE,CAAC;;QACb,CAAC;QAED,KAAK,OAAG,gQAAkB,EAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;QAClD,IAAI,KAAK,EAAE,CAAC;;QACZ,KAAK,OAAG,yRAA2C,EAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;QAC3E,IAAI,KAAK,EAAE,CAAC;;QAEZ,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CACvB,CAAC,CAAC,EAAE,CACH,CADK,GACD,4MAAY,CACf,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,SAAS,CAAC,EAClC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,SAAS,CAAC,CAClC,CACF,CAAC;QAEF,IAAI,KAAK,EAAE,CAAC;;QAEZ,oFAAoF;QAEpF,OAAO;YACN,QAAQ,EAAE,MAAM;YAChB,UAAU,EAAE,UAAU,CAAC,UAAU;SACjC,CAAC;IACH,CAAC;IAhPF,aAAA;QACkB,IAAA,CAAA,yBAAyB,GAAG,IAAI,gRAAyB,EAAE,CAAC;QAC5D,IAAA,CAAA,qBAAqB,GAAG,IAAI,kQAAkB,EAAE,CAAC;IA+OnE,CAAC;CAAA;AAED,SAAS,kBAAkB,CAAC,YAA0B;IACrD,OAAO,IAAI,gNAAgB,CAC1B,IAAI,gNAAS,CAAC,YAAY,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,EAAE,YAAY,CAAC,SAAS,CAAC,YAAY,GAAG,CAAC,CAAC,EACxF,IAAI,gNAAS,CAAC,YAAY,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,EAAE,YAAY,CAAC,SAAS,CAAC,YAAY,GAAG,CAAC,CAAC,CACxF,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 1855, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/legacyLinesDiffComputer.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/vs/editor/common/diff/legacyLinesDiffComputer.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { IDiffChange, ISequence, LcsDiff, IDiffResult } from '../../../base/common/diff/diff.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\n\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nexport class LegacyLinesDiffComputer implements ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tmaxComputationTime: options.maxComputationTimeMs,\n\t\t\tshouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n\t\t\tshouldComputeCharChanges: true,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t});\n\t\tconst result = diffComputer.computeDiff();\n\t\tconst changes: DetailedLineRangeMapping[] = [];\n\t\tlet lastChange: DetailedLineRangeMapping | null = null;\n\n\n\t\tfor (const c of result.changes) {\n\t\t\tlet originalRange: LineRange;\n\t\t\tif (c.originalEndLineNumber === 0) {\n\t\t\t\t// Insertion\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet modifiedRange: LineRange;\n\t\t\tif (c.modifiedEndLineNumber === 0) {\n\t\t\t\t// Deletion\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(\n\t\t\t\tnew Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn),\n\t\t\t\tnew Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn),\n\t\t\t)));\n\t\t\tif (lastChange) {\n\t\t\t\tif (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n\t\t\t\t\t|| lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n\t\t\t\t\t// join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n\t\t\t\t\tchange = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(change.original),\n\t\t\t\t\t\tlastChange.modified.join(change.modified),\n\t\t\t\t\t\tlastChange.innerChanges && change.innerChanges ?\n\t\t\t\t\t\t\tlastChange.innerChanges.concat(change.innerChanges) : undefined\n\t\t\t\t\t);\n\t\t\t\t\tchanges.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanges.push(change);\n\t\t\tlastChange = change;\n\t\t}\n\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(changes,\n\t\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t\t);\n\t\t});\n\n\t\treturn new LinesDiff(changes, [], result.quitEarly);\n\t}\n}\n\n/**\n * A change\n */\nexport interface IChange {\n\treadonly originalStartLineNumber: number;\n\treadonly originalEndLineNumber: number;\n\treadonly modifiedStartLineNumber: number;\n\treadonly modifiedEndLineNumber: number;\n}\n\n/**\n * A character level change.\n */\nexport interface ICharChange extends IChange {\n\treadonly originalStartColumn: number;\n\treadonly originalEndColumn: number;\n\treadonly modifiedStartColumn: number;\n\treadonly modifiedEndColumn: number;\n}\n\n/**\n * A line change\n */\nexport interface ILineChange extends IChange {\n\treadonly charChanges: ICharChange[] | undefined;\n}\n\nexport interface IDiffComputerResult {\n\tquitEarly: boolean;\n\tchanges: ILineChange[];\n}\n\nfunction computeDiff(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: () => boolean, pretty: boolean): IDiffResult {\n\tconst diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n\treturn diffAlgo.ComputeDiff(pretty);\n}\n\nclass LineSequence implements ISequence {\n\n\tpublic readonly lines: string[];\n\tprivate readonly _startColumns: number[];\n\tprivate readonly _endColumns: number[];\n\n\tconstructor(lines: string[]) {\n\t\tconst startColumns: number[] = [];\n\t\tconst endColumns: number[] = [];\n\t\tfor (let i = 0, length = lines.length; i < length; i++) {\n\t\t\tstartColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n\t\t\tendColumns[i] = getLastNonBlankColumn(lines[i], 1);\n\t\t}\n\t\tthis.lines = lines;\n\t\tthis._startColumns = startColumns;\n\t\tthis._endColumns = endColumns;\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\tconst elements: string[] = [];\n\t\tfor (let i = 0, len = this.lines.length; i < len; i++) {\n\t\t\telements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic getStrictElement(index: number): string {\n\t\treturn this.lines[index];\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic createCharSequence(shouldIgnoreTrimWhitespace: boolean, startIndex: number, endIndex: number): CharSequence {\n\t\tconst charCodes: number[] = [];\n\t\tconst lineNumbers: number[] = [];\n\t\tconst columns: number[] = [];\n\t\tlet len = 0;\n\t\tfor (let index = startIndex; index <= endIndex; index++) {\n\t\t\tconst lineContent = this.lines[index];\n\t\t\tconst startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n\t\t\tconst endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n\t\t\tfor (let col = startColumn; col < endColumn; col++) {\n\t\t\t\tcharCodes[len] = lineContent.charCodeAt(col - 1);\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = col;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (!shouldIgnoreTrimWhitespace && index < endIndex) {\n\t\t\t\t// Add \\n if trim whitespace is not ignored\n\t\t\t\tcharCodes[len] = CharCode.LineFeed;\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = lineContent.length + 1;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\treturn new CharSequence(charCodes, lineNumbers, columns);\n\t}\n}\n\nclass CharSequence implements ISequence {\n\n\tprivate readonly _charCodes: number[];\n\tprivate readonly _lineNumbers: number[];\n\tprivate readonly _columns: number[];\n\n\tconstructor(charCodes: number[], lineNumbers: number[], columns: number[]) {\n\t\tthis._charCodes = charCodes;\n\t\tthis._lineNumbers = lineNumbers;\n\t\tthis._columns = columns;\n\t}\n\n\tpublic toString() {\n\t\treturn (\n\t\t\t'[' + this._charCodes.map((s, idx) => (s === CharCode.LineFeed ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']'\n\t\t);\n\t}\n\n\tprivate _assertIndex(index: number, arr: number[]): void {\n\t\tif (index < 0 || index >= arr.length) {\n\t\t\tthrow new Error(`Illegal index`);\n\t\t}\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\treturn this._charCodes;\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\tif (i > 0 && i === this._lineNumbers.length) {\n\t\t\t// the start line number of the element after the last element\n\t\t\t// is the end line number of the last element\n\t\t\treturn this.getEndLineNumber(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end line number of the element before the first element\n\t\t\t// is the start line number of the first element\n\t\t\treturn this.getStartLineNumber(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn this._lineNumbers[i] + 1;\n\t\t}\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getStartColumn(i: number): number {\n\t\tif (i > 0 && i === this._columns.length) {\n\t\t\t// the start column of the element after the last element\n\t\t\t// is the end column of the last element\n\t\t\treturn this.getEndColumn(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\t\treturn this._columns[i];\n\t}\n\n\tpublic getEndColumn(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end column of the element before the first element\n\t\t\t// is the start column of the first element\n\t\t\treturn this.getStartColumn(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._columns[i] + 1;\n\t}\n}\n\nclass CharChange implements ICharChange {\n\n\tpublic originalStartLineNumber: number;\n\tpublic originalStartColumn: number;\n\tpublic originalEndLineNumber: number;\n\tpublic originalEndColumn: number;\n\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedStartColumn: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic modifiedEndColumn: number;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndLineNumber: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tmodifiedEndColumn: number\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalStartColumn = originalStartColumn;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.originalEndColumn = originalEndColumn;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedStartColumn = modifiedStartColumn;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.modifiedEndColumn = modifiedEndColumn;\n\t}\n\n\tpublic static createFromDiffChange(diffChange: IDiffChange, originalCharSequence: CharSequence, modifiedCharSequence: CharSequence): CharChange {\n\t\tconst originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n\t\tconst originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n\t\tconst originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\tconst originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n\n\t\tconst modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\tconst modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n\t\tconst modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\tconst modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\treturn new CharChange(\n\t\t\toriginalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn,\n\t\t\tmodifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn,\n\t\t);\n\t}\n}\n\nfunction postProcessCharChanges(rawChanges: IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\n\tconst result = [rawChanges[0]];\n\tlet prevChange = result[0];\n\n\tfor (let i = 1, len = rawChanges.length; i < len; i++) {\n\t\tconst currChange = rawChanges[i];\n\n\t\tconst originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n\t\tconst modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tconst matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n\t\t\tprevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber: number;\n\tpublic originalEndLineNumber: number;\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic charChanges: CharChange[] | undefined;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalEndLineNumber: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tcharChanges: CharChange[] | undefined\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.charChanges = charChanges;\n\t}\n\n\tpublic static createFromDiffResult(shouldIgnoreTrimWhitespace: boolean, diffChange: IDiffChange, originalLineSequence: LineSequence, modifiedLineSequence: LineSequence, continueCharDiff: () => boolean, shouldComputeCharChanges: boolean, shouldPostProcessCharChanges: boolean): LineChange {\n\t\tlet originalStartLineNumber: number;\n\t\tlet originalEndLineNumber: number;\n\t\tlet modifiedStartLineNumber: number;\n\t\tlet modifiedEndLineNumber: number;\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\n\t\tif (diffChange.originalLength === 0) {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n\t\t\toriginalEndLineNumber = 0;\n\t\t} else {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\toriginalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n\t\t\tmodifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tmodifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\n\t\tif (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n\t\t\t// Compute character changes for diff chunks of at most 20 lines...\n\t\t\tconst originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tconst modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\t\tif (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n\t\t\t\tlet rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n\n\t\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t\t}\n\n\t\t\t\tcharChanges = [];\n\t\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\t\tcharChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n\t}\n}\n\nexport interface IDiffComputerOpts {\n\tshouldComputeCharChanges: boolean;\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldMakePrettyDiff: boolean;\n\tmaxComputationTime: number;\n}\n\nexport class DiffComputer {\n\n\tprivate readonly shouldComputeCharChanges: boolean;\n\tprivate readonly shouldPostProcessCharChanges: boolean;\n\tprivate readonly shouldIgnoreTrimWhitespace: boolean;\n\tprivate readonly shouldMakePrettyDiff: boolean;\n\tprivate readonly originalLines: string[];\n\tprivate readonly modifiedLines: string[];\n\tprivate readonly original: LineSequence;\n\tprivate readonly modified: LineSequence;\n\tprivate readonly continueLineDiff: () => boolean;\n\tprivate readonly continueCharDiff: () => boolean;\n\n\tconstructor(originalLines: string[], modifiedLines: string[], opts: IDiffComputerOpts) {\n\t\tthis.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n\t\tthis.originalLines = originalLines;\n\t\tthis.modifiedLines = modifiedLines;\n\t\tthis.original = new LineSequence(originalLines);\n\t\tthis.modified = new LineSequence(modifiedLines);\n\n\t\tthis.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n\t\tthis.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n\t}\n\n\tpublic computeDiff(): IDiffComputerResult {\n\n\t\tif (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n\t\t\t// empty original => fast path\n\t\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tquitEarly: false,\n\t\t\t\t\tchanges: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: 1,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: this.modified.lines.length,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t// empty modified => fast path\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: this.original.lines.length,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: 1,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tconst diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n\t\tconst rawChanges = diffResult.changes;\n\t\tconst quitEarly = diffResult.quitEarly;\n\n\t\t// The diff is always computed with ignoring trim whitespace\n\t\t// This ensures we get the prettiest diff\n\n\t\tif (this.shouldIgnoreTrimWhitespace) {\n\t\t\tconst lineChanges: LineChange[] = [];\n\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tlineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquitEarly: quitEarly,\n\t\t\t\tchanges: lineChanges\n\t\t\t};\n\t\t}\n\n\t\t// Need to post-process and introduce changes where the trim whitespace is different\n\t\t// Note that we are looping starting at -1 to also cover the lines before the first change\n\t\tconst result: LineChange[] = [];\n\n\t\tlet originalLineIndex = 0;\n\t\tlet modifiedLineIndex = 0;\n\t\tfor (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n\t\t\tconst nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n\t\t\tconst originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n\t\t\tconst modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n\n\t\t\twhile (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n\t\t\t\tconst originalLine = this.originalLines[originalLineIndex];\n\t\t\t\tconst modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n\t\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\t\t// These lines differ only in trim whitespace\n\n\t\t\t\t\t// Check the leading whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\twhile (originalStartColumn > 1 && modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n\t\t\t\t\t\t\tconst modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalStartColumn--;\n\t\t\t\t\t\t\tmodifiedStartColumn--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalStartColumn > 1 || modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, 1, originalStartColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, 1, modifiedStartColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check the trailing whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\tconst originalMaxColumn = originalLine.length + 1;\n\t\t\t\t\t\tconst modifiedMaxColumn = modifiedLine.length + 1;\n\t\t\t\t\t\twhile (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n\t\t\t\t\t\t\tconst modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalEndColumn++;\n\t\t\t\t\t\t\tmodifiedEndColumn++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, originalEndColumn, originalMaxColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalLineIndex++;\n\t\t\t\tmodifiedLineIndex++;\n\t\t\t}\n\n\t\t\tif (nextChange) {\n\t\t\t\t// Emit the actual change\n\t\t\t\tresult.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\n\t\t\t\toriginalLineIndex += nextChange.originalLength;\n\t\t\t\tmodifiedLineIndex += nextChange.modifiedLength;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarly,\n\t\t\tchanges: result\n\t\t};\n\t}\n\n\tprivate _pushTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): void {\n\t\tif (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n\t\t\t// Merged into previous\n\t\t\treturn;\n\t\t}\n\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\t\tif (this.shouldComputeCharChanges) {\n\t\t\tcharChanges = [new CharChange(\n\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t)];\n\t\t}\n\t\tresult.push(new LineChange(\n\t\t\toriginalLineNumber, originalLineNumber,\n\t\t\tmodifiedLineNumber, modifiedLineNumber,\n\t\t\tcharChanges\n\t\t));\n\t}\n\n\tprivate _mergeTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): boolean {\n\t\tconst len = result.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst prevChange = result[len - 1];\n\n\t\tif (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n\t\t\t// Don't merge with inserts/deletes\n\t\t\treturn false;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n\t\t\tprevChange.originalEndLineNumber = originalLineNumber;\n\t\t\tprevChange.modifiedEndLineNumber = modifiedLineNumber;\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nfunction getFirstNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.firstNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 1;\n}\n\nfunction getLastNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.lastNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 2;\n}\n\nfunction createContinueProcessingPredicate(maximumRuntime: number): () => boolean {\n\tif (maximumRuntime === 0) {\n\t\treturn () => true;\n\t}\n\n\tconst startTime = Date.now();\n\treturn () => {\n\t\treturn Date.now() - startTime < maximumRuntime;\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from '../../../base/common/charCode.js';\nimport { IDiffChange, ISequence, LcsDiff, IDiffResult } from '../../../base/common/diff/diff.js';\nimport { ILinesDiffComputer, ILinesDiffComputerOptions, LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/ranges/lineRange.js';\n\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nexport class LegacyLinesDiffComputer implements ILinesDiffComputer {\n\tcomputeDiff(originalLines: string[], modifiedLines: string[], options: ILinesDiffComputerOptions): LinesDiff {\n\t\tconst diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tmaxComputationTime: options.maxComputationTimeMs,\n\t\t\tshouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n\t\t\tshouldComputeCharChanges: true,\n\t\t\tshouldMakePrettyDiff: true,\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t});\n\t\tconst result = diffComputer.computeDiff();\n\t\tconst changes: DetailedLineRangeMapping[] = [];\n\t\tlet lastChange: DetailedLineRangeMapping | null = null;\n\n\n\t\tfor (const c of result.changes) {\n\t\t\tlet originalRange: LineRange;\n\t\t\tif (c.originalEndLineNumber === 0) {\n\t\t\t\t// Insertion\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\toriginalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet modifiedRange: LineRange;\n\t\t\tif (c.modifiedEndLineNumber === 0) {\n\t\t\t\t// Deletion\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n\t\t\t} else {\n\t\t\t\tmodifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n\t\t\t}\n\n\t\t\tlet change = new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => new RangeMapping(\n\t\t\t\tnew Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn),\n\t\t\t\tnew Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn),\n\t\t\t)));\n\t\t\tif (lastChange) {\n\t\t\t\tif (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n\t\t\t\t\t|| lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n\t\t\t\t\t// join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n\t\t\t\t\tchange = new DetailedLineRangeMapping(\n\t\t\t\t\t\tlastChange.original.join(change.original),\n\t\t\t\t\t\tlastChange.modified.join(change.modified),\n\t\t\t\t\t\tlastChange.innerChanges && change.innerChanges ?\n\t\t\t\t\t\t\tlastChange.innerChanges.concat(change.innerChanges) : undefined\n\t\t\t\t\t);\n\t\t\t\t\tchanges.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanges.push(change);\n\t\t\tlastChange = change;\n\t\t}\n\n\t\tassertFn(() => {\n\t\t\treturn checkAdjacentItems(changes,\n\t\t\t\t(m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n\t\t\t\t\t// There has to be an unchanged line in between (otherwise both diffs should have been joined)\n\t\t\t\t\tm1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n\t\t\t\t\tm1.modified.endLineNumberExclusive < m2.modified.startLineNumber,\n\t\t\t);\n\t\t});\n\n\t\treturn new LinesDiff(changes, [], result.quitEarly);\n\t}\n}\n\n/**\n * A change\n */\nexport interface IChange {\n\treadonly originalStartLineNumber: number;\n\treadonly originalEndLineNumber: number;\n\treadonly modifiedStartLineNumber: number;\n\treadonly modifiedEndLineNumber: number;\n}\n\n/**\n * A character level change.\n */\nexport interface ICharChange extends IChange {\n\treadonly originalStartColumn: number;\n\treadonly originalEndColumn: number;\n\treadonly modifiedStartColumn: number;\n\treadonly modifiedEndColumn: number;\n}\n\n/**\n * A line change\n */\nexport interface ILineChange extends IChange {\n\treadonly charChanges: ICharChange[] | undefined;\n}\n\nexport interface IDiffComputerResult {\n\tquitEarly: boolean;\n\tchanges: ILineChange[];\n}\n\nfunction computeDiff(originalSequence: ISequence, modifiedSequence: ISequence, continueProcessingPredicate: () => boolean, pretty: boolean): IDiffResult {\n\tconst diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n\treturn diffAlgo.ComputeDiff(pretty);\n}\n\nclass LineSequence implements ISequence {\n\n\tpublic readonly lines: string[];\n\tprivate readonly _startColumns: number[];\n\tprivate readonly _endColumns: number[];\n\n\tconstructor(lines: string[]) {\n\t\tconst startColumns: number[] = [];\n\t\tconst endColumns: number[] = [];\n\t\tfor (let i = 0, length = lines.length; i < length; i++) {\n\t\t\tstartColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n\t\t\tendColumns[i] = getLastNonBlankColumn(lines[i], 1);\n\t\t}\n\t\tthis.lines = lines;\n\t\tthis._startColumns = startColumns;\n\t\tthis._endColumns = endColumns;\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\tconst elements: string[] = [];\n\t\tfor (let i = 0, len = this.lines.length; i < len; i++) {\n\t\t\telements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n\t\t}\n\t\treturn elements;\n\t}\n\n\tpublic getStrictElement(index: number): string {\n\t\treturn this.lines[index];\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\treturn i + 1;\n\t}\n\n\tpublic createCharSequence(shouldIgnoreTrimWhitespace: boolean, startIndex: number, endIndex: number): CharSequence {\n\t\tconst charCodes: number[] = [];\n\t\tconst lineNumbers: number[] = [];\n\t\tconst columns: number[] = [];\n\t\tlet len = 0;\n\t\tfor (let index = startIndex; index <= endIndex; index++) {\n\t\t\tconst lineContent = this.lines[index];\n\t\t\tconst startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n\t\t\tconst endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n\t\t\tfor (let col = startColumn; col < endColumn; col++) {\n\t\t\t\tcharCodes[len] = lineContent.charCodeAt(col - 1);\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = col;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (!shouldIgnoreTrimWhitespace && index < endIndex) {\n\t\t\t\t// Add \\n if trim whitespace is not ignored\n\t\t\t\tcharCodes[len] = CharCode.LineFeed;\n\t\t\t\tlineNumbers[len] = index + 1;\n\t\t\t\tcolumns[len] = lineContent.length + 1;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\treturn new CharSequence(charCodes, lineNumbers, columns);\n\t}\n}\n\nclass CharSequence implements ISequence {\n\n\tprivate readonly _charCodes: number[];\n\tprivate readonly _lineNumbers: number[];\n\tprivate readonly _columns: number[];\n\n\tconstructor(charCodes: number[], lineNumbers: number[], columns: number[]) {\n\t\tthis._charCodes = charCodes;\n\t\tthis._lineNumbers = lineNumbers;\n\t\tthis._columns = columns;\n\t}\n\n\tpublic toString() {\n\t\treturn (\n\t\t\t'[' + this._charCodes.map((s, idx) => (s === CharCode.LineFeed ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']'\n\t\t);\n\t}\n\n\tprivate _assertIndex(index: number, arr: number[]): void {\n\t\tif (index < 0 || index >= arr.length) {\n\t\t\tthrow new Error(`Illegal index`);\n\t\t}\n\t}\n\n\tpublic getElements(): Int32Array | number[] | string[] {\n\t\treturn this._charCodes;\n\t}\n\n\tpublic getStartLineNumber(i: number): number {\n\t\tif (i > 0 && i === this._lineNumbers.length) {\n\t\t\t// the start line number of the element after the last element\n\t\t\t// is the end line number of the last element\n\t\t\treturn this.getEndLineNumber(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getEndLineNumber(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end line number of the element before the first element\n\t\t\t// is the start line number of the first element\n\t\t\treturn this.getStartLineNumber(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._lineNumbers);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn this._lineNumbers[i] + 1;\n\t\t}\n\t\treturn this._lineNumbers[i];\n\t}\n\n\tpublic getStartColumn(i: number): number {\n\t\tif (i > 0 && i === this._columns.length) {\n\t\t\t// the start column of the element after the last element\n\t\t\t// is the end column of the last element\n\t\t\treturn this.getEndColumn(i - 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\t\treturn this._columns[i];\n\t}\n\n\tpublic getEndColumn(i: number): number {\n\t\tif (i === -1) {\n\t\t\t// the end column of the element before the first element\n\t\t\t// is the start column of the first element\n\t\t\treturn this.getStartColumn(i + 1);\n\t\t}\n\t\tthis._assertIndex(i, this._columns);\n\n\t\tif (this._charCodes[i] === CharCode.LineFeed) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn this._columns[i] + 1;\n\t}\n}\n\nclass CharChange implements ICharChange {\n\n\tpublic originalStartLineNumber: number;\n\tpublic originalStartColumn: number;\n\tpublic originalEndLineNumber: number;\n\tpublic originalEndColumn: number;\n\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedStartColumn: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic modifiedEndColumn: number;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalStartColumn: number,\n\t\toriginalEndLineNumber: number,\n\t\toriginalEndColumn: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedStartColumn: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tmodifiedEndColumn: number\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalStartColumn = originalStartColumn;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.originalEndColumn = originalEndColumn;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedStartColumn = modifiedStartColumn;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.modifiedEndColumn = modifiedEndColumn;\n\t}\n\n\tpublic static createFromDiffChange(diffChange: IDiffChange, originalCharSequence: CharSequence, modifiedCharSequence: CharSequence): CharChange {\n\t\tconst originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n\t\tconst originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n\t\tconst originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\tconst originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n\n\t\tconst modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\tconst modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n\t\tconst modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\tconst modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\treturn new CharChange(\n\t\t\toriginalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn,\n\t\t\tmodifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn,\n\t\t);\n\t}\n}\n\nfunction postProcessCharChanges(rawChanges: IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\n\tconst result = [rawChanges[0]];\n\tlet prevChange = result[0];\n\n\tfor (let i = 1, len = rawChanges.length; i < len; i++) {\n\t\tconst currChange = rawChanges[i];\n\n\t\tconst originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n\t\tconst modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tconst matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n\t\t\tprevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber: number;\n\tpublic originalEndLineNumber: number;\n\tpublic modifiedStartLineNumber: number;\n\tpublic modifiedEndLineNumber: number;\n\tpublic charChanges: CharChange[] | undefined;\n\n\tconstructor(\n\t\toriginalStartLineNumber: number,\n\t\toriginalEndLineNumber: number,\n\t\tmodifiedStartLineNumber: number,\n\t\tmodifiedEndLineNumber: number,\n\t\tcharChanges: CharChange[] | undefined\n\t) {\n\t\tthis.originalStartLineNumber = originalStartLineNumber;\n\t\tthis.originalEndLineNumber = originalEndLineNumber;\n\t\tthis.modifiedStartLineNumber = modifiedStartLineNumber;\n\t\tthis.modifiedEndLineNumber = modifiedEndLineNumber;\n\t\tthis.charChanges = charChanges;\n\t}\n\n\tpublic static createFromDiffResult(shouldIgnoreTrimWhitespace: boolean, diffChange: IDiffChange, originalLineSequence: LineSequence, modifiedLineSequence: LineSequence, continueCharDiff: () => boolean, shouldComputeCharChanges: boolean, shouldPostProcessCharChanges: boolean): LineChange {\n\t\tlet originalStartLineNumber: number;\n\t\tlet originalEndLineNumber: number;\n\t\tlet modifiedStartLineNumber: number;\n\t\tlet modifiedEndLineNumber: number;\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\n\t\tif (diffChange.originalLength === 0) {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n\t\t\toriginalEndLineNumber = 0;\n\t\t} else {\n\t\t\toriginalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\toriginalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n\t\t\tmodifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tmodifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tmodifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\n\t\tif (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n\t\t\t// Compute character changes for diff chunks of at most 20 lines...\n\t\t\tconst originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tconst modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\t\tif (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n\t\t\t\tlet rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n\n\t\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t\t}\n\n\t\t\t\tcharChanges = [];\n\t\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\t\tcharChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n\t}\n}\n\nexport interface IDiffComputerOpts {\n\tshouldComputeCharChanges: boolean;\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldMakePrettyDiff: boolean;\n\tmaxComputationTime: number;\n}\n\nexport class DiffComputer {\n\n\tprivate readonly shouldComputeCharChanges: boolean;\n\tprivate readonly shouldPostProcessCharChanges: boolean;\n\tprivate readonly shouldIgnoreTrimWhitespace: boolean;\n\tprivate readonly shouldMakePrettyDiff: boolean;\n\tprivate readonly originalLines: string[];\n\tprivate readonly modifiedLines: string[];\n\tprivate readonly original: LineSequence;\n\tprivate readonly modified: LineSequence;\n\tprivate readonly continueLineDiff: () => boolean;\n\tprivate readonly continueCharDiff: () => boolean;\n\n\tconstructor(originalLines: string[], modifiedLines: string[], opts: IDiffComputerOpts) {\n\t\tthis.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n\t\tthis.originalLines = originalLines;\n\t\tthis.modifiedLines = modifiedLines;\n\t\tthis.original = new LineSequence(originalLines);\n\t\tthis.modified = new LineSequence(modifiedLines);\n\n\t\tthis.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n\t\tthis.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n\t}\n\n\tpublic computeDiff(): IDiffComputerResult {\n\n\t\tif (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n\t\t\t// empty original => fast path\n\t\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tquitEarly: false,\n\t\t\t\t\tchanges: []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: 1,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: this.modified.lines.length,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tif (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n\t\t\t// empty modified => fast path\n\t\t\treturn {\n\t\t\t\tquitEarly: false,\n\t\t\t\tchanges: [{\n\t\t\t\t\toriginalStartLineNumber: 1,\n\t\t\t\t\toriginalEndLineNumber: this.original.lines.length,\n\t\t\t\t\tmodifiedStartLineNumber: 1,\n\t\t\t\t\tmodifiedEndLineNumber: 1,\n\t\t\t\t\tcharChanges: undefined\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tconst diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n\t\tconst rawChanges = diffResult.changes;\n\t\tconst quitEarly = diffResult.quitEarly;\n\n\t\t// The diff is always computed with ignoring trim whitespace\n\t\t// This ensures we get the prettiest diff\n\n\t\tif (this.shouldIgnoreTrimWhitespace) {\n\t\t\tconst lineChanges: LineChange[] = [];\n\t\t\tfor (let i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tlineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquitEarly: quitEarly,\n\t\t\t\tchanges: lineChanges\n\t\t\t};\n\t\t}\n\n\t\t// Need to post-process and introduce changes where the trim whitespace is different\n\t\t// Note that we are looping starting at -1 to also cover the lines before the first change\n\t\tconst result: LineChange[] = [];\n\n\t\tlet originalLineIndex = 0;\n\t\tlet modifiedLineIndex = 0;\n\t\tfor (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n\t\t\tconst nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n\t\t\tconst originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n\t\t\tconst modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n\n\t\t\twhile (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n\t\t\t\tconst originalLine = this.originalLines[originalLineIndex];\n\t\t\t\tconst modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n\t\t\t\tif (originalLine !== modifiedLine) {\n\t\t\t\t\t// These lines differ only in trim whitespace\n\n\t\t\t\t\t// Check the leading whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\twhile (originalStartColumn > 1 && modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n\t\t\t\t\t\t\tconst modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalStartColumn--;\n\t\t\t\t\t\t\tmodifiedStartColumn--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalStartColumn > 1 || modifiedStartColumn > 1) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, 1, originalStartColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, 1, modifiedStartColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check the trailing whitespace\n\t\t\t\t\t{\n\t\t\t\t\t\tlet originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n\t\t\t\t\t\tlet modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n\t\t\t\t\t\tconst originalMaxColumn = originalLine.length + 1;\n\t\t\t\t\t\tconst modifiedMaxColumn = modifiedLine.length + 1;\n\t\t\t\t\t\twhile (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tconst originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n\t\t\t\t\t\t\tconst modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n\t\t\t\t\t\t\tif (originalChar !== modifiedChar) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginalEndColumn++;\n\t\t\t\t\t\t\tmodifiedEndColumn++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n\t\t\t\t\t\t\tthis._pushTrimWhitespaceCharChange(result,\n\t\t\t\t\t\t\t\toriginalLineIndex + 1, originalEndColumn, originalMaxColumn,\n\t\t\t\t\t\t\t\tmodifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toriginalLineIndex++;\n\t\t\t\tmodifiedLineIndex++;\n\t\t\t}\n\n\t\t\tif (nextChange) {\n\t\t\t\t// Emit the actual change\n\t\t\t\tresult.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n\n\t\t\t\toriginalLineIndex += nextChange.originalLength;\n\t\t\t\tmodifiedLineIndex += nextChange.modifiedLength;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tquitEarly: quitEarly,\n\t\t\tchanges: result\n\t\t};\n\t}\n\n\tprivate _pushTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): void {\n\t\tif (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n\t\t\t// Merged into previous\n\t\t\treturn;\n\t\t}\n\n\t\tlet charChanges: CharChange[] | undefined = undefined;\n\t\tif (this.shouldComputeCharChanges) {\n\t\t\tcharChanges = [new CharChange(\n\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t)];\n\t\t}\n\t\tresult.push(new LineChange(\n\t\t\toriginalLineNumber, originalLineNumber,\n\t\t\tmodifiedLineNumber, modifiedLineNumber,\n\t\t\tcharChanges\n\t\t));\n\t}\n\n\tprivate _mergeTrimWhitespaceCharChange(\n\t\tresult: LineChange[],\n\t\toriginalLineNumber: number, originalStartColumn: number, originalEndColumn: number,\n\t\tmodifiedLineNumber: number, modifiedStartColumn: number, modifiedEndColumn: number\n\t): boolean {\n\t\tconst len = result.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst prevChange = result[len - 1];\n\n\t\tif (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n\t\t\t// Don't merge with inserts/deletes\n\t\t\treturn false;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n\t\t\tprevChange.originalEndLineNumber = originalLineNumber;\n\t\t\tprevChange.modifiedEndLineNumber = modifiedLineNumber;\n\t\t\tif (this.shouldComputeCharChanges && prevChange.charChanges) {\n\t\t\t\tprevChange.charChanges.push(new CharChange(\n\t\t\t\t\toriginalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn,\n\t\t\t\t\tmodifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn\n\t\t\t\t));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nfunction getFirstNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.firstNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 1;\n}\n\nfunction getLastNonBlankColumn(txt: string, defaultValue: number): number {\n\tconst r = strings.lastNonWhitespaceIndex(txt);\n\tif (r === -1) {\n\t\treturn defaultValue;\n\t}\n\treturn r + 2;\n}\n\nfunction createContinueProcessingPredicate(maximumRuntime: number): () => boolean {\n\tif (maximumRuntime === 0) {\n\t\treturn () => true;\n\t}\n\n\tconst startTime = Date.now();\n\treturn () => {\n\t\treturn Date.now() - startTime < maximumRuntime;\n\t};\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2336, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","sourceRoot":"file:///mnt/vss/_work/1/s/dependencies/vscode/out-editor-src","sources":["file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/file%3A/mnt/vss/_work/1/s/dependencies/vscode/out-editor-src/vs/editor/common/diff/linesDiffComputers.ts","file:///Users/liza/Desktop/FrontReady/node_modules/monaco-editor/esm/vs/editor/common/diff/vs/editor/common/diff/linesDiffComputers.ts"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nimport { ILinesDiffComputer } from './linesDiffComputer.js';\n\nexport const linesDiffComputers = {\n\tgetLegacy: () => new LegacyLinesDiffComputer(),\n\tgetDefault: () => new DefaultLinesDiffComputer(),\n} satisfies Record<string, () => ILinesDiffComputer>;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nimport { ILinesDiffComputer } from './linesDiffComputer.js';\n\nexport const linesDiffComputers = {\n\tgetLegacy: () => new LegacyLinesDiffComputer(),\n\tgetDefault: () => new DefaultLinesDiffComputer(),\n} satisfies Record<string, () => ILinesDiffComputer>;\n"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;AAEhG,OAAO,EAAE,uBAAuB,EAAE,MAAM,8BAA8B,CAAC;AACvE,OAAO,EAAE,wBAAwB,EAAE,MAAM,wDAAwD,CAAC;;;AAG3F,MAAM,kBAAkB,GAAG;IACjC,SAAS,EAAE,GAAG,CAAG,CAAD,GAAK,kOAAuB,EAAE;IAC9C,UAAU,EAAE,GAAG,CAAG,CAAD,GAAK,gQAAwB,EAAE;CACG,CAAC","debugId":null}}]
}